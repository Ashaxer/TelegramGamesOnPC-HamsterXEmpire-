var ni = Object.defineProperty;
var ii = (r,d,f)=>d in r ? ni(r, d, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: f
}) : r[d] = f;
var fn = (r,d,f)=>(ii(r, typeof d != "symbol" ? d + "" : d, f),
f);
import {t as time, s as a$1, r as checked, I as InvoiceModel, A as ApiError, F as F$1, m as TapokAPI, n as isTouchDevice, S as SecureUtil, G as GameConf, o as AccountModel, C as ChqService, v as isScreenIsLocked, l as lockPage, u as u$2, h as h$1, q as q$1, T as T$1} from "./UseOnMount-BY2_mLoZ.js";
function sleep(r) {
    return new Promise(d=>setTimeout(d, r))
}
function getDefaultExportFromCjs$1(r) {
    return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r
}
var browser$d = {
    exports: {}
}, process = browser$d.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined")
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined")
}
(function() {
    try {
        typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout
    } catch {
        cachedSetTimeout = defaultSetTimout
    }
    try {
        typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout
    } catch {
        cachedClearTimeout = defaultClearTimeout
    }
}
)();
function runTimeout(r) {
    if (cachedSetTimeout === setTimeout)
        return setTimeout(r, 0);
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
        return cachedSetTimeout = setTimeout,
        setTimeout(r, 0);
    try {
        return cachedSetTimeout(r, 0)
    } catch {
        try {
            return cachedSetTimeout.call(null, r, 0)
        } catch {
            return cachedSetTimeout.call(this, r, 0)
        }
    }
}
function runClearTimeout(r) {
    if (cachedClearTimeout === clearTimeout)
        return clearTimeout(r);
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
        return cachedClearTimeout = clearTimeout,
        clearTimeout(r);
    try {
        return cachedClearTimeout(r)
    } catch {
        try {
            return cachedClearTimeout.call(null, r)
        } catch {
            return cachedClearTimeout.call(this, r)
        }
    }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
    !draining || !currentQueue || (draining = !1,
    currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1,
    queue.length && drainQueue())
}
function drainQueue() {
    if (!draining) {
        var r = runTimeout(cleanUpNextTick);
        draining = !0;
        for (var d = queue.length; d; ) {
            for (currentQueue = queue,
            queue = []; ++queueIndex < d; )
                currentQueue && currentQueue[queueIndex].run();
            queueIndex = -1,
            d = queue.length
        }
        currentQueue = null,
        draining = !1,
        runClearTimeout(r)
    }
}
process.nextTick = function(r) {
    var d = new Array(arguments.length - 1);
    if (arguments.length > 1)
        for (var f = 1; f < arguments.length; f++)
            d[f - 1] = arguments[f];
    queue.push(new Item(r,d)),
    queue.length === 1 && !draining && runTimeout(drainQueue)
}
;
function Item(r, d) {
    this.fun = r,
    this.array = d
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array)
}
;
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop$1() {}
process.on = noop$1;
process.addListener = noop$1;
process.once = noop$1;
process.off = noop$1;
process.removeListener = noop$1;
process.removeAllListeners = noop$1;
process.emit = noop$1;
process.prependListener = noop$1;
process.prependOnceListener = noop$1;
process.listeners = function(r) {
    return []
}
;
process.binding = function(r) {
    throw new Error("process.binding is not supported")
}
;
process.cwd = function() {
    return "/"
}
;
process.chdir = function(r) {
    throw new Error("process.chdir is not supported")
}
;
process.umask = function() {
    return 0
}
;
var browserExports = browser$d.exports;
const process$1 = getDefaultExportFromCjs$1(browserExports);
var buffer$1 = {}
  , base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup$1 = []
  , revLookup = []
  , Arr = typeof Uint8Array < "u" ? Uint8Array : Array
  , code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1)
    lookup$1[i$1] = code[i$1],
    revLookup[code.charCodeAt(i$1)] = i$1;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(r) {
    var d = r.length;
    if (d % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
    var f = r.indexOf("=");
    f === -1 && (f = d);
    var m = f === d ? 0 : 4 - f % 4;
    return [f, m]
}
function byteLength(r) {
    var d = getLens(r)
      , f = d[0]
      , m = d[1];
    return (f + m) * 3 / 4 - m
}
function _byteLength(r, d, f) {
    return (d + f) * 3 / 4 - f
}
function toByteArray(r) {
    var d, f = getLens(r), m = f[0], k = f[1], y = new Arr(_byteLength(r, m, k)), ee = 0, dt = k > 0 ? m - 4 : m, mt;
    for (mt = 0; mt < dt; mt += 4)
        d = revLookup[r.charCodeAt(mt)] << 18 | revLookup[r.charCodeAt(mt + 1)] << 12 | revLookup[r.charCodeAt(mt + 2)] << 6 | revLookup[r.charCodeAt(mt + 3)],
        y[ee++] = d >> 16 & 255,
        y[ee++] = d >> 8 & 255,
        y[ee++] = d & 255;
    return k === 2 && (d = revLookup[r.charCodeAt(mt)] << 2 | revLookup[r.charCodeAt(mt + 1)] >> 4,
    y[ee++] = d & 255),
    k === 1 && (d = revLookup[r.charCodeAt(mt)] << 10 | revLookup[r.charCodeAt(mt + 1)] << 4 | revLookup[r.charCodeAt(mt + 2)] >> 2,
    y[ee++] = d >> 8 & 255,
    y[ee++] = d & 255),
    y
}
function tripletToBase64(r) {
    return lookup$1[r >> 18 & 63] + lookup$1[r >> 12 & 63] + lookup$1[r >> 6 & 63] + lookup$1[r & 63]
}
function encodeChunk(r, d, f) {
    for (var m, k = [], y = d; y < f; y += 3)
        m = (r[y] << 16 & 16711680) + (r[y + 1] << 8 & 65280) + (r[y + 2] & 255),
        k.push(tripletToBase64(m));
    return k.join("")
}
function fromByteArray(r) {
    for (var d, f = r.length, m = f % 3, k = [], y = 16383, ee = 0, dt = f - m; ee < dt; ee += y)
        k.push(encodeChunk(r, ee, ee + y > dt ? dt : ee + y));
    return m === 1 ? (d = r[f - 1],
    k.push(lookup$1[d >> 2] + lookup$1[d << 4 & 63] + "==")) : m === 2 && (d = (r[f - 2] << 8) + r[f - 1],
    k.push(lookup$1[d >> 10] + lookup$1[d >> 4 & 63] + lookup$1[d << 2 & 63] + "=")),
    k.join("")
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(r, d, f, m, k) {
    var y, ee, dt = k * 8 - m - 1, mt = (1 << dt) - 1, yt = mt >> 1, pt = -7, bt = f ? k - 1 : 0, wt = f ? -1 : 1, xt = r[d + bt];
    for (bt += wt,
    y = xt & (1 << -pt) - 1,
    xt >>= -pt,
    pt += dt; pt > 0; y = y * 256 + r[d + bt],
    bt += wt,
    pt -= 8)
        ;
    for (ee = y & (1 << -pt) - 1,
    y >>= -pt,
    pt += m; pt > 0; ee = ee * 256 + r[d + bt],
    bt += wt,
    pt -= 8)
        ;
    if (y === 0)
        y = 1 - yt;
    else {
        if (y === mt)
            return ee ? NaN : (xt ? -1 : 1) * (1 / 0);
        ee = ee + Math.pow(2, m),
        y = y - yt
    }
    return (xt ? -1 : 1) * ee * Math.pow(2, y - m)
}
;
ieee754.write = function(r, d, f, m, k, y) {
    var ee, dt, mt, yt = y * 8 - k - 1, pt = (1 << yt) - 1, bt = pt >> 1, wt = k === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, xt = m ? 0 : y - 1, At = m ? 1 : -1, Ct = d < 0 || d === 0 && 1 / d < 0 ? 1 : 0;
    for (d = Math.abs(d),
    isNaN(d) || d === 1 / 0 ? (dt = isNaN(d) ? 1 : 0,
    ee = pt) : (ee = Math.floor(Math.log(d) / Math.LN2),
    d * (mt = Math.pow(2, -ee)) < 1 && (ee--,
    mt *= 2),
    ee + bt >= 1 ? d += wt / mt : d += wt * Math.pow(2, 1 - bt),
    d * mt >= 2 && (ee++,
    mt /= 2),
    ee + bt >= pt ? (dt = 0,
    ee = pt) : ee + bt >= 1 ? (dt = (d * mt - 1) * Math.pow(2, k),
    ee = ee + bt) : (dt = d * Math.pow(2, bt - 1) * Math.pow(2, k),
    ee = 0)); k >= 8; r[f + xt] = dt & 255,
    xt += At,
    dt /= 256,
    k -= 8)
        ;
    for (ee = ee << k | dt,
    yt += k; yt > 0; r[f + xt] = ee & 255,
    xt += At,
    ee /= 256,
    yt -= 8)
        ;
    r[f + xt - At] |= Ct * 128
}
;
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(r) {
    const d = base64Js
      , f = ieee754
      , m = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    r.Buffer = pt,
    r.SlowBuffer = Wt,
    r.INSPECT_MAX_BYTES = 50;
    const k = 2147483647;
    r.kMaxLength = k;
    const {Uint8Array: y, ArrayBuffer: ee, SharedArrayBuffer: dt} = globalThis;
    pt.TYPED_ARRAY_SUPPORT = mt(),
    !pt.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function mt() {
        try {
            const Ft = new y(1)
              , Ut = {
                foo: function() {
                    return 42
                }
            };
            return Object.setPrototypeOf(Ut, y.prototype),
            Object.setPrototypeOf(Ft, Ut),
            Ft.foo() === 42
        } catch {
            return !1
        }
    }
    Object.defineProperty(pt.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (pt.isBuffer(this))
                return this.buffer
        }
    }),
    Object.defineProperty(pt.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (pt.isBuffer(this))
                return this.byteOffset
        }
    });
    function yt(Ft) {
        if (Ft > k)
            throw new RangeError('The value "' + Ft + '" is invalid for option "size"');
        const Ut = new y(Ft);
        return Object.setPrototypeOf(Ut, pt.prototype),
        Ut
    }
    function pt(Ft, Ut, Dt) {
        if (typeof Ft == "number") {
            if (typeof Ut == "string")
                throw new TypeError('The "string" argument must be of type string. Received type number');
            return At(Ft)
        }
        return bt(Ft, Ut, Dt)
    }
    pt.poolSize = 8192;
    function bt(Ft, Ut, Dt) {
        if (typeof Ft == "string")
            return Ct(Ft, Ut);
        if (ee.isView(Ft))
            return $t(Ft);
        if (Ft == null)
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Ft);
        if (vr(Ft, ee) || Ft && vr(Ft.buffer, ee) || typeof dt < "u" && (vr(Ft, dt) || Ft && vr(Ft.buffer, dt)))
            return Ot(Ft, Ut, Dt);
        if (typeof Ft == "number")
            throw new TypeError('The "value" argument must not be of type number. Received type number');
        const er = Ft.valueOf && Ft.valueOf();
        if (er != null && er !== Ft)
            return pt.from(er, Ut, Dt);
        const br = Nt(Ft);
        if (br)
            return br;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Ft[Symbol.toPrimitive] == "function")
            return pt.from(Ft[Symbol.toPrimitive]("string"), Ut, Dt);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Ft)
    }
    pt.from = function(Ft, Ut, Dt) {
        return bt(Ft, Ut, Dt)
    }
    ,
    Object.setPrototypeOf(pt.prototype, y.prototype),
    Object.setPrototypeOf(pt, y);
    function wt(Ft) {
        if (typeof Ft != "number")
            throw new TypeError('"size" argument must be of type number');
        if (Ft < 0)
            throw new RangeError('The value "' + Ft + '" is invalid for option "size"')
    }
    function xt(Ft, Ut, Dt) {
        return wt(Ft),
        Ft <= 0 ? yt(Ft) : Ut !== void 0 ? typeof Dt == "string" ? yt(Ft).fill(Ut, Dt) : yt(Ft).fill(Ut) : yt(Ft)
    }
    pt.alloc = function(Ft, Ut, Dt) {
        return xt(Ft, Ut, Dt)
    }
    ;
    function At(Ft) {
        return wt(Ft),
        yt(Ft < 0 ? 0 : zt(Ft) | 0)
    }
    pt.allocUnsafe = function(Ft) {
        return At(Ft)
    }
    ,
    pt.allocUnsafeSlow = function(Ft) {
        return At(Ft)
    }
    ;
    function Ct(Ft, Ut) {
        if ((typeof Ut != "string" || Ut === "") && (Ut = "utf8"),
        !pt.isEncoding(Ut))
            throw new TypeError("Unknown encoding: " + Ut);
        const Dt = Kt(Ft, Ut) | 0;
        let er = yt(Dt);
        const br = er.write(Ft, Ut);
        return br !== Dt && (er = er.slice(0, br)),
        er
    }
    function Pt(Ft) {
        const Ut = Ft.length < 0 ? 0 : zt(Ft.length) | 0
          , Dt = yt(Ut);
        for (let er = 0; er < Ut; er += 1)
            Dt[er] = Ft[er] & 255;
        return Dt
    }
    function $t(Ft) {
        if (vr(Ft, y)) {
            const Ut = new y(Ft);
            return Ot(Ut.buffer, Ut.byteOffset, Ut.byteLength)
        }
        return Pt(Ft)
    }
    function Ot(Ft, Ut, Dt) {
        if (Ut < 0 || Ft.byteLength < Ut)
            throw new RangeError('"offset" is outside of buffer bounds');
        if (Ft.byteLength < Ut + (Dt || 0))
            throw new RangeError('"length" is outside of buffer bounds');
        let er;
        return Ut === void 0 && Dt === void 0 ? er = new y(Ft) : Dt === void 0 ? er = new y(Ft,Ut) : er = new y(Ft,Ut,Dt),
        Object.setPrototypeOf(er, pt.prototype),
        er
    }
    function Nt(Ft) {
        if (pt.isBuffer(Ft)) {
            const Ut = zt(Ft.length) | 0
              , Dt = yt(Ut);
            return Dt.length === 0 || Ft.copy(Dt, 0, 0, Ut),
            Dt
        }
        if (Ft.length !== void 0)
            return typeof Ft.length != "number" || ar(Ft.length) ? yt(0) : Pt(Ft);
        if (Ft.type === "Buffer" && Array.isArray(Ft.data))
            return Pt(Ft.data)
    }
    function zt(Ft) {
        if (Ft >= k)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + k.toString(16) + " bytes");
        return Ft | 0
    }
    function Wt(Ft) {
        return +Ft != Ft && (Ft = 0),
        pt.alloc(+Ft)
    }
    pt.isBuffer = function(Ut) {
        return Ut != null && Ut._isBuffer === !0 && Ut !== pt.prototype
    }
    ,
    pt.compare = function(Ut, Dt) {
        if (vr(Ut, y) && (Ut = pt.from(Ut, Ut.offset, Ut.byteLength)),
        vr(Dt, y) && (Dt = pt.from(Dt, Dt.offset, Dt.byteLength)),
        !pt.isBuffer(Ut) || !pt.isBuffer(Dt))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (Ut === Dt)
            return 0;
        let er = Ut.length
          , br = Dt.length;
        for (let Cr = 0, xr = Math.min(er, br); Cr < xr; ++Cr)
            if (Ut[Cr] !== Dt[Cr]) {
                er = Ut[Cr],
                br = Dt[Cr];
                break
            }
        return er < br ? -1 : br < er ? 1 : 0
    }
    ,
    pt.isEncoding = function(Ut) {
        switch (String(Ut).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return !0;
        default:
            return !1
        }
    }
    ,
    pt.concat = function(Ut, Dt) {
        if (!Array.isArray(Ut))
            throw new TypeError('"list" argument must be an Array of Buffers');
        if (Ut.length === 0)
            return pt.alloc(0);
        let er;
        if (Dt === void 0)
            for (Dt = 0,
            er = 0; er < Ut.length; ++er)
                Dt += Ut[er].length;
        const br = pt.allocUnsafe(Dt);
        let Cr = 0;
        for (er = 0; er < Ut.length; ++er) {
            let xr = Ut[er];
            if (vr(xr, y))
                Cr + xr.length > br.length ? (pt.isBuffer(xr) || (xr = pt.from(xr)),
                xr.copy(br, Cr)) : y.prototype.set.call(br, xr, Cr);
            else if (pt.isBuffer(xr))
                xr.copy(br, Cr);
            else
                throw new TypeError('"list" argument must be an Array of Buffers');
            Cr += xr.length
        }
        return br
    }
    ;
    function Kt(Ft, Ut) {
        if (pt.isBuffer(Ft))
            return Ft.length;
        if (ee.isView(Ft) || vr(Ft, ee))
            return Ft.byteLength;
        if (typeof Ft != "string")
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Ft);
        const Dt = Ft.length
          , er = arguments.length > 2 && arguments[2] === !0;
        if (!er && Dt === 0)
            return 0;
        let br = !1;
        for (; ; )
            switch (Ut) {
            case "ascii":
            case "latin1":
            case "binary":
                return Dt;
            case "utf8":
            case "utf-8":
                return Zr(Ft).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Dt * 2;
            case "hex":
                return Dt >>> 1;
            case "base64":
                return Qr(Ft).length;
            default:
                if (br)
                    return er ? -1 : Zr(Ft).length;
                Ut = ("" + Ut).toLowerCase(),
                br = !0
            }
    }
    pt.byteLength = Kt;
    function ir(Ft, Ut, Dt) {
        let er = !1;
        if ((Ut === void 0 || Ut < 0) && (Ut = 0),
        Ut > this.length || ((Dt === void 0 || Dt > this.length) && (Dt = this.length),
        Dt <= 0) || (Dt >>>= 0,
        Ut >>>= 0,
        Dt <= Ut))
            return "";
        for (Ft || (Ft = "utf8"); ; )
            switch (Ft) {
            case "hex":
                return St(this, Ut, Dt);
            case "utf8":
            case "utf-8":
                return Bt(this, Ut, Dt);
            case "ascii":
                return Tt(this, Ut, Dt);
            case "latin1":
            case "binary":
                return It(this, Ut, Dt);
            case "base64":
                return Et(this, Ut, Dt);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return qt(this, Ut, Dt);
            default:
                if (er)
                    throw new TypeError("Unknown encoding: " + Ft);
                Ft = (Ft + "").toLowerCase(),
                er = !0
            }
    }
    pt.prototype._isBuffer = !0;
    function or(Ft, Ut, Dt) {
        const er = Ft[Ut];
        Ft[Ut] = Ft[Dt],
        Ft[Dt] = er
    }
    pt.prototype.swap16 = function() {
        const Ut = this.length;
        if (Ut % 2 !== 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let Dt = 0; Dt < Ut; Dt += 2)
            or(this, Dt, Dt + 1);
        return this
    }
    ,
    pt.prototype.swap32 = function() {
        const Ut = this.length;
        if (Ut % 4 !== 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let Dt = 0; Dt < Ut; Dt += 4)
            or(this, Dt, Dt + 3),
            or(this, Dt + 1, Dt + 2);
        return this
    }
    ,
    pt.prototype.swap64 = function() {
        const Ut = this.length;
        if (Ut % 8 !== 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let Dt = 0; Dt < Ut; Dt += 8)
            or(this, Dt, Dt + 7),
            or(this, Dt + 1, Dt + 6),
            or(this, Dt + 2, Dt + 5),
            or(this, Dt + 3, Dt + 4);
        return this
    }
    ,
    pt.prototype.toString = function() {
        const Ut = this.length;
        return Ut === 0 ? "" : arguments.length === 0 ? Bt(this, 0, Ut) : ir.apply(this, arguments)
    }
    ,
    pt.prototype.toLocaleString = pt.prototype.toString,
    pt.prototype.equals = function(Ut) {
        if (!pt.isBuffer(Ut))
            throw new TypeError("Argument must be a Buffer");
        return this === Ut ? !0 : pt.compare(this, Ut) === 0
    }
    ,
    pt.prototype.inspect = function() {
        let Ut = "";
        const Dt = r.INSPECT_MAX_BYTES;
        return Ut = this.toString("hex", 0, Dt).replace(/(.{2})/g, "$1 ").trim(),
        this.length > Dt && (Ut += " ... "),
        "<Buffer " + Ut + ">"
    }
    ,
    m && (pt.prototype[m] = pt.prototype.inspect),
    pt.prototype.compare = function(Ut, Dt, er, br, Cr) {
        if (vr(Ut, y) && (Ut = pt.from(Ut, Ut.offset, Ut.byteLength)),
        !pt.isBuffer(Ut))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Ut);
        if (Dt === void 0 && (Dt = 0),
        er === void 0 && (er = Ut ? Ut.length : 0),
        br === void 0 && (br = 0),
        Cr === void 0 && (Cr = this.length),
        Dt < 0 || er > Ut.length || br < 0 || Cr > this.length)
            throw new RangeError("out of range index");
        if (br >= Cr && Dt >= er)
            return 0;
        if (br >= Cr)
            return -1;
        if (Dt >= er)
            return 1;
        if (Dt >>>= 0,
        er >>>= 0,
        br >>>= 0,
        Cr >>>= 0,
        this === Ut)
            return 0;
        let xr = Cr - br
          , Lr = er - Dt;
        const Ur = Math.min(xr, Lr)
          , Ir = this.slice(br, Cr)
          , Jr = Ut.slice(Dt, er);
        for (let Wr = 0; Wr < Ur; ++Wr)
            if (Ir[Wr] !== Jr[Wr]) {
                xr = Ir[Wr],
                Lr = Jr[Wr];
                break
            }
        return xr < Lr ? -1 : Lr < xr ? 1 : 0
    }
    ;
    function tr(Ft, Ut, Dt, er, br) {
        if (Ft.length === 0)
            return -1;
        if (typeof Dt == "string" ? (er = Dt,
        Dt = 0) : Dt > 2147483647 ? Dt = 2147483647 : Dt < -2147483648 && (Dt = -2147483648),
        Dt = +Dt,
        ar(Dt) && (Dt = br ? 0 : Ft.length - 1),
        Dt < 0 && (Dt = Ft.length + Dt),
        Dt >= Ft.length) {
            if (br)
                return -1;
            Dt = Ft.length - 1
        } else if (Dt < 0)
            if (br)
                Dt = 0;
            else
                return -1;
        if (typeof Ut == "string" && (Ut = pt.from(Ut, er)),
        pt.isBuffer(Ut))
            return Ut.length === 0 ? -1 : wr(Ft, Ut, Dt, er, br);
        if (typeof Ut == "number")
            return Ut = Ut & 255,
            typeof y.prototype.indexOf == "function" ? br ? y.prototype.indexOf.call(Ft, Ut, Dt) : y.prototype.lastIndexOf.call(Ft, Ut, Dt) : wr(Ft, [Ut], Dt, er, br);
        throw new TypeError("val must be string, number or Buffer")
    }
    function wr(Ft, Ut, Dt, er, br) {
        let Cr = 1
          , xr = Ft.length
          , Lr = Ut.length;
        if (er !== void 0 && (er = String(er).toLowerCase(),
        er === "ucs2" || er === "ucs-2" || er === "utf16le" || er === "utf-16le")) {
            if (Ft.length < 2 || Ut.length < 2)
                return -1;
            Cr = 2,
            xr /= 2,
            Lr /= 2,
            Dt /= 2
        }
        function Ur(Jr, Wr) {
            return Cr === 1 ? Jr[Wr] : Jr.readUInt16BE(Wr * Cr)
        }
        let Ir;
        if (br) {
            let Jr = -1;
            for (Ir = Dt; Ir < xr; Ir++)
                if (Ur(Ft, Ir) === Ur(Ut, Jr === -1 ? 0 : Ir - Jr)) {
                    if (Jr === -1 && (Jr = Ir),
                    Ir - Jr + 1 === Lr)
                        return Jr * Cr
                } else
                    Jr !== -1 && (Ir -= Ir - Jr),
                    Jr = -1
        } else
            for (Dt + Lr > xr && (Dt = xr - Lr),
            Ir = Dt; Ir >= 0; Ir--) {
                let Jr = !0;
                for (let Wr = 0; Wr < Lr; Wr++)
                    if (Ur(Ft, Ir + Wr) !== Ur(Ut, Wr)) {
                        Jr = !1;
                        break
                    }
                if (Jr)
                    return Ir
            }
        return -1
    }
    pt.prototype.includes = function(Ut, Dt, er) {
        return this.indexOf(Ut, Dt, er) !== -1
    }
    ,
    pt.prototype.indexOf = function(Ut, Dt, er) {
        return tr(this, Ut, Dt, er, !0)
    }
    ,
    pt.prototype.lastIndexOf = function(Ut, Dt, er) {
        return tr(this, Ut, Dt, er, !1)
    }
    ;
    function Ht(Ft, Ut, Dt, er) {
        Dt = Number(Dt) || 0;
        const br = Ft.length - Dt;
        er ? (er = Number(er),
        er > br && (er = br)) : er = br;
        const Cr = Ut.length;
        er > Cr / 2 && (er = Cr / 2);
        let xr;
        for (xr = 0; xr < er; ++xr) {
            const Lr = parseInt(Ut.substr(xr * 2, 2), 16);
            if (ar(Lr))
                return xr;
            Ft[Dt + xr] = Lr
        }
        return xr
    }
    function Mt(Ft, Ut, Dt, er) {
        return Gr(Zr(Ut, Ft.length - Dt), Ft, Dt, er)
    }
    function _t(Ft, Ut, Dt, er) {
        return Gr(Hr(Ut), Ft, Dt, er)
    }
    function gt(Ft, Ut, Dt, er) {
        return Gr(Qr(Ut), Ft, Dt, er)
    }
    function vt(Ft, Ut, Dt, er) {
        return Gr(un(Ut, Ft.length - Dt), Ft, Dt, er)
    }
    pt.prototype.write = function(Ut, Dt, er, br) {
        if (Dt === void 0)
            br = "utf8",
            er = this.length,
            Dt = 0;
        else if (er === void 0 && typeof Dt == "string")
            br = Dt,
            er = this.length,
            Dt = 0;
        else if (isFinite(Dt))
            Dt = Dt >>> 0,
            isFinite(er) ? (er = er >>> 0,
            br === void 0 && (br = "utf8")) : (br = er,
            er = void 0);
        else
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const Cr = this.length - Dt;
        if ((er === void 0 || er > Cr) && (er = Cr),
        Ut.length > 0 && (er < 0 || Dt < 0) || Dt > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
        br || (br = "utf8");
        let xr = !1;
        for (; ; )
            switch (br) {
            case "hex":
                return Ht(this, Ut, Dt, er);
            case "utf8":
            case "utf-8":
                return Mt(this, Ut, Dt, er);
            case "ascii":
            case "latin1":
            case "binary":
                return _t(this, Ut, Dt, er);
            case "base64":
                return gt(this, Ut, Dt, er);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return vt(this, Ut, Dt, er);
            default:
                if (xr)
                    throw new TypeError("Unknown encoding: " + br);
                br = ("" + br).toLowerCase(),
                xr = !0
            }
    }
    ,
    pt.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    }
    ;
    function Et(Ft, Ut, Dt) {
        return Ut === 0 && Dt === Ft.length ? d.fromByteArray(Ft) : d.fromByteArray(Ft.slice(Ut, Dt))
    }
    function Bt(Ft, Ut, Dt) {
        Dt = Math.min(Ft.length, Dt);
        const er = [];
        let br = Ut;
        for (; br < Dt; ) {
            const Cr = Ft[br];
            let xr = null
              , Lr = Cr > 239 ? 4 : Cr > 223 ? 3 : Cr > 191 ? 2 : 1;
            if (br + Lr <= Dt) {
                let Ur, Ir, Jr, Wr;
                switch (Lr) {
                case 1:
                    Cr < 128 && (xr = Cr);
                    break;
                case 2:
                    Ur = Ft[br + 1],
                    (Ur & 192) === 128 && (Wr = (Cr & 31) << 6 | Ur & 63,
                    Wr > 127 && (xr = Wr));
                    break;
                case 3:
                    Ur = Ft[br + 1],
                    Ir = Ft[br + 2],
                    (Ur & 192) === 128 && (Ir & 192) === 128 && (Wr = (Cr & 15) << 12 | (Ur & 63) << 6 | Ir & 63,
                    Wr > 2047 && (Wr < 55296 || Wr > 57343) && (xr = Wr));
                    break;
                case 4:
                    Ur = Ft[br + 1],
                    Ir = Ft[br + 2],
                    Jr = Ft[br + 3],
                    (Ur & 192) === 128 && (Ir & 192) === 128 && (Jr & 192) === 128 && (Wr = (Cr & 15) << 18 | (Ur & 63) << 12 | (Ir & 63) << 6 | Jr & 63,
                    Wr > 65535 && Wr < 1114112 && (xr = Wr))
                }
            }
            xr === null ? (xr = 65533,
            Lr = 1) : xr > 65535 && (xr -= 65536,
            er.push(xr >>> 10 & 1023 | 55296),
            xr = 56320 | xr & 1023),
            er.push(xr),
            br += Lr
        }
        return kt(er)
    }
    const Rt = 4096;
    function kt(Ft) {
        const Ut = Ft.length;
        if (Ut <= Rt)
            return String.fromCharCode.apply(String, Ft);
        let Dt = ""
          , er = 0;
        for (; er < Ut; )
            Dt += String.fromCharCode.apply(String, Ft.slice(er, er += Rt));
        return Dt
    }
    function Tt(Ft, Ut, Dt) {
        let er = "";
        Dt = Math.min(Ft.length, Dt);
        for (let br = Ut; br < Dt; ++br)
            er += String.fromCharCode(Ft[br] & 127);
        return er
    }
    function It(Ft, Ut, Dt) {
        let er = "";
        Dt = Math.min(Ft.length, Dt);
        for (let br = Ut; br < Dt; ++br)
            er += String.fromCharCode(Ft[br]);
        return er
    }
    function St(Ft, Ut, Dt) {
        const er = Ft.length;
        (!Ut || Ut < 0) && (Ut = 0),
        (!Dt || Dt < 0 || Dt > er) && (Dt = er);
        let br = "";
        for (let Cr = Ut; Cr < Dt; ++Cr)
            br += hr[Ft[Cr]];
        return br
    }
    function qt(Ft, Ut, Dt) {
        const er = Ft.slice(Ut, Dt);
        let br = "";
        for (let Cr = 0; Cr < er.length - 1; Cr += 2)
            br += String.fromCharCode(er[Cr] + er[Cr + 1] * 256);
        return br
    }
    pt.prototype.slice = function(Ut, Dt) {
        const er = this.length;
        Ut = ~~Ut,
        Dt = Dt === void 0 ? er : ~~Dt,
        Ut < 0 ? (Ut += er,
        Ut < 0 && (Ut = 0)) : Ut > er && (Ut = er),
        Dt < 0 ? (Dt += er,
        Dt < 0 && (Dt = 0)) : Dt > er && (Dt = er),
        Dt < Ut && (Dt = Ut);
        const br = this.subarray(Ut, Dt);
        return Object.setPrototypeOf(br, pt.prototype),
        br
    }
    ;
    function ur(Ft, Ut, Dt) {
        if (Ft % 1 !== 0 || Ft < 0)
            throw new RangeError("offset is not uint");
        if (Ft + Ut > Dt)
            throw new RangeError("Trying to access beyond buffer length")
    }
    pt.prototype.readUintLE = pt.prototype.readUIntLE = function(Ut, Dt, er) {
        Ut = Ut >>> 0,
        Dt = Dt >>> 0,
        er || ur(Ut, Dt, this.length);
        let br = this[Ut]
          , Cr = 1
          , xr = 0;
        for (; ++xr < Dt && (Cr *= 256); )
            br += this[Ut + xr] * Cr;
        return br
    }
    ,
    pt.prototype.readUintBE = pt.prototype.readUIntBE = function(Ut, Dt, er) {
        Ut = Ut >>> 0,
        Dt = Dt >>> 0,
        er || ur(Ut, Dt, this.length);
        let br = this[Ut + --Dt]
          , Cr = 1;
        for (; Dt > 0 && (Cr *= 256); )
            br += this[Ut + --Dt] * Cr;
        return br
    }
    ,
    pt.prototype.readUint8 = pt.prototype.readUInt8 = function(Ut, Dt) {
        return Ut = Ut >>> 0,
        Dt || ur(Ut, 1, this.length),
        this[Ut]
    }
    ,
    pt.prototype.readUint16LE = pt.prototype.readUInt16LE = function(Ut, Dt) {
        return Ut = Ut >>> 0,
        Dt || ur(Ut, 2, this.length),
        this[Ut] | this[Ut + 1] << 8
    }
    ,
    pt.prototype.readUint16BE = pt.prototype.readUInt16BE = function(Ut, Dt) {
        return Ut = Ut >>> 0,
        Dt || ur(Ut, 2, this.length),
        this[Ut] << 8 | this[Ut + 1]
    }
    ,
    pt.prototype.readUint32LE = pt.prototype.readUInt32LE = function(Ut, Dt) {
        return Ut = Ut >>> 0,
        Dt || ur(Ut, 4, this.length),
        (this[Ut] | this[Ut + 1] << 8 | this[Ut + 2] << 16) + this[Ut + 3] * 16777216
    }
    ,
    pt.prototype.readUint32BE = pt.prototype.readUInt32BE = function(Ut, Dt) {
        return Ut = Ut >>> 0,
        Dt || ur(Ut, 4, this.length),
        this[Ut] * 16777216 + (this[Ut + 1] << 16 | this[Ut + 2] << 8 | this[Ut + 3])
    }
    ,
    pt.prototype.readBigUInt64LE = _r(function(Ut) {
        Ut = Ut >>> 0,
        Nr(Ut, "offset");
        const Dt = this[Ut]
          , er = this[Ut + 7];
        (Dt === void 0 || er === void 0) && Dr(Ut, this.length - 8);
        const br = Dt + this[++Ut] * 2 ** 8 + this[++Ut] * 2 ** 16 + this[++Ut] * 2 ** 24
          , Cr = this[++Ut] + this[++Ut] * 2 ** 8 + this[++Ut] * 2 ** 16 + er * 2 ** 24;
        return BigInt(br) + (BigInt(Cr) << BigInt(32))
    }),
    pt.prototype.readBigUInt64BE = _r(function(Ut) {
        Ut = Ut >>> 0,
        Nr(Ut, "offset");
        const Dt = this[Ut]
          , er = this[Ut + 7];
        (Dt === void 0 || er === void 0) && Dr(Ut, this.length - 8);
        const br = Dt * 2 ** 24 + this[++Ut] * 2 ** 16 + this[++Ut] * 2 ** 8 + this[++Ut]
          , Cr = this[++Ut] * 2 ** 24 + this[++Ut] * 2 ** 16 + this[++Ut] * 2 ** 8 + er;
        return (BigInt(br) << BigInt(32)) + BigInt(Cr)
    }),
    pt.prototype.readIntLE = function(Ut, Dt, er) {
        Ut = Ut >>> 0,
        Dt = Dt >>> 0,
        er || ur(Ut, Dt, this.length);
        let br = this[Ut]
          , Cr = 1
          , xr = 0;
        for (; ++xr < Dt && (Cr *= 256); )
            br += this[Ut + xr] * Cr;
        return Cr *= 128,
        br >= Cr && (br -= Math.pow(2, 8 * Dt)),
        br
    }
    ,
    pt.prototype.readIntBE = function(Ut, Dt, er) {
        Ut = Ut >>> 0,
        Dt = Dt >>> 0,
        er || ur(Ut, Dt, this.length);
        let br = Dt
          , Cr = 1
          , xr = this[Ut + --br];
        for (; br > 0 && (Cr *= 256); )
            xr += this[Ut + --br] * Cr;
        return Cr *= 128,
        xr >= Cr && (xr -= Math.pow(2, 8 * Dt)),
        xr
    }
    ,
    pt.prototype.readInt8 = function(Ut, Dt) {
        return Ut = Ut >>> 0,
        Dt || ur(Ut, 1, this.length),
        this[Ut] & 128 ? (255 - this[Ut] + 1) * -1 : this[Ut]
    }
    ,
    pt.prototype.readInt16LE = function(Ut, Dt) {
        Ut = Ut >>> 0,
        Dt || ur(Ut, 2, this.length);
        const er = this[Ut] | this[Ut + 1] << 8;
        return er & 32768 ? er | 4294901760 : er
    }
    ,
    pt.prototype.readInt16BE = function(Ut, Dt) {
        Ut = Ut >>> 0,
        Dt || ur(Ut, 2, this.length);
        const er = this[Ut + 1] | this[Ut] << 8;
        return er & 32768 ? er | 4294901760 : er
    }
    ,
    pt.prototype.readInt32LE = function(Ut, Dt) {
        return Ut = Ut >>> 0,
        Dt || ur(Ut, 4, this.length),
        this[Ut] | this[Ut + 1] << 8 | this[Ut + 2] << 16 | this[Ut + 3] << 24
    }
    ,
    pt.prototype.readInt32BE = function(Ut, Dt) {
        return Ut = Ut >>> 0,
        Dt || ur(Ut, 4, this.length),
        this[Ut] << 24 | this[Ut + 1] << 16 | this[Ut + 2] << 8 | this[Ut + 3]
    }
    ,
    pt.prototype.readBigInt64LE = _r(function(Ut) {
        Ut = Ut >>> 0,
        Nr(Ut, "offset");
        const Dt = this[Ut]
          , er = this[Ut + 7];
        (Dt === void 0 || er === void 0) && Dr(Ut, this.length - 8);
        const br = this[Ut + 4] + this[Ut + 5] * 2 ** 8 + this[Ut + 6] * 2 ** 16 + (er << 24);
        return (BigInt(br) << BigInt(32)) + BigInt(Dt + this[++Ut] * 2 ** 8 + this[++Ut] * 2 ** 16 + this[++Ut] * 2 ** 24)
    }),
    pt.prototype.readBigInt64BE = _r(function(Ut) {
        Ut = Ut >>> 0,
        Nr(Ut, "offset");
        const Dt = this[Ut]
          , er = this[Ut + 7];
        (Dt === void 0 || er === void 0) && Dr(Ut, this.length - 8);
        const br = (Dt << 24) + this[++Ut] * 2 ** 16 + this[++Ut] * 2 ** 8 + this[++Ut];
        return (BigInt(br) << BigInt(32)) + BigInt(this[++Ut] * 2 ** 24 + this[++Ut] * 2 ** 16 + this[++Ut] * 2 ** 8 + er)
    }),
    pt.prototype.readFloatLE = function(Ut, Dt) {
        return Ut = Ut >>> 0,
        Dt || ur(Ut, 4, this.length),
        f.read(this, Ut, !0, 23, 4)
    }
    ,
    pt.prototype.readFloatBE = function(Ut, Dt) {
        return Ut = Ut >>> 0,
        Dt || ur(Ut, 4, this.length),
        f.read(this, Ut, !1, 23, 4)
    }
    ,
    pt.prototype.readDoubleLE = function(Ut, Dt) {
        return Ut = Ut >>> 0,
        Dt || ur(Ut, 8, this.length),
        f.read(this, Ut, !0, 52, 8)
    }
    ,
    pt.prototype.readDoubleBE = function(Ut, Dt) {
        return Ut = Ut >>> 0,
        Dt || ur(Ut, 8, this.length),
        f.read(this, Ut, !1, 52, 8)
    }
    ;
    function gr(Ft, Ut, Dt, er, br, Cr) {
        if (!pt.isBuffer(Ft))
            throw new TypeError('"buffer" argument must be a Buffer instance');
        if (Ut > br || Ut < Cr)
            throw new RangeError('"value" argument is out of bounds');
        if (Dt + er > Ft.length)
            throw new RangeError("Index out of range")
    }
    pt.prototype.writeUintLE = pt.prototype.writeUIntLE = function(Ut, Dt, er, br) {
        if (Ut = +Ut,
        Dt = Dt >>> 0,
        er = er >>> 0,
        !br) {
            const Lr = Math.pow(2, 8 * er) - 1;
            gr(this, Ut, Dt, er, Lr, 0)
        }
        let Cr = 1
          , xr = 0;
        for (this[Dt] = Ut & 255; ++xr < er && (Cr *= 256); )
            this[Dt + xr] = Ut / Cr & 255;
        return Dt + er
    }
    ,
    pt.prototype.writeUintBE = pt.prototype.writeUIntBE = function(Ut, Dt, er, br) {
        if (Ut = +Ut,
        Dt = Dt >>> 0,
        er = er >>> 0,
        !br) {
            const Lr = Math.pow(2, 8 * er) - 1;
            gr(this, Ut, Dt, er, Lr, 0)
        }
        let Cr = er - 1
          , xr = 1;
        for (this[Dt + Cr] = Ut & 255; --Cr >= 0 && (xr *= 256); )
            this[Dt + Cr] = Ut / xr & 255;
        return Dt + er
    }
    ,
    pt.prototype.writeUint8 = pt.prototype.writeUInt8 = function(Ut, Dt, er) {
        return Ut = +Ut,
        Dt = Dt >>> 0,
        er || gr(this, Ut, Dt, 1, 255, 0),
        this[Dt] = Ut & 255,
        Dt + 1
    }
    ,
    pt.prototype.writeUint16LE = pt.prototype.writeUInt16LE = function(Ut, Dt, er) {
        return Ut = +Ut,
        Dt = Dt >>> 0,
        er || gr(this, Ut, Dt, 2, 65535, 0),
        this[Dt] = Ut & 255,
        this[Dt + 1] = Ut >>> 8,
        Dt + 2
    }
    ,
    pt.prototype.writeUint16BE = pt.prototype.writeUInt16BE = function(Ut, Dt, er) {
        return Ut = +Ut,
        Dt = Dt >>> 0,
        er || gr(this, Ut, Dt, 2, 65535, 0),
        this[Dt] = Ut >>> 8,
        this[Dt + 1] = Ut & 255,
        Dt + 2
    }
    ,
    pt.prototype.writeUint32LE = pt.prototype.writeUInt32LE = function(Ut, Dt, er) {
        return Ut = +Ut,
        Dt = Dt >>> 0,
        er || gr(this, Ut, Dt, 4, 4294967295, 0),
        this[Dt + 3] = Ut >>> 24,
        this[Dt + 2] = Ut >>> 16,
        this[Dt + 1] = Ut >>> 8,
        this[Dt] = Ut & 255,
        Dt + 4
    }
    ,
    pt.prototype.writeUint32BE = pt.prototype.writeUInt32BE = function(Ut, Dt, er) {
        return Ut = +Ut,
        Dt = Dt >>> 0,
        er || gr(this, Ut, Dt, 4, 4294967295, 0),
        this[Dt] = Ut >>> 24,
        this[Dt + 1] = Ut >>> 16,
        this[Dt + 2] = Ut >>> 8,
        this[Dt + 3] = Ut & 255,
        Dt + 4
    }
    ;
    function lr(Ft, Ut, Dt, er, br) {
        qr(Ut, er, br, Ft, Dt, 7);
        let Cr = Number(Ut & BigInt(4294967295));
        Ft[Dt++] = Cr,
        Cr = Cr >> 8,
        Ft[Dt++] = Cr,
        Cr = Cr >> 8,
        Ft[Dt++] = Cr,
        Cr = Cr >> 8,
        Ft[Dt++] = Cr;
        let xr = Number(Ut >> BigInt(32) & BigInt(4294967295));
        return Ft[Dt++] = xr,
        xr = xr >> 8,
        Ft[Dt++] = xr,
        xr = xr >> 8,
        Ft[Dt++] = xr,
        xr = xr >> 8,
        Ft[Dt++] = xr,
        Dt
    }
    function Zt(Ft, Ut, Dt, er, br) {
        qr(Ut, er, br, Ft, Dt, 7);
        let Cr = Number(Ut & BigInt(4294967295));
        Ft[Dt + 7] = Cr,
        Cr = Cr >> 8,
        Ft[Dt + 6] = Cr,
        Cr = Cr >> 8,
        Ft[Dt + 5] = Cr,
        Cr = Cr >> 8,
        Ft[Dt + 4] = Cr;
        let xr = Number(Ut >> BigInt(32) & BigInt(4294967295));
        return Ft[Dt + 3] = xr,
        xr = xr >> 8,
        Ft[Dt + 2] = xr,
        xr = xr >> 8,
        Ft[Dt + 1] = xr,
        xr = xr >> 8,
        Ft[Dt] = xr,
        Dt + 8
    }
    pt.prototype.writeBigUInt64LE = _r(function(Ut, Dt=0) {
        return lr(this, Ut, Dt, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    pt.prototype.writeBigUInt64BE = _r(function(Ut, Dt=0) {
        return Zt(this, Ut, Dt, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    pt.prototype.writeIntLE = function(Ut, Dt, er, br) {
        if (Ut = +Ut,
        Dt = Dt >>> 0,
        !br) {
            const Ur = Math.pow(2, 8 * er - 1);
            gr(this, Ut, Dt, er, Ur - 1, -Ur)
        }
        let Cr = 0
          , xr = 1
          , Lr = 0;
        for (this[Dt] = Ut & 255; ++Cr < er && (xr *= 256); )
            Ut < 0 && Lr === 0 && this[Dt + Cr - 1] !== 0 && (Lr = 1),
            this[Dt + Cr] = (Ut / xr >> 0) - Lr & 255;
        return Dt + er
    }
    ,
    pt.prototype.writeIntBE = function(Ut, Dt, er, br) {
        if (Ut = +Ut,
        Dt = Dt >>> 0,
        !br) {
            const Ur = Math.pow(2, 8 * er - 1);
            gr(this, Ut, Dt, er, Ur - 1, -Ur)
        }
        let Cr = er - 1
          , xr = 1
          , Lr = 0;
        for (this[Dt + Cr] = Ut & 255; --Cr >= 0 && (xr *= 256); )
            Ut < 0 && Lr === 0 && this[Dt + Cr + 1] !== 0 && (Lr = 1),
            this[Dt + Cr] = (Ut / xr >> 0) - Lr & 255;
        return Dt + er
    }
    ,
    pt.prototype.writeInt8 = function(Ut, Dt, er) {
        return Ut = +Ut,
        Dt = Dt >>> 0,
        er || gr(this, Ut, Dt, 1, 127, -128),
        Ut < 0 && (Ut = 255 + Ut + 1),
        this[Dt] = Ut & 255,
        Dt + 1
    }
    ,
    pt.prototype.writeInt16LE = function(Ut, Dt, er) {
        return Ut = +Ut,
        Dt = Dt >>> 0,
        er || gr(this, Ut, Dt, 2, 32767, -32768),
        this[Dt] = Ut & 255,
        this[Dt + 1] = Ut >>> 8,
        Dt + 2
    }
    ,
    pt.prototype.writeInt16BE = function(Ut, Dt, er) {
        return Ut = +Ut,
        Dt = Dt >>> 0,
        er || gr(this, Ut, Dt, 2, 32767, -32768),
        this[Dt] = Ut >>> 8,
        this[Dt + 1] = Ut & 255,
        Dt + 2
    }
    ,
    pt.prototype.writeInt32LE = function(Ut, Dt, er) {
        return Ut = +Ut,
        Dt = Dt >>> 0,
        er || gr(this, Ut, Dt, 4, 2147483647, -2147483648),
        this[Dt] = Ut & 255,
        this[Dt + 1] = Ut >>> 8,
        this[Dt + 2] = Ut >>> 16,
        this[Dt + 3] = Ut >>> 24,
        Dt + 4
    }
    ,
    pt.prototype.writeInt32BE = function(Ut, Dt, er) {
        return Ut = +Ut,
        Dt = Dt >>> 0,
        er || gr(this, Ut, Dt, 4, 2147483647, -2147483648),
        Ut < 0 && (Ut = 4294967295 + Ut + 1),
        this[Dt] = Ut >>> 24,
        this[Dt + 1] = Ut >>> 16,
        this[Dt + 2] = Ut >>> 8,
        this[Dt + 3] = Ut & 255,
        Dt + 4
    }
    ,
    pt.prototype.writeBigInt64LE = _r(function(Ut, Dt=0) {
        return lr(this, Ut, Dt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }),
    pt.prototype.writeBigInt64BE = _r(function(Ut, Dt=0) {
        return Zt(this, Ut, Dt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });
    function Vt(Ft, Ut, Dt, er, br, Cr) {
        if (Dt + er > Ft.length)
            throw new RangeError("Index out of range");
        if (Dt < 0)
            throw new RangeError("Index out of range")
    }
    function rr(Ft, Ut, Dt, er, br) {
        return Ut = +Ut,
        Dt = Dt >>> 0,
        br || Vt(Ft, Ut, Dt, 4),
        f.write(Ft, Ut, Dt, er, 23, 4),
        Dt + 4
    }
    pt.prototype.writeFloatLE = function(Ut, Dt, er) {
        return rr(this, Ut, Dt, !0, er)
    }
    ,
    pt.prototype.writeFloatBE = function(Ut, Dt, er) {
        return rr(this, Ut, Dt, !1, er)
    }
    ;
    function fr(Ft, Ut, Dt, er, br) {
        return Ut = +Ut,
        Dt = Dt >>> 0,
        br || Vt(Ft, Ut, Dt, 8),
        f.write(Ft, Ut, Dt, er, 52, 8),
        Dt + 8
    }
    pt.prototype.writeDoubleLE = function(Ut, Dt, er) {
        return fr(this, Ut, Dt, !0, er)
    }
    ,
    pt.prototype.writeDoubleBE = function(Ut, Dt, er) {
        return fr(this, Ut, Dt, !1, er)
    }
    ,
    pt.prototype.copy = function(Ut, Dt, er, br) {
        if (!pt.isBuffer(Ut))
            throw new TypeError("argument should be a Buffer");
        if (er || (er = 0),
        !br && br !== 0 && (br = this.length),
        Dt >= Ut.length && (Dt = Ut.length),
        Dt || (Dt = 0),
        br > 0 && br < er && (br = er),
        br === er || Ut.length === 0 || this.length === 0)
            return 0;
        if (Dt < 0)
            throw new RangeError("targetStart out of bounds");
        if (er < 0 || er >= this.length)
            throw new RangeError("Index out of range");
        if (br < 0)
            throw new RangeError("sourceEnd out of bounds");
        br > this.length && (br = this.length),
        Ut.length - Dt < br - er && (br = Ut.length - Dt + er);
        const Cr = br - er;
        return this === Ut && typeof y.prototype.copyWithin == "function" ? this.copyWithin(Dt, er, br) : y.prototype.set.call(Ut, this.subarray(er, br), Dt),
        Cr
    }
    ,
    pt.prototype.fill = function(Ut, Dt, er, br) {
        if (typeof Ut == "string") {
            if (typeof Dt == "string" ? (br = Dt,
            Dt = 0,
            er = this.length) : typeof er == "string" && (br = er,
            er = this.length),
            br !== void 0 && typeof br != "string")
                throw new TypeError("encoding must be a string");
            if (typeof br == "string" && !pt.isEncoding(br))
                throw new TypeError("Unknown encoding: " + br);
            if (Ut.length === 1) {
                const xr = Ut.charCodeAt(0);
                (br === "utf8" && xr < 128 || br === "latin1") && (Ut = xr)
            }
        } else
            typeof Ut == "number" ? Ut = Ut & 255 : typeof Ut == "boolean" && (Ut = Number(Ut));
        if (Dt < 0 || this.length < Dt || this.length < er)
            throw new RangeError("Out of range index");
        if (er <= Dt)
            return this;
        Dt = Dt >>> 0,
        er = er === void 0 ? this.length : er >>> 0,
        Ut || (Ut = 0);
        let Cr;
        if (typeof Ut == "number")
            for (Cr = Dt; Cr < er; ++Cr)
                this[Cr] = Ut;
        else {
            const xr = pt.isBuffer(Ut) ? Ut : pt.from(Ut, br)
              , Lr = xr.length;
            if (Lr === 0)
                throw new TypeError('The value "' + Ut + '" is invalid for argument "value"');
            for (Cr = 0; Cr < er - Dt; ++Cr)
                this[Cr + Dt] = xr[Cr % Lr]
        }
        return this
    }
    ;
    const Yt = {};
    function Xt(Ft, Ut, Dt) {
        Yt[Ft] = class extends Dt {
            constructor() {
                super(),
                Object.defineProperty(this, "message", {
                    value: Ut.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }),
                this.name = `${this.name} [${Ft}]`,
                this.stack,
                delete this.name
            }
            get code() {
                return Ft
            }
            set code(br) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: br,
                    writable: !0
                })
            }
            toString() {
                return `${this.name} [${Ft}]: ${this.message}`
            }
        }
    }
    Xt("ERR_BUFFER_OUT_OF_BOUNDS", function(Ft) {
        return Ft ? `${Ft} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError),
    Xt("ERR_INVALID_ARG_TYPE", function(Ft, Ut) {
        return `The "${Ft}" argument must be of type number. Received type ${typeof Ut}`
    }, TypeError),
    Xt("ERR_OUT_OF_RANGE", function(Ft, Ut, Dt) {
        let er = `The value of "${Ft}" is out of range.`
          , br = Dt;
        return Number.isInteger(Dt) && Math.abs(Dt) > 2 ** 32 ? br = Sr(String(Dt)) : typeof Dt == "bigint" && (br = String(Dt),
        (Dt > BigInt(2) ** BigInt(32) || Dt < -(BigInt(2) ** BigInt(32))) && (br = Sr(br)),
        br += "n"),
        er += ` It must be ${Ut}. Received ${br}`,
        er
    }, RangeError);
    function Sr(Ft) {
        let Ut = ""
          , Dt = Ft.length;
        const er = Ft[0] === "-" ? 1 : 0;
        for (; Dt >= er + 4; Dt -= 3)
            Ut = `_${Ft.slice(Dt - 3, Dt)}${Ut}`;
        return `${Ft.slice(0, Dt)}${Ut}`
    }
    function Rr(Ft, Ut, Dt) {
        Nr(Ut, "offset"),
        (Ft[Ut] === void 0 || Ft[Ut + Dt] === void 0) && Dr(Ut, Ft.length - (Dt + 1))
    }
    function qr(Ft, Ut, Dt, er, br, Cr) {
        if (Ft > Dt || Ft < Ut) {
            const xr = typeof Ut == "bigint" ? "n" : "";
            let Lr;
            throw Cr > 3 ? Ut === 0 || Ut === BigInt(0) ? Lr = `>= 0${xr} and < 2${xr} ** ${(Cr + 1) * 8}${xr}` : Lr = `>= -(2${xr} ** ${(Cr + 1) * 8 - 1}${xr}) and < 2 ** ${(Cr + 1) * 8 - 1}${xr}` : Lr = `>= ${Ut}${xr} and <= ${Dt}${xr}`,
            new Yt.ERR_OUT_OF_RANGE("value",Lr,Ft)
        }
        Rr(er, br, Cr)
    }
    function Nr(Ft, Ut) {
        if (typeof Ft != "number")
            throw new Yt.ERR_INVALID_ARG_TYPE(Ut,"number",Ft)
    }
    function Dr(Ft, Ut, Dt) {
        throw Math.floor(Ft) !== Ft ? (Nr(Ft, Dt),
        new Yt.ERR_OUT_OF_RANGE(Dt || "offset","an integer",Ft)) : Ut < 0 ? new Yt.ERR_BUFFER_OUT_OF_BOUNDS : new Yt.ERR_OUT_OF_RANGE(Dt || "offset",`>= ${Dt ? 1 : 0} and <= ${Ut}`,Ft)
    }
    const Or = /[^+/0-9A-Za-z-_]/g;
    function $r(Ft) {
        if (Ft = Ft.split("=")[0],
        Ft = Ft.trim().replace(Or, ""),
        Ft.length < 2)
            return "";
        for (; Ft.length % 4 !== 0; )
            Ft = Ft + "=";
        return Ft
    }
    function Zr(Ft, Ut) {
        Ut = Ut || 1 / 0;
        let Dt;
        const er = Ft.length;
        let br = null;
        const Cr = [];
        for (let xr = 0; xr < er; ++xr) {
            if (Dt = Ft.charCodeAt(xr),
            Dt > 55295 && Dt < 57344) {
                if (!br) {
                    if (Dt > 56319) {
                        (Ut -= 3) > -1 && Cr.push(239, 191, 189);
                        continue
                    } else if (xr + 1 === er) {
                        (Ut -= 3) > -1 && Cr.push(239, 191, 189);
                        continue
                    }
                    br = Dt;
                    continue
                }
                if (Dt < 56320) {
                    (Ut -= 3) > -1 && Cr.push(239, 191, 189),
                    br = Dt;
                    continue
                }
                Dt = (br - 55296 << 10 | Dt - 56320) + 65536
            } else
                br && (Ut -= 3) > -1 && Cr.push(239, 191, 189);
            if (br = null,
            Dt < 128) {
                if ((Ut -= 1) < 0)
                    break;
                Cr.push(Dt)
            } else if (Dt < 2048) {
                if ((Ut -= 2) < 0)
                    break;
                Cr.push(Dt >> 6 | 192, Dt & 63 | 128)
            } else if (Dt < 65536) {
                if ((Ut -= 3) < 0)
                    break;
                Cr.push(Dt >> 12 | 224, Dt >> 6 & 63 | 128, Dt & 63 | 128)
            } else if (Dt < 1114112) {
                if ((Ut -= 4) < 0)
                    break;
                Cr.push(Dt >> 18 | 240, Dt >> 12 & 63 | 128, Dt >> 6 & 63 | 128, Dt & 63 | 128)
            } else
                throw new Error("Invalid code point")
        }
        return Cr
    }
    function Hr(Ft) {
        const Ut = [];
        for (let Dt = 0; Dt < Ft.length; ++Dt)
            Ut.push(Ft.charCodeAt(Dt) & 255);
        return Ut
    }
    function un(Ft, Ut) {
        let Dt, er, br;
        const Cr = [];
        for (let xr = 0; xr < Ft.length && !((Ut -= 2) < 0); ++xr)
            Dt = Ft.charCodeAt(xr),
            er = Dt >> 8,
            br = Dt % 256,
            Cr.push(br),
            Cr.push(er);
        return Cr
    }
    function Qr(Ft) {
        return d.toByteArray($r(Ft))
    }
    function Gr(Ft, Ut, Dt, er) {
        let br;
        for (br = 0; br < er && !(br + Dt >= Ut.length || br >= Ft.length); ++br)
            Ut[br + Dt] = Ft[br];
        return br
    }
    function vr(Ft, Ut) {
        return Ft instanceof Ut || Ft != null && Ft.constructor != null && Ft.constructor.name != null && Ft.constructor.name === Ut.name
    }
    function ar(Ft) {
        return Ft !== Ft
    }
    const hr = function() {
        const Ft = "0123456789abcdef"
          , Ut = new Array(256);
        for (let Dt = 0; Dt < 16; ++Dt) {
            const er = Dt * 16;
            for (let br = 0; br < 16; ++br)
                Ut[er + br] = Ft[Dt] + Ft[br]
        }
        return Ut
    }();
    function _r(Ft) {
        return typeof BigInt > "u" ? Ar : Ft
    }
    function Ar() {
        throw new Error("BigInt not supported")
    }
}
)(buffer$1);
const Buffer = buffer$1.Buffer
  , Blob$2 = buffer$1.Blob
  , BlobOptions = buffer$1.BlobOptions
  , Buffer$1 = buffer$1.Buffer
  , File = buffer$1.File
  , FileOptions = buffer$1.FileOptions
  , INSPECT_MAX_BYTES = buffer$1.INSPECT_MAX_BYTES
  , SlowBuffer = buffer$1.SlowBuffer
  , TranscodeEncoding = buffer$1.TranscodeEncoding
  , atob$1 = buffer$1.atob
  , btoa$1 = buffer$1.btoa
  , constants$1 = buffer$1.constants
  , isAscii = buffer$1.isAscii
  , isUtf8 = buffer$1.isUtf8
  , kMaxLength = buffer$1.kMaxLength
  , kStringMaxLength = buffer$1.kStringMaxLength
  , resolveObjectURL = buffer$1.resolveObjectURL
  , transcode = buffer$1.transcode
  , dist$3 = Object.freeze(Object.defineProperty({
    __proto__: null,
    Blob: Blob$2,
    BlobOptions,
    Buffer: Buffer$1,
    File,
    FileOptions,
    INSPECT_MAX_BYTES,
    SlowBuffer,
    TranscodeEncoding,
    atob: atob$1,
    btoa: btoa$1,
    constants: constants$1,
    default: Buffer,
    isAscii,
    isUtf8,
    kMaxLength,
    kStringMaxLength,
    resolveObjectURL,
    transcode
}, Symbol.toStringTag, {
    value: "Module"
}));
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(r) {
    return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r
}
function getAugmentedNamespace(r) {
    if (r.__esModule)
        return r;
    var d = r.default;
    if (typeof d == "function") {
        var f = function m() {
            return this instanceof m ? Reflect.construct(d, arguments, this.constructor) : d.apply(this, arguments)
        };
        f.prototype = d.prototype
    } else
        f = {};
    return Object.defineProperty(f, "__esModule", {
        value: !0
    }),
    Object.keys(r).forEach(function(m) {
        var k = Object.getOwnPropertyDescriptor(r, m);
        Object.defineProperty(f, m, k.get ? k : {
            enumerable: !0,
            get: function() {
                return r[m]
            }
        })
    }),
    f
}
var naclUtil = {
    exports: {}
};
(function(r) {
    (function(d, f) {
        r.exports ? r.exports = f() : (d.nacl || (d.nacl = {}),
        d.nacl.util = f())
    }
    )(commonjsGlobal, function() {
        var d = {};
        function f(m) {
            if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(m))
                throw new TypeError("invalid encoding")
        }
        return d.decodeUTF8 = function(m) {
            if (typeof m != "string")
                throw new TypeError("expected string");
            var k, y = unescape(encodeURIComponent(m)), ee = new Uint8Array(y.length);
            for (k = 0; k < y.length; k++)
                ee[k] = y.charCodeAt(k);
            return ee
        }
        ,
        d.encodeUTF8 = function(m) {
            var k, y = [];
            for (k = 0; k < m.length; k++)
                y.push(String.fromCharCode(m[k]));
            return decodeURIComponent(escape(y.join("")))
        }
        ,
        typeof atob > "u" ? typeof Buffer.from < "u" ? (d.encodeBase64 = function(m) {
            return Buffer.from(m).toString("base64")
        }
        ,
        d.decodeBase64 = function(m) {
            return f(m),
            new Uint8Array(Array.prototype.slice.call(Buffer.from(m, "base64"), 0))
        }
        ) : (d.encodeBase64 = function(m) {
            return new Buffer(m).toString("base64")
        }
        ,
        d.decodeBase64 = function(m) {
            return f(m),
            new Uint8Array(Array.prototype.slice.call(new Buffer(m,"base64"), 0))
        }
        ) : (d.encodeBase64 = function(m) {
            var k, y = [], ee = m.length;
            for (k = 0; k < ee; k++)
                y.push(String.fromCharCode(m[k]));
            return btoa(y.join(""))
        }
        ,
        d.decodeBase64 = function(m) {
            f(m);
            var k, y = atob(m), ee = new Uint8Array(y.length);
            for (k = 0; k < y.length; k++)
                ee[k] = y.charCodeAt(k);
            return ee
        }
        ),
        d
    })
}
)(naclUtil);
var naclUtilExports = naclUtil.exports;
const nacl$2 = getDefaultExportFromCjs(naclUtilExports);
function commonjsRequire(r) {
    throw new Error('Could not dynamically require "' + r + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')
}
var naclFast = {
    exports: {}
}
  , cryptoBrowserify = {}
  , browser$c = {
    exports: {}
}
  , safeBuffer$1 = {
    exports: {}
};
const require$$1$2 = getAugmentedNamespace(dist$3);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer$1;
function requireSafeBuffer$1() {
    return hasRequiredSafeBuffer$1 || (hasRequiredSafeBuffer$1 = 1,
    function(r, d) {
        var f = require$$1$2
          , m = f.Buffer;
        function k(ee, dt) {
            for (var mt in ee)
                dt[mt] = ee[mt]
        }
        m.from && m.alloc && m.allocUnsafe && m.allocUnsafeSlow ? r.exports = f : (k(f, d),
        d.Buffer = y);
        function y(ee, dt, mt) {
            return m(ee, dt, mt)
        }
        y.prototype = Object.create(m.prototype),
        k(m, y),
        y.from = function(ee, dt, mt) {
            if (typeof ee == "number")
                throw new TypeError("Argument must not be a number");
            return m(ee, dt, mt)
        }
        ,
        y.alloc = function(ee, dt, mt) {
            if (typeof ee != "number")
                throw new TypeError("Argument must be a number");
            var yt = m(ee);
            return dt !== void 0 ? typeof mt == "string" ? yt.fill(dt, mt) : yt.fill(dt) : yt.fill(0),
            yt
        }
        ,
        y.allocUnsafe = function(ee) {
            if (typeof ee != "number")
                throw new TypeError("Argument must be a number");
            return m(ee)
        }
        ,
        y.allocUnsafeSlow = function(ee) {
            if (typeof ee != "number")
                throw new TypeError("Argument must be a number");
            return f.SlowBuffer(ee)
        }
    }(safeBuffer$1, safeBuffer$1.exports)),
    safeBuffer$1.exports
}
var hasRequiredBrowser$b;
function requireBrowser$b() {
    if (hasRequiredBrowser$b)
        return browser$c.exports;
    hasRequiredBrowser$b = 1;
    var r = 65536
      , d = 4294967295;
    function f() {
        throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`)
    }
    var m = requireSafeBuffer$1().Buffer
      , k = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
    k && k.getRandomValues ? browser$c.exports = y : browser$c.exports = f;
    function y(ee, dt) {
        if (ee > d)
            throw new RangeError("requested too many random bytes");
        var mt = m.allocUnsafe(ee);
        if (ee > 0)
            if (ee > r)
                for (var yt = 0; yt < ee; yt += r)
                    k.getRandomValues(mt.slice(yt, yt + r));
            else
                k.getRandomValues(mt);
        return typeof dt == "function" ? process$1.nextTick(function() {
            dt(null, mt)
        }) : mt
    }
    return browser$c.exports
}
var inherits_browser = {
    exports: {}
}, hasRequiredInherits_browser;
function requireInherits_browser() {
    return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1,
    typeof Object.create == "function" ? inherits_browser.exports = function(d, f) {
        f && (d.super_ = f,
        d.prototype = Object.create(f.prototype, {
            constructor: {
                value: d,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }))
    }
    : inherits_browser.exports = function(d, f) {
        if (f) {
            d.super_ = f;
            var m = function() {};
            m.prototype = f.prototype,
            d.prototype = new m,
            d.prototype.constructor = d
        }
    }
    ),
    inherits_browser.exports
}
var readableBrowser$1 = {
    exports: {}
}, events = {
    exports: {}
}, hasRequiredEvents;
function requireEvents() {
    if (hasRequiredEvents)
        return events.exports;
    hasRequiredEvents = 1;
    var r = typeof Reflect == "object" ? Reflect : null, d = r && typeof r.apply == "function" ? r.apply : function(Wt, Kt, ir) {
        return Function.prototype.apply.call(Wt, Kt, ir)
    }
    , f;
    r && typeof r.ownKeys == "function" ? f = r.ownKeys : Object.getOwnPropertySymbols ? f = function(Wt) {
        return Object.getOwnPropertyNames(Wt).concat(Object.getOwnPropertySymbols(Wt))
    }
    : f = function(Wt) {
        return Object.getOwnPropertyNames(Wt)
    }
    ;
    function m(zt) {
        console && console.warn && console.warn(zt)
    }
    var k = Number.isNaN || function(Wt) {
        return Wt !== Wt
    }
    ;
    function y() {
        y.init.call(this)
    }
    events.exports = y,
    events.exports.once = $t,
    y.EventEmitter = y,
    y.prototype._events = void 0,
    y.prototype._eventsCount = 0,
    y.prototype._maxListeners = void 0;
    var ee = 10;
    function dt(zt) {
        if (typeof zt != "function")
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof zt)
    }
    Object.defineProperty(y, "defaultMaxListeners", {
        enumerable: !0,
        get: function() {
            return ee
        },
        set: function(zt) {
            if (typeof zt != "number" || zt < 0 || k(zt))
                throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + zt + ".");
            ee = zt
        }
    }),
    y.init = function() {
        (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null),
        this._eventsCount = 0),
        this._maxListeners = this._maxListeners || void 0
    }
    ,
    y.prototype.setMaxListeners = function(Wt) {
        if (typeof Wt != "number" || Wt < 0 || k(Wt))
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + Wt + ".");
        return this._maxListeners = Wt,
        this
    }
    ;
    function mt(zt) {
        return zt._maxListeners === void 0 ? y.defaultMaxListeners : zt._maxListeners
    }
    y.prototype.getMaxListeners = function() {
        return mt(this)
    }
    ,
    y.prototype.emit = function(Wt) {
        for (var Kt = [], ir = 1; ir < arguments.length; ir++)
            Kt.push(arguments[ir]);
        var or = Wt === "error"
          , tr = this._events;
        if (tr !== void 0)
            or = or && tr.error === void 0;
        else if (!or)
            return !1;
        if (or) {
            var wr;
            if (Kt.length > 0 && (wr = Kt[0]),
            wr instanceof Error)
                throw wr;
            var Ht = new Error("Unhandled error." + (wr ? " (" + wr.message + ")" : ""));
            throw Ht.context = wr,
            Ht
        }
        var Mt = tr[Wt];
        if (Mt === void 0)
            return !1;
        if (typeof Mt == "function")
            d(Mt, this, Kt);
        else
            for (var _t = Mt.length, gt = At(Mt, _t), ir = 0; ir < _t; ++ir)
                d(gt[ir], this, Kt);
        return !0
    }
    ;
    function yt(zt, Wt, Kt, ir) {
        var or, tr, wr;
        if (dt(Kt),
        tr = zt._events,
        tr === void 0 ? (tr = zt._events = Object.create(null),
        zt._eventsCount = 0) : (tr.newListener !== void 0 && (zt.emit("newListener", Wt, Kt.listener ? Kt.listener : Kt),
        tr = zt._events),
        wr = tr[Wt]),
        wr === void 0)
            wr = tr[Wt] = Kt,
            ++zt._eventsCount;
        else if (typeof wr == "function" ? wr = tr[Wt] = ir ? [Kt, wr] : [wr, Kt] : ir ? wr.unshift(Kt) : wr.push(Kt),
        or = mt(zt),
        or > 0 && wr.length > or && !wr.warned) {
            wr.warned = !0;
            var Ht = new Error("Possible EventEmitter memory leak detected. " + wr.length + " " + String(Wt) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            Ht.name = "MaxListenersExceededWarning",
            Ht.emitter = zt,
            Ht.type = Wt,
            Ht.count = wr.length,
            m(Ht)
        }
        return zt
    }
    y.prototype.addListener = function(Wt, Kt) {
        return yt(this, Wt, Kt, !1)
    }
    ,
    y.prototype.on = y.prototype.addListener,
    y.prototype.prependListener = function(Wt, Kt) {
        return yt(this, Wt, Kt, !0)
    }
    ;
    function pt() {
        if (!this.fired)
            return this.target.removeListener(this.type, this.wrapFn),
            this.fired = !0,
            arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
    }
    function bt(zt, Wt, Kt) {
        var ir = {
            fired: !1,
            wrapFn: void 0,
            target: zt,
            type: Wt,
            listener: Kt
        }
          , or = pt.bind(ir);
        return or.listener = Kt,
        ir.wrapFn = or,
        or
    }
    y.prototype.once = function(Wt, Kt) {
        return dt(Kt),
        this.on(Wt, bt(this, Wt, Kt)),
        this
    }
    ,
    y.prototype.prependOnceListener = function(Wt, Kt) {
        return dt(Kt),
        this.prependListener(Wt, bt(this, Wt, Kt)),
        this
    }
    ,
    y.prototype.removeListener = function(Wt, Kt) {
        var ir, or, tr, wr, Ht;
        if (dt(Kt),
        or = this._events,
        or === void 0)
            return this;
        if (ir = or[Wt],
        ir === void 0)
            return this;
        if (ir === Kt || ir.listener === Kt)
            --this._eventsCount === 0 ? this._events = Object.create(null) : (delete or[Wt],
            or.removeListener && this.emit("removeListener", Wt, ir.listener || Kt));
        else if (typeof ir != "function") {
            for (tr = -1,
            wr = ir.length - 1; wr >= 0; wr--)
                if (ir[wr] === Kt || ir[wr].listener === Kt) {
                    Ht = ir[wr].listener,
                    tr = wr;
                    break
                }
            if (tr < 0)
                return this;
            tr === 0 ? ir.shift() : Ct(ir, tr),
            ir.length === 1 && (or[Wt] = ir[0]),
            or.removeListener !== void 0 && this.emit("removeListener", Wt, Ht || Kt)
        }
        return this
    }
    ,
    y.prototype.off = y.prototype.removeListener,
    y.prototype.removeAllListeners = function(Wt) {
        var Kt, ir, or;
        if (ir = this._events,
        ir === void 0)
            return this;
        if (ir.removeListener === void 0)
            return arguments.length === 0 ? (this._events = Object.create(null),
            this._eventsCount = 0) : ir[Wt] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete ir[Wt]),
            this;
        if (arguments.length === 0) {
            var tr = Object.keys(ir), wr;
            for (or = 0; or < tr.length; ++or)
                wr = tr[or],
                wr !== "removeListener" && this.removeAllListeners(wr);
            return this.removeAllListeners("removeListener"),
            this._events = Object.create(null),
            this._eventsCount = 0,
            this
        }
        if (Kt = ir[Wt],
        typeof Kt == "function")
            this.removeListener(Wt, Kt);
        else if (Kt !== void 0)
            for (or = Kt.length - 1; or >= 0; or--)
                this.removeListener(Wt, Kt[or]);
        return this
    }
    ;
    function wt(zt, Wt, Kt) {
        var ir = zt._events;
        if (ir === void 0)
            return [];
        var or = ir[Wt];
        return or === void 0 ? [] : typeof or == "function" ? Kt ? [or.listener || or] : [or] : Kt ? Pt(or) : At(or, or.length)
    }
    y.prototype.listeners = function(Wt) {
        return wt(this, Wt, !0)
    }
    ,
    y.prototype.rawListeners = function(Wt) {
        return wt(this, Wt, !1)
    }
    ,
    y.listenerCount = function(zt, Wt) {
        return typeof zt.listenerCount == "function" ? zt.listenerCount(Wt) : xt.call(zt, Wt)
    }
    ,
    y.prototype.listenerCount = xt;
    function xt(zt) {
        var Wt = this._events;
        if (Wt !== void 0) {
            var Kt = Wt[zt];
            if (typeof Kt == "function")
                return 1;
            if (Kt !== void 0)
                return Kt.length
        }
        return 0
    }
    y.prototype.eventNames = function() {
        return this._eventsCount > 0 ? f(this._events) : []
    }
    ;
    function At(zt, Wt) {
        for (var Kt = new Array(Wt), ir = 0; ir < Wt; ++ir)
            Kt[ir] = zt[ir];
        return Kt
    }
    function Ct(zt, Wt) {
        for (; Wt + 1 < zt.length; Wt++)
            zt[Wt] = zt[Wt + 1];
        zt.pop()
    }
    function Pt(zt) {
        for (var Wt = new Array(zt.length), Kt = 0; Kt < Wt.length; ++Kt)
            Wt[Kt] = zt[Kt].listener || zt[Kt];
        return Wt
    }
    function $t(zt, Wt) {
        return new Promise(function(Kt, ir) {
            function or(wr) {
                zt.removeListener(Wt, tr),
                ir(wr)
            }
            function tr() {
                typeof zt.removeListener == "function" && zt.removeListener("error", or),
                Kt([].slice.call(arguments))
            }
            Nt(zt, Wt, tr, {
                once: !0
            }),
            Wt !== "error" && Ot(zt, or, {
                once: !0
            })
        }
        )
    }
    function Ot(zt, Wt, Kt) {
        typeof zt.on == "function" && Nt(zt, "error", Wt, Kt)
    }
    function Nt(zt, Wt, Kt, ir) {
        if (typeof zt.on == "function")
            ir.once ? zt.once(Wt, Kt) : zt.on(Wt, Kt);
        else if (typeof zt.addEventListener == "function")
            zt.addEventListener(Wt, function or(tr) {
                ir.once && zt.removeEventListener(Wt, or),
                Kt(tr)
            });
        else
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof zt)
    }
    return events.exports
}
var streamBrowser$1, hasRequiredStreamBrowser$1;
function requireStreamBrowser$1() {
    return hasRequiredStreamBrowser$1 || (hasRequiredStreamBrowser$1 = 1,
    streamBrowser$1 = requireEvents().EventEmitter),
    streamBrowser$1
}
var util$2 = {}, types$1 = {}, shams$2, hasRequiredShams$2;
function requireShams$2() {
    return hasRequiredShams$2 || (hasRequiredShams$2 = 1,
    shams$2 = function() {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
            return !1;
        if (typeof Symbol.iterator == "symbol")
            return !0;
        var d = {}
          , f = Symbol("test")
          , m = Object(f);
        if (typeof f == "string" || Object.prototype.toString.call(f) !== "[object Symbol]" || Object.prototype.toString.call(m) !== "[object Symbol]")
            return !1;
        var k = 42;
        d[f] = k;
        for (f in d)
            return !1;
        if (typeof Object.keys == "function" && Object.keys(d).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(d).length !== 0)
            return !1;
        var y = Object.getOwnPropertySymbols(d);
        if (y.length !== 1 || y[0] !== f || !Object.prototype.propertyIsEnumerable.call(d, f))
            return !1;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
            var ee = Object.getOwnPropertyDescriptor(d, f);
            if (ee.value !== k || ee.enumerable !== !0)
                return !1
        }
        return !0
    }
    ),
    shams$2
}
var shams$1, hasRequiredShams$1;
function requireShams$1() {
    if (hasRequiredShams$1)
        return shams$1;
    hasRequiredShams$1 = 1;
    var r = requireShams$2();
    return shams$1 = function() {
        return r() && !!Symbol.toStringTag
    }
    ,
    shams$1
}
var hasSymbols, hasRequiredHasSymbols;
function requireHasSymbols() {
    if (hasRequiredHasSymbols)
        return hasSymbols;
    hasRequiredHasSymbols = 1;
    var r = typeof Symbol < "u" && Symbol
      , d = requireShams$2();
    return hasSymbols = function() {
        return typeof r != "function" || typeof Symbol != "function" || typeof r("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : d()
    }
    ,
    hasSymbols
}
var hasProto, hasRequiredHasProto;
function requireHasProto() {
    if (hasRequiredHasProto)
        return hasProto;
    hasRequiredHasProto = 1;
    var r = {
        foo: {}
    }
      , d = Object;
    return hasProto = function() {
        return {
            __proto__: r
        }.foo === r.foo && !({
            __proto__: null
        }instanceof d)
    }
    ,
    hasProto
}
var implementation, hasRequiredImplementation;
function requireImplementation() {
    if (hasRequiredImplementation)
        return implementation;
    hasRequiredImplementation = 1;
    var r = "Function.prototype.bind called on incompatible "
      , d = Object.prototype.toString
      , f = Math.max
      , m = "[object Function]"
      , k = function(mt, yt) {
        for (var pt = [], bt = 0; bt < mt.length; bt += 1)
            pt[bt] = mt[bt];
        for (var wt = 0; wt < yt.length; wt += 1)
            pt[wt + mt.length] = yt[wt];
        return pt
    }
      , y = function(mt, yt) {
        for (var pt = [], bt = yt || 0, wt = 0; bt < mt.length; bt += 1,
        wt += 1)
            pt[wt] = mt[bt];
        return pt
    }
      , ee = function(dt, mt) {
        for (var yt = "", pt = 0; pt < dt.length; pt += 1)
            yt += dt[pt],
            pt + 1 < dt.length && (yt += mt);
        return yt
    };
    return implementation = function(mt) {
        var yt = this;
        if (typeof yt != "function" || d.apply(yt) !== m)
            throw new TypeError(r + yt);
        for (var pt = y(arguments, 1), bt, wt = function() {
            if (this instanceof bt) {
                var $t = yt.apply(this, k(pt, arguments));
                return Object($t) === $t ? $t : this
            }
            return yt.apply(mt, k(pt, arguments))
        }, xt = f(0, yt.length - pt.length), At = [], Ct = 0; Ct < xt; Ct++)
            At[Ct] = "$" + Ct;
        if (bt = Function("binder", "return function (" + ee(At, ",") + "){ return binder.apply(this,arguments); }")(wt),
        yt.prototype) {
            var Pt = function() {};
            Pt.prototype = yt.prototype,
            bt.prototype = new Pt,
            Pt.prototype = null
        }
        return bt
    }
    ,
    implementation
}
var functionBind, hasRequiredFunctionBind;
function requireFunctionBind() {
    if (hasRequiredFunctionBind)
        return functionBind;
    hasRequiredFunctionBind = 1;
    var r = requireImplementation();
    return functionBind = Function.prototype.bind || r,
    functionBind
}
var hasown, hasRequiredHasown;
function requireHasown() {
    if (hasRequiredHasown)
        return hasown;
    hasRequiredHasown = 1;
    var r = Function.prototype.call
      , d = Object.prototype.hasOwnProperty
      , f = requireFunctionBind();
    return hasown = f.call(r, d),
    hasown
}
var getIntrinsic$2, hasRequiredGetIntrinsic$2;
function requireGetIntrinsic$2() {
    if (hasRequiredGetIntrinsic$2)
        return getIntrinsic$2;
    hasRequiredGetIntrinsic$2 = 1;
    var r, d = SyntaxError, f = Function, m = TypeError, k = function(Mt) {
        try {
            return f('"use strict"; return (' + Mt + ").constructor;")()
        } catch {}
    }, y = Object.getOwnPropertyDescriptor;
    if (y)
        try {
            y({}, "")
        } catch {
            y = null
        }
    var ee = function() {
        throw new m
    }
      , dt = y ? function() {
        try {
            return arguments.callee,
            ee
        } catch {
            try {
                return y(arguments, "callee").get
            } catch {
                return ee
            }
        }
    }() : ee
      , mt = requireHasSymbols()()
      , yt = requireHasProto()()
      , pt = Object.getPrototypeOf || (yt ? function(Mt) {
        return Mt.__proto__
    }
    : null)
      , bt = {}
      , wt = typeof Uint8Array > "u" || !pt ? r : pt(Uint8Array)
      , xt = {
        "%AggregateError%": typeof AggregateError > "u" ? r : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer > "u" ? r : ArrayBuffer,
        "%ArrayIteratorPrototype%": mt && pt ? pt([][Symbol.iterator]()) : r,
        "%AsyncFromSyncIteratorPrototype%": r,
        "%AsyncFunction%": bt,
        "%AsyncGenerator%": bt,
        "%AsyncGeneratorFunction%": bt,
        "%AsyncIteratorPrototype%": bt,
        "%Atomics%": typeof Atomics > "u" ? r : Atomics,
        "%BigInt%": typeof BigInt > "u" ? r : BigInt,
        "%BigInt64Array%": typeof BigInt64Array > "u" ? r : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array > "u" ? r : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView > "u" ? r : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array > "u" ? r : Float32Array,
        "%Float64Array%": typeof Float64Array > "u" ? r : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? r : FinalizationRegistry,
        "%Function%": f,
        "%GeneratorFunction%": bt,
        "%Int8Array%": typeof Int8Array > "u" ? r : Int8Array,
        "%Int16Array%": typeof Int16Array > "u" ? r : Int16Array,
        "%Int32Array%": typeof Int32Array > "u" ? r : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": mt && pt ? pt(pt([][Symbol.iterator]())) : r,
        "%JSON%": typeof JSON == "object" ? JSON : r,
        "%Map%": typeof Map > "u" ? r : Map,
        "%MapIteratorPrototype%": typeof Map > "u" || !mt || !pt ? r : pt(new Map()[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise > "u" ? r : Promise,
        "%Proxy%": typeof Proxy > "u" ? r : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect > "u" ? r : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set > "u" ? r : Set,
        "%SetIteratorPrototype%": typeof Set > "u" || !mt || !pt ? r : pt(new Set()[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? r : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": mt && pt ? pt(""[Symbol.iterator]()) : r,
        "%Symbol%": mt ? Symbol : r,
        "%SyntaxError%": d,
        "%ThrowTypeError%": dt,
        "%TypedArray%": wt,
        "%TypeError%": m,
        "%Uint8Array%": typeof Uint8Array > "u" ? r : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? r : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array > "u" ? r : Uint16Array,
        "%Uint32Array%": typeof Uint32Array > "u" ? r : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap > "u" ? r : WeakMap,
        "%WeakRef%": typeof WeakRef > "u" ? r : WeakRef,
        "%WeakSet%": typeof WeakSet > "u" ? r : WeakSet
    };
    if (pt)
        try {
            null.error
        } catch (Mt) {
            var At = pt(pt(Mt));
            xt["%Error.prototype%"] = At
        }
    var Ct = function Mt(_t) {
        var gt;
        if (_t === "%AsyncFunction%")
            gt = k("async function () {}");
        else if (_t === "%GeneratorFunction%")
            gt = k("function* () {}");
        else if (_t === "%AsyncGeneratorFunction%")
            gt = k("async function* () {}");
        else if (_t === "%AsyncGenerator%") {
            var vt = Mt("%AsyncGeneratorFunction%");
            vt && (gt = vt.prototype)
        } else if (_t === "%AsyncIteratorPrototype%") {
            var Et = Mt("%AsyncGenerator%");
            Et && pt && (gt = pt(Et.prototype))
        }
        return xt[_t] = gt,
        gt
    }
      , Pt = {
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
    }
      , $t = requireFunctionBind()
      , Ot = requireHasown()
      , Nt = $t.call(Function.call, Array.prototype.concat)
      , zt = $t.call(Function.apply, Array.prototype.splice)
      , Wt = $t.call(Function.call, String.prototype.replace)
      , Kt = $t.call(Function.call, String.prototype.slice)
      , ir = $t.call(Function.call, RegExp.prototype.exec)
      , or = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g
      , tr = /\\(\\)?/g
      , wr = function(_t) {
        var gt = Kt(_t, 0, 1)
          , vt = Kt(_t, -1);
        if (gt === "%" && vt !== "%")
            throw new d("invalid intrinsic syntax, expected closing `%`");
        if (vt === "%" && gt !== "%")
            throw new d("invalid intrinsic syntax, expected opening `%`");
        var Et = [];
        return Wt(_t, or, function(Bt, Rt, kt, Tt) {
            Et[Et.length] = kt ? Wt(Tt, tr, "$1") : Rt || Bt
        }),
        Et
    }
      , Ht = function(_t, gt) {
        var vt = _t, Et;
        if (Ot(Pt, vt) && (Et = Pt[vt],
        vt = "%" + Et[0] + "%"),
        Ot(xt, vt)) {
            var Bt = xt[vt];
            if (Bt === bt && (Bt = Ct(vt)),
            typeof Bt > "u" && !gt)
                throw new m("intrinsic " + _t + " exists, but is not available. Please file an issue!");
            return {
                alias: Et,
                name: vt,
                value: Bt
            }
        }
        throw new d("intrinsic " + _t + " does not exist!")
    };
    return getIntrinsic$2 = function(_t, gt) {
        if (typeof _t != "string" || _t.length === 0)
            throw new m("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof gt != "boolean")
            throw new m('"allowMissing" argument must be a boolean');
        if (ir(/^%?[^%]*%?$/, _t) === null)
            throw new d("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var vt = wr(_t)
          , Et = vt.length > 0 ? vt[0] : ""
          , Bt = Ht("%" + Et + "%", gt)
          , Rt = Bt.name
          , kt = Bt.value
          , Tt = !1
          , It = Bt.alias;
        It && (Et = It[0],
        zt(vt, Nt([0, 1], It)));
        for (var St = 1, qt = !0; St < vt.length; St += 1) {
            var ur = vt[St]
              , gr = Kt(ur, 0, 1)
              , lr = Kt(ur, -1);
            if ((gr === '"' || gr === "'" || gr === "`" || lr === '"' || lr === "'" || lr === "`") && gr !== lr)
                throw new d("property names with quotes must have matching quotes");
            if ((ur === "constructor" || !qt) && (Tt = !0),
            Et += "." + ur,
            Rt = "%" + Et + "%",
            Ot(xt, Rt))
                kt = xt[Rt];
            else if (kt != null) {
                if (!(ur in kt)) {
                    if (!gt)
                        throw new m("base intrinsic for " + _t + " exists, but the property is not available.");
                    return
                }
                if (y && St + 1 >= vt.length) {
                    var Zt = y(kt, ur);
                    qt = !!Zt,
                    qt && "get"in Zt && !("originalValue"in Zt.get) ? kt = Zt.get : kt = kt[ur]
                } else
                    qt = Ot(kt, ur),
                    kt = kt[ur];
                qt && !Tt && (xt[Rt] = kt)
            }
        }
        return kt
    }
    ,
    getIntrinsic$2
}
var callBind$1 = {
    exports: {}
}, hasPropertyDescriptors_1$1, hasRequiredHasPropertyDescriptors$1;
function requireHasPropertyDescriptors$1() {
    if (hasRequiredHasPropertyDescriptors$1)
        return hasPropertyDescriptors_1$1;
    hasRequiredHasPropertyDescriptors$1 = 1;
    var r = requireGetIntrinsic$2()
      , d = r("%Object.defineProperty%", !0)
      , f = function() {
        if (d)
            try {
                return d({}, "a", {
                    value: 1
                }),
                !0
            } catch {
                return !1
            }
        return !1
    };
    return f.hasArrayLengthDefineBug = function() {
        if (!f())
            return null;
        try {
            return d([], "length", {
                value: 1
            }).length !== 1
        } catch {
            return !0
        }
    }
    ,
    hasPropertyDescriptors_1$1 = f,
    hasPropertyDescriptors_1$1
}
var gopd, hasRequiredGopd;
function requireGopd() {
    if (hasRequiredGopd)
        return gopd;
    hasRequiredGopd = 1;
    var r = requireGetIntrinsic$2()
      , d = r("%Object.getOwnPropertyDescriptor%", !0);
    if (d)
        try {
            d([], "length")
        } catch {
            d = null
        }
    return gopd = d,
    gopd
}
var defineDataProperty$1, hasRequiredDefineDataProperty$1;
function requireDefineDataProperty$1() {
    if (hasRequiredDefineDataProperty$1)
        return defineDataProperty$1;
    hasRequiredDefineDataProperty$1 = 1;
    var r = requireHasPropertyDescriptors$1()()
      , d = requireGetIntrinsic$2()
      , f = r && d("%Object.defineProperty%", !0);
    if (f)
        try {
            f({}, "a", {
                value: 1
            })
        } catch {
            f = !1
        }
    var m = d("%SyntaxError%")
      , k = d("%TypeError%")
      , y = requireGopd();
    return defineDataProperty$1 = function(dt, mt, yt) {
        if (!dt || typeof dt != "object" && typeof dt != "function")
            throw new k("`obj` must be an object or a function`");
        if (typeof mt != "string" && typeof mt != "symbol")
            throw new k("`property` must be a string or a symbol`");
        if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
            throw new k("`nonEnumerable`, if provided, must be a boolean or null");
        if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
            throw new k("`nonWritable`, if provided, must be a boolean or null");
        if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
            throw new k("`nonConfigurable`, if provided, must be a boolean or null");
        if (arguments.length > 6 && typeof arguments[6] != "boolean")
            throw new k("`loose`, if provided, must be a boolean");
        var pt = arguments.length > 3 ? arguments[3] : null
          , bt = arguments.length > 4 ? arguments[4] : null
          , wt = arguments.length > 5 ? arguments[5] : null
          , xt = arguments.length > 6 ? arguments[6] : !1
          , At = !!y && y(dt, mt);
        if (f)
            f(dt, mt, {
                configurable: wt === null && At ? At.configurable : !wt,
                enumerable: pt === null && At ? At.enumerable : !pt,
                value: yt,
                writable: bt === null && At ? At.writable : !bt
            });
        else if (xt || !pt && !bt && !wt)
            dt[mt] = yt;
        else
            throw new m("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.")
    }
    ,
    defineDataProperty$1
}
var setFunctionLength$1, hasRequiredSetFunctionLength$1;
function requireSetFunctionLength$1() {
    if (hasRequiredSetFunctionLength$1)
        return setFunctionLength$1;
    hasRequiredSetFunctionLength$1 = 1;
    var r = requireGetIntrinsic$2()
      , d = requireDefineDataProperty$1()
      , f = requireHasPropertyDescriptors$1()()
      , m = requireGopd()
      , k = r("%TypeError%")
      , y = r("%Math.floor%");
    return setFunctionLength$1 = function(dt, mt) {
        if (typeof dt != "function")
            throw new k("`fn` is not a function");
        if (typeof mt != "number" || mt < 0 || mt > 4294967295 || y(mt) !== mt)
            throw new k("`length` must be a positive 32-bit integer");
        var yt = arguments.length > 2 && !!arguments[2]
          , pt = !0
          , bt = !0;
        if ("length"in dt && m) {
            var wt = m(dt, "length");
            wt && !wt.configurable && (pt = !1),
            wt && !wt.writable && (bt = !1)
        }
        return (pt || bt || !yt) && (f ? d(dt, "length", mt, !0, !0) : d(dt, "length", mt)),
        dt
    }
    ,
    setFunctionLength$1
}
var hasRequiredCallBind$1;
function requireCallBind$1() {
    return hasRequiredCallBind$1 || (hasRequiredCallBind$1 = 1,
    function(r) {
        var d = requireFunctionBind()
          , f = requireGetIntrinsic$2()
          , m = requireSetFunctionLength$1()
          , k = f("%TypeError%")
          , y = f("%Function.prototype.apply%")
          , ee = f("%Function.prototype.call%")
          , dt = f("%Reflect.apply%", !0) || d.call(ee, y)
          , mt = f("%Object.defineProperty%", !0)
          , yt = f("%Math.max%");
        if (mt)
            try {
                mt({}, "a", {
                    value: 1
                })
            } catch {
                mt = null
            }
        r.exports = function(wt) {
            if (typeof wt != "function")
                throw new k("a function is required");
            var xt = dt(d, ee, arguments);
            return m(xt, 1 + yt(0, wt.length - (arguments.length - 1)), !0)
        }
        ;
        var pt = function() {
            return dt(d, y, arguments)
        };
        mt ? mt(r.exports, "apply", {
            value: pt
        }) : r.exports.apply = pt
    }(callBind$1)),
    callBind$1.exports
}
var callBound$1, hasRequiredCallBound$1;
function requireCallBound$1() {
    if (hasRequiredCallBound$1)
        return callBound$1;
    hasRequiredCallBound$1 = 1;
    var r = requireGetIntrinsic$2()
      , d = requireCallBind$1()
      , f = d(r("String.prototype.indexOf"));
    return callBound$1 = function(k, y) {
        var ee = r(k, !!y);
        return typeof ee == "function" && f(k, ".prototype.") > -1 ? d(ee) : ee
    }
    ,
    callBound$1
}
var isArguments, hasRequiredIsArguments;
function requireIsArguments() {
    if (hasRequiredIsArguments)
        return isArguments;
    hasRequiredIsArguments = 1;
    var r = requireShams$1()()
      , d = requireCallBound$1()
      , f = d("Object.prototype.toString")
      , m = function(dt) {
        return r && dt && typeof dt == "object" && Symbol.toStringTag in dt ? !1 : f(dt) === "[object Arguments]"
    }
      , k = function(dt) {
        return m(dt) ? !0 : dt !== null && typeof dt == "object" && typeof dt.length == "number" && dt.length >= 0 && f(dt) !== "[object Array]" && f(dt.callee) === "[object Function]"
    }
      , y = function() {
        return m(arguments)
    }();
    return m.isLegacyArguments = k,
    isArguments = y ? m : k,
    isArguments
}
var isGeneratorFunction, hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
    if (hasRequiredIsGeneratorFunction)
        return isGeneratorFunction;
    hasRequiredIsGeneratorFunction = 1;
    var r = Object.prototype.toString, d = Function.prototype.toString, f = /^\s*(?:function)?\*/, m = requireShams$1()(), k = Object.getPrototypeOf, y = function() {
        if (!m)
            return !1;
        try {
            return Function("return function*() {}")()
        } catch {}
    }, ee;
    return isGeneratorFunction = function(mt) {
        if (typeof mt != "function")
            return !1;
        if (f.test(d.call(mt)))
            return !0;
        if (!m) {
            var yt = r.call(mt);
            return yt === "[object GeneratorFunction]"
        }
        if (!k)
            return !1;
        if (typeof ee > "u") {
            var pt = y();
            ee = pt ? k(pt) : !1
        }
        return k(mt) === ee
    }
    ,
    isGeneratorFunction
}
var isCallable, hasRequiredIsCallable;
function requireIsCallable() {
    if (hasRequiredIsCallable)
        return isCallable;
    hasRequiredIsCallable = 1;
    var r = Function.prototype.toString, d = typeof Reflect == "object" && Reflect !== null && Reflect.apply, f, m;
    if (typeof d == "function" && typeof Object.defineProperty == "function")
        try {
            f = Object.defineProperty({}, "length", {
                get: function() {
                    throw m
                }
            }),
            m = {},
            d(function() {
                throw 42
            }, null, f)
        } catch (Ot) {
            Ot !== m && (d = null)
        }
    else
        d = null;
    var k = /^\s*class\b/
      , y = function(Nt) {
        try {
            var zt = r.call(Nt);
            return k.test(zt)
        } catch {
            return !1
        }
    }
      , ee = function(Nt) {
        try {
            return y(Nt) ? !1 : (r.call(Nt),
            !0)
        } catch {
            return !1
        }
    }
      , dt = Object.prototype.toString
      , mt = "[object Object]"
      , yt = "[object Function]"
      , pt = "[object GeneratorFunction]"
      , bt = "[object HTMLAllCollection]"
      , wt = "[object HTML document.all class]"
      , xt = "[object HTMLCollection]"
      , At = typeof Symbol == "function" && !!Symbol.toStringTag
      , Ct = !(0 in [, ])
      , Pt = function() {
        return !1
    };
    if (typeof document == "object") {
        var $t = document.all;
        dt.call($t) === dt.call(document.all) && (Pt = function(Nt) {
            if ((Ct || !Nt) && (typeof Nt > "u" || typeof Nt == "object"))
                try {
                    var zt = dt.call(Nt);
                    return (zt === bt || zt === wt || zt === xt || zt === mt) && Nt("") == null
                } catch {}
            return !1
        }
        )
    }
    return isCallable = d ? function(Nt) {
        if (Pt(Nt))
            return !0;
        if (!Nt || typeof Nt != "function" && typeof Nt != "object")
            return !1;
        try {
            d(Nt, null, f)
        } catch (zt) {
            if (zt !== m)
                return !1
        }
        return !y(Nt) && ee(Nt)
    }
    : function(Nt) {
        if (Pt(Nt))
            return !0;
        if (!Nt || typeof Nt != "function" && typeof Nt != "object")
            return !1;
        if (At)
            return ee(Nt);
        if (y(Nt))
            return !1;
        var zt = dt.call(Nt);
        return zt !== yt && zt !== pt && !/^\[object HTML/.test(zt) ? !1 : ee(Nt)
    }
    ,
    isCallable
}
var forEach_1, hasRequiredForEach;
function requireForEach() {
    if (hasRequiredForEach)
        return forEach_1;
    hasRequiredForEach = 1;
    var r = requireIsCallable()
      , d = Object.prototype.toString
      , f = Object.prototype.hasOwnProperty
      , m = function(mt, yt, pt) {
        for (var bt = 0, wt = mt.length; bt < wt; bt++)
            f.call(mt, bt) && (pt == null ? yt(mt[bt], bt, mt) : yt.call(pt, mt[bt], bt, mt))
    }
      , k = function(mt, yt, pt) {
        for (var bt = 0, wt = mt.length; bt < wt; bt++)
            pt == null ? yt(mt.charAt(bt), bt, mt) : yt.call(pt, mt.charAt(bt), bt, mt)
    }
      , y = function(mt, yt, pt) {
        for (var bt in mt)
            f.call(mt, bt) && (pt == null ? yt(mt[bt], bt, mt) : yt.call(pt, mt[bt], bt, mt))
    }
      , ee = function(mt, yt, pt) {
        if (!r(yt))
            throw new TypeError("iterator must be a function");
        var bt;
        arguments.length >= 3 && (bt = pt),
        d.call(mt) === "[object Array]" ? m(mt, yt, bt) : typeof mt == "string" ? k(mt, yt, bt) : y(mt, yt, bt)
    };
    return forEach_1 = ee,
    forEach_1
}
var possibleTypedArrayNames, hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
    return hasRequiredPossibleTypedArrayNames || (hasRequiredPossibleTypedArrayNames = 1,
    possibleTypedArrayNames = ["Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array"]),
    possibleTypedArrayNames
}
var availableTypedArrays, hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
    if (hasRequiredAvailableTypedArrays)
        return availableTypedArrays;
    hasRequiredAvailableTypedArrays = 1;
    var r = requirePossibleTypedArrayNames()
      , d = typeof globalThis > "u" ? commonjsGlobal : globalThis;
    return availableTypedArrays = function() {
        for (var m = [], k = 0; k < r.length; k++)
            typeof d[r[k]] == "function" && (m[m.length] = r[k]);
        return m
    }
    ,
    availableTypedArrays
}
var callBind = {
    exports: {}
}, esErrors, hasRequiredEsErrors;
function requireEsErrors() {
    return hasRequiredEsErrors || (hasRequiredEsErrors = 1,
    esErrors = Error),
    esErrors
}
var _eval, hasRequired_eval;
function require_eval() {
    return hasRequired_eval || (hasRequired_eval = 1,
    _eval = EvalError),
    _eval
}
var range, hasRequiredRange;
function requireRange() {
    return hasRequiredRange || (hasRequiredRange = 1,
    range = RangeError),
    range
}
var ref, hasRequiredRef;
function requireRef() {
    return hasRequiredRef || (hasRequiredRef = 1,
    ref = ReferenceError),
    ref
}
var syntax, hasRequiredSyntax;
function requireSyntax() {
    return hasRequiredSyntax || (hasRequiredSyntax = 1,
    syntax = SyntaxError),
    syntax
}
var type, hasRequiredType;
function requireType() {
    return hasRequiredType || (hasRequiredType = 1,
    type = TypeError),
    type
}
var uri, hasRequiredUri;
function requireUri() {
    return hasRequiredUri || (hasRequiredUri = 1,
    uri = URIError),
    uri
}
var getIntrinsic$1, hasRequiredGetIntrinsic$1;
function requireGetIntrinsic$1() {
    if (hasRequiredGetIntrinsic$1)
        return getIntrinsic$1;
    hasRequiredGetIntrinsic$1 = 1;
    var r, d = requireEsErrors(), f = require_eval(), m = requireRange(), k = requireRef(), y = requireSyntax(), ee = requireType(), dt = requireUri(), mt = Function, yt = function(Bt) {
        try {
            return mt('"use strict"; return (' + Bt + ").constructor;")()
        } catch {}
    }, pt = Object.getOwnPropertyDescriptor;
    if (pt)
        try {
            pt({}, "")
        } catch {
            pt = null
        }
    var bt = function() {
        throw new ee
    }
      , wt = pt ? function() {
        try {
            return arguments.callee,
            bt
        } catch {
            try {
                return pt(arguments, "callee").get
            } catch {
                return bt
            }
        }
    }() : bt
      , xt = requireHasSymbols()()
      , At = requireHasProto()()
      , Ct = Object.getPrototypeOf || (At ? function(Bt) {
        return Bt.__proto__
    }
    : null)
      , Pt = {}
      , $t = typeof Uint8Array > "u" || !Ct ? r : Ct(Uint8Array)
      , Ot = {
        __proto__: null,
        "%AggregateError%": typeof AggregateError > "u" ? r : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer > "u" ? r : ArrayBuffer,
        "%ArrayIteratorPrototype%": xt && Ct ? Ct([][Symbol.iterator]()) : r,
        "%AsyncFromSyncIteratorPrototype%": r,
        "%AsyncFunction%": Pt,
        "%AsyncGenerator%": Pt,
        "%AsyncGeneratorFunction%": Pt,
        "%AsyncIteratorPrototype%": Pt,
        "%Atomics%": typeof Atomics > "u" ? r : Atomics,
        "%BigInt%": typeof BigInt > "u" ? r : BigInt,
        "%BigInt64Array%": typeof BigInt64Array > "u" ? r : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array > "u" ? r : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView > "u" ? r : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": d,
        "%eval%": eval,
        "%EvalError%": f,
        "%Float32Array%": typeof Float32Array > "u" ? r : Float32Array,
        "%Float64Array%": typeof Float64Array > "u" ? r : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? r : FinalizationRegistry,
        "%Function%": mt,
        "%GeneratorFunction%": Pt,
        "%Int8Array%": typeof Int8Array > "u" ? r : Int8Array,
        "%Int16Array%": typeof Int16Array > "u" ? r : Int16Array,
        "%Int32Array%": typeof Int32Array > "u" ? r : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": xt && Ct ? Ct(Ct([][Symbol.iterator]())) : r,
        "%JSON%": typeof JSON == "object" ? JSON : r,
        "%Map%": typeof Map > "u" ? r : Map,
        "%MapIteratorPrototype%": typeof Map > "u" || !xt || !Ct ? r : Ct(new Map()[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise > "u" ? r : Promise,
        "%Proxy%": typeof Proxy > "u" ? r : Proxy,
        "%RangeError%": m,
        "%ReferenceError%": k,
        "%Reflect%": typeof Reflect > "u" ? r : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set > "u" ? r : Set,
        "%SetIteratorPrototype%": typeof Set > "u" || !xt || !Ct ? r : Ct(new Set()[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? r : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": xt && Ct ? Ct(""[Symbol.iterator]()) : r,
        "%Symbol%": xt ? Symbol : r,
        "%SyntaxError%": y,
        "%ThrowTypeError%": wt,
        "%TypedArray%": $t,
        "%TypeError%": ee,
        "%Uint8Array%": typeof Uint8Array > "u" ? r : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? r : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array > "u" ? r : Uint16Array,
        "%Uint32Array%": typeof Uint32Array > "u" ? r : Uint32Array,
        "%URIError%": dt,
        "%WeakMap%": typeof WeakMap > "u" ? r : WeakMap,
        "%WeakRef%": typeof WeakRef > "u" ? r : WeakRef,
        "%WeakSet%": typeof WeakSet > "u" ? r : WeakSet
    };
    if (Ct)
        try {
            null.error
        } catch (Bt) {
            var Nt = Ct(Ct(Bt));
            Ot["%Error.prototype%"] = Nt
        }
    var zt = function Bt(Rt) {
        var kt;
        if (Rt === "%AsyncFunction%")
            kt = yt("async function () {}");
        else if (Rt === "%GeneratorFunction%")
            kt = yt("function* () {}");
        else if (Rt === "%AsyncGeneratorFunction%")
            kt = yt("async function* () {}");
        else if (Rt === "%AsyncGenerator%") {
            var Tt = Bt("%AsyncGeneratorFunction%");
            Tt && (kt = Tt.prototype)
        } else if (Rt === "%AsyncIteratorPrototype%") {
            var It = Bt("%AsyncGenerator%");
            It && Ct && (kt = Ct(It.prototype))
        }
        return Ot[Rt] = kt,
        kt
    }
      , Wt = {
        __proto__: null,
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
    }
      , Kt = requireFunctionBind()
      , ir = requireHasown()
      , or = Kt.call(Function.call, Array.prototype.concat)
      , tr = Kt.call(Function.apply, Array.prototype.splice)
      , wr = Kt.call(Function.call, String.prototype.replace)
      , Ht = Kt.call(Function.call, String.prototype.slice)
      , Mt = Kt.call(Function.call, RegExp.prototype.exec)
      , _t = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g
      , gt = /\\(\\)?/g
      , vt = function(Rt) {
        var kt = Ht(Rt, 0, 1)
          , Tt = Ht(Rt, -1);
        if (kt === "%" && Tt !== "%")
            throw new y("invalid intrinsic syntax, expected closing `%`");
        if (Tt === "%" && kt !== "%")
            throw new y("invalid intrinsic syntax, expected opening `%`");
        var It = [];
        return wr(Rt, _t, function(St, qt, ur, gr) {
            It[It.length] = ur ? wr(gr, gt, "$1") : qt || St
        }),
        It
    }
      , Et = function(Rt, kt) {
        var Tt = Rt, It;
        if (ir(Wt, Tt) && (It = Wt[Tt],
        Tt = "%" + It[0] + "%"),
        ir(Ot, Tt)) {
            var St = Ot[Tt];
            if (St === Pt && (St = zt(Tt)),
            typeof St > "u" && !kt)
                throw new ee("intrinsic " + Rt + " exists, but is not available. Please file an issue!");
            return {
                alias: It,
                name: Tt,
                value: St
            }
        }
        throw new y("intrinsic " + Rt + " does not exist!")
    };
    return getIntrinsic$1 = function(Rt, kt) {
        if (typeof Rt != "string" || Rt.length === 0)
            throw new ee("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof kt != "boolean")
            throw new ee('"allowMissing" argument must be a boolean');
        if (Mt(/^%?[^%]*%?$/, Rt) === null)
            throw new y("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var Tt = vt(Rt)
          , It = Tt.length > 0 ? Tt[0] : ""
          , St = Et("%" + It + "%", kt)
          , qt = St.name
          , ur = St.value
          , gr = !1
          , lr = St.alias;
        lr && (It = lr[0],
        tr(Tt, or([0, 1], lr)));
        for (var Zt = 1, Vt = !0; Zt < Tt.length; Zt += 1) {
            var rr = Tt[Zt]
              , fr = Ht(rr, 0, 1)
              , Yt = Ht(rr, -1);
            if ((fr === '"' || fr === "'" || fr === "`" || Yt === '"' || Yt === "'" || Yt === "`") && fr !== Yt)
                throw new y("property names with quotes must have matching quotes");
            if ((rr === "constructor" || !Vt) && (gr = !0),
            It += "." + rr,
            qt = "%" + It + "%",
            ir(Ot, qt))
                ur = Ot[qt];
            else if (ur != null) {
                if (!(rr in ur)) {
                    if (!kt)
                        throw new ee("base intrinsic for " + Rt + " exists, but the property is not available.");
                    return
                }
                if (pt && Zt + 1 >= Tt.length) {
                    var Xt = pt(ur, rr);
                    Vt = !!Xt,
                    Vt && "get"in Xt && !("originalValue"in Xt.get) ? ur = Xt.get : ur = ur[rr]
                } else
                    Vt = ir(ur, rr),
                    ur = ur[rr];
                Vt && !gr && (Ot[qt] = ur)
            }
        }
        return ur
    }
    ,
    getIntrinsic$1
}
var getIntrinsic, hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
    if (hasRequiredGetIntrinsic)
        return getIntrinsic;
    hasRequiredGetIntrinsic = 1;
    var r, d = requireEsErrors(), f = require_eval(), m = requireRange(), k = requireRef(), y = requireSyntax(), ee = requireType(), dt = requireUri(), mt = Function, yt = function(Bt) {
        try {
            return mt('"use strict"; return (' + Bt + ").constructor;")()
        } catch {}
    }, pt = Object.getOwnPropertyDescriptor;
    if (pt)
        try {
            pt({}, "")
        } catch {
            pt = null
        }
    var bt = function() {
        throw new ee
    }
      , wt = pt ? function() {
        try {
            return arguments.callee,
            bt
        } catch {
            try {
                return pt(arguments, "callee").get
            } catch {
                return bt
            }
        }
    }() : bt
      , xt = requireHasSymbols()()
      , At = requireHasProto()()
      , Ct = Object.getPrototypeOf || (At ? function(Bt) {
        return Bt.__proto__
    }
    : null)
      , Pt = {}
      , $t = typeof Uint8Array > "u" || !Ct ? r : Ct(Uint8Array)
      , Ot = {
        __proto__: null,
        "%AggregateError%": typeof AggregateError > "u" ? r : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer > "u" ? r : ArrayBuffer,
        "%ArrayIteratorPrototype%": xt && Ct ? Ct([][Symbol.iterator]()) : r,
        "%AsyncFromSyncIteratorPrototype%": r,
        "%AsyncFunction%": Pt,
        "%AsyncGenerator%": Pt,
        "%AsyncGeneratorFunction%": Pt,
        "%AsyncIteratorPrototype%": Pt,
        "%Atomics%": typeof Atomics > "u" ? r : Atomics,
        "%BigInt%": typeof BigInt > "u" ? r : BigInt,
        "%BigInt64Array%": typeof BigInt64Array > "u" ? r : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array > "u" ? r : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView > "u" ? r : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": d,
        "%eval%": eval,
        "%EvalError%": f,
        "%Float32Array%": typeof Float32Array > "u" ? r : Float32Array,
        "%Float64Array%": typeof Float64Array > "u" ? r : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? r : FinalizationRegistry,
        "%Function%": mt,
        "%GeneratorFunction%": Pt,
        "%Int8Array%": typeof Int8Array > "u" ? r : Int8Array,
        "%Int16Array%": typeof Int16Array > "u" ? r : Int16Array,
        "%Int32Array%": typeof Int32Array > "u" ? r : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": xt && Ct ? Ct(Ct([][Symbol.iterator]())) : r,
        "%JSON%": typeof JSON == "object" ? JSON : r,
        "%Map%": typeof Map > "u" ? r : Map,
        "%MapIteratorPrototype%": typeof Map > "u" || !xt || !Ct ? r : Ct(new Map()[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise > "u" ? r : Promise,
        "%Proxy%": typeof Proxy > "u" ? r : Proxy,
        "%RangeError%": m,
        "%ReferenceError%": k,
        "%Reflect%": typeof Reflect > "u" ? r : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set > "u" ? r : Set,
        "%SetIteratorPrototype%": typeof Set > "u" || !xt || !Ct ? r : Ct(new Set()[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? r : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": xt && Ct ? Ct(""[Symbol.iterator]()) : r,
        "%Symbol%": xt ? Symbol : r,
        "%SyntaxError%": y,
        "%ThrowTypeError%": wt,
        "%TypedArray%": $t,
        "%TypeError%": ee,
        "%Uint8Array%": typeof Uint8Array > "u" ? r : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? r : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array > "u" ? r : Uint16Array,
        "%Uint32Array%": typeof Uint32Array > "u" ? r : Uint32Array,
        "%URIError%": dt,
        "%WeakMap%": typeof WeakMap > "u" ? r : WeakMap,
        "%WeakRef%": typeof WeakRef > "u" ? r : WeakRef,
        "%WeakSet%": typeof WeakSet > "u" ? r : WeakSet
    };
    if (Ct)
        try {
            null.error
        } catch (Bt) {
            var Nt = Ct(Ct(Bt));
            Ot["%Error.prototype%"] = Nt
        }
    var zt = function Bt(Rt) {
        var kt;
        if (Rt === "%AsyncFunction%")
            kt = yt("async function () {}");
        else if (Rt === "%GeneratorFunction%")
            kt = yt("function* () {}");
        else if (Rt === "%AsyncGeneratorFunction%")
            kt = yt("async function* () {}");
        else if (Rt === "%AsyncGenerator%") {
            var Tt = Bt("%AsyncGeneratorFunction%");
            Tt && (kt = Tt.prototype)
        } else if (Rt === "%AsyncIteratorPrototype%") {
            var It = Bt("%AsyncGenerator%");
            It && Ct && (kt = Ct(It.prototype))
        }
        return Ot[Rt] = kt,
        kt
    }
      , Wt = {
        __proto__: null,
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
    }
      , Kt = requireFunctionBind()
      , ir = requireHasown()
      , or = Kt.call(Function.call, Array.prototype.concat)
      , tr = Kt.call(Function.apply, Array.prototype.splice)
      , wr = Kt.call(Function.call, String.prototype.replace)
      , Ht = Kt.call(Function.call, String.prototype.slice)
      , Mt = Kt.call(Function.call, RegExp.prototype.exec)
      , _t = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g
      , gt = /\\(\\)?/g
      , vt = function(Rt) {
        var kt = Ht(Rt, 0, 1)
          , Tt = Ht(Rt, -1);
        if (kt === "%" && Tt !== "%")
            throw new y("invalid intrinsic syntax, expected closing `%`");
        if (Tt === "%" && kt !== "%")
            throw new y("invalid intrinsic syntax, expected opening `%`");
        var It = [];
        return wr(Rt, _t, function(St, qt, ur, gr) {
            It[It.length] = ur ? wr(gr, gt, "$1") : qt || St
        }),
        It
    }
      , Et = function(Rt, kt) {
        var Tt = Rt, It;
        if (ir(Wt, Tt) && (It = Wt[Tt],
        Tt = "%" + It[0] + "%"),
        ir(Ot, Tt)) {
            var St = Ot[Tt];
            if (St === Pt && (St = zt(Tt)),
            typeof St > "u" && !kt)
                throw new ee("intrinsic " + Rt + " exists, but is not available. Please file an issue!");
            return {
                alias: It,
                name: Tt,
                value: St
            }
        }
        throw new y("intrinsic " + Rt + " does not exist!")
    };
    return getIntrinsic = function(Rt, kt) {
        if (typeof Rt != "string" || Rt.length === 0)
            throw new ee("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof kt != "boolean")
            throw new ee('"allowMissing" argument must be a boolean');
        if (Mt(/^%?[^%]*%?$/, Rt) === null)
            throw new y("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var Tt = vt(Rt)
          , It = Tt.length > 0 ? Tt[0] : ""
          , St = Et("%" + It + "%", kt)
          , qt = St.name
          , ur = St.value
          , gr = !1
          , lr = St.alias;
        lr && (It = lr[0],
        tr(Tt, or([0, 1], lr)));
        for (var Zt = 1, Vt = !0; Zt < Tt.length; Zt += 1) {
            var rr = Tt[Zt]
              , fr = Ht(rr, 0, 1)
              , Yt = Ht(rr, -1);
            if ((fr === '"' || fr === "'" || fr === "`" || Yt === '"' || Yt === "'" || Yt === "`") && fr !== Yt)
                throw new y("property names with quotes must have matching quotes");
            if ((rr === "constructor" || !Vt) && (gr = !0),
            It += "." + rr,
            qt = "%" + It + "%",
            ir(Ot, qt))
                ur = Ot[qt];
            else if (ur != null) {
                if (!(rr in ur)) {
                    if (!kt)
                        throw new ee("base intrinsic for " + Rt + " exists, but the property is not available.");
                    return
                }
                if (pt && Zt + 1 >= Tt.length) {
                    var Xt = pt(ur, rr);
                    Vt = !!Xt,
                    Vt && "get"in Xt && !("originalValue"in Xt.get) ? ur = Xt.get : ur = ur[rr]
                } else
                    Vt = ir(ur, rr),
                    ur = ur[rr];
                Vt && !gr && (Ot[qt] = ur)
            }
        }
        return ur
    }
    ,
    getIntrinsic
}
var esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
    if (hasRequiredEsDefineProperty)
        return esDefineProperty;
    hasRequiredEsDefineProperty = 1;
    var r = requireGetIntrinsic()
      , d = r("%Object.defineProperty%", !0) || !1;
    if (d)
        try {
            d({}, "a", {
                value: 1
            })
        } catch {
            d = !1
        }
    return esDefineProperty = d,
    esDefineProperty
}
var defineDataProperty, hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
    if (hasRequiredDefineDataProperty)
        return defineDataProperty;
    hasRequiredDefineDataProperty = 1;
    var r = requireEsDefineProperty()
      , d = requireSyntax()
      , f = requireType()
      , m = requireGopd();
    return defineDataProperty = function(y, ee, dt) {
        if (!y || typeof y != "object" && typeof y != "function")
            throw new f("`obj` must be an object or a function`");
        if (typeof ee != "string" && typeof ee != "symbol")
            throw new f("`property` must be a string or a symbol`");
        if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
            throw new f("`nonEnumerable`, if provided, must be a boolean or null");
        if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
            throw new f("`nonWritable`, if provided, must be a boolean or null");
        if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
            throw new f("`nonConfigurable`, if provided, must be a boolean or null");
        if (arguments.length > 6 && typeof arguments[6] != "boolean")
            throw new f("`loose`, if provided, must be a boolean");
        var mt = arguments.length > 3 ? arguments[3] : null
          , yt = arguments.length > 4 ? arguments[4] : null
          , pt = arguments.length > 5 ? arguments[5] : null
          , bt = arguments.length > 6 ? arguments[6] : !1
          , wt = !!m && m(y, ee);
        if (r)
            r(y, ee, {
                configurable: pt === null && wt ? wt.configurable : !pt,
                enumerable: mt === null && wt ? wt.enumerable : !mt,
                value: dt,
                writable: yt === null && wt ? wt.writable : !yt
            });
        else if (bt || !mt && !yt && !pt)
            y[ee] = dt;
        else
            throw new d("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.")
    }
    ,
    defineDataProperty
}
var hasPropertyDescriptors_1, hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
    if (hasRequiredHasPropertyDescriptors)
        return hasPropertyDescriptors_1;
    hasRequiredHasPropertyDescriptors = 1;
    var r = requireEsDefineProperty()
      , d = function() {
        return !!r
    };
    return d.hasArrayLengthDefineBug = function() {
        if (!r)
            return null;
        try {
            return r([], "length", {
                value: 1
            }).length !== 1
        } catch {
            return !0
        }
    }
    ,
    hasPropertyDescriptors_1 = d,
    hasPropertyDescriptors_1
}
var setFunctionLength, hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
    if (hasRequiredSetFunctionLength)
        return setFunctionLength;
    hasRequiredSetFunctionLength = 1;
    var r = requireGetIntrinsic$1()
      , d = requireDefineDataProperty()
      , f = requireHasPropertyDescriptors()()
      , m = requireGopd()
      , k = requireType()
      , y = r("%Math.floor%");
    return setFunctionLength = function(dt, mt) {
        if (typeof dt != "function")
            throw new k("`fn` is not a function");
        if (typeof mt != "number" || mt < 0 || mt > 4294967295 || y(mt) !== mt)
            throw new k("`length` must be a positive 32-bit integer");
        var yt = arguments.length > 2 && !!arguments[2]
          , pt = !0
          , bt = !0;
        if ("length"in dt && m) {
            var wt = m(dt, "length");
            wt && !wt.configurable && (pt = !1),
            wt && !wt.writable && (bt = !1)
        }
        return (pt || bt || !yt) && (f ? d(dt, "length", mt, !0, !0) : d(dt, "length", mt)),
        dt
    }
    ,
    setFunctionLength
}
var hasRequiredCallBind;
function requireCallBind() {
    return hasRequiredCallBind || (hasRequiredCallBind = 1,
    function(r) {
        var d = requireFunctionBind()
          , f = requireGetIntrinsic$1()
          , m = requireSetFunctionLength()
          , k = requireType()
          , y = f("%Function.prototype.apply%")
          , ee = f("%Function.prototype.call%")
          , dt = f("%Reflect.apply%", !0) || d.call(ee, y)
          , mt = requireEsDefineProperty()
          , yt = f("%Math.max%");
        r.exports = function(wt) {
            if (typeof wt != "function")
                throw new k("a function is required");
            var xt = dt(d, ee, arguments);
            return m(xt, 1 + yt(0, wt.length - (arguments.length - 1)), !0)
        }
        ;
        var pt = function() {
            return dt(d, y, arguments)
        };
        mt ? mt(r.exports, "apply", {
            value: pt
        }) : r.exports.apply = pt
    }(callBind)),
    callBind.exports
}
var callBound, hasRequiredCallBound;
function requireCallBound() {
    if (hasRequiredCallBound)
        return callBound;
    hasRequiredCallBound = 1;
    var r = requireGetIntrinsic$1()
      , d = requireCallBind()
      , f = d(r("String.prototype.indexOf"));
    return callBound = function(k, y) {
        var ee = r(k, !!y);
        return typeof ee == "function" && f(k, ".prototype.") > -1 ? d(ee) : ee
    }
    ,
    callBound
}
var shams, hasRequiredShams;
function requireShams() {
    if (hasRequiredShams)
        return shams;
    hasRequiredShams = 1;
    var r = requireShams$2();
    return shams = function() {
        return r() && !!Symbol.toStringTag
    }
    ,
    shams
}
var whichTypedArray, hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
    if (hasRequiredWhichTypedArray)
        return whichTypedArray;
    hasRequiredWhichTypedArray = 1;
    var r = requireForEach()
      , d = requireAvailableTypedArrays()
      , f = requireCallBind()
      , m = requireCallBound()
      , k = requireGopd()
      , y = m("Object.prototype.toString")
      , ee = requireShams()()
      , dt = typeof globalThis > "u" ? commonjsGlobal : globalThis
      , mt = d()
      , yt = m("String.prototype.slice")
      , pt = Object.getPrototypeOf
      , bt = m("Array.prototype.indexOf", !0) || function(Pt, $t) {
        for (var Ot = 0; Ot < Pt.length; Ot += 1)
            if (Pt[Ot] === $t)
                return Ot;
        return -1
    }
      , wt = {
        __proto__: null
    };
    ee && k && pt ? r(mt, function(Ct) {
        var Pt = new dt[Ct];
        if (Symbol.toStringTag in Pt) {
            var $t = pt(Pt)
              , Ot = k($t, Symbol.toStringTag);
            if (!Ot) {
                var Nt = pt($t);
                Ot = k(Nt, Symbol.toStringTag)
            }
            wt["$" + Ct] = f(Ot.get)
        }
    }) : r(mt, function(Ct) {
        var Pt = new dt[Ct]
          , $t = Pt.slice || Pt.set;
        $t && (wt["$" + Ct] = f($t))
    });
    var xt = function(Pt) {
        var $t = !1;
        return r(wt, function(Ot, Nt) {
            if (!$t)
                try {
                    "$" + Ot(Pt) === Nt && ($t = yt(Nt, 1))
                } catch {}
        }),
        $t
    }
      , At = function(Pt) {
        var $t = !1;
        return r(wt, function(Ot, Nt) {
            if (!$t)
                try {
                    Ot(Pt),
                    $t = yt(Nt, 1)
                } catch {}
        }),
        $t
    };
    return whichTypedArray = function(Pt) {
        if (!Pt || typeof Pt != "object")
            return !1;
        if (!ee) {
            var $t = yt(y(Pt), 8, -1);
            return bt(mt, $t) > -1 ? $t : $t !== "Object" ? !1 : At(Pt)
        }
        return k ? xt(Pt) : null
    }
    ,
    whichTypedArray
}
var isTypedArray$1, hasRequiredIsTypedArray;
function requireIsTypedArray() {
    if (hasRequiredIsTypedArray)
        return isTypedArray$1;
    hasRequiredIsTypedArray = 1;
    var r = requireWhichTypedArray();
    return isTypedArray$1 = function(f) {
        return !!r(f)
    }
    ,
    isTypedArray$1
}
var hasRequiredTypes;
function requireTypes() {
    return hasRequiredTypes || (hasRequiredTypes = 1,
    function(r) {
        var d = requireIsArguments()
          , f = requireIsGeneratorFunction()
          , m = requireWhichTypedArray()
          , k = requireIsTypedArray();
        function y($r) {
            return $r.call.bind($r)
        }
        var ee = typeof BigInt < "u"
          , dt = typeof Symbol < "u"
          , mt = y(Object.prototype.toString)
          , yt = y(Number.prototype.valueOf)
          , pt = y(String.prototype.valueOf)
          , bt = y(Boolean.prototype.valueOf);
        if (ee)
            var wt = y(BigInt.prototype.valueOf);
        if (dt)
            var xt = y(Symbol.prototype.valueOf);
        function At($r, Zr) {
            if (typeof $r != "object")
                return !1;
            try {
                return Zr($r),
                !0
            } catch {
                return !1
            }
        }
        r.isArgumentsObject = d,
        r.isGeneratorFunction = f,
        r.isTypedArray = k;
        function Ct($r) {
            return typeof Promise < "u" && $r instanceof Promise || $r !== null && typeof $r == "object" && typeof $r.then == "function" && typeof $r.catch == "function"
        }
        r.isPromise = Ct;
        function Pt($r) {
            return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView($r) : k($r) || qt($r)
        }
        r.isArrayBufferView = Pt;
        function $t($r) {
            return m($r) === "Uint8Array"
        }
        r.isUint8Array = $t;
        function Ot($r) {
            return m($r) === "Uint8ClampedArray"
        }
        r.isUint8ClampedArray = Ot;
        function Nt($r) {
            return m($r) === "Uint16Array"
        }
        r.isUint16Array = Nt;
        function zt($r) {
            return m($r) === "Uint32Array"
        }
        r.isUint32Array = zt;
        function Wt($r) {
            return m($r) === "Int8Array"
        }
        r.isInt8Array = Wt;
        function Kt($r) {
            return m($r) === "Int16Array"
        }
        r.isInt16Array = Kt;
        function ir($r) {
            return m($r) === "Int32Array"
        }
        r.isInt32Array = ir;
        function or($r) {
            return m($r) === "Float32Array"
        }
        r.isFloat32Array = or;
        function tr($r) {
            return m($r) === "Float64Array"
        }
        r.isFloat64Array = tr;
        function wr($r) {
            return m($r) === "BigInt64Array"
        }
        r.isBigInt64Array = wr;
        function Ht($r) {
            return m($r) === "BigUint64Array"
        }
        r.isBigUint64Array = Ht;
        function Mt($r) {
            return mt($r) === "[object Map]"
        }
        Mt.working = typeof Map < "u" && Mt(new Map);
        function _t($r) {
            return typeof Map > "u" ? !1 : Mt.working ? Mt($r) : $r instanceof Map
        }
        r.isMap = _t;
        function gt($r) {
            return mt($r) === "[object Set]"
        }
        gt.working = typeof Set < "u" && gt(new Set);
        function vt($r) {
            return typeof Set > "u" ? !1 : gt.working ? gt($r) : $r instanceof Set
        }
        r.isSet = vt;
        function Et($r) {
            return mt($r) === "[object WeakMap]"
        }
        Et.working = typeof WeakMap < "u" && Et(new WeakMap);
        function Bt($r) {
            return typeof WeakMap > "u" ? !1 : Et.working ? Et($r) : $r instanceof WeakMap
        }
        r.isWeakMap = Bt;
        function Rt($r) {
            return mt($r) === "[object WeakSet]"
        }
        Rt.working = typeof WeakSet < "u" && Rt(new WeakSet);
        function kt($r) {
            return Rt($r)
        }
        r.isWeakSet = kt;
        function Tt($r) {
            return mt($r) === "[object ArrayBuffer]"
        }
        Tt.working = typeof ArrayBuffer < "u" && Tt(new ArrayBuffer);
        function It($r) {
            return typeof ArrayBuffer > "u" ? !1 : Tt.working ? Tt($r) : $r instanceof ArrayBuffer
        }
        r.isArrayBuffer = It;
        function St($r) {
            return mt($r) === "[object DataView]"
        }
        St.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && St(new DataView(new ArrayBuffer(1),0,1));
        function qt($r) {
            return typeof DataView > "u" ? !1 : St.working ? St($r) : $r instanceof DataView
        }
        r.isDataView = qt;
        var ur = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
        function gr($r) {
            return mt($r) === "[object SharedArrayBuffer]"
        }
        function lr($r) {
            return typeof ur > "u" ? !1 : (typeof gr.working > "u" && (gr.working = gr(new ur)),
            gr.working ? gr($r) : $r instanceof ur)
        }
        r.isSharedArrayBuffer = lr;
        function Zt($r) {
            return mt($r) === "[object AsyncFunction]"
        }
        r.isAsyncFunction = Zt;
        function Vt($r) {
            return mt($r) === "[object Map Iterator]"
        }
        r.isMapIterator = Vt;
        function rr($r) {
            return mt($r) === "[object Set Iterator]"
        }
        r.isSetIterator = rr;
        function fr($r) {
            return mt($r) === "[object Generator]"
        }
        r.isGeneratorObject = fr;
        function Yt($r) {
            return mt($r) === "[object WebAssembly.Module]"
        }
        r.isWebAssemblyCompiledModule = Yt;
        function Xt($r) {
            return At($r, yt)
        }
        r.isNumberObject = Xt;
        function Sr($r) {
            return At($r, pt)
        }
        r.isStringObject = Sr;
        function Rr($r) {
            return At($r, bt)
        }
        r.isBooleanObject = Rr;
        function qr($r) {
            return ee && At($r, wt)
        }
        r.isBigIntObject = qr;
        function Nr($r) {
            return dt && At($r, xt)
        }
        r.isSymbolObject = Nr;
        function Dr($r) {
            return Xt($r) || Sr($r) || Rr($r) || qr($r) || Nr($r)
        }
        r.isBoxedPrimitive = Dr;
        function Or($r) {
            return typeof Uint8Array < "u" && (It($r) || lr($r))
        }
        r.isAnyArrayBuffer = Or,
        ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function($r) {
            Object.defineProperty(r, $r, {
                enumerable: !1,
                value: function() {
                    throw new Error($r + " is not supported in userland")
                }
            })
        })
    }(types$1)),
    types$1
}
var isBufferBrowser, hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
    return hasRequiredIsBufferBrowser || (hasRequiredIsBufferBrowser = 1,
    isBufferBrowser = function(d) {
        return d && typeof d == "object" && typeof d.copy == "function" && typeof d.fill == "function" && typeof d.readUInt8 == "function"
    }
    ),
    isBufferBrowser
}
var hasRequiredUtil$1;
function requireUtil$1() {
    return hasRequiredUtil$1 || (hasRequiredUtil$1 = 1,
    function(r) {
        var d = {}
          , f = Object.getOwnPropertyDescriptors || function(ur) {
            for (var gr = Object.keys(ur), lr = {}, Zt = 0; Zt < gr.length; Zt++)
                lr[gr[Zt]] = Object.getOwnPropertyDescriptor(ur, gr[Zt]);
            return lr
        }
          , m = /%[sdj%]/g;
        r.format = function(qt) {
            if (!Kt(qt)) {
                for (var ur = [], gr = 0; gr < arguments.length; gr++)
                    ur.push(dt(arguments[gr]));
                return ur.join(" ")
            }
            for (var gr = 1, lr = arguments, Zt = lr.length, Vt = String(qt).replace(m, function(fr) {
                if (fr === "%%")
                    return "%";
                if (gr >= Zt)
                    return fr;
                switch (fr) {
                case "%s":
                    return String(lr[gr++]);
                case "%d":
                    return Number(lr[gr++]);
                case "%j":
                    try {
                        return JSON.stringify(lr[gr++])
                    } catch {
                        return "[Circular]"
                    }
                default:
                    return fr
                }
            }), rr = lr[gr]; gr < Zt; rr = lr[++gr])
                Nt(rr) || !wr(rr) ? Vt += " " + rr : Vt += " " + dt(rr);
            return Vt
        }
        ,
        r.deprecate = function(qt, ur) {
            if (typeof process$1 < "u" && process$1.noDeprecation === !0)
                return qt;
            if (typeof process$1 > "u")
                return function() {
                    return r.deprecate(qt, ur).apply(this, arguments)
                }
                ;
            var gr = !1;
            function lr() {
                if (!gr) {
                    if (process$1.throwDeprecation)
                        throw new Error(ur);
                    process$1.traceDeprecation ? console.trace(ur) : console.error(ur),
                    gr = !0
                }
                return qt.apply(this, arguments)
            }
            return lr
        }
        ;
        var k = {}
          , y = /^$/;
        if (d.NODE_DEBUG) {
            var ee = d.NODE_DEBUG;
            ee = ee.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(),
            y = new RegExp("^" + ee + "$","i")
        }
        r.debuglog = function(qt) {
            if (qt = qt.toUpperCase(),
            !k[qt])
                if (y.test(qt)) {
                    var ur = process$1.pid;
                    k[qt] = function() {
                        var gr = r.format.apply(r, arguments);
                        console.error("%s %d: %s", qt, ur, gr)
                    }
                } else
                    k[qt] = function() {}
                    ;
            return k[qt]
        }
        ;
        function dt(qt, ur) {
            var gr = {
                seen: [],
                stylize: yt
            };
            return arguments.length >= 3 && (gr.depth = arguments[2]),
            arguments.length >= 4 && (gr.colors = arguments[3]),
            Ot(ur) ? gr.showHidden = ur : ur && r._extend(gr, ur),
            or(gr.showHidden) && (gr.showHidden = !1),
            or(gr.depth) && (gr.depth = 2),
            or(gr.colors) && (gr.colors = !1),
            or(gr.customInspect) && (gr.customInspect = !0),
            gr.colors && (gr.stylize = mt),
            bt(gr, qt, gr.depth)
        }
        r.inspect = dt,
        dt.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39]
        },
        dt.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            regexp: "red"
        };
        function mt(qt, ur) {
            var gr = dt.styles[ur];
            return gr ? "\x1B[" + dt.colors[gr][0] + "m" + qt + "\x1B[" + dt.colors[gr][1] + "m" : qt
        }
        function yt(qt, ur) {
            return qt
        }
        function pt(qt) {
            var ur = {};
            return qt.forEach(function(gr, lr) {
                ur[gr] = !0
            }),
            ur
        }
        function bt(qt, ur, gr) {
            if (qt.customInspect && ur && _t(ur.inspect) && ur.inspect !== r.inspect && !(ur.constructor && ur.constructor.prototype === ur)) {
                var lr = ur.inspect(gr, qt);
                return Kt(lr) || (lr = bt(qt, lr, gr)),
                lr
            }
            var Zt = wt(qt, ur);
            if (Zt)
                return Zt;
            var Vt = Object.keys(ur)
              , rr = pt(Vt);
            if (qt.showHidden && (Vt = Object.getOwnPropertyNames(ur)),
            Mt(ur) && (Vt.indexOf("message") >= 0 || Vt.indexOf("description") >= 0))
                return xt(ur);
            if (Vt.length === 0) {
                if (_t(ur)) {
                    var fr = ur.name ? ": " + ur.name : "";
                    return qt.stylize("[Function" + fr + "]", "special")
                }
                if (tr(ur))
                    return qt.stylize(RegExp.prototype.toString.call(ur), "regexp");
                if (Ht(ur))
                    return qt.stylize(Date.prototype.toString.call(ur), "date");
                if (Mt(ur))
                    return xt(ur)
            }
            var Yt = ""
              , Xt = !1
              , Sr = ["{", "}"];
            if ($t(ur) && (Xt = !0,
            Sr = ["[", "]"]),
            _t(ur)) {
                var Rr = ur.name ? ": " + ur.name : "";
                Yt = " [Function" + Rr + "]"
            }
            if (tr(ur) && (Yt = " " + RegExp.prototype.toString.call(ur)),
            Ht(ur) && (Yt = " " + Date.prototype.toUTCString.call(ur)),
            Mt(ur) && (Yt = " " + xt(ur)),
            Vt.length === 0 && (!Xt || ur.length == 0))
                return Sr[0] + Yt + Sr[1];
            if (gr < 0)
                return tr(ur) ? qt.stylize(RegExp.prototype.toString.call(ur), "regexp") : qt.stylize("[Object]", "special");
            qt.seen.push(ur);
            var qr;
            return Xt ? qr = At(qt, ur, gr, rr, Vt) : qr = Vt.map(function(Nr) {
                return Ct(qt, ur, gr, rr, Nr, Xt)
            }),
            qt.seen.pop(),
            Pt(qr, Yt, Sr)
        }
        function wt(qt, ur) {
            if (or(ur))
                return qt.stylize("undefined", "undefined");
            if (Kt(ur)) {
                var gr = "'" + JSON.stringify(ur).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return qt.stylize(gr, "string")
            }
            if (Wt(ur))
                return qt.stylize("" + ur, "number");
            if (Ot(ur))
                return qt.stylize("" + ur, "boolean");
            if (Nt(ur))
                return qt.stylize("null", "null")
        }
        function xt(qt) {
            return "[" + Error.prototype.toString.call(qt) + "]"
        }
        function At(qt, ur, gr, lr, Zt) {
            for (var Vt = [], rr = 0, fr = ur.length; rr < fr; ++rr)
                kt(ur, String(rr)) ? Vt.push(Ct(qt, ur, gr, lr, String(rr), !0)) : Vt.push("");
            return Zt.forEach(function(Yt) {
                Yt.match(/^\d+$/) || Vt.push(Ct(qt, ur, gr, lr, Yt, !0))
            }),
            Vt
        }
        function Ct(qt, ur, gr, lr, Zt, Vt) {
            var rr, fr, Yt;
            if (Yt = Object.getOwnPropertyDescriptor(ur, Zt) || {
                value: ur[Zt]
            },
            Yt.get ? Yt.set ? fr = qt.stylize("[Getter/Setter]", "special") : fr = qt.stylize("[Getter]", "special") : Yt.set && (fr = qt.stylize("[Setter]", "special")),
            kt(lr, Zt) || (rr = "[" + Zt + "]"),
            fr || (qt.seen.indexOf(Yt.value) < 0 ? (Nt(gr) ? fr = bt(qt, Yt.value, null) : fr = bt(qt, Yt.value, gr - 1),
            fr.indexOf(`
`) > -1 && (Vt ? fr = fr.split(`
`).map(function(Xt) {
                return "  " + Xt
            }).join(`
`).slice(2) : fr = `
` + fr.split(`
`).map(function(Xt) {
                return "   " + Xt
            }).join(`
`))) : fr = qt.stylize("[Circular]", "special")),
            or(rr)) {
                if (Vt && Zt.match(/^\d+$/))
                    return fr;
                rr = JSON.stringify("" + Zt),
                rr.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (rr = rr.slice(1, -1),
                rr = qt.stylize(rr, "name")) : (rr = rr.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"),
                rr = qt.stylize(rr, "string"))
            }
            return rr + ": " + fr
        }
        function Pt(qt, ur, gr) {
            var lr = qt.reduce(function(Zt, Vt) {
                return Vt.indexOf(`
`) >= 0,
                Zt + Vt.replace(/\u001b\[\d\d?m/g, "").length + 1
            }, 0);
            return lr > 60 ? gr[0] + (ur === "" ? "" : ur + `
 `) + " " + qt.join(`,
  `) + " " + gr[1] : gr[0] + ur + " " + qt.join(", ") + " " + gr[1]
        }
        r.types = requireTypes();
        function $t(qt) {
            return Array.isArray(qt)
        }
        r.isArray = $t;
        function Ot(qt) {
            return typeof qt == "boolean"
        }
        r.isBoolean = Ot;
        function Nt(qt) {
            return qt === null
        }
        r.isNull = Nt;
        function zt(qt) {
            return qt == null
        }
        r.isNullOrUndefined = zt;
        function Wt(qt) {
            return typeof qt == "number"
        }
        r.isNumber = Wt;
        function Kt(qt) {
            return typeof qt == "string"
        }
        r.isString = Kt;
        function ir(qt) {
            return typeof qt == "symbol"
        }
        r.isSymbol = ir;
        function or(qt) {
            return qt === void 0
        }
        r.isUndefined = or;
        function tr(qt) {
            return wr(qt) && vt(qt) === "[object RegExp]"
        }
        r.isRegExp = tr,
        r.types.isRegExp = tr;
        function wr(qt) {
            return typeof qt == "object" && qt !== null
        }
        r.isObject = wr;
        function Ht(qt) {
            return wr(qt) && vt(qt) === "[object Date]"
        }
        r.isDate = Ht,
        r.types.isDate = Ht;
        function Mt(qt) {
            return wr(qt) && (vt(qt) === "[object Error]" || qt instanceof Error)
        }
        r.isError = Mt,
        r.types.isNativeError = Mt;
        function _t(qt) {
            return typeof qt == "function"
        }
        r.isFunction = _t;
        function gt(qt) {
            return qt === null || typeof qt == "boolean" || typeof qt == "number" || typeof qt == "string" || typeof qt == "symbol" || typeof qt > "u"
        }
        r.isPrimitive = gt,
        r.isBuffer = requireIsBufferBrowser();
        function vt(qt) {
            return Object.prototype.toString.call(qt)
        }
        function Et(qt) {
            return qt < 10 ? "0" + qt.toString(10) : qt.toString(10)
        }
        var Bt = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        function Rt() {
            var qt = new Date
              , ur = [Et(qt.getHours()), Et(qt.getMinutes()), Et(qt.getSeconds())].join(":");
            return [qt.getDate(), Bt[qt.getMonth()], ur].join(" ")
        }
        r.log = function() {
            console.log("%s - %s", Rt(), r.format.apply(r, arguments))
        }
        ,
        r.inherits = requireInherits_browser(),
        r._extend = function(qt, ur) {
            if (!ur || !wr(ur))
                return qt;
            for (var gr = Object.keys(ur), lr = gr.length; lr--; )
                qt[gr[lr]] = ur[gr[lr]];
            return qt
        }
        ;
        function kt(qt, ur) {
            return Object.prototype.hasOwnProperty.call(qt, ur)
        }
        var Tt = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
        r.promisify = function(ur) {
            if (typeof ur != "function")
                throw new TypeError('The "original" argument must be of type Function');
            if (Tt && ur[Tt]) {
                var gr = ur[Tt];
                if (typeof gr != "function")
                    throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                return Object.defineProperty(gr, Tt, {
                    value: gr,
                    enumerable: !1,
                    writable: !1,
                    configurable: !0
                }),
                gr
            }
            function gr() {
                for (var lr, Zt, Vt = new Promise(function(Yt, Xt) {
                    lr = Yt,
                    Zt = Xt
                }
                ), rr = [], fr = 0; fr < arguments.length; fr++)
                    rr.push(arguments[fr]);
                rr.push(function(Yt, Xt) {
                    Yt ? Zt(Yt) : lr(Xt)
                });
                try {
                    ur.apply(this, rr)
                } catch (Yt) {
                    Zt(Yt)
                }
                return Vt
            }
            return Object.setPrototypeOf(gr, Object.getPrototypeOf(ur)),
            Tt && Object.defineProperty(gr, Tt, {
                value: gr,
                enumerable: !1,
                writable: !1,
                configurable: !0
            }),
            Object.defineProperties(gr, f(ur))
        }
        ,
        r.promisify.custom = Tt;
        function It(qt, ur) {
            if (!qt) {
                var gr = new Error("Promise was rejected with a falsy value");
                gr.reason = qt,
                qt = gr
            }
            return ur(qt)
        }
        function St(qt) {
            if (typeof qt != "function")
                throw new TypeError('The "original" argument must be of type Function');
            function ur() {
                for (var gr = [], lr = 0; lr < arguments.length; lr++)
                    gr.push(arguments[lr]);
                var Zt = gr.pop();
                if (typeof Zt != "function")
                    throw new TypeError("The last argument must be of type Function");
                var Vt = this
                  , rr = function() {
                    return Zt.apply(Vt, arguments)
                };
                qt.apply(this, gr).then(function(fr) {
                    process$1.nextTick(rr.bind(null, null, fr))
                }, function(fr) {
                    process$1.nextTick(It.bind(null, fr, rr))
                })
            }
            return Object.setPrototypeOf(ur, Object.getPrototypeOf(qt)),
            Object.defineProperties(ur, f(qt)),
            ur
        }
        r.callbackify = St
    }(util$2)),
    util$2
}
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
    if (hasRequiredBuffer_list)
        return buffer_list;
    hasRequiredBuffer_list = 1;
    function r(At, Ct) {
        var Pt = Object.keys(At);
        if (Object.getOwnPropertySymbols) {
            var $t = Object.getOwnPropertySymbols(At);
            Ct && ($t = $t.filter(function(Ot) {
                return Object.getOwnPropertyDescriptor(At, Ot).enumerable
            })),
            Pt.push.apply(Pt, $t)
        }
        return Pt
    }
    function d(At) {
        for (var Ct = 1; Ct < arguments.length; Ct++) {
            var Pt = arguments[Ct] != null ? arguments[Ct] : {};
            Ct % 2 ? r(Object(Pt), !0).forEach(function($t) {
                f(At, $t, Pt[$t])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(At, Object.getOwnPropertyDescriptors(Pt)) : r(Object(Pt)).forEach(function($t) {
                Object.defineProperty(At, $t, Object.getOwnPropertyDescriptor(Pt, $t))
            })
        }
        return At
    }
    function f(At, Ct, Pt) {
        return Ct = ee(Ct),
        Ct in At ? Object.defineProperty(At, Ct, {
            value: Pt,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : At[Ct] = Pt,
        At
    }
    function m(At, Ct) {
        if (!(At instanceof Ct))
            throw new TypeError("Cannot call a class as a function")
    }
    function k(At, Ct) {
        for (var Pt = 0; Pt < Ct.length; Pt++) {
            var $t = Ct[Pt];
            $t.enumerable = $t.enumerable || !1,
            $t.configurable = !0,
            "value"in $t && ($t.writable = !0),
            Object.defineProperty(At, ee($t.key), $t)
        }
    }
    function y(At, Ct, Pt) {
        return Ct && k(At.prototype, Ct),
        Pt && k(At, Pt),
        Object.defineProperty(At, "prototype", {
            writable: !1
        }),
        At
    }
    function ee(At) {
        var Ct = dt(At, "string");
        return typeof Ct == "symbol" ? Ct : String(Ct)
    }
    function dt(At, Ct) {
        if (typeof At != "object" || At === null)
            return At;
        var Pt = At[Symbol.toPrimitive];
        if (Pt !== void 0) {
            var $t = Pt.call(At, Ct || "default");
            if (typeof $t != "object")
                return $t;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return (Ct === "string" ? String : Number)(At)
    }
    var mt = require$$1$2
      , yt = mt.Buffer
      , pt = requireUtil$1()
      , bt = pt.inspect
      , wt = bt && bt.custom || "inspect";
    function xt(At, Ct, Pt) {
        yt.prototype.copy.call(At, Ct, Pt)
    }
    return buffer_list = function() {
        function At() {
            m(this, At),
            this.head = null,
            this.tail = null,
            this.length = 0
        }
        return y(At, [{
            key: "push",
            value: function(Pt) {
                var $t = {
                    data: Pt,
                    next: null
                };
                this.length > 0 ? this.tail.next = $t : this.head = $t,
                this.tail = $t,
                ++this.length
            }
        }, {
            key: "unshift",
            value: function(Pt) {
                var $t = {
                    data: Pt,
                    next: this.head
                };
                this.length === 0 && (this.tail = $t),
                this.head = $t,
                ++this.length
            }
        }, {
            key: "shift",
            value: function() {
                if (this.length !== 0) {
                    var Pt = this.head.data;
                    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next,
                    --this.length,
                    Pt
                }
            }
        }, {
            key: "clear",
            value: function() {
                this.head = this.tail = null,
                this.length = 0
            }
        }, {
            key: "join",
            value: function(Pt) {
                if (this.length === 0)
                    return "";
                for (var $t = this.head, Ot = "" + $t.data; $t = $t.next; )
                    Ot += Pt + $t.data;
                return Ot
            }
        }, {
            key: "concat",
            value: function(Pt) {
                if (this.length === 0)
                    return yt.alloc(0);
                for (var $t = yt.allocUnsafe(Pt >>> 0), Ot = this.head, Nt = 0; Ot; )
                    xt(Ot.data, $t, Nt),
                    Nt += Ot.data.length,
                    Ot = Ot.next;
                return $t
            }
        }, {
            key: "consume",
            value: function(Pt, $t) {
                var Ot;
                return Pt < this.head.data.length ? (Ot = this.head.data.slice(0, Pt),
                this.head.data = this.head.data.slice(Pt)) : Pt === this.head.data.length ? Ot = this.shift() : Ot = $t ? this._getString(Pt) : this._getBuffer(Pt),
                Ot
            }
        }, {
            key: "first",
            value: function() {
                return this.head.data
            }
        }, {
            key: "_getString",
            value: function(Pt) {
                var $t = this.head
                  , Ot = 1
                  , Nt = $t.data;
                for (Pt -= Nt.length; $t = $t.next; ) {
                    var zt = $t.data
                      , Wt = Pt > zt.length ? zt.length : Pt;
                    if (Wt === zt.length ? Nt += zt : Nt += zt.slice(0, Pt),
                    Pt -= Wt,
                    Pt === 0) {
                        Wt === zt.length ? (++Ot,
                        $t.next ? this.head = $t.next : this.head = this.tail = null) : (this.head = $t,
                        $t.data = zt.slice(Wt));
                        break
                    }
                    ++Ot
                }
                return this.length -= Ot,
                Nt
            }
        }, {
            key: "_getBuffer",
            value: function(Pt) {
                var $t = yt.allocUnsafe(Pt)
                  , Ot = this.head
                  , Nt = 1;
                for (Ot.data.copy($t),
                Pt -= Ot.data.length; Ot = Ot.next; ) {
                    var zt = Ot.data
                      , Wt = Pt > zt.length ? zt.length : Pt;
                    if (zt.copy($t, $t.length - Pt, 0, Wt),
                    Pt -= Wt,
                    Pt === 0) {
                        Wt === zt.length ? (++Nt,
                        Ot.next ? this.head = Ot.next : this.head = this.tail = null) : (this.head = Ot,
                        Ot.data = zt.slice(Wt));
                        break
                    }
                    ++Nt
                }
                return this.length -= Nt,
                $t
            }
        }, {
            key: wt,
            value: function(Pt, $t) {
                return bt(this, d(d({}, $t), {}, {
                    depth: 0,
                    customInspect: !1
                }))
            }
        }]),
        At
    }(),
    buffer_list
}
var destroy_1$1, hasRequiredDestroy$1;
function requireDestroy$1() {
    if (hasRequiredDestroy$1)
        return destroy_1$1;
    hasRequiredDestroy$1 = 1;
    function r(ee, dt) {
        var mt = this
          , yt = this._readableState && this._readableState.destroyed
          , pt = this._writableState && this._writableState.destroyed;
        return yt || pt ? (dt ? dt(ee) : ee && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0,
        process$1.nextTick(k, this, ee)) : process$1.nextTick(k, this, ee)),
        this) : (this._readableState && (this._readableState.destroyed = !0),
        this._writableState && (this._writableState.destroyed = !0),
        this._destroy(ee || null, function(bt) {
            !dt && bt ? mt._writableState ? mt._writableState.errorEmitted ? process$1.nextTick(f, mt) : (mt._writableState.errorEmitted = !0,
            process$1.nextTick(d, mt, bt)) : process$1.nextTick(d, mt, bt) : dt ? (process$1.nextTick(f, mt),
            dt(bt)) : process$1.nextTick(f, mt)
        }),
        this)
    }
    function d(ee, dt) {
        k(ee, dt),
        f(ee)
    }
    function f(ee) {
        ee._writableState && !ee._writableState.emitClose || ee._readableState && !ee._readableState.emitClose || ee.emit("close")
    }
    function m() {
        this._readableState && (this._readableState.destroyed = !1,
        this._readableState.reading = !1,
        this._readableState.ended = !1,
        this._readableState.endEmitted = !1),
        this._writableState && (this._writableState.destroyed = !1,
        this._writableState.ended = !1,
        this._writableState.ending = !1,
        this._writableState.finalCalled = !1,
        this._writableState.prefinished = !1,
        this._writableState.finished = !1,
        this._writableState.errorEmitted = !1)
    }
    function k(ee, dt) {
        ee.emit("error", dt)
    }
    function y(ee, dt) {
        var mt = ee._readableState
          , yt = ee._writableState;
        mt && mt.autoDestroy || yt && yt.autoDestroy ? ee.destroy(dt) : ee.emit("error", dt)
    }
    return destroy_1$1 = {
        destroy: r,
        undestroy: m,
        errorOrDestroy: y
    },
    destroy_1$1
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
    if (hasRequiredErrorsBrowser)
        return errorsBrowser;
    hasRequiredErrorsBrowser = 1;
    function r(dt, mt) {
        dt.prototype = Object.create(mt.prototype),
        dt.prototype.constructor = dt,
        dt.__proto__ = mt
    }
    var d = {};
    function f(dt, mt, yt) {
        yt || (yt = Error);
        function pt(wt, xt, At) {
            return typeof mt == "string" ? mt : mt(wt, xt, At)
        }
        var bt = function(wt) {
            r(xt, wt);
            function xt(At, Ct, Pt) {
                return wt.call(this, pt(At, Ct, Pt)) || this
            }
            return xt
        }(yt);
        bt.prototype.name = yt.name,
        bt.prototype.code = dt,
        d[dt] = bt
    }
    function m(dt, mt) {
        if (Array.isArray(dt)) {
            var yt = dt.length;
            return dt = dt.map(function(pt) {
                return String(pt)
            }),
            yt > 2 ? "one of ".concat(mt, " ").concat(dt.slice(0, yt - 1).join(", "), ", or ") + dt[yt - 1] : yt === 2 ? "one of ".concat(mt, " ").concat(dt[0], " or ").concat(dt[1]) : "of ".concat(mt, " ").concat(dt[0])
        } else
            return "of ".concat(mt, " ").concat(String(dt))
    }
    function k(dt, mt, yt) {
        return dt.substr(!yt || yt < 0 ? 0 : +yt, mt.length) === mt
    }
    function y(dt, mt, yt) {
        return (yt === void 0 || yt > dt.length) && (yt = dt.length),
        dt.substring(yt - mt.length, yt) === mt
    }
    function ee(dt, mt, yt) {
        return typeof yt != "number" && (yt = 0),
        yt + mt.length > dt.length ? !1 : dt.indexOf(mt, yt) !== -1
    }
    return f("ERR_INVALID_OPT_VALUE", function(dt, mt) {
        return 'The value "' + mt + '" is invalid for option "' + dt + '"'
    }, TypeError),
    f("ERR_INVALID_ARG_TYPE", function(dt, mt, yt) {
        var pt;
        typeof mt == "string" && k(mt, "not ") ? (pt = "must not be",
        mt = mt.replace(/^not /, "")) : pt = "must be";
        var bt;
        if (y(dt, " argument"))
            bt = "The ".concat(dt, " ").concat(pt, " ").concat(m(mt, "type"));
        else {
            var wt = ee(dt, ".") ? "property" : "argument";
            bt = 'The "'.concat(dt, '" ').concat(wt, " ").concat(pt, " ").concat(m(mt, "type"))
        }
        return bt += ". Received type ".concat(typeof yt),
        bt
    }, TypeError),
    f("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"),
    f("ERR_METHOD_NOT_IMPLEMENTED", function(dt) {
        return "The " + dt + " method is not implemented"
    }),
    f("ERR_STREAM_PREMATURE_CLOSE", "Premature close"),
    f("ERR_STREAM_DESTROYED", function(dt) {
        return "Cannot call " + dt + " after a stream was destroyed"
    }),
    f("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"),
    f("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"),
    f("ERR_STREAM_WRITE_AFTER_END", "write after end"),
    f("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError),
    f("ERR_UNKNOWN_ENCODING", function(dt) {
        return "Unknown encoding: " + dt
    }, TypeError),
    f("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"),
    errorsBrowser.codes = d,
    errorsBrowser
}
var state, hasRequiredState;
function requireState() {
    if (hasRequiredState)
        return state;
    hasRequiredState = 1;
    var r = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
    function d(m, k, y) {
        return m.highWaterMark != null ? m.highWaterMark : k ? m[y] : null
    }
    function f(m, k, y, ee) {
        var dt = d(k, ee, y);
        if (dt != null) {
            if (!(isFinite(dt) && Math.floor(dt) === dt) || dt < 0) {
                var mt = ee ? y : "highWaterMark";
                throw new r(mt,dt)
            }
            return Math.floor(dt)
        }
        return m.objectMode ? 16 : 16 * 1024
    }
    return state = {
        getHighWaterMark: f
    },
    state
}
var browser$b, hasRequiredBrowser$a;
function requireBrowser$a() {
    if (hasRequiredBrowser$a)
        return browser$b;
    hasRequiredBrowser$a = 1,
    browser$b = r;
    function r(f, m) {
        if (d("noDeprecation"))
            return f;
        var k = !1;
        function y() {
            if (!k) {
                if (d("throwDeprecation"))
                    throw new Error(m);
                d("traceDeprecation") ? console.trace(m) : console.warn(m),
                k = !0
            }
            return f.apply(this, arguments)
        }
        return y
    }
    function d(f) {
        try {
            if (!commonjsGlobal.localStorage)
                return !1
        } catch {
            return !1
        }
        var m = commonjsGlobal.localStorage[f];
        return m == null ? !1 : String(m).toLowerCase() === "true"
    }
    return browser$b
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
    if (hasRequired_stream_writable$1)
        return _stream_writable$1;
    hasRequired_stream_writable$1 = 1,
    _stream_writable$1 = or;
    function r(lr) {
        var Zt = this;
        this.next = null,
        this.entry = null,
        this.finish = function() {
            gr(Zt, lr)
        }
    }
    var d;
    or.WritableState = Kt;
    var f = {
        deprecate: requireBrowser$a()
    }
      , m = requireStreamBrowser$1()
      , k = require$$1$2.Buffer
      , y = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {}
    ;
    function ee(lr) {
        return k.from(lr)
    }
    function dt(lr) {
        return k.isBuffer(lr) || lr instanceof y
    }
    var mt = requireDestroy$1()
      , yt = requireState()
      , pt = yt.getHighWaterMark
      , bt = requireErrorsBrowser().codes
      , wt = bt.ERR_INVALID_ARG_TYPE
      , xt = bt.ERR_METHOD_NOT_IMPLEMENTED
      , At = bt.ERR_MULTIPLE_CALLBACK
      , Ct = bt.ERR_STREAM_CANNOT_PIPE
      , Pt = bt.ERR_STREAM_DESTROYED
      , $t = bt.ERR_STREAM_NULL_VALUES
      , Ot = bt.ERR_STREAM_WRITE_AFTER_END
      , Nt = bt.ERR_UNKNOWN_ENCODING
      , zt = mt.errorOrDestroy;
    requireInherits_browser()(or, m);
    function Wt() {}
    function Kt(lr, Zt, Vt) {
        d = d || require_stream_duplex$1(),
        lr = lr || {},
        typeof Vt != "boolean" && (Vt = Zt instanceof d),
        this.objectMode = !!lr.objectMode,
        Vt && (this.objectMode = this.objectMode || !!lr.writableObjectMode),
        this.highWaterMark = pt(this, lr, "writableHighWaterMark", Vt),
        this.finalCalled = !1,
        this.needDrain = !1,
        this.ending = !1,
        this.ended = !1,
        this.finished = !1,
        this.destroyed = !1;
        var rr = lr.decodeStrings === !1;
        this.decodeStrings = !rr,
        this.defaultEncoding = lr.defaultEncoding || "utf8",
        this.length = 0,
        this.writing = !1,
        this.corked = 0,
        this.sync = !0,
        this.bufferProcessing = !1,
        this.onwrite = function(fr) {
            Et(Zt, fr)
        }
        ,
        this.writecb = null,
        this.writelen = 0,
        this.bufferedRequest = null,
        this.lastBufferedRequest = null,
        this.pendingcb = 0,
        this.prefinished = !1,
        this.errorEmitted = !1,
        this.emitClose = lr.emitClose !== !1,
        this.autoDestroy = !!lr.autoDestroy,
        this.bufferedRequestCount = 0,
        this.corkedRequestsFree = new r(this)
    }
    Kt.prototype.getBuffer = function() {
        for (var Zt = this.bufferedRequest, Vt = []; Zt; )
            Vt.push(Zt),
            Zt = Zt.next;
        return Vt
    }
    ,
    function() {
        try {
            Object.defineProperty(Kt.prototype, "buffer", {
                get: f.deprecate(function() {
                    return this.getBuffer()
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
            })
        } catch {}
    }();
    var ir;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ir = Function.prototype[Symbol.hasInstance],
    Object.defineProperty(or, Symbol.hasInstance, {
        value: function(Zt) {
            return ir.call(this, Zt) ? !0 : this !== or ? !1 : Zt && Zt._writableState instanceof Kt
        }
    })) : ir = function(Zt) {
        return Zt instanceof this
    }
    ;
    function or(lr) {
        d = d || require_stream_duplex$1();
        var Zt = this instanceof d;
        if (!Zt && !ir.call(or, this))
            return new or(lr);
        this._writableState = new Kt(lr,this,Zt),
        this.writable = !0,
        lr && (typeof lr.write == "function" && (this._write = lr.write),
        typeof lr.writev == "function" && (this._writev = lr.writev),
        typeof lr.destroy == "function" && (this._destroy = lr.destroy),
        typeof lr.final == "function" && (this._final = lr.final)),
        m.call(this)
    }
    or.prototype.pipe = function() {
        zt(this, new Ct)
    }
    ;
    function tr(lr, Zt) {
        var Vt = new Ot;
        zt(lr, Vt),
        process$1.nextTick(Zt, Vt)
    }
    function wr(lr, Zt, Vt, rr) {
        var fr;
        return Vt === null ? fr = new $t : typeof Vt != "string" && !Zt.objectMode && (fr = new wt("chunk",["string", "Buffer"],Vt)),
        fr ? (zt(lr, fr),
        process$1.nextTick(rr, fr),
        !1) : !0
    }
    or.prototype.write = function(lr, Zt, Vt) {
        var rr = this._writableState
          , fr = !1
          , Yt = !rr.objectMode && dt(lr);
        return Yt && !k.isBuffer(lr) && (lr = ee(lr)),
        typeof Zt == "function" && (Vt = Zt,
        Zt = null),
        Yt ? Zt = "buffer" : Zt || (Zt = rr.defaultEncoding),
        typeof Vt != "function" && (Vt = Wt),
        rr.ending ? tr(this, Vt) : (Yt || wr(this, rr, lr, Vt)) && (rr.pendingcb++,
        fr = Mt(this, rr, Yt, lr, Zt, Vt)),
        fr
    }
    ,
    or.prototype.cork = function() {
        this._writableState.corked++
    }
    ,
    or.prototype.uncork = function() {
        var lr = this._writableState;
        lr.corked && (lr.corked--,
        !lr.writing && !lr.corked && !lr.bufferProcessing && lr.bufferedRequest && kt(this, lr))
    }
    ,
    or.prototype.setDefaultEncoding = function(Zt) {
        if (typeof Zt == "string" && (Zt = Zt.toLowerCase()),
        !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Zt + "").toLowerCase()) > -1))
            throw new Nt(Zt);
        return this._writableState.defaultEncoding = Zt,
        this
    }
    ,
    Object.defineProperty(or.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer()
        }
    });
    function Ht(lr, Zt, Vt) {
        return !lr.objectMode && lr.decodeStrings !== !1 && typeof Zt == "string" && (Zt = k.from(Zt, Vt)),
        Zt
    }
    Object.defineProperty(or.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark
        }
    });
    function Mt(lr, Zt, Vt, rr, fr, Yt) {
        if (!Vt) {
            var Xt = Ht(Zt, rr, fr);
            rr !== Xt && (Vt = !0,
            fr = "buffer",
            rr = Xt)
        }
        var Sr = Zt.objectMode ? 1 : rr.length;
        Zt.length += Sr;
        var Rr = Zt.length < Zt.highWaterMark;
        if (Rr || (Zt.needDrain = !0),
        Zt.writing || Zt.corked) {
            var qr = Zt.lastBufferedRequest;
            Zt.lastBufferedRequest = {
                chunk: rr,
                encoding: fr,
                isBuf: Vt,
                callback: Yt,
                next: null
            },
            qr ? qr.next = Zt.lastBufferedRequest : Zt.bufferedRequest = Zt.lastBufferedRequest,
            Zt.bufferedRequestCount += 1
        } else
            _t(lr, Zt, !1, Sr, rr, fr, Yt);
        return Rr
    }
    function _t(lr, Zt, Vt, rr, fr, Yt, Xt) {
        Zt.writelen = rr,
        Zt.writecb = Xt,
        Zt.writing = !0,
        Zt.sync = !0,
        Zt.destroyed ? Zt.onwrite(new Pt("write")) : Vt ? lr._writev(fr, Zt.onwrite) : lr._write(fr, Yt, Zt.onwrite),
        Zt.sync = !1
    }
    function gt(lr, Zt, Vt, rr, fr) {
        --Zt.pendingcb,
        Vt ? (process$1.nextTick(fr, rr),
        process$1.nextTick(qt, lr, Zt),
        lr._writableState.errorEmitted = !0,
        zt(lr, rr)) : (fr(rr),
        lr._writableState.errorEmitted = !0,
        zt(lr, rr),
        qt(lr, Zt))
    }
    function vt(lr) {
        lr.writing = !1,
        lr.writecb = null,
        lr.length -= lr.writelen,
        lr.writelen = 0
    }
    function Et(lr, Zt) {
        var Vt = lr._writableState
          , rr = Vt.sync
          , fr = Vt.writecb;
        if (typeof fr != "function")
            throw new At;
        if (vt(Vt),
        Zt)
            gt(lr, Vt, rr, Zt, fr);
        else {
            var Yt = Tt(Vt) || lr.destroyed;
            !Yt && !Vt.corked && !Vt.bufferProcessing && Vt.bufferedRequest && kt(lr, Vt),
            rr ? process$1.nextTick(Bt, lr, Vt, Yt, fr) : Bt(lr, Vt, Yt, fr)
        }
    }
    function Bt(lr, Zt, Vt, rr) {
        Vt || Rt(lr, Zt),
        Zt.pendingcb--,
        rr(),
        qt(lr, Zt)
    }
    function Rt(lr, Zt) {
        Zt.length === 0 && Zt.needDrain && (Zt.needDrain = !1,
        lr.emit("drain"))
    }
    function kt(lr, Zt) {
        Zt.bufferProcessing = !0;
        var Vt = Zt.bufferedRequest;
        if (lr._writev && Vt && Vt.next) {
            var rr = Zt.bufferedRequestCount
              , fr = new Array(rr)
              , Yt = Zt.corkedRequestsFree;
            Yt.entry = Vt;
            for (var Xt = 0, Sr = !0; Vt; )
                fr[Xt] = Vt,
                Vt.isBuf || (Sr = !1),
                Vt = Vt.next,
                Xt += 1;
            fr.allBuffers = Sr,
            _t(lr, Zt, !0, Zt.length, fr, "", Yt.finish),
            Zt.pendingcb++,
            Zt.lastBufferedRequest = null,
            Yt.next ? (Zt.corkedRequestsFree = Yt.next,
            Yt.next = null) : Zt.corkedRequestsFree = new r(Zt),
            Zt.bufferedRequestCount = 0
        } else {
            for (; Vt; ) {
                var Rr = Vt.chunk
                  , qr = Vt.encoding
                  , Nr = Vt.callback
                  , Dr = Zt.objectMode ? 1 : Rr.length;
                if (_t(lr, Zt, !1, Dr, Rr, qr, Nr),
                Vt = Vt.next,
                Zt.bufferedRequestCount--,
                Zt.writing)
                    break
            }
            Vt === null && (Zt.lastBufferedRequest = null)
        }
        Zt.bufferedRequest = Vt,
        Zt.bufferProcessing = !1
    }
    or.prototype._write = function(lr, Zt, Vt) {
        Vt(new xt("_write()"))
    }
    ,
    or.prototype._writev = null,
    or.prototype.end = function(lr, Zt, Vt) {
        var rr = this._writableState;
        return typeof lr == "function" ? (Vt = lr,
        lr = null,
        Zt = null) : typeof Zt == "function" && (Vt = Zt,
        Zt = null),
        lr != null && this.write(lr, Zt),
        rr.corked && (rr.corked = 1,
        this.uncork()),
        rr.ending || ur(this, rr, Vt),
        this
    }
    ,
    Object.defineProperty(or.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length
        }
    });
    function Tt(lr) {
        return lr.ending && lr.length === 0 && lr.bufferedRequest === null && !lr.finished && !lr.writing
    }
    function It(lr, Zt) {
        lr._final(function(Vt) {
            Zt.pendingcb--,
            Vt && zt(lr, Vt),
            Zt.prefinished = !0,
            lr.emit("prefinish"),
            qt(lr, Zt)
        })
    }
    function St(lr, Zt) {
        !Zt.prefinished && !Zt.finalCalled && (typeof lr._final == "function" && !Zt.destroyed ? (Zt.pendingcb++,
        Zt.finalCalled = !0,
        process$1.nextTick(It, lr, Zt)) : (Zt.prefinished = !0,
        lr.emit("prefinish")))
    }
    function qt(lr, Zt) {
        var Vt = Tt(Zt);
        if (Vt && (St(lr, Zt),
        Zt.pendingcb === 0 && (Zt.finished = !0,
        lr.emit("finish"),
        Zt.autoDestroy))) {
            var rr = lr._readableState;
            (!rr || rr.autoDestroy && rr.endEmitted) && lr.destroy()
        }
        return Vt
    }
    function ur(lr, Zt, Vt) {
        Zt.ending = !0,
        qt(lr, Zt),
        Vt && (Zt.finished ? process$1.nextTick(Vt) : lr.once("finish", Vt)),
        Zt.ended = !0,
        lr.writable = !1
    }
    function gr(lr, Zt, Vt) {
        var rr = lr.entry;
        for (lr.entry = null; rr; ) {
            var fr = rr.callback;
            Zt.pendingcb--,
            fr(Vt),
            rr = rr.next
        }
        Zt.corkedRequestsFree.next = lr
    }
    return Object.defineProperty(or.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._writableState === void 0 ? !1 : this._writableState.destroyed
        },
        set: function(Zt) {
            this._writableState && (this._writableState.destroyed = Zt)
        }
    }),
    or.prototype.destroy = mt.destroy,
    or.prototype._undestroy = mt.undestroy,
    or.prototype._destroy = function(lr, Zt) {
        Zt(lr)
    }
    ,
    _stream_writable$1
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
    if (hasRequired_stream_duplex$1)
        return _stream_duplex$1;
    hasRequired_stream_duplex$1 = 1;
    var r = Object.keys || function(yt) {
        var pt = [];
        for (var bt in yt)
            pt.push(bt);
        return pt
    }
    ;
    _stream_duplex$1 = ee;
    var d = require_stream_readable$1()
      , f = require_stream_writable$1();
    requireInherits_browser()(ee, d);
    for (var m = r(f.prototype), k = 0; k < m.length; k++) {
        var y = m[k];
        ee.prototype[y] || (ee.prototype[y] = f.prototype[y])
    }
    function ee(yt) {
        if (!(this instanceof ee))
            return new ee(yt);
        d.call(this, yt),
        f.call(this, yt),
        this.allowHalfOpen = !0,
        yt && (yt.readable === !1 && (this.readable = !1),
        yt.writable === !1 && (this.writable = !1),
        yt.allowHalfOpen === !1 && (this.allowHalfOpen = !1,
        this.once("end", dt)))
    }
    Object.defineProperty(ee.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark
        }
    }),
    Object.defineProperty(ee.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer()
        }
    }),
    Object.defineProperty(ee.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length
        }
    });
    function dt() {
        this._writableState.ended || process$1.nextTick(mt, this)
    }
    function mt(yt) {
        yt.end()
    }
    return Object.defineProperty(ee.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed
        },
        set: function(pt) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = pt,
            this._writableState.destroyed = pt)
        }
    }),
    _stream_duplex$1
}
var string_decoder = {}, hasRequiredString_decoder;
function requireString_decoder() {
    if (hasRequiredString_decoder)
        return string_decoder;
    hasRequiredString_decoder = 1;
    var r = requireSafeBuffer$1().Buffer
      , d = r.isEncoding || function($t) {
        switch ($t = "" + $t,
        $t && $t.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
            return !0;
        default:
            return !1
        }
    }
    ;
    function f($t) {
        if (!$t)
            return "utf8";
        for (var Ot; ; )
            switch ($t) {
            case "utf8":
            case "utf-8":
                return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return "utf16le";
            case "latin1":
            case "binary":
                return "latin1";
            case "base64":
            case "ascii":
            case "hex":
                return $t;
            default:
                if (Ot)
                    return;
                $t = ("" + $t).toLowerCase(),
                Ot = !0
            }
    }
    function m($t) {
        var Ot = f($t);
        if (typeof Ot != "string" && (r.isEncoding === d || !d($t)))
            throw new Error("Unknown encoding: " + $t);
        return Ot || $t
    }
    string_decoder.StringDecoder = k;
    function k($t) {
        this.encoding = m($t);
        var Ot;
        switch (this.encoding) {
        case "utf16le":
            this.text = bt,
            this.end = wt,
            Ot = 4;
            break;
        case "utf8":
            this.fillLast = mt,
            Ot = 4;
            break;
        case "base64":
            this.text = xt,
            this.end = At,
            Ot = 3;
            break;
        default:
            this.write = Ct,
            this.end = Pt;
            return
        }
        this.lastNeed = 0,
        this.lastTotal = 0,
        this.lastChar = r.allocUnsafe(Ot)
    }
    k.prototype.write = function($t) {
        if ($t.length === 0)
            return "";
        var Ot, Nt;
        if (this.lastNeed) {
            if (Ot = this.fillLast($t),
            Ot === void 0)
                return "";
            Nt = this.lastNeed,
            this.lastNeed = 0
        } else
            Nt = 0;
        return Nt < $t.length ? Ot ? Ot + this.text($t, Nt) : this.text($t, Nt) : Ot || ""
    }
    ,
    k.prototype.end = pt,
    k.prototype.text = yt,
    k.prototype.fillLast = function($t) {
        if (this.lastNeed <= $t.length)
            return $t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed),
            this.lastChar.toString(this.encoding, 0, this.lastTotal);
        $t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, $t.length),
        this.lastNeed -= $t.length
    }
    ;
    function y($t) {
        return $t <= 127 ? 0 : $t >> 5 === 6 ? 2 : $t >> 4 === 14 ? 3 : $t >> 3 === 30 ? 4 : $t >> 6 === 2 ? -1 : -2
    }
    function ee($t, Ot, Nt) {
        var zt = Ot.length - 1;
        if (zt < Nt)
            return 0;
        var Wt = y(Ot[zt]);
        return Wt >= 0 ? (Wt > 0 && ($t.lastNeed = Wt - 1),
        Wt) : --zt < Nt || Wt === -2 ? 0 : (Wt = y(Ot[zt]),
        Wt >= 0 ? (Wt > 0 && ($t.lastNeed = Wt - 2),
        Wt) : --zt < Nt || Wt === -2 ? 0 : (Wt = y(Ot[zt]),
        Wt >= 0 ? (Wt > 0 && (Wt === 2 ? Wt = 0 : $t.lastNeed = Wt - 3),
        Wt) : 0))
    }
    function dt($t, Ot, Nt) {
        if ((Ot[0] & 192) !== 128)
            return $t.lastNeed = 0,
            "�";
        if ($t.lastNeed > 1 && Ot.length > 1) {
            if ((Ot[1] & 192) !== 128)
                return $t.lastNeed = 1,
                "�";
            if ($t.lastNeed > 2 && Ot.length > 2 && (Ot[2] & 192) !== 128)
                return $t.lastNeed = 2,
                "�"
        }
    }
    function mt($t) {
        var Ot = this.lastTotal - this.lastNeed
          , Nt = dt(this, $t);
        if (Nt !== void 0)
            return Nt;
        if (this.lastNeed <= $t.length)
            return $t.copy(this.lastChar, Ot, 0, this.lastNeed),
            this.lastChar.toString(this.encoding, 0, this.lastTotal);
        $t.copy(this.lastChar, Ot, 0, $t.length),
        this.lastNeed -= $t.length
    }
    function yt($t, Ot) {
        var Nt = ee(this, $t, Ot);
        if (!this.lastNeed)
            return $t.toString("utf8", Ot);
        this.lastTotal = Nt;
        var zt = $t.length - (Nt - this.lastNeed);
        return $t.copy(this.lastChar, 0, zt),
        $t.toString("utf8", Ot, zt)
    }
    function pt($t) {
        var Ot = $t && $t.length ? this.write($t) : "";
        return this.lastNeed ? Ot + "�" : Ot
    }
    function bt($t, Ot) {
        if (($t.length - Ot) % 2 === 0) {
            var Nt = $t.toString("utf16le", Ot);
            if (Nt) {
                var zt = Nt.charCodeAt(Nt.length - 1);
                if (zt >= 55296 && zt <= 56319)
                    return this.lastNeed = 2,
                    this.lastTotal = 4,
                    this.lastChar[0] = $t[$t.length - 2],
                    this.lastChar[1] = $t[$t.length - 1],
                    Nt.slice(0, -1)
            }
            return Nt
        }
        return this.lastNeed = 1,
        this.lastTotal = 2,
        this.lastChar[0] = $t[$t.length - 1],
        $t.toString("utf16le", Ot, $t.length - 1)
    }
    function wt($t) {
        var Ot = $t && $t.length ? this.write($t) : "";
        if (this.lastNeed) {
            var Nt = this.lastTotal - this.lastNeed;
            return Ot + this.lastChar.toString("utf16le", 0, Nt)
        }
        return Ot
    }
    function xt($t, Ot) {
        var Nt = ($t.length - Ot) % 3;
        return Nt === 0 ? $t.toString("base64", Ot) : (this.lastNeed = 3 - Nt,
        this.lastTotal = 3,
        Nt === 1 ? this.lastChar[0] = $t[$t.length - 1] : (this.lastChar[0] = $t[$t.length - 2],
        this.lastChar[1] = $t[$t.length - 1]),
        $t.toString("base64", Ot, $t.length - Nt))
    }
    function At($t) {
        var Ot = $t && $t.length ? this.write($t) : "";
        return this.lastNeed ? Ot + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : Ot
    }
    function Ct($t) {
        return $t.toString(this.encoding)
    }
    function Pt($t) {
        return $t && $t.length ? this.write($t) : ""
    }
    return string_decoder
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
    if (hasRequiredEndOfStream)
        return endOfStream;
    hasRequiredEndOfStream = 1;
    var r = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function d(y) {
        var ee = !1;
        return function() {
            if (!ee) {
                ee = !0;
                for (var dt = arguments.length, mt = new Array(dt), yt = 0; yt < dt; yt++)
                    mt[yt] = arguments[yt];
                y.apply(this, mt)
            }
        }
    }
    function f() {}
    function m(y) {
        return y.setHeader && typeof y.abort == "function"
    }
    function k(y, ee, dt) {
        if (typeof ee == "function")
            return k(y, null, ee);
        ee || (ee = {}),
        dt = d(dt || f);
        var mt = ee.readable || ee.readable !== !1 && y.readable
          , yt = ee.writable || ee.writable !== !1 && y.writable
          , pt = function() {
            y.writable || wt()
        }
          , bt = y._writableState && y._writableState.finished
          , wt = function() {
            yt = !1,
            bt = !0,
            mt || dt.call(y)
        }
          , xt = y._readableState && y._readableState.endEmitted
          , At = function() {
            mt = !1,
            xt = !0,
            yt || dt.call(y)
        }
          , Ct = function(Nt) {
            dt.call(y, Nt)
        }
          , Pt = function() {
            var Nt;
            if (mt && !xt)
                return (!y._readableState || !y._readableState.ended) && (Nt = new r),
                dt.call(y, Nt);
            if (yt && !bt)
                return (!y._writableState || !y._writableState.ended) && (Nt = new r),
                dt.call(y, Nt)
        }
          , $t = function() {
            y.req.on("finish", wt)
        };
        return m(y) ? (y.on("complete", wt),
        y.on("abort", Pt),
        y.req ? $t() : y.on("request", $t)) : yt && !y._writableState && (y.on("end", pt),
        y.on("close", pt)),
        y.on("end", At),
        y.on("finish", wt),
        ee.error !== !1 && y.on("error", Ct),
        y.on("close", Pt),
        function() {
            y.removeListener("complete", wt),
            y.removeListener("abort", Pt),
            y.removeListener("request", $t),
            y.req && y.req.removeListener("finish", wt),
            y.removeListener("end", pt),
            y.removeListener("close", pt),
            y.removeListener("finish", wt),
            y.removeListener("end", At),
            y.removeListener("error", Ct),
            y.removeListener("close", Pt)
        }
    }
    return endOfStream = k,
    endOfStream
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
    if (hasRequiredAsync_iterator)
        return async_iterator;
    hasRequiredAsync_iterator = 1;
    var r;
    function d(Nt, zt, Wt) {
        return zt = f(zt),
        zt in Nt ? Object.defineProperty(Nt, zt, {
            value: Wt,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : Nt[zt] = Wt,
        Nt
    }
    function f(Nt) {
        var zt = m(Nt, "string");
        return typeof zt == "symbol" ? zt : String(zt)
    }
    function m(Nt, zt) {
        if (typeof Nt != "object" || Nt === null)
            return Nt;
        var Wt = Nt[Symbol.toPrimitive];
        if (Wt !== void 0) {
            var Kt = Wt.call(Nt, zt || "default");
            if (typeof Kt != "object")
                return Kt;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return (zt === "string" ? String : Number)(Nt)
    }
    var k = requireEndOfStream()
      , y = Symbol("lastResolve")
      , ee = Symbol("lastReject")
      , dt = Symbol("error")
      , mt = Symbol("ended")
      , yt = Symbol("lastPromise")
      , pt = Symbol("handlePromise")
      , bt = Symbol("stream");
    function wt(Nt, zt) {
        return {
            value: Nt,
            done: zt
        }
    }
    function xt(Nt) {
        var zt = Nt[y];
        if (zt !== null) {
            var Wt = Nt[bt].read();
            Wt !== null && (Nt[yt] = null,
            Nt[y] = null,
            Nt[ee] = null,
            zt(wt(Wt, !1)))
        }
    }
    function At(Nt) {
        process$1.nextTick(xt, Nt)
    }
    function Ct(Nt, zt) {
        return function(Wt, Kt) {
            Nt.then(function() {
                if (zt[mt]) {
                    Wt(wt(void 0, !0));
                    return
                }
                zt[pt](Wt, Kt)
            }, Kt)
        }
    }
    var Pt = Object.getPrototypeOf(function() {})
      , $t = Object.setPrototypeOf((r = {
        get stream() {
            return this[bt]
        },
        next: function() {
            var zt = this
              , Wt = this[dt];
            if (Wt !== null)
                return Promise.reject(Wt);
            if (this[mt])
                return Promise.resolve(wt(void 0, !0));
            if (this[bt].destroyed)
                return new Promise(function(tr, wr) {
                    process$1.nextTick(function() {
                        zt[dt] ? wr(zt[dt]) : tr(wt(void 0, !0))
                    })
                }
                );
            var Kt = this[yt], ir;
            if (Kt)
                ir = new Promise(Ct(Kt, this));
            else {
                var or = this[bt].read();
                if (or !== null)
                    return Promise.resolve(wt(or, !1));
                ir = new Promise(this[pt])
            }
            return this[yt] = ir,
            ir
        }
    },
    d(r, Symbol.asyncIterator, function() {
        return this
    }),
    d(r, "return", function() {
        var zt = this;
        return new Promise(function(Wt, Kt) {
            zt[bt].destroy(null, function(ir) {
                if (ir) {
                    Kt(ir);
                    return
                }
                Wt(wt(void 0, !0))
            })
        }
        )
    }),
    r), Pt)
      , Ot = function(zt) {
        var Wt, Kt = Object.create($t, (Wt = {},
        d(Wt, bt, {
            value: zt,
            writable: !0
        }),
        d(Wt, y, {
            value: null,
            writable: !0
        }),
        d(Wt, ee, {
            value: null,
            writable: !0
        }),
        d(Wt, dt, {
            value: null,
            writable: !0
        }),
        d(Wt, mt, {
            value: zt._readableState.endEmitted,
            writable: !0
        }),
        d(Wt, pt, {
            value: function(or, tr) {
                var wr = Kt[bt].read();
                wr ? (Kt[yt] = null,
                Kt[y] = null,
                Kt[ee] = null,
                or(wt(wr, !1))) : (Kt[y] = or,
                Kt[ee] = tr)
            },
            writable: !0
        }),
        Wt));
        return Kt[yt] = null,
        k(zt, function(ir) {
            if (ir && ir.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var or = Kt[ee];
                or !== null && (Kt[yt] = null,
                Kt[y] = null,
                Kt[ee] = null,
                or(ir)),
                Kt[dt] = ir;
                return
            }
            var tr = Kt[y];
            tr !== null && (Kt[yt] = null,
            Kt[y] = null,
            Kt[ee] = null,
            tr(wt(void 0, !0))),
            Kt[mt] = !0
        }),
        zt.on("readable", At.bind(null, Kt)),
        Kt
    };
    return async_iterator = Ot,
    async_iterator
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
    return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1,
    fromBrowser = function() {
        throw new Error("Readable.from is not available in the browser")
    }
    ),
    fromBrowser
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
    if (hasRequired_stream_readable$1)
        return _stream_readable$1;
    hasRequired_stream_readable$1 = 1,
    _stream_readable$1 = tr;
    var r;
    tr.ReadableState = or,
    requireEvents().EventEmitter;
    var d = function(Xt, Sr) {
        return Xt.listeners(Sr).length
    }
      , f = requireStreamBrowser$1()
      , m = require$$1$2.Buffer
      , k = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {}
    ;
    function y(Yt) {
        return m.from(Yt)
    }
    function ee(Yt) {
        return m.isBuffer(Yt) || Yt instanceof k
    }
    var dt = requireUtil$1(), mt;
    dt && dt.debuglog ? mt = dt.debuglog("stream") : mt = function() {}
    ;
    var yt = requireBuffer_list(), pt = requireDestroy$1(), bt = requireState(), wt = bt.getHighWaterMark, xt = requireErrorsBrowser().codes, At = xt.ERR_INVALID_ARG_TYPE, Ct = xt.ERR_STREAM_PUSH_AFTER_EOF, Pt = xt.ERR_METHOD_NOT_IMPLEMENTED, $t = xt.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Ot, Nt, zt;
    requireInherits_browser()(tr, f);
    var Wt = pt.errorOrDestroy
      , Kt = ["error", "close", "destroy", "pause", "resume"];
    function ir(Yt, Xt, Sr) {
        if (typeof Yt.prependListener == "function")
            return Yt.prependListener(Xt, Sr);
        !Yt._events || !Yt._events[Xt] ? Yt.on(Xt, Sr) : Array.isArray(Yt._events[Xt]) ? Yt._events[Xt].unshift(Sr) : Yt._events[Xt] = [Sr, Yt._events[Xt]]
    }
    function or(Yt, Xt, Sr) {
        r = r || require_stream_duplex$1(),
        Yt = Yt || {},
        typeof Sr != "boolean" && (Sr = Xt instanceof r),
        this.objectMode = !!Yt.objectMode,
        Sr && (this.objectMode = this.objectMode || !!Yt.readableObjectMode),
        this.highWaterMark = wt(this, Yt, "readableHighWaterMark", Sr),
        this.buffer = new yt,
        this.length = 0,
        this.pipes = null,
        this.pipesCount = 0,
        this.flowing = null,
        this.ended = !1,
        this.endEmitted = !1,
        this.reading = !1,
        this.sync = !0,
        this.needReadable = !1,
        this.emittedReadable = !1,
        this.readableListening = !1,
        this.resumeScheduled = !1,
        this.paused = !0,
        this.emitClose = Yt.emitClose !== !1,
        this.autoDestroy = !!Yt.autoDestroy,
        this.destroyed = !1,
        this.defaultEncoding = Yt.defaultEncoding || "utf8",
        this.awaitDrain = 0,
        this.readingMore = !1,
        this.decoder = null,
        this.encoding = null,
        Yt.encoding && (Ot || (Ot = requireString_decoder().StringDecoder),
        this.decoder = new Ot(Yt.encoding),
        this.encoding = Yt.encoding)
    }
    function tr(Yt) {
        if (r = r || require_stream_duplex$1(),
        !(this instanceof tr))
            return new tr(Yt);
        var Xt = this instanceof r;
        this._readableState = new or(Yt,this,Xt),
        this.readable = !0,
        Yt && (typeof Yt.read == "function" && (this._read = Yt.read),
        typeof Yt.destroy == "function" && (this._destroy = Yt.destroy)),
        f.call(this)
    }
    Object.defineProperty(tr.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._readableState === void 0 ? !1 : this._readableState.destroyed
        },
        set: function(Xt) {
            this._readableState && (this._readableState.destroyed = Xt)
        }
    }),
    tr.prototype.destroy = pt.destroy,
    tr.prototype._undestroy = pt.undestroy,
    tr.prototype._destroy = function(Yt, Xt) {
        Xt(Yt)
    }
    ,
    tr.prototype.push = function(Yt, Xt) {
        var Sr = this._readableState, Rr;
        return Sr.objectMode ? Rr = !0 : typeof Yt == "string" && (Xt = Xt || Sr.defaultEncoding,
        Xt !== Sr.encoding && (Yt = m.from(Yt, Xt),
        Xt = ""),
        Rr = !0),
        wr(this, Yt, Xt, !1, Rr)
    }
    ,
    tr.prototype.unshift = function(Yt) {
        return wr(this, Yt, null, !0, !1)
    }
    ;
    function wr(Yt, Xt, Sr, Rr, qr) {
        mt("readableAddChunk", Xt);
        var Nr = Yt._readableState;
        if (Xt === null)
            Nr.reading = !1,
            Et(Yt, Nr);
        else {
            var Dr;
            if (qr || (Dr = Mt(Nr, Xt)),
            Dr)
                Wt(Yt, Dr);
            else if (Nr.objectMode || Xt && Xt.length > 0)
                if (typeof Xt != "string" && !Nr.objectMode && Object.getPrototypeOf(Xt) !== m.prototype && (Xt = y(Xt)),
                Rr)
                    Nr.endEmitted ? Wt(Yt, new $t) : Ht(Yt, Nr, Xt, !0);
                else if (Nr.ended)
                    Wt(Yt, new Ct);
                else {
                    if (Nr.destroyed)
                        return !1;
                    Nr.reading = !1,
                    Nr.decoder && !Sr ? (Xt = Nr.decoder.write(Xt),
                    Nr.objectMode || Xt.length !== 0 ? Ht(Yt, Nr, Xt, !1) : kt(Yt, Nr)) : Ht(Yt, Nr, Xt, !1)
                }
            else
                Rr || (Nr.reading = !1,
                kt(Yt, Nr))
        }
        return !Nr.ended && (Nr.length < Nr.highWaterMark || Nr.length === 0)
    }
    function Ht(Yt, Xt, Sr, Rr) {
        Xt.flowing && Xt.length === 0 && !Xt.sync ? (Xt.awaitDrain = 0,
        Yt.emit("data", Sr)) : (Xt.length += Xt.objectMode ? 1 : Sr.length,
        Rr ? Xt.buffer.unshift(Sr) : Xt.buffer.push(Sr),
        Xt.needReadable && Bt(Yt)),
        kt(Yt, Xt)
    }
    function Mt(Yt, Xt) {
        var Sr;
        return !ee(Xt) && typeof Xt != "string" && Xt !== void 0 && !Yt.objectMode && (Sr = new At("chunk",["string", "Buffer", "Uint8Array"],Xt)),
        Sr
    }
    tr.prototype.isPaused = function() {
        return this._readableState.flowing === !1
    }
    ,
    tr.prototype.setEncoding = function(Yt) {
        Ot || (Ot = requireString_decoder().StringDecoder);
        var Xt = new Ot(Yt);
        this._readableState.decoder = Xt,
        this._readableState.encoding = this._readableState.decoder.encoding;
        for (var Sr = this._readableState.buffer.head, Rr = ""; Sr !== null; )
            Rr += Xt.write(Sr.data),
            Sr = Sr.next;
        return this._readableState.buffer.clear(),
        Rr !== "" && this._readableState.buffer.push(Rr),
        this._readableState.length = Rr.length,
        this
    }
    ;
    var _t = 1073741824;
    function gt(Yt) {
        return Yt >= _t ? Yt = _t : (Yt--,
        Yt |= Yt >>> 1,
        Yt |= Yt >>> 2,
        Yt |= Yt >>> 4,
        Yt |= Yt >>> 8,
        Yt |= Yt >>> 16,
        Yt++),
        Yt
    }
    function vt(Yt, Xt) {
        return Yt <= 0 || Xt.length === 0 && Xt.ended ? 0 : Xt.objectMode ? 1 : Yt !== Yt ? Xt.flowing && Xt.length ? Xt.buffer.head.data.length : Xt.length : (Yt > Xt.highWaterMark && (Xt.highWaterMark = gt(Yt)),
        Yt <= Xt.length ? Yt : Xt.ended ? Xt.length : (Xt.needReadable = !0,
        0))
    }
    tr.prototype.read = function(Yt) {
        mt("read", Yt),
        Yt = parseInt(Yt, 10);
        var Xt = this._readableState
          , Sr = Yt;
        if (Yt !== 0 && (Xt.emittedReadable = !1),
        Yt === 0 && Xt.needReadable && ((Xt.highWaterMark !== 0 ? Xt.length >= Xt.highWaterMark : Xt.length > 0) || Xt.ended))
            return mt("read: emitReadable", Xt.length, Xt.ended),
            Xt.length === 0 && Xt.ended ? Vt(this) : Bt(this),
            null;
        if (Yt = vt(Yt, Xt),
        Yt === 0 && Xt.ended)
            return Xt.length === 0 && Vt(this),
            null;
        var Rr = Xt.needReadable;
        mt("need readable", Rr),
        (Xt.length === 0 || Xt.length - Yt < Xt.highWaterMark) && (Rr = !0,
        mt("length less than watermark", Rr)),
        Xt.ended || Xt.reading ? (Rr = !1,
        mt("reading or ended", Rr)) : Rr && (mt("do read"),
        Xt.reading = !0,
        Xt.sync = !0,
        Xt.length === 0 && (Xt.needReadable = !0),
        this._read(Xt.highWaterMark),
        Xt.sync = !1,
        Xt.reading || (Yt = vt(Sr, Xt)));
        var qr;
        return Yt > 0 ? qr = Zt(Yt, Xt) : qr = null,
        qr === null ? (Xt.needReadable = Xt.length <= Xt.highWaterMark,
        Yt = 0) : (Xt.length -= Yt,
        Xt.awaitDrain = 0),
        Xt.length === 0 && (Xt.ended || (Xt.needReadable = !0),
        Sr !== Yt && Xt.ended && Vt(this)),
        qr !== null && this.emit("data", qr),
        qr
    }
    ;
    function Et(Yt, Xt) {
        if (mt("onEofChunk"),
        !Xt.ended) {
            if (Xt.decoder) {
                var Sr = Xt.decoder.end();
                Sr && Sr.length && (Xt.buffer.push(Sr),
                Xt.length += Xt.objectMode ? 1 : Sr.length)
            }
            Xt.ended = !0,
            Xt.sync ? Bt(Yt) : (Xt.needReadable = !1,
            Xt.emittedReadable || (Xt.emittedReadable = !0,
            Rt(Yt)))
        }
    }
    function Bt(Yt) {
        var Xt = Yt._readableState;
        mt("emitReadable", Xt.needReadable, Xt.emittedReadable),
        Xt.needReadable = !1,
        Xt.emittedReadable || (mt("emitReadable", Xt.flowing),
        Xt.emittedReadable = !0,
        process$1.nextTick(Rt, Yt))
    }
    function Rt(Yt) {
        var Xt = Yt._readableState;
        mt("emitReadable_", Xt.destroyed, Xt.length, Xt.ended),
        !Xt.destroyed && (Xt.length || Xt.ended) && (Yt.emit("readable"),
        Xt.emittedReadable = !1),
        Xt.needReadable = !Xt.flowing && !Xt.ended && Xt.length <= Xt.highWaterMark,
        lr(Yt)
    }
    function kt(Yt, Xt) {
        Xt.readingMore || (Xt.readingMore = !0,
        process$1.nextTick(Tt, Yt, Xt))
    }
    function Tt(Yt, Xt) {
        for (; !Xt.reading && !Xt.ended && (Xt.length < Xt.highWaterMark || Xt.flowing && Xt.length === 0); ) {
            var Sr = Xt.length;
            if (mt("maybeReadMore read 0"),
            Yt.read(0),
            Sr === Xt.length)
                break
        }
        Xt.readingMore = !1
    }
    tr.prototype._read = function(Yt) {
        Wt(this, new Pt("_read()"))
    }
    ,
    tr.prototype.pipe = function(Yt, Xt) {
        var Sr = this
          , Rr = this._readableState;
        switch (Rr.pipesCount) {
        case 0:
            Rr.pipes = Yt;
            break;
        case 1:
            Rr.pipes = [Rr.pipes, Yt];
            break;
        default:
            Rr.pipes.push(Yt);
            break
        }
        Rr.pipesCount += 1,
        mt("pipe count=%d opts=%j", Rr.pipesCount, Xt);
        var qr = (!Xt || Xt.end !== !1) && Yt !== process$1.stdout && Yt !== process$1.stderr
          , Nr = qr ? Or : ar;
        Rr.endEmitted ? process$1.nextTick(Nr) : Sr.once("end", Nr),
        Yt.on("unpipe", Dr);
        function Dr(hr, _r) {
            mt("onunpipe"),
            hr === Sr && _r && _r.hasUnpiped === !1 && (_r.hasUnpiped = !0,
            Hr())
        }
        function Or() {
            mt("onend"),
            Yt.end()
        }
        var $r = It(Sr);
        Yt.on("drain", $r);
        var Zr = !1;
        function Hr() {
            mt("cleanup"),
            Yt.removeListener("close", Gr),
            Yt.removeListener("finish", vr),
            Yt.removeListener("drain", $r),
            Yt.removeListener("error", Qr),
            Yt.removeListener("unpipe", Dr),
            Sr.removeListener("end", Or),
            Sr.removeListener("end", ar),
            Sr.removeListener("data", un),
            Zr = !0,
            Rr.awaitDrain && (!Yt._writableState || Yt._writableState.needDrain) && $r()
        }
        Sr.on("data", un);
        function un(hr) {
            mt("ondata");
            var _r = Yt.write(hr);
            mt("dest.write", _r),
            _r === !1 && ((Rr.pipesCount === 1 && Rr.pipes === Yt || Rr.pipesCount > 1 && fr(Rr.pipes, Yt) !== -1) && !Zr && (mt("false write response, pause", Rr.awaitDrain),
            Rr.awaitDrain++),
            Sr.pause())
        }
        function Qr(hr) {
            mt("onerror", hr),
            ar(),
            Yt.removeListener("error", Qr),
            d(Yt, "error") === 0 && Wt(Yt, hr)
        }
        ir(Yt, "error", Qr);
        function Gr() {
            Yt.removeListener("finish", vr),
            ar()
        }
        Yt.once("close", Gr);
        function vr() {
            mt("onfinish"),
            Yt.removeListener("close", Gr),
            ar()
        }
        Yt.once("finish", vr);
        function ar() {
            mt("unpipe"),
            Sr.unpipe(Yt)
        }
        return Yt.emit("pipe", Sr),
        Rr.flowing || (mt("pipe resume"),
        Sr.resume()),
        Yt
    }
    ;
    function It(Yt) {
        return function() {
            var Sr = Yt._readableState;
            mt("pipeOnDrain", Sr.awaitDrain),
            Sr.awaitDrain && Sr.awaitDrain--,
            Sr.awaitDrain === 0 && d(Yt, "data") && (Sr.flowing = !0,
            lr(Yt))
        }
    }
    tr.prototype.unpipe = function(Yt) {
        var Xt = this._readableState
          , Sr = {
            hasUnpiped: !1
        };
        if (Xt.pipesCount === 0)
            return this;
        if (Xt.pipesCount === 1)
            return Yt && Yt !== Xt.pipes ? this : (Yt || (Yt = Xt.pipes),
            Xt.pipes = null,
            Xt.pipesCount = 0,
            Xt.flowing = !1,
            Yt && Yt.emit("unpipe", this, Sr),
            this);
        if (!Yt) {
            var Rr = Xt.pipes
              , qr = Xt.pipesCount;
            Xt.pipes = null,
            Xt.pipesCount = 0,
            Xt.flowing = !1;
            for (var Nr = 0; Nr < qr; Nr++)
                Rr[Nr].emit("unpipe", this, {
                    hasUnpiped: !1
                });
            return this
        }
        var Dr = fr(Xt.pipes, Yt);
        return Dr === -1 ? this : (Xt.pipes.splice(Dr, 1),
        Xt.pipesCount -= 1,
        Xt.pipesCount === 1 && (Xt.pipes = Xt.pipes[0]),
        Yt.emit("unpipe", this, Sr),
        this)
    }
    ,
    tr.prototype.on = function(Yt, Xt) {
        var Sr = f.prototype.on.call(this, Yt, Xt)
          , Rr = this._readableState;
        return Yt === "data" ? (Rr.readableListening = this.listenerCount("readable") > 0,
        Rr.flowing !== !1 && this.resume()) : Yt === "readable" && !Rr.endEmitted && !Rr.readableListening && (Rr.readableListening = Rr.needReadable = !0,
        Rr.flowing = !1,
        Rr.emittedReadable = !1,
        mt("on readable", Rr.length, Rr.reading),
        Rr.length ? Bt(this) : Rr.reading || process$1.nextTick(qt, this)),
        Sr
    }
    ,
    tr.prototype.addListener = tr.prototype.on,
    tr.prototype.removeListener = function(Yt, Xt) {
        var Sr = f.prototype.removeListener.call(this, Yt, Xt);
        return Yt === "readable" && process$1.nextTick(St, this),
        Sr
    }
    ,
    tr.prototype.removeAllListeners = function(Yt) {
        var Xt = f.prototype.removeAllListeners.apply(this, arguments);
        return (Yt === "readable" || Yt === void 0) && process$1.nextTick(St, this),
        Xt
    }
    ;
    function St(Yt) {
        var Xt = Yt._readableState;
        Xt.readableListening = Yt.listenerCount("readable") > 0,
        Xt.resumeScheduled && !Xt.paused ? Xt.flowing = !0 : Yt.listenerCount("data") > 0 && Yt.resume()
    }
    function qt(Yt) {
        mt("readable nexttick read 0"),
        Yt.read(0)
    }
    tr.prototype.resume = function() {
        var Yt = this._readableState;
        return Yt.flowing || (mt("resume"),
        Yt.flowing = !Yt.readableListening,
        ur(this, Yt)),
        Yt.paused = !1,
        this
    }
    ;
    function ur(Yt, Xt) {
        Xt.resumeScheduled || (Xt.resumeScheduled = !0,
        process$1.nextTick(gr, Yt, Xt))
    }
    function gr(Yt, Xt) {
        mt("resume", Xt.reading),
        Xt.reading || Yt.read(0),
        Xt.resumeScheduled = !1,
        Yt.emit("resume"),
        lr(Yt),
        Xt.flowing && !Xt.reading && Yt.read(0)
    }
    tr.prototype.pause = function() {
        return mt("call pause flowing=%j", this._readableState.flowing),
        this._readableState.flowing !== !1 && (mt("pause"),
        this._readableState.flowing = !1,
        this.emit("pause")),
        this._readableState.paused = !0,
        this
    }
    ;
    function lr(Yt) {
        var Xt = Yt._readableState;
        for (mt("flow", Xt.flowing); Xt.flowing && Yt.read() !== null; )
            ;
    }
    tr.prototype.wrap = function(Yt) {
        var Xt = this
          , Sr = this._readableState
          , Rr = !1;
        Yt.on("end", function() {
            if (mt("wrapped end"),
            Sr.decoder && !Sr.ended) {
                var Dr = Sr.decoder.end();
                Dr && Dr.length && Xt.push(Dr)
            }
            Xt.push(null)
        }),
        Yt.on("data", function(Dr) {
            if (mt("wrapped data"),
            Sr.decoder && (Dr = Sr.decoder.write(Dr)),
            !(Sr.objectMode && Dr == null) && !(!Sr.objectMode && (!Dr || !Dr.length))) {
                var Or = Xt.push(Dr);
                Or || (Rr = !0,
                Yt.pause())
            }
        });
        for (var qr in Yt)
            this[qr] === void 0 && typeof Yt[qr] == "function" && (this[qr] = function(Or) {
                return function() {
                    return Yt[Or].apply(Yt, arguments)
                }
            }(qr));
        for (var Nr = 0; Nr < Kt.length; Nr++)
            Yt.on(Kt[Nr], this.emit.bind(this, Kt[Nr]));
        return this._read = function(Dr) {
            mt("wrapped _read", Dr),
            Rr && (Rr = !1,
            Yt.resume())
        }
        ,
        this
    }
    ,
    typeof Symbol == "function" && (tr.prototype[Symbol.asyncIterator] = function() {
        return Nt === void 0 && (Nt = requireAsync_iterator()),
        Nt(this)
    }
    ),
    Object.defineProperty(tr.prototype, "readableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._readableState.highWaterMark
        }
    }),
    Object.defineProperty(tr.prototype, "readableBuffer", {
        enumerable: !1,
        get: function() {
            return this._readableState && this._readableState.buffer
        }
    }),
    Object.defineProperty(tr.prototype, "readableFlowing", {
        enumerable: !1,
        get: function() {
            return this._readableState.flowing
        },
        set: function(Xt) {
            this._readableState && (this._readableState.flowing = Xt)
        }
    }),
    tr._fromList = Zt,
    Object.defineProperty(tr.prototype, "readableLength", {
        enumerable: !1,
        get: function() {
            return this._readableState.length
        }
    });
    function Zt(Yt, Xt) {
        if (Xt.length === 0)
            return null;
        var Sr;
        return Xt.objectMode ? Sr = Xt.buffer.shift() : !Yt || Yt >= Xt.length ? (Xt.decoder ? Sr = Xt.buffer.join("") : Xt.buffer.length === 1 ? Sr = Xt.buffer.first() : Sr = Xt.buffer.concat(Xt.length),
        Xt.buffer.clear()) : Sr = Xt.buffer.consume(Yt, Xt.decoder),
        Sr
    }
    function Vt(Yt) {
        var Xt = Yt._readableState;
        mt("endReadable", Xt.endEmitted),
        Xt.endEmitted || (Xt.ended = !0,
        process$1.nextTick(rr, Xt, Yt))
    }
    function rr(Yt, Xt) {
        if (mt("endReadableNT", Yt.endEmitted, Yt.length),
        !Yt.endEmitted && Yt.length === 0 && (Yt.endEmitted = !0,
        Xt.readable = !1,
        Xt.emit("end"),
        Yt.autoDestroy)) {
            var Sr = Xt._writableState;
            (!Sr || Sr.autoDestroy && Sr.finished) && Xt.destroy()
        }
    }
    typeof Symbol == "function" && (tr.from = function(Yt, Xt) {
        return zt === void 0 && (zt = requireFromBrowser()),
        zt(tr, Yt, Xt)
    }
    );
    function fr(Yt, Xt) {
        for (var Sr = 0, Rr = Yt.length; Sr < Rr; Sr++)
            if (Yt[Sr] === Xt)
                return Sr;
        return -1
    }
    return _stream_readable$1
}
var _stream_transform$1, hasRequired_stream_transform$1;
function require_stream_transform$1() {
    if (hasRequired_stream_transform$1)
        return _stream_transform$1;
    hasRequired_stream_transform$1 = 1,
    _stream_transform$1 = dt;
    var r = requireErrorsBrowser().codes
      , d = r.ERR_METHOD_NOT_IMPLEMENTED
      , f = r.ERR_MULTIPLE_CALLBACK
      , m = r.ERR_TRANSFORM_ALREADY_TRANSFORMING
      , k = r.ERR_TRANSFORM_WITH_LENGTH_0
      , y = require_stream_duplex$1();
    requireInherits_browser()(dt, y);
    function ee(pt, bt) {
        var wt = this._transformState;
        wt.transforming = !1;
        var xt = wt.writecb;
        if (xt === null)
            return this.emit("error", new f);
        wt.writechunk = null,
        wt.writecb = null,
        bt != null && this.push(bt),
        xt(pt);
        var At = this._readableState;
        At.reading = !1,
        (At.needReadable || At.length < At.highWaterMark) && this._read(At.highWaterMark)
    }
    function dt(pt) {
        if (!(this instanceof dt))
            return new dt(pt);
        y.call(this, pt),
        this._transformState = {
            afterTransform: ee.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
        },
        this._readableState.needReadable = !0,
        this._readableState.sync = !1,
        pt && (typeof pt.transform == "function" && (this._transform = pt.transform),
        typeof pt.flush == "function" && (this._flush = pt.flush)),
        this.on("prefinish", mt)
    }
    function mt() {
        var pt = this;
        typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(bt, wt) {
            yt(pt, bt, wt)
        }) : yt(this, null, null)
    }
    dt.prototype.push = function(pt, bt) {
        return this._transformState.needTransform = !1,
        y.prototype.push.call(this, pt, bt)
    }
    ,
    dt.prototype._transform = function(pt, bt, wt) {
        wt(new d("_transform()"))
    }
    ,
    dt.prototype._write = function(pt, bt, wt) {
        var xt = this._transformState;
        if (xt.writecb = wt,
        xt.writechunk = pt,
        xt.writeencoding = bt,
        !xt.transforming) {
            var At = this._readableState;
            (xt.needTransform || At.needReadable || At.length < At.highWaterMark) && this._read(At.highWaterMark)
        }
    }
    ,
    dt.prototype._read = function(pt) {
        var bt = this._transformState;
        bt.writechunk !== null && !bt.transforming ? (bt.transforming = !0,
        this._transform(bt.writechunk, bt.writeencoding, bt.afterTransform)) : bt.needTransform = !0
    }
    ,
    dt.prototype._destroy = function(pt, bt) {
        y.prototype._destroy.call(this, pt, function(wt) {
            bt(wt)
        })
    }
    ;
    function yt(pt, bt, wt) {
        if (bt)
            return pt.emit("error", bt);
        if (wt != null && pt.push(wt),
        pt._writableState.length)
            throw new k;
        if (pt._transformState.transforming)
            throw new m;
        return pt.push(null)
    }
    return _stream_transform$1
}
var _stream_passthrough$1, hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
    if (hasRequired_stream_passthrough$1)
        return _stream_passthrough$1;
    hasRequired_stream_passthrough$1 = 1,
    _stream_passthrough$1 = d;
    var r = require_stream_transform$1();
    requireInherits_browser()(d, r);
    function d(f) {
        if (!(this instanceof d))
            return new d(f);
        r.call(this, f)
    }
    return d.prototype._transform = function(f, m, k) {
        k(null, f)
    }
    ,
    _stream_passthrough$1
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
    if (hasRequiredPipeline)
        return pipeline_1;
    hasRequiredPipeline = 1;
    var r;
    function d(wt) {
        var xt = !1;
        return function() {
            xt || (xt = !0,
            wt.apply(void 0, arguments))
        }
    }
    var f = requireErrorsBrowser().codes
      , m = f.ERR_MISSING_ARGS
      , k = f.ERR_STREAM_DESTROYED;
    function y(wt) {
        if (wt)
            throw wt
    }
    function ee(wt) {
        return wt.setHeader && typeof wt.abort == "function"
    }
    function dt(wt, xt, At, Ct) {
        Ct = d(Ct);
        var Pt = !1;
        wt.on("close", function() {
            Pt = !0
        }),
        r === void 0 && (r = requireEndOfStream()),
        r(wt, {
            readable: xt,
            writable: At
        }, function(Ot) {
            if (Ot)
                return Ct(Ot);
            Pt = !0,
            Ct()
        });
        var $t = !1;
        return function(Ot) {
            if (!Pt && !$t) {
                if ($t = !0,
                ee(wt))
                    return wt.abort();
                if (typeof wt.destroy == "function")
                    return wt.destroy();
                Ct(Ot || new k("pipe"))
            }
        }
    }
    function mt(wt) {
        wt()
    }
    function yt(wt, xt) {
        return wt.pipe(xt)
    }
    function pt(wt) {
        return !wt.length || typeof wt[wt.length - 1] != "function" ? y : wt.pop()
    }
    function bt() {
        for (var wt = arguments.length, xt = new Array(wt), At = 0; At < wt; At++)
            xt[At] = arguments[At];
        var Ct = pt(xt);
        if (Array.isArray(xt[0]) && (xt = xt[0]),
        xt.length < 2)
            throw new m("streams");
        var Pt, $t = xt.map(function(Ot, Nt) {
            var zt = Nt < xt.length - 1
              , Wt = Nt > 0;
            return dt(Ot, zt, Wt, function(Kt) {
                Pt || (Pt = Kt),
                Kt && $t.forEach(mt),
                !zt && ($t.forEach(mt),
                Ct(Pt))
            })
        });
        return xt.reduce(yt)
    }
    return pipeline_1 = bt,
    pipeline_1
}
var hasRequiredReadableBrowser$1;
function requireReadableBrowser$1() {
    return hasRequiredReadableBrowser$1 || (hasRequiredReadableBrowser$1 = 1,
    function(r, d) {
        d = r.exports = require_stream_readable$1(),
        d.Stream = d,
        d.Readable = d,
        d.Writable = require_stream_writable$1(),
        d.Duplex = require_stream_duplex$1(),
        d.Transform = require_stream_transform$1(),
        d.PassThrough = require_stream_passthrough$1(),
        d.finished = requireEndOfStream(),
        d.pipeline = requirePipeline()
    }(readableBrowser$1, readableBrowser$1.exports)),
    readableBrowser$1.exports
}
var hashBase$1, hasRequiredHashBase$1;
function requireHashBase$1() {
    if (hasRequiredHashBase$1)
        return hashBase$1;
    hasRequiredHashBase$1 = 1;
    var r = requireSafeBuffer$1().Buffer
      , d = requireReadableBrowser$1().Transform
      , f = requireInherits_browser();
    function m(y, ee) {
        if (!r.isBuffer(y) && typeof y != "string")
            throw new TypeError(ee + " must be a string or a buffer")
    }
    function k(y) {
        d.call(this),
        this._block = r.allocUnsafe(y),
        this._blockSize = y,
        this._blockOffset = 0,
        this._length = [0, 0, 0, 0],
        this._finalized = !1
    }
    return f(k, d),
    k.prototype._transform = function(y, ee, dt) {
        var mt = null;
        try {
            this.update(y, ee)
        } catch (yt) {
            mt = yt
        }
        dt(mt)
    }
    ,
    k.prototype._flush = function(y) {
        var ee = null;
        try {
            this.push(this.digest())
        } catch (dt) {
            ee = dt
        }
        y(ee)
    }
    ,
    k.prototype.update = function(y, ee) {
        if (m(y, "Data"),
        this._finalized)
            throw new Error("Digest already called");
        r.isBuffer(y) || (y = r.from(y, ee));
        for (var dt = this._block, mt = 0; this._blockOffset + y.length - mt >= this._blockSize; ) {
            for (var yt = this._blockOffset; yt < this._blockSize; )
                dt[yt++] = y[mt++];
            this._update(),
            this._blockOffset = 0
        }
        for (; mt < y.length; )
            dt[this._blockOffset++] = y[mt++];
        for (var pt = 0, bt = y.length * 8; bt > 0; ++pt)
            this._length[pt] += bt,
            bt = this._length[pt] / 4294967296 | 0,
            bt > 0 && (this._length[pt] -= 4294967296 * bt);
        return this
    }
    ,
    k.prototype._update = function() {
        throw new Error("_update is not implemented")
    }
    ,
    k.prototype.digest = function(y) {
        if (this._finalized)
            throw new Error("Digest already called");
        this._finalized = !0;
        var ee = this._digest();
        y !== void 0 && (ee = ee.toString(y)),
        this._block.fill(0),
        this._blockOffset = 0;
        for (var dt = 0; dt < 4; ++dt)
            this._length[dt] = 0;
        return ee
    }
    ,
    k.prototype._digest = function() {
        throw new Error("_digest is not implemented")
    }
    ,
    hashBase$1 = k,
    hashBase$1
}
var md5_js, hasRequiredMd5_js;
function requireMd5_js() {
    if (hasRequiredMd5_js)
        return md5_js;
    hasRequiredMd5_js = 1;
    var r = requireInherits_browser()
      , d = requireHashBase$1()
      , f = requireSafeBuffer$1().Buffer
      , m = new Array(16);
    function k() {
        d.call(this, 64),
        this._a = 1732584193,
        this._b = 4023233417,
        this._c = 2562383102,
        this._d = 271733878
    }
    r(k, d),
    k.prototype._update = function() {
        for (var pt = m, bt = 0; bt < 16; ++bt)
            pt[bt] = this._block.readInt32LE(bt * 4);
        var wt = this._a
          , xt = this._b
          , At = this._c
          , Ct = this._d;
        wt = ee(wt, xt, At, Ct, pt[0], 3614090360, 7),
        Ct = ee(Ct, wt, xt, At, pt[1], 3905402710, 12),
        At = ee(At, Ct, wt, xt, pt[2], 606105819, 17),
        xt = ee(xt, At, Ct, wt, pt[3], 3250441966, 22),
        wt = ee(wt, xt, At, Ct, pt[4], 4118548399, 7),
        Ct = ee(Ct, wt, xt, At, pt[5], 1200080426, 12),
        At = ee(At, Ct, wt, xt, pt[6], 2821735955, 17),
        xt = ee(xt, At, Ct, wt, pt[7], 4249261313, 22),
        wt = ee(wt, xt, At, Ct, pt[8], 1770035416, 7),
        Ct = ee(Ct, wt, xt, At, pt[9], 2336552879, 12),
        At = ee(At, Ct, wt, xt, pt[10], 4294925233, 17),
        xt = ee(xt, At, Ct, wt, pt[11], 2304563134, 22),
        wt = ee(wt, xt, At, Ct, pt[12], 1804603682, 7),
        Ct = ee(Ct, wt, xt, At, pt[13], 4254626195, 12),
        At = ee(At, Ct, wt, xt, pt[14], 2792965006, 17),
        xt = ee(xt, At, Ct, wt, pt[15], 1236535329, 22),
        wt = dt(wt, xt, At, Ct, pt[1], 4129170786, 5),
        Ct = dt(Ct, wt, xt, At, pt[6], 3225465664, 9),
        At = dt(At, Ct, wt, xt, pt[11], 643717713, 14),
        xt = dt(xt, At, Ct, wt, pt[0], 3921069994, 20),
        wt = dt(wt, xt, At, Ct, pt[5], 3593408605, 5),
        Ct = dt(Ct, wt, xt, At, pt[10], 38016083, 9),
        At = dt(At, Ct, wt, xt, pt[15], 3634488961, 14),
        xt = dt(xt, At, Ct, wt, pt[4], 3889429448, 20),
        wt = dt(wt, xt, At, Ct, pt[9], 568446438, 5),
        Ct = dt(Ct, wt, xt, At, pt[14], 3275163606, 9),
        At = dt(At, Ct, wt, xt, pt[3], 4107603335, 14),
        xt = dt(xt, At, Ct, wt, pt[8], 1163531501, 20),
        wt = dt(wt, xt, At, Ct, pt[13], 2850285829, 5),
        Ct = dt(Ct, wt, xt, At, pt[2], 4243563512, 9),
        At = dt(At, Ct, wt, xt, pt[7], 1735328473, 14),
        xt = dt(xt, At, Ct, wt, pt[12], 2368359562, 20),
        wt = mt(wt, xt, At, Ct, pt[5], 4294588738, 4),
        Ct = mt(Ct, wt, xt, At, pt[8], 2272392833, 11),
        At = mt(At, Ct, wt, xt, pt[11], 1839030562, 16),
        xt = mt(xt, At, Ct, wt, pt[14], 4259657740, 23),
        wt = mt(wt, xt, At, Ct, pt[1], 2763975236, 4),
        Ct = mt(Ct, wt, xt, At, pt[4], 1272893353, 11),
        At = mt(At, Ct, wt, xt, pt[7], 4139469664, 16),
        xt = mt(xt, At, Ct, wt, pt[10], 3200236656, 23),
        wt = mt(wt, xt, At, Ct, pt[13], 681279174, 4),
        Ct = mt(Ct, wt, xt, At, pt[0], 3936430074, 11),
        At = mt(At, Ct, wt, xt, pt[3], 3572445317, 16),
        xt = mt(xt, At, Ct, wt, pt[6], 76029189, 23),
        wt = mt(wt, xt, At, Ct, pt[9], 3654602809, 4),
        Ct = mt(Ct, wt, xt, At, pt[12], 3873151461, 11),
        At = mt(At, Ct, wt, xt, pt[15], 530742520, 16),
        xt = mt(xt, At, Ct, wt, pt[2], 3299628645, 23),
        wt = yt(wt, xt, At, Ct, pt[0], 4096336452, 6),
        Ct = yt(Ct, wt, xt, At, pt[7], 1126891415, 10),
        At = yt(At, Ct, wt, xt, pt[14], 2878612391, 15),
        xt = yt(xt, At, Ct, wt, pt[5], 4237533241, 21),
        wt = yt(wt, xt, At, Ct, pt[12], 1700485571, 6),
        Ct = yt(Ct, wt, xt, At, pt[3], 2399980690, 10),
        At = yt(At, Ct, wt, xt, pt[10], 4293915773, 15),
        xt = yt(xt, At, Ct, wt, pt[1], 2240044497, 21),
        wt = yt(wt, xt, At, Ct, pt[8], 1873313359, 6),
        Ct = yt(Ct, wt, xt, At, pt[15], 4264355552, 10),
        At = yt(At, Ct, wt, xt, pt[6], 2734768916, 15),
        xt = yt(xt, At, Ct, wt, pt[13], 1309151649, 21),
        wt = yt(wt, xt, At, Ct, pt[4], 4149444226, 6),
        Ct = yt(Ct, wt, xt, At, pt[11], 3174756917, 10),
        At = yt(At, Ct, wt, xt, pt[2], 718787259, 15),
        xt = yt(xt, At, Ct, wt, pt[9], 3951481745, 21),
        this._a = this._a + wt | 0,
        this._b = this._b + xt | 0,
        this._c = this._c + At | 0,
        this._d = this._d + Ct | 0
    }
    ,
    k.prototype._digest = function() {
        this._block[this._blockOffset++] = 128,
        this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64),
        this._update(),
        this._blockOffset = 0),
        this._block.fill(0, this._blockOffset, 56),
        this._block.writeUInt32LE(this._length[0], 56),
        this._block.writeUInt32LE(this._length[1], 60),
        this._update();
        var pt = f.allocUnsafe(16);
        return pt.writeInt32LE(this._a, 0),
        pt.writeInt32LE(this._b, 4),
        pt.writeInt32LE(this._c, 8),
        pt.writeInt32LE(this._d, 12),
        pt
    }
    ;
    function y(pt, bt) {
        return pt << bt | pt >>> 32 - bt
    }
    function ee(pt, bt, wt, xt, At, Ct, Pt) {
        return y(pt + (bt & wt | ~bt & xt) + At + Ct | 0, Pt) + bt | 0
    }
    function dt(pt, bt, wt, xt, At, Ct, Pt) {
        return y(pt + (bt & xt | wt & ~xt) + At + Ct | 0, Pt) + bt | 0
    }
    function mt(pt, bt, wt, xt, At, Ct, Pt) {
        return y(pt + (bt ^ wt ^ xt) + At + Ct | 0, Pt) + bt | 0
    }
    function yt(pt, bt, wt, xt, At, Ct, Pt) {
        return y(pt + (wt ^ (bt | ~xt)) + At + Ct | 0, Pt) + bt | 0
    }
    return md5_js = k,
    md5_js
}
var hashBase, hasRequiredHashBase;
function requireHashBase() {
    if (hasRequiredHashBase)
        return hashBase;
    hasRequiredHashBase = 1;
    var r = requireSafeBuffer$1().Buffer
      , d = requireReadableBrowser$1().Transform
      , f = requireInherits_browser();
    function m(y, ee) {
        if (!r.isBuffer(y) && typeof y != "string")
            throw new TypeError(ee + " must be a string or a buffer")
    }
    function k(y) {
        d.call(this),
        this._block = r.allocUnsafe(y),
        this._blockSize = y,
        this._blockOffset = 0,
        this._length = [0, 0, 0, 0],
        this._finalized = !1
    }
    return f(k, d),
    k.prototype._transform = function(y, ee, dt) {
        var mt = null;
        try {
            this.update(y, ee)
        } catch (yt) {
            mt = yt
        }
        dt(mt)
    }
    ,
    k.prototype._flush = function(y) {
        var ee = null;
        try {
            this.push(this.digest())
        } catch (dt) {
            ee = dt
        }
        y(ee)
    }
    ,
    k.prototype.update = function(y, ee) {
        if (m(y, "Data"),
        this._finalized)
            throw new Error("Digest already called");
        r.isBuffer(y) || (y = r.from(y, ee));
        for (var dt = this._block, mt = 0; this._blockOffset + y.length - mt >= this._blockSize; ) {
            for (var yt = this._blockOffset; yt < this._blockSize; )
                dt[yt++] = y[mt++];
            this._update(),
            this._blockOffset = 0
        }
        for (; mt < y.length; )
            dt[this._blockOffset++] = y[mt++];
        for (var pt = 0, bt = y.length * 8; bt > 0; ++pt)
            this._length[pt] += bt,
            bt = this._length[pt] / 4294967296 | 0,
            bt > 0 && (this._length[pt] -= 4294967296 * bt);
        return this
    }
    ,
    k.prototype._update = function() {
        throw new Error("_update is not implemented")
    }
    ,
    k.prototype.digest = function(y) {
        if (this._finalized)
            throw new Error("Digest already called");
        this._finalized = !0;
        var ee = this._digest();
        y !== void 0 && (ee = ee.toString(y)),
        this._block.fill(0),
        this._blockOffset = 0;
        for (var dt = 0; dt < 4; ++dt)
            this._length[dt] = 0;
        return ee
    }
    ,
    k.prototype._digest = function() {
        throw new Error("_digest is not implemented")
    }
    ,
    hashBase = k,
    hashBase
}
var ripemd160, hasRequiredRipemd160;
function requireRipemd160() {
    if (hasRequiredRipemd160)
        return ripemd160;
    hasRequiredRipemd160 = 1;
    var r = require$$1$2.Buffer
      , d = requireInherits_browser()
      , f = requireHashBase()
      , m = new Array(16)
      , k = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]
      , y = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]
      , ee = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]
      , dt = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]
      , mt = [0, 1518500249, 1859775393, 2400959708, 2840853838]
      , yt = [1352829926, 1548603684, 1836072691, 2053994217, 0];
    function pt() {
        f.call(this, 64),
        this._a = 1732584193,
        this._b = 4023233417,
        this._c = 2562383102,
        this._d = 271733878,
        this._e = 3285377520
    }
    d(pt, f),
    pt.prototype._update = function() {
        for (var $t = m, Ot = 0; Ot < 16; ++Ot)
            $t[Ot] = this._block.readInt32LE(Ot * 4);
        for (var Nt = this._a | 0, zt = this._b | 0, Wt = this._c | 0, Kt = this._d | 0, ir = this._e | 0, or = this._a | 0, tr = this._b | 0, wr = this._c | 0, Ht = this._d | 0, Mt = this._e | 0, _t = 0; _t < 80; _t += 1) {
            var gt, vt;
            _t < 16 ? (gt = wt(Nt, zt, Wt, Kt, ir, $t[k[_t]], mt[0], ee[_t]),
            vt = Pt(or, tr, wr, Ht, Mt, $t[y[_t]], yt[0], dt[_t])) : _t < 32 ? (gt = xt(Nt, zt, Wt, Kt, ir, $t[k[_t]], mt[1], ee[_t]),
            vt = Ct(or, tr, wr, Ht, Mt, $t[y[_t]], yt[1], dt[_t])) : _t < 48 ? (gt = At(Nt, zt, Wt, Kt, ir, $t[k[_t]], mt[2], ee[_t]),
            vt = At(or, tr, wr, Ht, Mt, $t[y[_t]], yt[2], dt[_t])) : _t < 64 ? (gt = Ct(Nt, zt, Wt, Kt, ir, $t[k[_t]], mt[3], ee[_t]),
            vt = xt(or, tr, wr, Ht, Mt, $t[y[_t]], yt[3], dt[_t])) : (gt = Pt(Nt, zt, Wt, Kt, ir, $t[k[_t]], mt[4], ee[_t]),
            vt = wt(or, tr, wr, Ht, Mt, $t[y[_t]], yt[4], dt[_t])),
            Nt = ir,
            ir = Kt,
            Kt = bt(Wt, 10),
            Wt = zt,
            zt = gt,
            or = Mt,
            Mt = Ht,
            Ht = bt(wr, 10),
            wr = tr,
            tr = vt
        }
        var Et = this._b + Wt + Ht | 0;
        this._b = this._c + Kt + Mt | 0,
        this._c = this._d + ir + or | 0,
        this._d = this._e + Nt + tr | 0,
        this._e = this._a + zt + wr | 0,
        this._a = Et
    }
    ,
    pt.prototype._digest = function() {
        this._block[this._blockOffset++] = 128,
        this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64),
        this._update(),
        this._blockOffset = 0),
        this._block.fill(0, this._blockOffset, 56),
        this._block.writeUInt32LE(this._length[0], 56),
        this._block.writeUInt32LE(this._length[1], 60),
        this._update();
        var $t = r.alloc ? r.alloc(20) : new r(20);
        return $t.writeInt32LE(this._a, 0),
        $t.writeInt32LE(this._b, 4),
        $t.writeInt32LE(this._c, 8),
        $t.writeInt32LE(this._d, 12),
        $t.writeInt32LE(this._e, 16),
        $t
    }
    ;
    function bt($t, Ot) {
        return $t << Ot | $t >>> 32 - Ot
    }
    function wt($t, Ot, Nt, zt, Wt, Kt, ir, or) {
        return bt($t + (Ot ^ Nt ^ zt) + Kt + ir | 0, or) + Wt | 0
    }
    function xt($t, Ot, Nt, zt, Wt, Kt, ir, or) {
        return bt($t + (Ot & Nt | ~Ot & zt) + Kt + ir | 0, or) + Wt | 0
    }
    function At($t, Ot, Nt, zt, Wt, Kt, ir, or) {
        return bt($t + ((Ot | ~Nt) ^ zt) + Kt + ir | 0, or) + Wt | 0
    }
    function Ct($t, Ot, Nt, zt, Wt, Kt, ir, or) {
        return bt($t + (Ot & zt | Nt & ~zt) + Kt + ir | 0, or) + Wt | 0
    }
    function Pt($t, Ot, Nt, zt, Wt, Kt, ir, or) {
        return bt($t + (Ot ^ (Nt | ~zt)) + Kt + ir | 0, or) + Wt | 0
    }
    return ripemd160 = pt,
    ripemd160
}
var sha_js = {
    exports: {}
}, hash$1, hasRequiredHash$1;
function requireHash$1() {
    if (hasRequiredHash$1)
        return hash$1;
    hasRequiredHash$1 = 1;
    var r = requireSafeBuffer$1().Buffer;
    function d(f, m) {
        this._block = r.alloc(f),
        this._finalSize = m,
        this._blockSize = f,
        this._len = 0
    }
    return d.prototype.update = function(f, m) {
        typeof f == "string" && (m = m || "utf8",
        f = r.from(f, m));
        for (var k = this._block, y = this._blockSize, ee = f.length, dt = this._len, mt = 0; mt < ee; ) {
            for (var yt = dt % y, pt = Math.min(ee - mt, y - yt), bt = 0; bt < pt; bt++)
                k[yt + bt] = f[mt + bt];
            dt += pt,
            mt += pt,
            dt % y === 0 && this._update(k)
        }
        return this._len += ee,
        this
    }
    ,
    d.prototype.digest = function(f) {
        var m = this._len % this._blockSize;
        this._block[m] = 128,
        this._block.fill(0, m + 1),
        m >= this._finalSize && (this._update(this._block),
        this._block.fill(0));
        var k = this._len * 8;
        if (k <= 4294967295)
            this._block.writeUInt32BE(k, this._blockSize - 4);
        else {
            var y = (k & 4294967295) >>> 0
              , ee = (k - y) / 4294967296;
            this._block.writeUInt32BE(ee, this._blockSize - 8),
            this._block.writeUInt32BE(y, this._blockSize - 4)
        }
        this._update(this._block);
        var dt = this._hash();
        return f ? dt.toString(f) : dt
    }
    ,
    d.prototype._update = function() {
        throw new Error("_update must be implemented by subclass")
    }
    ,
    hash$1 = d,
    hash$1
}
var sha$2, hasRequiredSha$1;
function requireSha$1() {
    if (hasRequiredSha$1)
        return sha$2;
    hasRequiredSha$1 = 1;
    var r = requireInherits_browser()
      , d = requireHash$1()
      , f = requireSafeBuffer$1().Buffer
      , m = [1518500249, 1859775393, -1894007588, -899497514]
      , k = new Array(80);
    function y() {
        this.init(),
        this._w = k,
        d.call(this, 64, 56)
    }
    r(y, d),
    y.prototype.init = function() {
        return this._a = 1732584193,
        this._b = 4023233417,
        this._c = 2562383102,
        this._d = 271733878,
        this._e = 3285377520,
        this
    }
    ;
    function ee(yt) {
        return yt << 5 | yt >>> 27
    }
    function dt(yt) {
        return yt << 30 | yt >>> 2
    }
    function mt(yt, pt, bt, wt) {
        return yt === 0 ? pt & bt | ~pt & wt : yt === 2 ? pt & bt | pt & wt | bt & wt : pt ^ bt ^ wt
    }
    return y.prototype._update = function(yt) {
        for (var pt = this._w, bt = this._a | 0, wt = this._b | 0, xt = this._c | 0, At = this._d | 0, Ct = this._e | 0, Pt = 0; Pt < 16; ++Pt)
            pt[Pt] = yt.readInt32BE(Pt * 4);
        for (; Pt < 80; ++Pt)
            pt[Pt] = pt[Pt - 3] ^ pt[Pt - 8] ^ pt[Pt - 14] ^ pt[Pt - 16];
        for (var $t = 0; $t < 80; ++$t) {
            var Ot = ~~($t / 20)
              , Nt = ee(bt) + mt(Ot, wt, xt, At) + Ct + pt[$t] + m[Ot] | 0;
            Ct = At,
            At = xt,
            xt = dt(wt),
            wt = bt,
            bt = Nt
        }
        this._a = bt + this._a | 0,
        this._b = wt + this._b | 0,
        this._c = xt + this._c | 0,
        this._d = At + this._d | 0,
        this._e = Ct + this._e | 0
    }
    ,
    y.prototype._hash = function() {
        var yt = f.allocUnsafe(20);
        return yt.writeInt32BE(this._a | 0, 0),
        yt.writeInt32BE(this._b | 0, 4),
        yt.writeInt32BE(this._c | 0, 8),
        yt.writeInt32BE(this._d | 0, 12),
        yt.writeInt32BE(this._e | 0, 16),
        yt
    }
    ,
    sha$2 = y,
    sha$2
}
var sha1, hasRequiredSha1;
function requireSha1() {
    if (hasRequiredSha1)
        return sha1;
    hasRequiredSha1 = 1;
    var r = requireInherits_browser()
      , d = requireHash$1()
      , f = requireSafeBuffer$1().Buffer
      , m = [1518500249, 1859775393, -1894007588, -899497514]
      , k = new Array(80);
    function y() {
        this.init(),
        this._w = k,
        d.call(this, 64, 56)
    }
    r(y, d),
    y.prototype.init = function() {
        return this._a = 1732584193,
        this._b = 4023233417,
        this._c = 2562383102,
        this._d = 271733878,
        this._e = 3285377520,
        this
    }
    ;
    function ee(pt) {
        return pt << 1 | pt >>> 31
    }
    function dt(pt) {
        return pt << 5 | pt >>> 27
    }
    function mt(pt) {
        return pt << 30 | pt >>> 2
    }
    function yt(pt, bt, wt, xt) {
        return pt === 0 ? bt & wt | ~bt & xt : pt === 2 ? bt & wt | bt & xt | wt & xt : bt ^ wt ^ xt
    }
    return y.prototype._update = function(pt) {
        for (var bt = this._w, wt = this._a | 0, xt = this._b | 0, At = this._c | 0, Ct = this._d | 0, Pt = this._e | 0, $t = 0; $t < 16; ++$t)
            bt[$t] = pt.readInt32BE($t * 4);
        for (; $t < 80; ++$t)
            bt[$t] = ee(bt[$t - 3] ^ bt[$t - 8] ^ bt[$t - 14] ^ bt[$t - 16]);
        for (var Ot = 0; Ot < 80; ++Ot) {
            var Nt = ~~(Ot / 20)
              , zt = dt(wt) + yt(Nt, xt, At, Ct) + Pt + bt[Ot] + m[Nt] | 0;
            Pt = Ct,
            Ct = At,
            At = mt(xt),
            xt = wt,
            wt = zt
        }
        this._a = wt + this._a | 0,
        this._b = xt + this._b | 0,
        this._c = At + this._c | 0,
        this._d = Ct + this._d | 0,
        this._e = Pt + this._e | 0
    }
    ,
    y.prototype._hash = function() {
        var pt = f.allocUnsafe(20);
        return pt.writeInt32BE(this._a | 0, 0),
        pt.writeInt32BE(this._b | 0, 4),
        pt.writeInt32BE(this._c | 0, 8),
        pt.writeInt32BE(this._d | 0, 12),
        pt.writeInt32BE(this._e | 0, 16),
        pt
    }
    ,
    sha1 = y,
    sha1
}
var sha256$5, hasRequiredSha256;
function requireSha256() {
    if (hasRequiredSha256)
        return sha256$5;
    hasRequiredSha256 = 1;
    var r = requireInherits_browser()
      , d = requireHash$1()
      , f = requireSafeBuffer$1().Buffer
      , m = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]
      , k = new Array(64);
    function y() {
        this.init(),
        this._w = k,
        d.call(this, 64, 56)
    }
    r(y, d),
    y.prototype.init = function() {
        return this._a = 1779033703,
        this._b = 3144134277,
        this._c = 1013904242,
        this._d = 2773480762,
        this._e = 1359893119,
        this._f = 2600822924,
        this._g = 528734635,
        this._h = 1541459225,
        this
    }
    ;
    function ee(wt, xt, At) {
        return At ^ wt & (xt ^ At)
    }
    function dt(wt, xt, At) {
        return wt & xt | At & (wt | xt)
    }
    function mt(wt) {
        return (wt >>> 2 | wt << 30) ^ (wt >>> 13 | wt << 19) ^ (wt >>> 22 | wt << 10)
    }
    function yt(wt) {
        return (wt >>> 6 | wt << 26) ^ (wt >>> 11 | wt << 21) ^ (wt >>> 25 | wt << 7)
    }
    function pt(wt) {
        return (wt >>> 7 | wt << 25) ^ (wt >>> 18 | wt << 14) ^ wt >>> 3
    }
    function bt(wt) {
        return (wt >>> 17 | wt << 15) ^ (wt >>> 19 | wt << 13) ^ wt >>> 10
    }
    return y.prototype._update = function(wt) {
        for (var xt = this._w, At = this._a | 0, Ct = this._b | 0, Pt = this._c | 0, $t = this._d | 0, Ot = this._e | 0, Nt = this._f | 0, zt = this._g | 0, Wt = this._h | 0, Kt = 0; Kt < 16; ++Kt)
            xt[Kt] = wt.readInt32BE(Kt * 4);
        for (; Kt < 64; ++Kt)
            xt[Kt] = bt(xt[Kt - 2]) + xt[Kt - 7] + pt(xt[Kt - 15]) + xt[Kt - 16] | 0;
        for (var ir = 0; ir < 64; ++ir) {
            var or = Wt + yt(Ot) + ee(Ot, Nt, zt) + m[ir] + xt[ir] | 0
              , tr = mt(At) + dt(At, Ct, Pt) | 0;
            Wt = zt,
            zt = Nt,
            Nt = Ot,
            Ot = $t + or | 0,
            $t = Pt,
            Pt = Ct,
            Ct = At,
            At = or + tr | 0
        }
        this._a = At + this._a | 0,
        this._b = Ct + this._b | 0,
        this._c = Pt + this._c | 0,
        this._d = $t + this._d | 0,
        this._e = Ot + this._e | 0,
        this._f = Nt + this._f | 0,
        this._g = zt + this._g | 0,
        this._h = Wt + this._h | 0
    }
    ,
    y.prototype._hash = function() {
        var wt = f.allocUnsafe(32);
        return wt.writeInt32BE(this._a, 0),
        wt.writeInt32BE(this._b, 4),
        wt.writeInt32BE(this._c, 8),
        wt.writeInt32BE(this._d, 12),
        wt.writeInt32BE(this._e, 16),
        wt.writeInt32BE(this._f, 20),
        wt.writeInt32BE(this._g, 24),
        wt.writeInt32BE(this._h, 28),
        wt
    }
    ,
    sha256$5 = y,
    sha256$5
}
var sha224$1, hasRequiredSha224;
function requireSha224() {
    if (hasRequiredSha224)
        return sha224$1;
    hasRequiredSha224 = 1;
    var r = requireInherits_browser()
      , d = requireSha256()
      , f = requireHash$1()
      , m = requireSafeBuffer$1().Buffer
      , k = new Array(64);
    function y() {
        this.init(),
        this._w = k,
        f.call(this, 64, 56)
    }
    return r(y, d),
    y.prototype.init = function() {
        return this._a = 3238371032,
        this._b = 914150663,
        this._c = 812702999,
        this._d = 4144912697,
        this._e = 4290775857,
        this._f = 1750603025,
        this._g = 1694076839,
        this._h = 3204075428,
        this
    }
    ,
    y.prototype._hash = function() {
        var ee = m.allocUnsafe(28);
        return ee.writeInt32BE(this._a, 0),
        ee.writeInt32BE(this._b, 4),
        ee.writeInt32BE(this._c, 8),
        ee.writeInt32BE(this._d, 12),
        ee.writeInt32BE(this._e, 16),
        ee.writeInt32BE(this._f, 20),
        ee.writeInt32BE(this._g, 24),
        ee
    }
    ,
    sha224$1 = y,
    sha224$1
}
var sha512$5, hasRequiredSha512;
function requireSha512() {
    if (hasRequiredSha512)
        return sha512$5;
    hasRequiredSha512 = 1;
    var r = requireInherits_browser()
      , d = requireHash$1()
      , f = requireSafeBuffer$1().Buffer
      , m = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591]
      , k = new Array(160);
    function y() {
        this.init(),
        this._w = k,
        d.call(this, 128, 112)
    }
    r(y, d),
    y.prototype.init = function() {
        return this._ah = 1779033703,
        this._bh = 3144134277,
        this._ch = 1013904242,
        this._dh = 2773480762,
        this._eh = 1359893119,
        this._fh = 2600822924,
        this._gh = 528734635,
        this._hh = 1541459225,
        this._al = 4089235720,
        this._bl = 2227873595,
        this._cl = 4271175723,
        this._dl = 1595750129,
        this._el = 2917565137,
        this._fl = 725511199,
        this._gl = 4215389547,
        this._hl = 327033209,
        this
    }
    ;
    function ee(Ct, Pt, $t) {
        return $t ^ Ct & (Pt ^ $t)
    }
    function dt(Ct, Pt, $t) {
        return Ct & Pt | $t & (Ct | Pt)
    }
    function mt(Ct, Pt) {
        return (Ct >>> 28 | Pt << 4) ^ (Pt >>> 2 | Ct << 30) ^ (Pt >>> 7 | Ct << 25)
    }
    function yt(Ct, Pt) {
        return (Ct >>> 14 | Pt << 18) ^ (Ct >>> 18 | Pt << 14) ^ (Pt >>> 9 | Ct << 23)
    }
    function pt(Ct, Pt) {
        return (Ct >>> 1 | Pt << 31) ^ (Ct >>> 8 | Pt << 24) ^ Ct >>> 7
    }
    function bt(Ct, Pt) {
        return (Ct >>> 1 | Pt << 31) ^ (Ct >>> 8 | Pt << 24) ^ (Ct >>> 7 | Pt << 25)
    }
    function wt(Ct, Pt) {
        return (Ct >>> 19 | Pt << 13) ^ (Pt >>> 29 | Ct << 3) ^ Ct >>> 6
    }
    function xt(Ct, Pt) {
        return (Ct >>> 19 | Pt << 13) ^ (Pt >>> 29 | Ct << 3) ^ (Ct >>> 6 | Pt << 26)
    }
    function At(Ct, Pt) {
        return Ct >>> 0 < Pt >>> 0 ? 1 : 0
    }
    return y.prototype._update = function(Ct) {
        for (var Pt = this._w, $t = this._ah | 0, Ot = this._bh | 0, Nt = this._ch | 0, zt = this._dh | 0, Wt = this._eh | 0, Kt = this._fh | 0, ir = this._gh | 0, or = this._hh | 0, tr = this._al | 0, wr = this._bl | 0, Ht = this._cl | 0, Mt = this._dl | 0, _t = this._el | 0, gt = this._fl | 0, vt = this._gl | 0, Et = this._hl | 0, Bt = 0; Bt < 32; Bt += 2)
            Pt[Bt] = Ct.readInt32BE(Bt * 4),
            Pt[Bt + 1] = Ct.readInt32BE(Bt * 4 + 4);
        for (; Bt < 160; Bt += 2) {
            var Rt = Pt[Bt - 30]
              , kt = Pt[Bt - 15 * 2 + 1]
              , Tt = pt(Rt, kt)
              , It = bt(kt, Rt);
            Rt = Pt[Bt - 2 * 2],
            kt = Pt[Bt - 2 * 2 + 1];
            var St = wt(Rt, kt)
              , qt = xt(kt, Rt)
              , ur = Pt[Bt - 7 * 2]
              , gr = Pt[Bt - 7 * 2 + 1]
              , lr = Pt[Bt - 16 * 2]
              , Zt = Pt[Bt - 16 * 2 + 1]
              , Vt = It + gr | 0
              , rr = Tt + ur + At(Vt, It) | 0;
            Vt = Vt + qt | 0,
            rr = rr + St + At(Vt, qt) | 0,
            Vt = Vt + Zt | 0,
            rr = rr + lr + At(Vt, Zt) | 0,
            Pt[Bt] = rr,
            Pt[Bt + 1] = Vt
        }
        for (var fr = 0; fr < 160; fr += 2) {
            rr = Pt[fr],
            Vt = Pt[fr + 1];
            var Yt = dt($t, Ot, Nt)
              , Xt = dt(tr, wr, Ht)
              , Sr = mt($t, tr)
              , Rr = mt(tr, $t)
              , qr = yt(Wt, _t)
              , Nr = yt(_t, Wt)
              , Dr = m[fr]
              , Or = m[fr + 1]
              , $r = ee(Wt, Kt, ir)
              , Zr = ee(_t, gt, vt)
              , Hr = Et + Nr | 0
              , un = or + qr + At(Hr, Et) | 0;
            Hr = Hr + Zr | 0,
            un = un + $r + At(Hr, Zr) | 0,
            Hr = Hr + Or | 0,
            un = un + Dr + At(Hr, Or) | 0,
            Hr = Hr + Vt | 0,
            un = un + rr + At(Hr, Vt) | 0;
            var Qr = Rr + Xt | 0
              , Gr = Sr + Yt + At(Qr, Rr) | 0;
            or = ir,
            Et = vt,
            ir = Kt,
            vt = gt,
            Kt = Wt,
            gt = _t,
            _t = Mt + Hr | 0,
            Wt = zt + un + At(_t, Mt) | 0,
            zt = Nt,
            Mt = Ht,
            Nt = Ot,
            Ht = wr,
            Ot = $t,
            wr = tr,
            tr = Hr + Qr | 0,
            $t = un + Gr + At(tr, Hr) | 0
        }
        this._al = this._al + tr | 0,
        this._bl = this._bl + wr | 0,
        this._cl = this._cl + Ht | 0,
        this._dl = this._dl + Mt | 0,
        this._el = this._el + _t | 0,
        this._fl = this._fl + gt | 0,
        this._gl = this._gl + vt | 0,
        this._hl = this._hl + Et | 0,
        this._ah = this._ah + $t + At(this._al, tr) | 0,
        this._bh = this._bh + Ot + At(this._bl, wr) | 0,
        this._ch = this._ch + Nt + At(this._cl, Ht) | 0,
        this._dh = this._dh + zt + At(this._dl, Mt) | 0,
        this._eh = this._eh + Wt + At(this._el, _t) | 0,
        this._fh = this._fh + Kt + At(this._fl, gt) | 0,
        this._gh = this._gh + ir + At(this._gl, vt) | 0,
        this._hh = this._hh + or + At(this._hl, Et) | 0
    }
    ,
    y.prototype._hash = function() {
        var Ct = f.allocUnsafe(64);
        function Pt($t, Ot, Nt) {
            Ct.writeInt32BE($t, Nt),
            Ct.writeInt32BE(Ot, Nt + 4)
        }
        return Pt(this._ah, this._al, 0),
        Pt(this._bh, this._bl, 8),
        Pt(this._ch, this._cl, 16),
        Pt(this._dh, this._dl, 24),
        Pt(this._eh, this._el, 32),
        Pt(this._fh, this._fl, 40),
        Pt(this._gh, this._gl, 48),
        Pt(this._hh, this._hl, 56),
        Ct
    }
    ,
    sha512$5 = y,
    sha512$5
}
var sha384$1, hasRequiredSha384;
function requireSha384() {
    if (hasRequiredSha384)
        return sha384$1;
    hasRequiredSha384 = 1;
    var r = requireInherits_browser()
      , d = requireSha512()
      , f = requireHash$1()
      , m = requireSafeBuffer$1().Buffer
      , k = new Array(160);
    function y() {
        this.init(),
        this._w = k,
        f.call(this, 128, 112)
    }
    return r(y, d),
    y.prototype.init = function() {
        return this._ah = 3418070365,
        this._bh = 1654270250,
        this._ch = 2438529370,
        this._dh = 355462360,
        this._eh = 1731405415,
        this._fh = 2394180231,
        this._gh = 3675008525,
        this._hh = 1203062813,
        this._al = 3238371032,
        this._bl = 914150663,
        this._cl = 812702999,
        this._dl = 4144912697,
        this._el = 4290775857,
        this._fl = 1750603025,
        this._gl = 1694076839,
        this._hl = 3204075428,
        this
    }
    ,
    y.prototype._hash = function() {
        var ee = m.allocUnsafe(48);
        function dt(mt, yt, pt) {
            ee.writeInt32BE(mt, pt),
            ee.writeInt32BE(yt, pt + 4)
        }
        return dt(this._ah, this._al, 0),
        dt(this._bh, this._bl, 8),
        dt(this._ch, this._cl, 16),
        dt(this._dh, this._dl, 24),
        dt(this._eh, this._el, 32),
        dt(this._fh, this._fl, 40),
        ee
    }
    ,
    sha384$1 = y,
    sha384$1
}
var hasRequiredSha_js;
function requireSha_js() {
    if (hasRequiredSha_js)
        return sha_js.exports;
    hasRequiredSha_js = 1;
    var r = sha_js.exports = function(f) {
        f = f.toLowerCase();
        var m = r[f];
        if (!m)
            throw new Error(f + " is not supported (we accept pull requests)");
        return new m
    }
    ;
    return r.sha = requireSha$1(),
    r.sha1 = requireSha1(),
    r.sha224 = requireSha224(),
    r.sha256 = requireSha256(),
    r.sha384 = requireSha384(),
    r.sha512 = requireSha512(),
    sha_js.exports
}
var streamBrowserify, hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
    if (hasRequiredStreamBrowserify)
        return streamBrowserify;
    hasRequiredStreamBrowserify = 1,
    streamBrowserify = f;
    var r = requireEvents().EventEmitter
      , d = requireInherits_browser();
    d(f, r),
    f.Readable = require_stream_readable$1(),
    f.Writable = require_stream_writable$1(),
    f.Duplex = require_stream_duplex$1(),
    f.Transform = require_stream_transform$1(),
    f.PassThrough = require_stream_passthrough$1(),
    f.finished = requireEndOfStream(),
    f.pipeline = requirePipeline(),
    f.Stream = f;
    function f() {
        r.call(this)
    }
    return f.prototype.pipe = function(m, k) {
        var y = this;
        function ee(xt) {
            m.writable && m.write(xt) === !1 && y.pause && y.pause()
        }
        y.on("data", ee);
        function dt() {
            y.readable && y.resume && y.resume()
        }
        m.on("drain", dt),
        !m._isStdio && (!k || k.end !== !1) && (y.on("end", yt),
        y.on("close", pt));
        var mt = !1;
        function yt() {
            mt || (mt = !0,
            m.end())
        }
        function pt() {
            mt || (mt = !0,
            typeof m.destroy == "function" && m.destroy())
        }
        function bt(xt) {
            if (wt(),
            r.listenerCount(this, "error") === 0)
                throw xt
        }
        y.on("error", bt),
        m.on("error", bt);
        function wt() {
            y.removeListener("data", ee),
            m.removeListener("drain", dt),
            y.removeListener("end", yt),
            y.removeListener("close", pt),
            y.removeListener("error", bt),
            m.removeListener("error", bt),
            y.removeListener("end", wt),
            y.removeListener("close", wt),
            m.removeListener("close", wt)
        }
        return y.on("end", wt),
        y.on("close", wt),
        m.on("close", wt),
        m.emit("pipe", y),
        m
    }
    ,
    streamBrowserify
}
var cipherBase, hasRequiredCipherBase;
function requireCipherBase() {
    if (hasRequiredCipherBase)
        return cipherBase;
    hasRequiredCipherBase = 1;
    var r = requireSafeBuffer$1().Buffer
      , d = requireStreamBrowserify().Transform
      , f = requireString_decoder().StringDecoder
      , m = requireInherits_browser();
    function k(y) {
        d.call(this),
        this.hashMode = typeof y == "string",
        this.hashMode ? this[y] = this._finalOrDigest : this.final = this._finalOrDigest,
        this._final && (this.__final = this._final,
        this._final = null),
        this._decoder = null,
        this._encoding = null
    }
    return m(k, d),
    k.prototype.update = function(y, ee, dt) {
        typeof y == "string" && (y = r.from(y, ee));
        var mt = this._update(y);
        return this.hashMode ? this : (dt && (mt = this._toString(mt, dt)),
        mt)
    }
    ,
    k.prototype.setAutoPadding = function() {}
    ,
    k.prototype.getAuthTag = function() {
        throw new Error("trying to get auth tag in unsupported state")
    }
    ,
    k.prototype.setAuthTag = function() {
        throw new Error("trying to set auth tag in unsupported state")
    }
    ,
    k.prototype.setAAD = function() {
        throw new Error("trying to set aad in unsupported state")
    }
    ,
    k.prototype._transform = function(y, ee, dt) {
        var mt;
        try {
            this.hashMode ? this._update(y) : this.push(this._update(y))
        } catch (yt) {
            mt = yt
        } finally {
            dt(mt)
        }
    }
    ,
    k.prototype._flush = function(y) {
        var ee;
        try {
            this.push(this.__final())
        } catch (dt) {
            ee = dt
        }
        y(ee)
    }
    ,
    k.prototype._finalOrDigest = function(y) {
        var ee = this.__final() || r.alloc(0);
        return y && (ee = this._toString(ee, y, !0)),
        ee
    }
    ,
    k.prototype._toString = function(y, ee, dt) {
        if (this._decoder || (this._decoder = new f(ee),
        this._encoding = ee),
        this._encoding !== ee)
            throw new Error("can't switch encodings");
        var mt = this._decoder.write(y);
        return dt && (mt += this._decoder.end()),
        mt
    }
    ,
    cipherBase = k,
    cipherBase
}
var browser$a, hasRequiredBrowser$9;
function requireBrowser$9() {
    if (hasRequiredBrowser$9)
        return browser$a;
    hasRequiredBrowser$9 = 1;
    var r = requireInherits_browser()
      , d = requireMd5_js()
      , f = requireRipemd160()
      , m = requireSha_js()
      , k = requireCipherBase();
    function y(ee) {
        k.call(this, "digest"),
        this._hash = ee
    }
    return r(y, k),
    y.prototype._update = function(ee) {
        this._hash.update(ee)
    }
    ,
    y.prototype._final = function() {
        return this._hash.digest()
    }
    ,
    browser$a = function(dt) {
        return dt = dt.toLowerCase(),
        dt === "md5" ? new d : dt === "rmd160" || dt === "ripemd160" ? new f : new y(m(dt))
    }
    ,
    browser$a
}
var legacy, hasRequiredLegacy;
function requireLegacy() {
    if (hasRequiredLegacy)
        return legacy;
    hasRequiredLegacy = 1;
    var r = requireInherits_browser()
      , d = requireSafeBuffer$1().Buffer
      , f = requireCipherBase()
      , m = d.alloc(128)
      , k = 64;
    function y(ee, dt) {
        f.call(this, "digest"),
        typeof dt == "string" && (dt = d.from(dt)),
        this._alg = ee,
        this._key = dt,
        dt.length > k ? dt = ee(dt) : dt.length < k && (dt = d.concat([dt, m], k));
        for (var mt = this._ipad = d.allocUnsafe(k), yt = this._opad = d.allocUnsafe(k), pt = 0; pt < k; pt++)
            mt[pt] = dt[pt] ^ 54,
            yt[pt] = dt[pt] ^ 92;
        this._hash = [mt]
    }
    return r(y, f),
    y.prototype._update = function(ee) {
        this._hash.push(ee)
    }
    ,
    y.prototype._final = function() {
        var ee = this._alg(d.concat(this._hash));
        return this._alg(d.concat([this._opad, ee]))
    }
    ,
    legacy = y,
    legacy
}
var md5, hasRequiredMd5;
function requireMd5() {
    if (hasRequiredMd5)
        return md5;
    hasRequiredMd5 = 1;
    var r = requireMd5_js();
    return md5 = function(d) {
        return new r().update(d).digest()
    }
    ,
    md5
}
var browser$9, hasRequiredBrowser$8;
function requireBrowser$8() {
    if (hasRequiredBrowser$8)
        return browser$9;
    hasRequiredBrowser$8 = 1;
    var r = requireInherits_browser()
      , d = requireLegacy()
      , f = requireCipherBase()
      , m = requireSafeBuffer$1().Buffer
      , k = requireMd5()
      , y = requireRipemd160()
      , ee = requireSha_js()
      , dt = m.alloc(128);
    function mt(yt, pt) {
        f.call(this, "digest"),
        typeof pt == "string" && (pt = m.from(pt));
        var bt = yt === "sha512" || yt === "sha384" ? 128 : 64;
        if (this._alg = yt,
        this._key = pt,
        pt.length > bt) {
            var wt = yt === "rmd160" ? new y : ee(yt);
            pt = wt.update(pt).digest()
        } else
            pt.length < bt && (pt = m.concat([pt, dt], bt));
        for (var xt = this._ipad = m.allocUnsafe(bt), At = this._opad = m.allocUnsafe(bt), Ct = 0; Ct < bt; Ct++)
            xt[Ct] = pt[Ct] ^ 54,
            At[Ct] = pt[Ct] ^ 92;
        this._hash = yt === "rmd160" ? new y : ee(yt),
        this._hash.update(xt)
    }
    return r(mt, f),
    mt.prototype._update = function(yt) {
        this._hash.update(yt)
    }
    ,
    mt.prototype._final = function() {
        var yt = this._hash.digest()
          , pt = this._alg === "rmd160" ? new y : ee(this._alg);
        return pt.update(this._opad).update(yt).digest()
    }
    ,
    browser$9 = function(pt, bt) {
        return pt = pt.toLowerCase(),
        pt === "rmd160" || pt === "ripemd160" ? new mt("rmd160",bt) : pt === "md5" ? new d(k,bt) : new mt(pt,bt)
    }
    ,
    browser$9
}
const sha224WithRSAEncryption = {
    sign: "rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
}
  , sha256WithRSAEncryption = {
    sign: "rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
}
  , sha384WithRSAEncryption = {
    sign: "rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
}
  , sha512WithRSAEncryption = {
    sign: "rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
}
  , sha256$4 = {
    sign: "ecdsa",
    hash: "sha256",
    id: ""
}
  , sha224 = {
    sign: "ecdsa",
    hash: "sha224",
    id: ""
}
  , sha384 = {
    sign: "ecdsa",
    hash: "sha384",
    id: ""
}
  , sha512$4 = {
    sign: "ecdsa",
    hash: "sha512",
    id: ""
}
  , DSA = {
    sign: "dsa",
    hash: "sha1",
    id: ""
}
  , ripemd160WithRSA = {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
}
  , md5WithRSAEncryption = {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
}
  , require$$6 = {
    sha224WithRSAEncryption,
    "RSA-SHA224": {
        sign: "ecdsa/rsa",
        hash: "sha224",
        id: "302d300d06096086480165030402040500041c"
    },
    sha256WithRSAEncryption,
    "RSA-SHA256": {
        sign: "ecdsa/rsa",
        hash: "sha256",
        id: "3031300d060960864801650304020105000420"
    },
    sha384WithRSAEncryption,
    "RSA-SHA384": {
        sign: "ecdsa/rsa",
        hash: "sha384",
        id: "3041300d060960864801650304020205000430"
    },
    sha512WithRSAEncryption,
    "RSA-SHA512": {
        sign: "ecdsa/rsa",
        hash: "sha512",
        id: "3051300d060960864801650304020305000440"
    },
    "RSA-SHA1": {
        sign: "rsa",
        hash: "sha1",
        id: "3021300906052b0e03021a05000414"
    },
    "ecdsa-with-SHA1": {
        sign: "ecdsa",
        hash: "sha1",
        id: ""
    },
    sha256: sha256$4,
    sha224,
    sha384,
    sha512: sha512$4,
    "DSA-SHA": {
        sign: "dsa",
        hash: "sha1",
        id: ""
    },
    "DSA-SHA1": {
        sign: "dsa",
        hash: "sha1",
        id: ""
    },
    DSA,
    "DSA-WITH-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
    },
    "DSA-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
    },
    "DSA-WITH-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
    },
    "DSA-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
    },
    "DSA-WITH-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
    },
    "DSA-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
    },
    "DSA-WITH-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
    },
    "DSA-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
    },
    "DSA-RIPEMD160": {
        sign: "dsa",
        hash: "rmd160",
        id: ""
    },
    ripemd160WithRSA,
    "RSA-RIPEMD160": {
        sign: "rsa",
        hash: "rmd160",
        id: "3021300906052b2403020105000414"
    },
    md5WithRSAEncryption,
    "RSA-MD5": {
        sign: "rsa",
        hash: "md5",
        id: "3020300c06082a864886f70d020505000410"
    }
};
var algos, hasRequiredAlgos;
function requireAlgos() {
    return hasRequiredAlgos || (hasRequiredAlgos = 1,
    algos = require$$6),
    algos
}
var browser$8 = {}, precondition, hasRequiredPrecondition;
function requirePrecondition() {
    if (hasRequiredPrecondition)
        return precondition;
    hasRequiredPrecondition = 1;
    var r = Math.pow(2, 30) - 1;
    return precondition = function(d, f) {
        if (typeof d != "number")
            throw new TypeError("Iterations not a number");
        if (d < 0)
            throw new TypeError("Bad iterations");
        if (typeof f != "number")
            throw new TypeError("Key length not a number");
        if (f < 0 || f > r || f !== f)
            throw new TypeError("Bad key length")
    }
    ,
    precondition
}
var defaultEncoding_1, hasRequiredDefaultEncoding;
function requireDefaultEncoding() {
    if (hasRequiredDefaultEncoding)
        return defaultEncoding_1;
    hasRequiredDefaultEncoding = 1;
    var r;
    if (commonjsGlobal.process && commonjsGlobal.process.browser)
        r = "utf-8";
    else if (commonjsGlobal.process && commonjsGlobal.process.version) {
        var d = parseInt(process$1.version.split(".")[0].slice(1), 10);
        r = d >= 6 ? "utf-8" : "binary"
    } else
        r = "utf-8";
    return defaultEncoding_1 = r,
    defaultEncoding_1
}
var toBuffer, hasRequiredToBuffer;
function requireToBuffer() {
    if (hasRequiredToBuffer)
        return toBuffer;
    hasRequiredToBuffer = 1;
    var r = requireSafeBuffer$1().Buffer;
    return toBuffer = function(d, f, m) {
        if (r.isBuffer(d))
            return d;
        if (typeof d == "string")
            return r.from(d, f);
        if (ArrayBuffer.isView(d))
            return r.from(d.buffer);
        throw new TypeError(m + " must be a string, a Buffer, a typed array or a DataView")
    }
    ,
    toBuffer
}
var syncBrowser, hasRequiredSyncBrowser;
function requireSyncBrowser() {
    if (hasRequiredSyncBrowser)
        return syncBrowser;
    hasRequiredSyncBrowser = 1;
    var r = requireMd5()
      , d = requireRipemd160()
      , f = requireSha_js()
      , m = requireSafeBuffer$1().Buffer
      , k = requirePrecondition()
      , y = requireDefaultEncoding()
      , ee = requireToBuffer()
      , dt = m.alloc(128)
      , mt = {
        md5: 16,
        sha1: 20,
        sha224: 28,
        sha256: 32,
        sha384: 48,
        sha512: 64,
        rmd160: 20,
        ripemd160: 20
    };
    function yt(wt, xt, At) {
        var Ct = pt(wt)
          , Pt = wt === "sha512" || wt === "sha384" ? 128 : 64;
        xt.length > Pt ? xt = Ct(xt) : xt.length < Pt && (xt = m.concat([xt, dt], Pt));
        for (var $t = m.allocUnsafe(Pt + mt[wt]), Ot = m.allocUnsafe(Pt + mt[wt]), Nt = 0; Nt < Pt; Nt++)
            $t[Nt] = xt[Nt] ^ 54,
            Ot[Nt] = xt[Nt] ^ 92;
        var zt = m.allocUnsafe(Pt + At + 4);
        $t.copy(zt, 0, 0, Pt),
        this.ipad1 = zt,
        this.ipad2 = $t,
        this.opad = Ot,
        this.alg = wt,
        this.blocksize = Pt,
        this.hash = Ct,
        this.size = mt[wt]
    }
    yt.prototype.run = function(wt, xt) {
        wt.copy(xt, this.blocksize);
        var At = this.hash(xt);
        return At.copy(this.opad, this.blocksize),
        this.hash(this.opad)
    }
    ;
    function pt(wt) {
        function xt(Ct) {
            return f(wt).update(Ct).digest()
        }
        function At(Ct) {
            return new d().update(Ct).digest()
        }
        return wt === "rmd160" || wt === "ripemd160" ? At : wt === "md5" ? r : xt
    }
    function bt(wt, xt, At, Ct, Pt) {
        k(At, Ct),
        wt = ee(wt, y, "Password"),
        xt = ee(xt, y, "Salt"),
        Pt = Pt || "sha1";
        var $t = new yt(Pt,wt,xt.length)
          , Ot = m.allocUnsafe(Ct)
          , Nt = m.allocUnsafe(xt.length + 4);
        xt.copy(Nt, 0, 0, xt.length);
        for (var zt = 0, Wt = mt[Pt], Kt = Math.ceil(Ct / Wt), ir = 1; ir <= Kt; ir++) {
            Nt.writeUInt32BE(ir, xt.length);
            for (var or = $t.run(Nt, $t.ipad1), tr = or, wr = 1; wr < At; wr++) {
                tr = $t.run(tr, $t.ipad2);
                for (var Ht = 0; Ht < Wt; Ht++)
                    or[Ht] ^= tr[Ht]
            }
            or.copy(Ot, zt),
            zt += Wt
        }
        return Ot
    }
    return syncBrowser = bt,
    syncBrowser
}
var async, hasRequiredAsync;
function requireAsync() {
    if (hasRequiredAsync)
        return async;
    hasRequiredAsync = 1;
    var r = requireSafeBuffer$1().Buffer, d = requirePrecondition(), f = requireDefaultEncoding(), m = requireSyncBrowser(), k = requireToBuffer(), y, ee = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, dt = {
        sha: "SHA-1",
        "sha-1": "SHA-1",
        sha1: "SHA-1",
        sha256: "SHA-256",
        "sha-256": "SHA-256",
        sha384: "SHA-384",
        "sha-384": "SHA-384",
        "sha-512": "SHA-512",
        sha512: "SHA-512"
    }, mt = [];
    function yt(At) {
        if (commonjsGlobal.process && !commonjsGlobal.process.browser || !ee || !ee.importKey || !ee.deriveBits)
            return Promise.resolve(!1);
        if (mt[At] !== void 0)
            return mt[At];
        y = y || r.alloc(8);
        var Ct = wt(y, y, 10, 128, At).then(function() {
            return !0
        }).catch(function() {
            return !1
        });
        return mt[At] = Ct,
        Ct
    }
    var pt;
    function bt() {
        return pt || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? pt = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? pt = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? pt = commonjsGlobal.setImmediate : pt = commonjsGlobal.setTimeout,
        pt)
    }
    function wt(At, Ct, Pt, $t, Ot) {
        return ee.importKey("raw", At, {
            name: "PBKDF2"
        }, !1, ["deriveBits"]).then(function(Nt) {
            return ee.deriveBits({
                name: "PBKDF2",
                salt: Ct,
                iterations: Pt,
                hash: {
                    name: Ot
                }
            }, Nt, $t << 3)
        }).then(function(Nt) {
            return r.from(Nt)
        })
    }
    function xt(At, Ct) {
        At.then(function(Pt) {
            bt()(function() {
                Ct(null, Pt)
            })
        }, function(Pt) {
            bt()(function() {
                Ct(Pt)
            })
        })
    }
    return async = function(At, Ct, Pt, $t, Ot, Nt) {
        typeof Ot == "function" && (Nt = Ot,
        Ot = void 0),
        Ot = Ot || "sha1";
        var zt = dt[Ot.toLowerCase()];
        if (!zt || typeof commonjsGlobal.Promise != "function") {
            bt()(function() {
                var Wt;
                try {
                    Wt = m(At, Ct, Pt, $t, Ot)
                } catch (Kt) {
                    return Nt(Kt)
                }
                Nt(null, Wt)
            });
            return
        }
        if (d(Pt, $t),
        At = k(At, f, "Password"),
        Ct = k(Ct, f, "Salt"),
        typeof Nt != "function")
            throw new Error("No callback provided to pbkdf2");
        xt(yt(zt).then(function(Wt) {
            return Wt ? wt(At, Ct, Pt, $t, zt) : m(At, Ct, Pt, $t, Ot)
        }), Nt)
    }
    ,
    async
}
var hasRequiredBrowser$7;
function requireBrowser$7() {
    return hasRequiredBrowser$7 || (hasRequiredBrowser$7 = 1,
    browser$8.pbkdf2 = requireAsync(),
    browser$8.pbkdf2Sync = requireSyncBrowser()),
    browser$8
}
var browser$7 = {}, des$1 = {}, utils$5 = {}, hasRequiredUtils$3;
function requireUtils$3() {
    if (hasRequiredUtils$3)
        return utils$5;
    hasRequiredUtils$3 = 1,
    utils$5.readUInt32BE = function(k, y) {
        var ee = k[0 + y] << 24 | k[1 + y] << 16 | k[2 + y] << 8 | k[3 + y];
        return ee >>> 0
    }
    ,
    utils$5.writeUInt32BE = function(k, y, ee) {
        k[0 + ee] = y >>> 24,
        k[1 + ee] = y >>> 16 & 255,
        k[2 + ee] = y >>> 8 & 255,
        k[3 + ee] = y & 255
    }
    ,
    utils$5.ip = function(k, y, ee, dt) {
        for (var mt = 0, yt = 0, pt = 6; pt >= 0; pt -= 2) {
            for (var bt = 0; bt <= 24; bt += 8)
                mt <<= 1,
                mt |= y >>> bt + pt & 1;
            for (var bt = 0; bt <= 24; bt += 8)
                mt <<= 1,
                mt |= k >>> bt + pt & 1
        }
        for (var pt = 6; pt >= 0; pt -= 2) {
            for (var bt = 1; bt <= 25; bt += 8)
                yt <<= 1,
                yt |= y >>> bt + pt & 1;
            for (var bt = 1; bt <= 25; bt += 8)
                yt <<= 1,
                yt |= k >>> bt + pt & 1
        }
        ee[dt + 0] = mt >>> 0,
        ee[dt + 1] = yt >>> 0
    }
    ,
    utils$5.rip = function(k, y, ee, dt) {
        for (var mt = 0, yt = 0, pt = 0; pt < 4; pt++)
            for (var bt = 24; bt >= 0; bt -= 8)
                mt <<= 1,
                mt |= y >>> bt + pt & 1,
                mt <<= 1,
                mt |= k >>> bt + pt & 1;
        for (var pt = 4; pt < 8; pt++)
            for (var bt = 24; bt >= 0; bt -= 8)
                yt <<= 1,
                yt |= y >>> bt + pt & 1,
                yt <<= 1,
                yt |= k >>> bt + pt & 1;
        ee[dt + 0] = mt >>> 0,
        ee[dt + 1] = yt >>> 0
    }
    ,
    utils$5.pc1 = function(k, y, ee, dt) {
        for (var mt = 0, yt = 0, pt = 7; pt >= 5; pt--) {
            for (var bt = 0; bt <= 24; bt += 8)
                mt <<= 1,
                mt |= y >> bt + pt & 1;
            for (var bt = 0; bt <= 24; bt += 8)
                mt <<= 1,
                mt |= k >> bt + pt & 1
        }
        for (var bt = 0; bt <= 24; bt += 8)
            mt <<= 1,
            mt |= y >> bt + pt & 1;
        for (var pt = 1; pt <= 3; pt++) {
            for (var bt = 0; bt <= 24; bt += 8)
                yt <<= 1,
                yt |= y >> bt + pt & 1;
            for (var bt = 0; bt <= 24; bt += 8)
                yt <<= 1,
                yt |= k >> bt + pt & 1
        }
        for (var bt = 0; bt <= 24; bt += 8)
            yt <<= 1,
            yt |= k >> bt + pt & 1;
        ee[dt + 0] = mt >>> 0,
        ee[dt + 1] = yt >>> 0
    }
    ,
    utils$5.r28shl = function(k, y) {
        return k << y & 268435455 | k >>> 28 - y
    }
    ;
    var r = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
    utils$5.pc2 = function(k, y, ee, dt) {
        for (var mt = 0, yt = 0, pt = r.length >>> 1, bt = 0; bt < pt; bt++)
            mt <<= 1,
            mt |= k >>> r[bt] & 1;
        for (var bt = pt; bt < r.length; bt++)
            yt <<= 1,
            yt |= y >>> r[bt] & 1;
        ee[dt + 0] = mt >>> 0,
        ee[dt + 1] = yt >>> 0
    }
    ,
    utils$5.expand = function(k, y, ee) {
        var dt = 0
          , mt = 0;
        dt = (k & 1) << 5 | k >>> 27;
        for (var yt = 23; yt >= 15; yt -= 4)
            dt <<= 6,
            dt |= k >>> yt & 63;
        for (var yt = 11; yt >= 3; yt -= 4)
            mt |= k >>> yt & 63,
            mt <<= 6;
        mt |= (k & 31) << 1 | k >>> 31,
        y[ee + 0] = dt >>> 0,
        y[ee + 1] = mt >>> 0
    }
    ;
    var d = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
    utils$5.substitute = function(k, y) {
        for (var ee = 0, dt = 0; dt < 4; dt++) {
            var mt = k >>> 18 - dt * 6 & 63
              , yt = d[dt * 64 + mt];
            ee <<= 4,
            ee |= yt
        }
        for (var dt = 0; dt < 4; dt++) {
            var mt = y >>> 18 - dt * 6 & 63
              , yt = d[4 * 64 + dt * 64 + mt];
            ee <<= 4,
            ee |= yt
        }
        return ee >>> 0
    }
    ;
    var f = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
    return utils$5.permute = function(k) {
        for (var y = 0, ee = 0; ee < f.length; ee++)
            y <<= 1,
            y |= k >>> f[ee] & 1;
        return y >>> 0
    }
    ,
    utils$5.padSplit = function(k, y, ee) {
        for (var dt = k.toString(2); dt.length < y; )
            dt = "0" + dt;
        for (var mt = [], yt = 0; yt < y; yt += ee)
            mt.push(dt.slice(yt, yt + ee));
        return mt.join(" ")
    }
    ,
    utils$5
}
var minimalisticAssert, hasRequiredMinimalisticAssert;
function requireMinimalisticAssert() {
    if (hasRequiredMinimalisticAssert)
        return minimalisticAssert;
    hasRequiredMinimalisticAssert = 1,
    minimalisticAssert = r;
    function r(d, f) {
        if (!d)
            throw new Error(f || "Assertion failed")
    }
    return r.equal = function(f, m, k) {
        if (f != m)
            throw new Error(k || "Assertion failed: " + f + " != " + m)
    }
    ,
    minimalisticAssert
}
var cipher, hasRequiredCipher;
function requireCipher() {
    if (hasRequiredCipher)
        return cipher;
    hasRequiredCipher = 1;
    var r = requireMinimalisticAssert();
    function d(f) {
        this.options = f,
        this.type = this.options.type,
        this.blockSize = 8,
        this._init(),
        this.buffer = new Array(this.blockSize),
        this.bufferOff = 0,
        this.padding = f.padding !== !1
    }
    return cipher = d,
    d.prototype._init = function() {}
    ,
    d.prototype.update = function(m) {
        return m.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(m) : this._updateEncrypt(m)
    }
    ,
    d.prototype._buffer = function(m, k) {
        for (var y = Math.min(this.buffer.length - this.bufferOff, m.length - k), ee = 0; ee < y; ee++)
            this.buffer[this.bufferOff + ee] = m[k + ee];
        return this.bufferOff += y,
        y
    }
    ,
    d.prototype._flushBuffer = function(m, k) {
        return this._update(this.buffer, 0, m, k),
        this.bufferOff = 0,
        this.blockSize
    }
    ,
    d.prototype._updateEncrypt = function(m) {
        var k = 0
          , y = 0
          , ee = (this.bufferOff + m.length) / this.blockSize | 0
          , dt = new Array(ee * this.blockSize);
        this.bufferOff !== 0 && (k += this._buffer(m, k),
        this.bufferOff === this.buffer.length && (y += this._flushBuffer(dt, y)));
        for (var mt = m.length - (m.length - k) % this.blockSize; k < mt; k += this.blockSize)
            this._update(m, k, dt, y),
            y += this.blockSize;
        for (; k < m.length; k++,
        this.bufferOff++)
            this.buffer[this.bufferOff] = m[k];
        return dt
    }
    ,
    d.prototype._updateDecrypt = function(m) {
        for (var k = 0, y = 0, ee = Math.ceil((this.bufferOff + m.length) / this.blockSize) - 1, dt = new Array(ee * this.blockSize); ee > 0; ee--)
            k += this._buffer(m, k),
            y += this._flushBuffer(dt, y);
        return k += this._buffer(m, k),
        dt
    }
    ,
    d.prototype.final = function(m) {
        var k;
        m && (k = this.update(m));
        var y;
        return this.type === "encrypt" ? y = this._finalEncrypt() : y = this._finalDecrypt(),
        k ? k.concat(y) : y
    }
    ,
    d.prototype._pad = function(m, k) {
        if (k === 0)
            return !1;
        for (; k < m.length; )
            m[k++] = 0;
        return !0
    }
    ,
    d.prototype._finalEncrypt = function() {
        if (!this._pad(this.buffer, this.bufferOff))
            return [];
        var m = new Array(this.blockSize);
        return this._update(this.buffer, 0, m, 0),
        m
    }
    ,
    d.prototype._unpad = function(m) {
        return m
    }
    ,
    d.prototype._finalDecrypt = function() {
        r.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
        var m = new Array(this.blockSize);
        return this._flushBuffer(m, 0),
        this._unpad(m)
    }
    ,
    cipher
}
var des, hasRequiredDes$1;
function requireDes$1() {
    if (hasRequiredDes$1)
        return des;
    hasRequiredDes$1 = 1;
    var r = requireMinimalisticAssert()
      , d = requireInherits_browser()
      , f = requireUtils$3()
      , m = requireCipher();
    function k() {
        this.tmp = new Array(2),
        this.keys = null
    }
    function y(dt) {
        m.call(this, dt);
        var mt = new k;
        this._desState = mt,
        this.deriveKeys(mt, dt.key)
    }
    d(y, m),
    des = y,
    y.create = function(mt) {
        return new y(mt)
    }
    ;
    var ee = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
    return y.prototype.deriveKeys = function(mt, yt) {
        mt.keys = new Array(16 * 2),
        r.equal(yt.length, this.blockSize, "Invalid key length");
        var pt = f.readUInt32BE(yt, 0)
          , bt = f.readUInt32BE(yt, 4);
        f.pc1(pt, bt, mt.tmp, 0),
        pt = mt.tmp[0],
        bt = mt.tmp[1];
        for (var wt = 0; wt < mt.keys.length; wt += 2) {
            var xt = ee[wt >>> 1];
            pt = f.r28shl(pt, xt),
            bt = f.r28shl(bt, xt),
            f.pc2(pt, bt, mt.keys, wt)
        }
    }
    ,
    y.prototype._update = function(mt, yt, pt, bt) {
        var wt = this._desState
          , xt = f.readUInt32BE(mt, yt)
          , At = f.readUInt32BE(mt, yt + 4);
        f.ip(xt, At, wt.tmp, 0),
        xt = wt.tmp[0],
        At = wt.tmp[1],
        this.type === "encrypt" ? this._encrypt(wt, xt, At, wt.tmp, 0) : this._decrypt(wt, xt, At, wt.tmp, 0),
        xt = wt.tmp[0],
        At = wt.tmp[1],
        f.writeUInt32BE(pt, xt, bt),
        f.writeUInt32BE(pt, At, bt + 4)
    }
    ,
    y.prototype._pad = function(mt, yt) {
        if (this.padding === !1)
            return !1;
        for (var pt = mt.length - yt, bt = yt; bt < mt.length; bt++)
            mt[bt] = pt;
        return !0
    }
    ,
    y.prototype._unpad = function(mt) {
        if (this.padding === !1)
            return mt;
        for (var yt = mt[mt.length - 1], pt = mt.length - yt; pt < mt.length; pt++)
            r.equal(mt[pt], yt);
        return mt.slice(0, mt.length - yt)
    }
    ,
    y.prototype._encrypt = function(mt, yt, pt, bt, wt) {
        for (var xt = yt, At = pt, Ct = 0; Ct < mt.keys.length; Ct += 2) {
            var Pt = mt.keys[Ct]
              , $t = mt.keys[Ct + 1];
            f.expand(At, mt.tmp, 0),
            Pt ^= mt.tmp[0],
            $t ^= mt.tmp[1];
            var Ot = f.substitute(Pt, $t)
              , Nt = f.permute(Ot)
              , zt = At;
            At = (xt ^ Nt) >>> 0,
            xt = zt
        }
        f.rip(At, xt, bt, wt)
    }
    ,
    y.prototype._decrypt = function(mt, yt, pt, bt, wt) {
        for (var xt = pt, At = yt, Ct = mt.keys.length - 2; Ct >= 0; Ct -= 2) {
            var Pt = mt.keys[Ct]
              , $t = mt.keys[Ct + 1];
            f.expand(xt, mt.tmp, 0),
            Pt ^= mt.tmp[0],
            $t ^= mt.tmp[1];
            var Ot = f.substitute(Pt, $t)
              , Nt = f.permute(Ot)
              , zt = xt;
            xt = (At ^ Nt) >>> 0,
            At = zt
        }
        f.rip(xt, At, bt, wt)
    }
    ,
    des
}
var cbc$1 = {}, hasRequiredCbc$1;
function requireCbc$1() {
    if (hasRequiredCbc$1)
        return cbc$1;
    hasRequiredCbc$1 = 1;
    var r = requireMinimalisticAssert()
      , d = requireInherits_browser()
      , f = {};
    function m(y) {
        r.equal(y.length, 8, "Invalid IV length"),
        this.iv = new Array(8);
        for (var ee = 0; ee < this.iv.length; ee++)
            this.iv[ee] = y[ee]
    }
    function k(y) {
        function ee(pt) {
            y.call(this, pt),
            this._cbcInit()
        }
        d(ee, y);
        for (var dt = Object.keys(f), mt = 0; mt < dt.length; mt++) {
            var yt = dt[mt];
            ee.prototype[yt] = f[yt]
        }
        return ee.create = function(bt) {
            return new ee(bt)
        }
        ,
        ee
    }
    return cbc$1.instantiate = k,
    f._cbcInit = function() {
        var ee = new m(this.options.iv);
        this._cbcState = ee
    }
    ,
    f._update = function(ee, dt, mt, yt) {
        var pt = this._cbcState
          , bt = this.constructor.super_.prototype
          , wt = pt.iv;
        if (this.type === "encrypt") {
            for (var xt = 0; xt < this.blockSize; xt++)
                wt[xt] ^= ee[dt + xt];
            bt._update.call(this, wt, 0, mt, yt);
            for (var xt = 0; xt < this.blockSize; xt++)
                wt[xt] = mt[yt + xt]
        } else {
            bt._update.call(this, ee, dt, mt, yt);
            for (var xt = 0; xt < this.blockSize; xt++)
                mt[yt + xt] ^= wt[xt];
            for (var xt = 0; xt < this.blockSize; xt++)
                wt[xt] = ee[dt + xt]
        }
    }
    ,
    cbc$1
}
var ede, hasRequiredEde;
function requireEde() {
    if (hasRequiredEde)
        return ede;
    hasRequiredEde = 1;
    var r = requireMinimalisticAssert()
      , d = requireInherits_browser()
      , f = requireCipher()
      , m = requireDes$1();
    function k(ee, dt) {
        r.equal(dt.length, 24, "Invalid key length");
        var mt = dt.slice(0, 8)
          , yt = dt.slice(8, 16)
          , pt = dt.slice(16, 24);
        ee === "encrypt" ? this.ciphers = [m.create({
            type: "encrypt",
            key: mt
        }), m.create({
            type: "decrypt",
            key: yt
        }), m.create({
            type: "encrypt",
            key: pt
        })] : this.ciphers = [m.create({
            type: "decrypt",
            key: pt
        }), m.create({
            type: "encrypt",
            key: yt
        }), m.create({
            type: "decrypt",
            key: mt
        })]
    }
    function y(ee) {
        f.call(this, ee);
        var dt = new k(this.type,this.options.key);
        this._edeState = dt
    }
    return d(y, f),
    ede = y,
    y.create = function(dt) {
        return new y(dt)
    }
    ,
    y.prototype._update = function(dt, mt, yt, pt) {
        var bt = this._edeState;
        bt.ciphers[0]._update(dt, mt, yt, pt),
        bt.ciphers[1]._update(yt, pt, yt, pt),
        bt.ciphers[2]._update(yt, pt, yt, pt)
    }
    ,
    y.prototype._pad = m.prototype._pad,
    y.prototype._unpad = m.prototype._unpad,
    ede
}
var hasRequiredDes;
function requireDes() {
    return hasRequiredDes || (hasRequiredDes = 1,
    des$1.utils = requireUtils$3(),
    des$1.Cipher = requireCipher(),
    des$1.DES = requireDes$1(),
    des$1.CBC = requireCbc$1(),
    des$1.EDE = requireEde()),
    des$1
}
var browserifyDes, hasRequiredBrowserifyDes;
function requireBrowserifyDes() {
    if (hasRequiredBrowserifyDes)
        return browserifyDes;
    hasRequiredBrowserifyDes = 1;
    var r = requireCipherBase()
      , d = requireDes()
      , f = requireInherits_browser()
      , m = requireSafeBuffer$1().Buffer
      , k = {
        "des-ede3-cbc": d.CBC.instantiate(d.EDE),
        "des-ede3": d.EDE,
        "des-ede-cbc": d.CBC.instantiate(d.EDE),
        "des-ede": d.EDE,
        "des-cbc": d.CBC.instantiate(d.DES),
        "des-ecb": d.DES
    };
    k.des = k["des-cbc"],
    k.des3 = k["des-ede3-cbc"],
    browserifyDes = y,
    f(y, r);
    function y(ee) {
        r.call(this);
        var dt = ee.mode.toLowerCase(), mt = k[dt], yt;
        ee.decrypt ? yt = "decrypt" : yt = "encrypt";
        var pt = ee.key;
        m.isBuffer(pt) || (pt = m.from(pt)),
        (dt === "des-ede" || dt === "des-ede-cbc") && (pt = m.concat([pt, pt.slice(0, 8)]));
        var bt = ee.iv;
        m.isBuffer(bt) || (bt = m.from(bt)),
        this._des = mt.create({
            key: pt,
            iv: bt,
            type: yt
        })
    }
    return y.prototype._update = function(ee) {
        return m.from(this._des.update(ee))
    }
    ,
    y.prototype._final = function() {
        return m.from(this._des.final())
    }
    ,
    browserifyDes
}
var browser$6 = {}, encrypter = {}, ecb = {}, hasRequiredEcb;
function requireEcb() {
    return hasRequiredEcb || (hasRequiredEcb = 1,
    ecb.encrypt = function(r, d) {
        return r._cipher.encryptBlock(d)
    }
    ,
    ecb.decrypt = function(r, d) {
        return r._cipher.decryptBlock(d)
    }
    ),
    ecb
}
var cbc = {}, bufferXor, hasRequiredBufferXor;
function requireBufferXor() {
    return hasRequiredBufferXor || (hasRequiredBufferXor = 1,
    bufferXor = function(d, f) {
        for (var m = Math.min(d.length, f.length), k = new Buffer(m), y = 0; y < m; ++y)
            k[y] = d[y] ^ f[y];
        return k
    }
    ),
    bufferXor
}
var hasRequiredCbc;
function requireCbc() {
    if (hasRequiredCbc)
        return cbc;
    hasRequiredCbc = 1;
    var r = requireBufferXor();
    return cbc.encrypt = function(d, f) {
        var m = r(f, d._prev);
        return d._prev = d._cipher.encryptBlock(m),
        d._prev
    }
    ,
    cbc.decrypt = function(d, f) {
        var m = d._prev;
        d._prev = f;
        var k = d._cipher.decryptBlock(f);
        return r(k, m)
    }
    ,
    cbc
}
var cfb = {}, hasRequiredCfb;
function requireCfb() {
    if (hasRequiredCfb)
        return cfb;
    hasRequiredCfb = 1;
    var r = requireSafeBuffer$1().Buffer
      , d = requireBufferXor();
    function f(m, k, y) {
        var ee = k.length
          , dt = d(k, m._cache);
        return m._cache = m._cache.slice(ee),
        m._prev = r.concat([m._prev, y ? k : dt]),
        dt
    }
    return cfb.encrypt = function(m, k, y) {
        for (var ee = r.allocUnsafe(0), dt; k.length; )
            if (m._cache.length === 0 && (m._cache = m._cipher.encryptBlock(m._prev),
            m._prev = r.allocUnsafe(0)),
            m._cache.length <= k.length)
                dt = m._cache.length,
                ee = r.concat([ee, f(m, k.slice(0, dt), y)]),
                k = k.slice(dt);
            else {
                ee = r.concat([ee, f(m, k, y)]);
                break
            }
        return ee
    }
    ,
    cfb
}
var cfb8 = {}, hasRequiredCfb8;
function requireCfb8() {
    if (hasRequiredCfb8)
        return cfb8;
    hasRequiredCfb8 = 1;
    var r = requireSafeBuffer$1().Buffer;
    function d(f, m, k) {
        var y = f._cipher.encryptBlock(f._prev)
          , ee = y[0] ^ m;
        return f._prev = r.concat([f._prev.slice(1), r.from([k ? m : ee])]),
        ee
    }
    return cfb8.encrypt = function(f, m, k) {
        for (var y = m.length, ee = r.allocUnsafe(y), dt = -1; ++dt < y; )
            ee[dt] = d(f, m[dt], k);
        return ee
    }
    ,
    cfb8
}
var cfb1 = {}, hasRequiredCfb1;
function requireCfb1() {
    if (hasRequiredCfb1)
        return cfb1;
    hasRequiredCfb1 = 1;
    var r = requireSafeBuffer$1().Buffer;
    function d(m, k, y) {
        for (var ee, dt = -1, mt = 8, yt = 0, pt, bt; ++dt < mt; )
            ee = m._cipher.encryptBlock(m._prev),
            pt = k & 1 << 7 - dt ? 128 : 0,
            bt = ee[0] ^ pt,
            yt += (bt & 128) >> dt % 8,
            m._prev = f(m._prev, y ? pt : bt);
        return yt
    }
    function f(m, k) {
        var y = m.length
          , ee = -1
          , dt = r.allocUnsafe(m.length);
        for (m = r.concat([m, r.from([k])]); ++ee < y; )
            dt[ee] = m[ee] << 1 | m[ee + 1] >> 7;
        return dt
    }
    return cfb1.encrypt = function(m, k, y) {
        for (var ee = k.length, dt = r.allocUnsafe(ee), mt = -1; ++mt < ee; )
            dt[mt] = d(m, k[mt], y);
        return dt
    }
    ,
    cfb1
}
var ofb = {}, hasRequiredOfb;
function requireOfb() {
    if (hasRequiredOfb)
        return ofb;
    hasRequiredOfb = 1;
    var r = requireBufferXor();
    function d(f) {
        return f._prev = f._cipher.encryptBlock(f._prev),
        f._prev
    }
    return ofb.encrypt = function(f, m) {
        for (; f._cache.length < m.length; )
            f._cache = Buffer.concat([f._cache, d(f)]);
        var k = f._cache.slice(0, m.length);
        return f._cache = f._cache.slice(m.length),
        r(m, k)
    }
    ,
    ofb
}
var ctr = {}, incr32_1, hasRequiredIncr32;
function requireIncr32() {
    if (hasRequiredIncr32)
        return incr32_1;
    hasRequiredIncr32 = 1;
    function r(d) {
        for (var f = d.length, m; f--; )
            if (m = d.readUInt8(f),
            m === 255)
                d.writeUInt8(0, f);
            else {
                m++,
                d.writeUInt8(m, f);
                break
            }
    }
    return incr32_1 = r,
    incr32_1
}
var hasRequiredCtr;
function requireCtr() {
    if (hasRequiredCtr)
        return ctr;
    hasRequiredCtr = 1;
    var r = requireBufferXor()
      , d = requireSafeBuffer$1().Buffer
      , f = requireIncr32();
    function m(y) {
        var ee = y._cipher.encryptBlockRaw(y._prev);
        return f(y._prev),
        ee
    }
    var k = 16;
    return ctr.encrypt = function(y, ee) {
        var dt = Math.ceil(ee.length / k)
          , mt = y._cache.length;
        y._cache = d.concat([y._cache, d.allocUnsafe(dt * k)]);
        for (var yt = 0; yt < dt; yt++) {
            var pt = m(y)
              , bt = mt + yt * k;
            y._cache.writeUInt32BE(pt[0], bt + 0),
            y._cache.writeUInt32BE(pt[1], bt + 4),
            y._cache.writeUInt32BE(pt[2], bt + 8),
            y._cache.writeUInt32BE(pt[3], bt + 12)
        }
        var wt = y._cache.slice(0, ee.length);
        return y._cache = y._cache.slice(ee.length),
        r(ee, wt)
    }
    ,
    ctr
}
const aes128 = {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
}
  , aes192 = {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
}
  , aes256 = {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
}
  , require$$2 = {
    "aes-128-ecb": {
        cipher: "AES",
        key: 128,
        iv: 0,
        mode: "ECB",
        type: "block"
    },
    "aes-192-ecb": {
        cipher: "AES",
        key: 192,
        iv: 0,
        mode: "ECB",
        type: "block"
    },
    "aes-256-ecb": {
        cipher: "AES",
        key: 256,
        iv: 0,
        mode: "ECB",
        type: "block"
    },
    "aes-128-cbc": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    "aes-192-cbc": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    "aes-256-cbc": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    aes128,
    aes192,
    aes256,
    "aes-128-cfb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB",
        type: "stream"
    },
    "aes-192-cfb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB",
        type: "stream"
    },
    "aes-256-cfb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB",
        type: "stream"
    },
    "aes-128-cfb8": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB8",
        type: "stream"
    },
    "aes-192-cfb8": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB8",
        type: "stream"
    },
    "aes-256-cfb8": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB8",
        type: "stream"
    },
    "aes-128-cfb1": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB1",
        type: "stream"
    },
    "aes-192-cfb1": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB1",
        type: "stream"
    },
    "aes-256-cfb1": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB1",
        type: "stream"
    },
    "aes-128-ofb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "OFB",
        type: "stream"
    },
    "aes-192-ofb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "OFB",
        type: "stream"
    },
    "aes-256-ofb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "OFB",
        type: "stream"
    },
    "aes-128-ctr": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CTR",
        type: "stream"
    },
    "aes-192-ctr": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CTR",
        type: "stream"
    },
    "aes-256-ctr": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CTR",
        type: "stream"
    },
    "aes-128-gcm": {
        cipher: "AES",
        key: 128,
        iv: 12,
        mode: "GCM",
        type: "auth"
    },
    "aes-192-gcm": {
        cipher: "AES",
        key: 192,
        iv: 12,
        mode: "GCM",
        type: "auth"
    },
    "aes-256-gcm": {
        cipher: "AES",
        key: 256,
        iv: 12,
        mode: "GCM",
        type: "auth"
    }
};
var modes_1, hasRequiredModes$1;
function requireModes$1() {
    if (hasRequiredModes$1)
        return modes_1;
    hasRequiredModes$1 = 1;
    var r = {
        ECB: requireEcb(),
        CBC: requireCbc(),
        CFB: requireCfb(),
        CFB8: requireCfb8(),
        CFB1: requireCfb1(),
        OFB: requireOfb(),
        CTR: requireCtr(),
        GCM: requireCtr()
    }
      , d = require$$2;
    for (var f in d)
        d[f].module = r[d[f].mode];
    return modes_1 = d,
    modes_1
}
var aes = {}, hasRequiredAes;
function requireAes() {
    if (hasRequiredAes)
        return aes;
    hasRequiredAes = 1;
    var r = requireSafeBuffer$1().Buffer;
    function d(dt) {
        r.isBuffer(dt) || (dt = r.from(dt));
        for (var mt = dt.length / 4 | 0, yt = new Array(mt), pt = 0; pt < mt; pt++)
            yt[pt] = dt.readUInt32BE(pt * 4);
        return yt
    }
    function f(dt) {
        for (var mt = 0; mt < dt.length; dt++)
            dt[mt] = 0
    }
    function m(dt, mt, yt, pt, bt) {
        for (var wt = yt[0], xt = yt[1], At = yt[2], Ct = yt[3], Pt = dt[0] ^ mt[0], $t = dt[1] ^ mt[1], Ot = dt[2] ^ mt[2], Nt = dt[3] ^ mt[3], zt, Wt, Kt, ir, or = 4, tr = 1; tr < bt; tr++)
            zt = wt[Pt >>> 24] ^ xt[$t >>> 16 & 255] ^ At[Ot >>> 8 & 255] ^ Ct[Nt & 255] ^ mt[or++],
            Wt = wt[$t >>> 24] ^ xt[Ot >>> 16 & 255] ^ At[Nt >>> 8 & 255] ^ Ct[Pt & 255] ^ mt[or++],
            Kt = wt[Ot >>> 24] ^ xt[Nt >>> 16 & 255] ^ At[Pt >>> 8 & 255] ^ Ct[$t & 255] ^ mt[or++],
            ir = wt[Nt >>> 24] ^ xt[Pt >>> 16 & 255] ^ At[$t >>> 8 & 255] ^ Ct[Ot & 255] ^ mt[or++],
            Pt = zt,
            $t = Wt,
            Ot = Kt,
            Nt = ir;
        return zt = (pt[Pt >>> 24] << 24 | pt[$t >>> 16 & 255] << 16 | pt[Ot >>> 8 & 255] << 8 | pt[Nt & 255]) ^ mt[or++],
        Wt = (pt[$t >>> 24] << 24 | pt[Ot >>> 16 & 255] << 16 | pt[Nt >>> 8 & 255] << 8 | pt[Pt & 255]) ^ mt[or++],
        Kt = (pt[Ot >>> 24] << 24 | pt[Nt >>> 16 & 255] << 16 | pt[Pt >>> 8 & 255] << 8 | pt[$t & 255]) ^ mt[or++],
        ir = (pt[Nt >>> 24] << 24 | pt[Pt >>> 16 & 255] << 16 | pt[$t >>> 8 & 255] << 8 | pt[Ot & 255]) ^ mt[or++],
        zt = zt >>> 0,
        Wt = Wt >>> 0,
        Kt = Kt >>> 0,
        ir = ir >>> 0,
        [zt, Wt, Kt, ir]
    }
    var k = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54]
      , y = function() {
        for (var dt = new Array(256), mt = 0; mt < 256; mt++)
            mt < 128 ? dt[mt] = mt << 1 : dt[mt] = mt << 1 ^ 283;
        for (var yt = [], pt = [], bt = [[], [], [], []], wt = [[], [], [], []], xt = 0, At = 0, Ct = 0; Ct < 256; ++Ct) {
            var Pt = At ^ At << 1 ^ At << 2 ^ At << 3 ^ At << 4;
            Pt = Pt >>> 8 ^ Pt & 255 ^ 99,
            yt[xt] = Pt,
            pt[Pt] = xt;
            var $t = dt[xt]
              , Ot = dt[$t]
              , Nt = dt[Ot]
              , zt = dt[Pt] * 257 ^ Pt * 16843008;
            bt[0][xt] = zt << 24 | zt >>> 8,
            bt[1][xt] = zt << 16 | zt >>> 16,
            bt[2][xt] = zt << 8 | zt >>> 24,
            bt[3][xt] = zt,
            zt = Nt * 16843009 ^ Ot * 65537 ^ $t * 257 ^ xt * 16843008,
            wt[0][Pt] = zt << 24 | zt >>> 8,
            wt[1][Pt] = zt << 16 | zt >>> 16,
            wt[2][Pt] = zt << 8 | zt >>> 24,
            wt[3][Pt] = zt,
            xt === 0 ? xt = At = 1 : (xt = $t ^ dt[dt[dt[Nt ^ $t]]],
            At ^= dt[dt[At]])
        }
        return {
            SBOX: yt,
            INV_SBOX: pt,
            SUB_MIX: bt,
            INV_SUB_MIX: wt
        }
    }();
    function ee(dt) {
        this._key = d(dt),
        this._reset()
    }
    return ee.blockSize = 4 * 4,
    ee.keySize = 256 / 8,
    ee.prototype.blockSize = ee.blockSize,
    ee.prototype.keySize = ee.keySize,
    ee.prototype._reset = function() {
        for (var dt = this._key, mt = dt.length, yt = mt + 6, pt = (yt + 1) * 4, bt = [], wt = 0; wt < mt; wt++)
            bt[wt] = dt[wt];
        for (wt = mt; wt < pt; wt++) {
            var xt = bt[wt - 1];
            wt % mt === 0 ? (xt = xt << 8 | xt >>> 24,
            xt = y.SBOX[xt >>> 24] << 24 | y.SBOX[xt >>> 16 & 255] << 16 | y.SBOX[xt >>> 8 & 255] << 8 | y.SBOX[xt & 255],
            xt ^= k[wt / mt | 0] << 24) : mt > 6 && wt % mt === 4 && (xt = y.SBOX[xt >>> 24] << 24 | y.SBOX[xt >>> 16 & 255] << 16 | y.SBOX[xt >>> 8 & 255] << 8 | y.SBOX[xt & 255]),
            bt[wt] = bt[wt - mt] ^ xt
        }
        for (var At = [], Ct = 0; Ct < pt; Ct++) {
            var Pt = pt - Ct
              , $t = bt[Pt - (Ct % 4 ? 0 : 4)];
            Ct < 4 || Pt <= 4 ? At[Ct] = $t : At[Ct] = y.INV_SUB_MIX[0][y.SBOX[$t >>> 24]] ^ y.INV_SUB_MIX[1][y.SBOX[$t >>> 16 & 255]] ^ y.INV_SUB_MIX[2][y.SBOX[$t >>> 8 & 255]] ^ y.INV_SUB_MIX[3][y.SBOX[$t & 255]]
        }
        this._nRounds = yt,
        this._keySchedule = bt,
        this._invKeySchedule = At
    }
    ,
    ee.prototype.encryptBlockRaw = function(dt) {
        return dt = d(dt),
        m(dt, this._keySchedule, y.SUB_MIX, y.SBOX, this._nRounds)
    }
    ,
    ee.prototype.encryptBlock = function(dt) {
        var mt = this.encryptBlockRaw(dt)
          , yt = r.allocUnsafe(16);
        return yt.writeUInt32BE(mt[0], 0),
        yt.writeUInt32BE(mt[1], 4),
        yt.writeUInt32BE(mt[2], 8),
        yt.writeUInt32BE(mt[3], 12),
        yt
    }
    ,
    ee.prototype.decryptBlock = function(dt) {
        dt = d(dt);
        var mt = dt[1];
        dt[1] = dt[3],
        dt[3] = mt;
        var yt = m(dt, this._invKeySchedule, y.INV_SUB_MIX, y.INV_SBOX, this._nRounds)
          , pt = r.allocUnsafe(16);
        return pt.writeUInt32BE(yt[0], 0),
        pt.writeUInt32BE(yt[3], 4),
        pt.writeUInt32BE(yt[2], 8),
        pt.writeUInt32BE(yt[1], 12),
        pt
    }
    ,
    ee.prototype.scrub = function() {
        f(this._keySchedule),
        f(this._invKeySchedule),
        f(this._key)
    }
    ,
    aes.AES = ee,
    aes
}
var ghash, hasRequiredGhash;
function requireGhash() {
    if (hasRequiredGhash)
        return ghash;
    hasRequiredGhash = 1;
    var r = requireSafeBuffer$1().Buffer
      , d = r.alloc(16, 0);
    function f(y) {
        return [y.readUInt32BE(0), y.readUInt32BE(4), y.readUInt32BE(8), y.readUInt32BE(12)]
    }
    function m(y) {
        var ee = r.allocUnsafe(16);
        return ee.writeUInt32BE(y[0] >>> 0, 0),
        ee.writeUInt32BE(y[1] >>> 0, 4),
        ee.writeUInt32BE(y[2] >>> 0, 8),
        ee.writeUInt32BE(y[3] >>> 0, 12),
        ee
    }
    function k(y) {
        this.h = y,
        this.state = r.alloc(16, 0),
        this.cache = r.allocUnsafe(0)
    }
    return k.prototype.ghash = function(y) {
        for (var ee = -1; ++ee < y.length; )
            this.state[ee] ^= y[ee];
        this._multiply()
    }
    ,
    k.prototype._multiply = function() {
        for (var y = f(this.h), ee = [0, 0, 0, 0], dt, mt, yt, pt = -1; ++pt < 128; ) {
            for (mt = (this.state[~~(pt / 8)] & 1 << 7 - pt % 8) !== 0,
            mt && (ee[0] ^= y[0],
            ee[1] ^= y[1],
            ee[2] ^= y[2],
            ee[3] ^= y[3]),
            yt = (y[3] & 1) !== 0,
            dt = 3; dt > 0; dt--)
                y[dt] = y[dt] >>> 1 | (y[dt - 1] & 1) << 31;
            y[0] = y[0] >>> 1,
            yt && (y[0] = y[0] ^ 225 << 24)
        }
        this.state = m(ee)
    }
    ,
    k.prototype.update = function(y) {
        this.cache = r.concat([this.cache, y]);
        for (var ee; this.cache.length >= 16; )
            ee = this.cache.slice(0, 16),
            this.cache = this.cache.slice(16),
            this.ghash(ee)
    }
    ,
    k.prototype.final = function(y, ee) {
        return this.cache.length && this.ghash(r.concat([this.cache, d], 16)),
        this.ghash(m([0, y, 0, ee])),
        this.state
    }
    ,
    ghash = k,
    ghash
}
var authCipher, hasRequiredAuthCipher;
function requireAuthCipher() {
    if (hasRequiredAuthCipher)
        return authCipher;
    hasRequiredAuthCipher = 1;
    var r = requireAes()
      , d = requireSafeBuffer$1().Buffer
      , f = requireCipherBase()
      , m = requireInherits_browser()
      , k = requireGhash()
      , y = requireBufferXor()
      , ee = requireIncr32();
    function dt(pt, bt) {
        var wt = 0;
        pt.length !== bt.length && wt++;
        for (var xt = Math.min(pt.length, bt.length), At = 0; At < xt; ++At)
            wt += pt[At] ^ bt[At];
        return wt
    }
    function mt(pt, bt, wt) {
        if (bt.length === 12)
            return pt._finID = d.concat([bt, d.from([0, 0, 0, 1])]),
            d.concat([bt, d.from([0, 0, 0, 2])]);
        var xt = new k(wt)
          , At = bt.length
          , Ct = At % 16;
        xt.update(bt),
        Ct && (Ct = 16 - Ct,
        xt.update(d.alloc(Ct, 0))),
        xt.update(d.alloc(8, 0));
        var Pt = At * 8
          , $t = d.alloc(8);
        $t.writeUIntBE(Pt, 0, 8),
        xt.update($t),
        pt._finID = xt.state;
        var Ot = d.from(pt._finID);
        return ee(Ot),
        Ot
    }
    function yt(pt, bt, wt, xt) {
        f.call(this);
        var At = d.alloc(4, 0);
        this._cipher = new r.AES(bt);
        var Ct = this._cipher.encryptBlock(At);
        this._ghash = new k(Ct),
        wt = mt(this, wt, Ct),
        this._prev = d.from(wt),
        this._cache = d.allocUnsafe(0),
        this._secCache = d.allocUnsafe(0),
        this._decrypt = xt,
        this._alen = 0,
        this._len = 0,
        this._mode = pt,
        this._authTag = null,
        this._called = !1
    }
    return m(yt, f),
    yt.prototype._update = function(pt) {
        if (!this._called && this._alen) {
            var bt = 16 - this._alen % 16;
            bt < 16 && (bt = d.alloc(bt, 0),
            this._ghash.update(bt))
        }
        this._called = !0;
        var wt = this._mode.encrypt(this, pt);
        return this._decrypt ? this._ghash.update(pt) : this._ghash.update(wt),
        this._len += pt.length,
        wt
    }
    ,
    yt.prototype._final = function() {
        if (this._decrypt && !this._authTag)
            throw new Error("Unsupported state or unable to authenticate data");
        var pt = y(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
        if (this._decrypt && dt(pt, this._authTag))
            throw new Error("Unsupported state or unable to authenticate data");
        this._authTag = pt,
        this._cipher.scrub()
    }
    ,
    yt.prototype.getAuthTag = function() {
        if (this._decrypt || !d.isBuffer(this._authTag))
            throw new Error("Attempting to get auth tag in unsupported state");
        return this._authTag
    }
    ,
    yt.prototype.setAuthTag = function(bt) {
        if (!this._decrypt)
            throw new Error("Attempting to set auth tag in unsupported state");
        this._authTag = bt
    }
    ,
    yt.prototype.setAAD = function(bt) {
        if (this._called)
            throw new Error("Attempting to set AAD in unsupported state");
        this._ghash.update(bt),
        this._alen += bt.length
    }
    ,
    authCipher = yt,
    authCipher
}
var streamCipher, hasRequiredStreamCipher;
function requireStreamCipher() {
    if (hasRequiredStreamCipher)
        return streamCipher;
    hasRequiredStreamCipher = 1;
    var r = requireAes()
      , d = requireSafeBuffer$1().Buffer
      , f = requireCipherBase()
      , m = requireInherits_browser();
    function k(y, ee, dt, mt) {
        f.call(this),
        this._cipher = new r.AES(ee),
        this._prev = d.from(dt),
        this._cache = d.allocUnsafe(0),
        this._secCache = d.allocUnsafe(0),
        this._decrypt = mt,
        this._mode = y
    }
    return m(k, f),
    k.prototype._update = function(y) {
        return this._mode.encrypt(this, y, this._decrypt)
    }
    ,
    k.prototype._final = function() {
        this._cipher.scrub()
    }
    ,
    streamCipher = k,
    streamCipher
}
var evp_bytestokey, hasRequiredEvp_bytestokey;
function requireEvp_bytestokey() {
    if (hasRequiredEvp_bytestokey)
        return evp_bytestokey;
    hasRequiredEvp_bytestokey = 1;
    var r = requireSafeBuffer$1().Buffer
      , d = requireMd5_js();
    function f(m, k, y, ee) {
        if (r.isBuffer(m) || (m = r.from(m, "binary")),
        k && (r.isBuffer(k) || (k = r.from(k, "binary")),
        k.length !== 8))
            throw new RangeError("salt should be Buffer with 8 byte length");
        for (var dt = y / 8, mt = r.alloc(dt), yt = r.alloc(ee || 0), pt = r.alloc(0); dt > 0 || ee > 0; ) {
            var bt = new d;
            bt.update(pt),
            bt.update(m),
            k && bt.update(k),
            pt = bt.digest();
            var wt = 0;
            if (dt > 0) {
                var xt = mt.length - dt;
                wt = Math.min(dt, pt.length),
                pt.copy(mt, xt, 0, wt),
                dt -= wt
            }
            if (wt < pt.length && ee > 0) {
                var At = yt.length - ee
                  , Ct = Math.min(ee, pt.length - wt);
                pt.copy(yt, At, wt, wt + Ct),
                ee -= Ct
            }
        }
        return pt.fill(0),
        {
            key: mt,
            iv: yt
        }
    }
    return evp_bytestokey = f,
    evp_bytestokey
}
var hasRequiredEncrypter;
function requireEncrypter() {
    if (hasRequiredEncrypter)
        return encrypter;
    hasRequiredEncrypter = 1;
    var r = requireModes$1()
      , d = requireAuthCipher()
      , f = requireSafeBuffer$1().Buffer
      , m = requireStreamCipher()
      , k = requireCipherBase()
      , y = requireAes()
      , ee = requireEvp_bytestokey()
      , dt = requireInherits_browser();
    function mt(xt, At, Ct) {
        k.call(this),
        this._cache = new pt,
        this._cipher = new y.AES(At),
        this._prev = f.from(Ct),
        this._mode = xt,
        this._autopadding = !0
    }
    dt(mt, k),
    mt.prototype._update = function(xt) {
        this._cache.add(xt);
        for (var At, Ct, Pt = []; At = this._cache.get(); )
            Ct = this._mode.encrypt(this, At),
            Pt.push(Ct);
        return f.concat(Pt)
    }
    ;
    var yt = f.alloc(16, 16);
    mt.prototype._final = function() {
        var xt = this._cache.flush();
        if (this._autopadding)
            return xt = this._mode.encrypt(this, xt),
            this._cipher.scrub(),
            xt;
        if (!xt.equals(yt))
            throw this._cipher.scrub(),
            new Error("data not multiple of block length")
    }
    ,
    mt.prototype.setAutoPadding = function(xt) {
        return this._autopadding = !!xt,
        this
    }
    ;
    function pt() {
        this.cache = f.allocUnsafe(0)
    }
    pt.prototype.add = function(xt) {
        this.cache = f.concat([this.cache, xt])
    }
    ,
    pt.prototype.get = function() {
        if (this.cache.length > 15) {
            var xt = this.cache.slice(0, 16);
            return this.cache = this.cache.slice(16),
            xt
        }
        return null
    }
    ,
    pt.prototype.flush = function() {
        for (var xt = 16 - this.cache.length, At = f.allocUnsafe(xt), Ct = -1; ++Ct < xt; )
            At.writeUInt8(xt, Ct);
        return f.concat([this.cache, At])
    }
    ;
    function bt(xt, At, Ct) {
        var Pt = r[xt.toLowerCase()];
        if (!Pt)
            throw new TypeError("invalid suite type");
        if (typeof At == "string" && (At = f.from(At)),
        At.length !== Pt.key / 8)
            throw new TypeError("invalid key length " + At.length);
        if (typeof Ct == "string" && (Ct = f.from(Ct)),
        Pt.mode !== "GCM" && Ct.length !== Pt.iv)
            throw new TypeError("invalid iv length " + Ct.length);
        return Pt.type === "stream" ? new m(Pt.module,At,Ct) : Pt.type === "auth" ? new d(Pt.module,At,Ct) : new mt(Pt.module,At,Ct)
    }
    function wt(xt, At) {
        var Ct = r[xt.toLowerCase()];
        if (!Ct)
            throw new TypeError("invalid suite type");
        var Pt = ee(At, !1, Ct.key, Ct.iv);
        return bt(xt, Pt.key, Pt.iv)
    }
    return encrypter.createCipheriv = bt,
    encrypter.createCipher = wt,
    encrypter
}
var decrypter = {}, hasRequiredDecrypter;
function requireDecrypter() {
    if (hasRequiredDecrypter)
        return decrypter;
    hasRequiredDecrypter = 1;
    var r = requireAuthCipher()
      , d = requireSafeBuffer$1().Buffer
      , f = requireModes$1()
      , m = requireStreamCipher()
      , k = requireCipherBase()
      , y = requireAes()
      , ee = requireEvp_bytestokey()
      , dt = requireInherits_browser();
    function mt(xt, At, Ct) {
        k.call(this),
        this._cache = new yt,
        this._last = void 0,
        this._cipher = new y.AES(At),
        this._prev = d.from(Ct),
        this._mode = xt,
        this._autopadding = !0
    }
    dt(mt, k),
    mt.prototype._update = function(xt) {
        this._cache.add(xt);
        for (var At, Ct, Pt = []; At = this._cache.get(this._autopadding); )
            Ct = this._mode.decrypt(this, At),
            Pt.push(Ct);
        return d.concat(Pt)
    }
    ,
    mt.prototype._final = function() {
        var xt = this._cache.flush();
        if (this._autopadding)
            return pt(this._mode.decrypt(this, xt));
        if (xt)
            throw new Error("data not multiple of block length")
    }
    ,
    mt.prototype.setAutoPadding = function(xt) {
        return this._autopadding = !!xt,
        this
    }
    ;
    function yt() {
        this.cache = d.allocUnsafe(0)
    }
    yt.prototype.add = function(xt) {
        this.cache = d.concat([this.cache, xt])
    }
    ,
    yt.prototype.get = function(xt) {
        var At;
        if (xt) {
            if (this.cache.length > 16)
                return At = this.cache.slice(0, 16),
                this.cache = this.cache.slice(16),
                At
        } else if (this.cache.length >= 16)
            return At = this.cache.slice(0, 16),
            this.cache = this.cache.slice(16),
            At;
        return null
    }
    ,
    yt.prototype.flush = function() {
        if (this.cache.length)
            return this.cache
    }
    ;
    function pt(xt) {
        var At = xt[15];
        if (At < 1 || At > 16)
            throw new Error("unable to decrypt data");
        for (var Ct = -1; ++Ct < At; )
            if (xt[Ct + (16 - At)] !== At)
                throw new Error("unable to decrypt data");
        if (At !== 16)
            return xt.slice(0, 16 - At)
    }
    function bt(xt, At, Ct) {
        var Pt = f[xt.toLowerCase()];
        if (!Pt)
            throw new TypeError("invalid suite type");
        if (typeof Ct == "string" && (Ct = d.from(Ct)),
        Pt.mode !== "GCM" && Ct.length !== Pt.iv)
            throw new TypeError("invalid iv length " + Ct.length);
        if (typeof At == "string" && (At = d.from(At)),
        At.length !== Pt.key / 8)
            throw new TypeError("invalid key length " + At.length);
        return Pt.type === "stream" ? new m(Pt.module,At,Ct,!0) : Pt.type === "auth" ? new r(Pt.module,At,Ct,!0) : new mt(Pt.module,At,Ct)
    }
    function wt(xt, At) {
        var Ct = f[xt.toLowerCase()];
        if (!Ct)
            throw new TypeError("invalid suite type");
        var Pt = ee(At, !1, Ct.key, Ct.iv);
        return bt(xt, Pt.key, Pt.iv)
    }
    return decrypter.createDecipher = wt,
    decrypter.createDecipheriv = bt,
    decrypter
}
var hasRequiredBrowser$6;
function requireBrowser$6() {
    if (hasRequiredBrowser$6)
        return browser$6;
    hasRequiredBrowser$6 = 1;
    var r = requireEncrypter()
      , d = requireDecrypter()
      , f = require$$2;
    function m() {
        return Object.keys(f)
    }
    return browser$6.createCipher = browser$6.Cipher = r.createCipher,
    browser$6.createCipheriv = browser$6.Cipheriv = r.createCipheriv,
    browser$6.createDecipher = browser$6.Decipher = d.createDecipher,
    browser$6.createDecipheriv = browser$6.Decipheriv = d.createDecipheriv,
    browser$6.listCiphers = browser$6.getCiphers = m,
    browser$6
}
var modes = {}, hasRequiredModes;
function requireModes() {
    return hasRequiredModes || (hasRequiredModes = 1,
    function(r) {
        r["des-ecb"] = {
            key: 8,
            iv: 0
        },
        r["des-cbc"] = r.des = {
            key: 8,
            iv: 8
        },
        r["des-ede3-cbc"] = r.des3 = {
            key: 24,
            iv: 8
        },
        r["des-ede3"] = {
            key: 24,
            iv: 0
        },
        r["des-ede-cbc"] = {
            key: 16,
            iv: 8
        },
        r["des-ede"] = {
            key: 16,
            iv: 0
        }
    }(modes)),
    modes
}
var hasRequiredBrowser$5;
function requireBrowser$5() {
    if (hasRequiredBrowser$5)
        return browser$7;
    hasRequiredBrowser$5 = 1;
    var r = requireBrowserifyDes()
      , d = requireBrowser$6()
      , f = requireModes$1()
      , m = requireModes()
      , k = requireEvp_bytestokey();
    function y(pt, bt) {
        pt = pt.toLowerCase();
        var wt, xt;
        if (f[pt])
            wt = f[pt].key,
            xt = f[pt].iv;
        else if (m[pt])
            wt = m[pt].key * 8,
            xt = m[pt].iv;
        else
            throw new TypeError("invalid suite type");
        var At = k(bt, !1, wt, xt);
        return dt(pt, At.key, At.iv)
    }
    function ee(pt, bt) {
        pt = pt.toLowerCase();
        var wt, xt;
        if (f[pt])
            wt = f[pt].key,
            xt = f[pt].iv;
        else if (m[pt])
            wt = m[pt].key * 8,
            xt = m[pt].iv;
        else
            throw new TypeError("invalid suite type");
        var At = k(bt, !1, wt, xt);
        return mt(pt, At.key, At.iv)
    }
    function dt(pt, bt, wt) {
        if (pt = pt.toLowerCase(),
        f[pt])
            return d.createCipheriv(pt, bt, wt);
        if (m[pt])
            return new r({
                key: bt,
                iv: wt,
                mode: pt
            });
        throw new TypeError("invalid suite type")
    }
    function mt(pt, bt, wt) {
        if (pt = pt.toLowerCase(),
        f[pt])
            return d.createDecipheriv(pt, bt, wt);
        if (m[pt])
            return new r({
                key: bt,
                iv: wt,
                mode: pt,
                decrypt: !0
            });
        throw new TypeError("invalid suite type")
    }
    function yt() {
        return Object.keys(m).concat(d.getCiphers())
    }
    return browser$7.createCipher = browser$7.Cipher = y,
    browser$7.createCipheriv = browser$7.Cipheriv = dt,
    browser$7.createDecipher = browser$7.Decipher = ee,
    browser$7.createDecipheriv = browser$7.Decipheriv = mt,
    browser$7.listCiphers = browser$7.getCiphers = yt,
    browser$7
}
var browser$5 = {}
  , bn$2 = {
    exports: {}
};
bn$2.exports;
var hasRequiredBn$2;
function requireBn$2() {
    return hasRequiredBn$2 || (hasRequiredBn$2 = 1,
    function(r) {
        (function(d, f) {
            function m(Ht, Mt) {
                if (!Ht)
                    throw new Error(Mt || "Assertion failed")
            }
            function k(Ht, Mt) {
                Ht.super_ = Mt;
                var _t = function() {};
                _t.prototype = Mt.prototype,
                Ht.prototype = new _t,
                Ht.prototype.constructor = Ht
            }
            function y(Ht, Mt, _t) {
                if (y.isBN(Ht))
                    return Ht;
                this.negative = 0,
                this.words = null,
                this.length = 0,
                this.red = null,
                Ht !== null && ((Mt === "le" || Mt === "be") && (_t = Mt,
                Mt = 10),
                this._init(Ht || 0, Mt || 10, _t || "be"))
            }
            typeof d == "object" ? d.exports = y : f.BN = y,
            y.BN = y,
            y.wordSize = 26;
            var ee;
            try {
                typeof window < "u" && typeof window.Buffer < "u" ? ee = window.Buffer : ee = require$$1$2.Buffer
            } catch {}
            y.isBN = function(Mt) {
                return Mt instanceof y ? !0 : Mt !== null && typeof Mt == "object" && Mt.constructor.wordSize === y.wordSize && Array.isArray(Mt.words)
            }
            ,
            y.max = function(Mt, _t) {
                return Mt.cmp(_t) > 0 ? Mt : _t
            }
            ,
            y.min = function(Mt, _t) {
                return Mt.cmp(_t) < 0 ? Mt : _t
            }
            ,
            y.prototype._init = function(Mt, _t, gt) {
                if (typeof Mt == "number")
                    return this._initNumber(Mt, _t, gt);
                if (typeof Mt == "object")
                    return this._initArray(Mt, _t, gt);
                _t === "hex" && (_t = 16),
                m(_t === (_t | 0) && _t >= 2 && _t <= 36),
                Mt = Mt.toString().replace(/\s+/g, "");
                var vt = 0;
                Mt[0] === "-" && (vt++,
                this.negative = 1),
                vt < Mt.length && (_t === 16 ? this._parseHex(Mt, vt, gt) : (this._parseBase(Mt, _t, vt),
                gt === "le" && this._initArray(this.toArray(), _t, gt)))
            }
            ,
            y.prototype._initNumber = function(Mt, _t, gt) {
                Mt < 0 && (this.negative = 1,
                Mt = -Mt),
                Mt < 67108864 ? (this.words = [Mt & 67108863],
                this.length = 1) : Mt < 4503599627370496 ? (this.words = [Mt & 67108863, Mt / 67108864 & 67108863],
                this.length = 2) : (m(Mt < 9007199254740992),
                this.words = [Mt & 67108863, Mt / 67108864 & 67108863, 1],
                this.length = 3),
                gt === "le" && this._initArray(this.toArray(), _t, gt)
            }
            ,
            y.prototype._initArray = function(Mt, _t, gt) {
                if (m(typeof Mt.length == "number"),
                Mt.length <= 0)
                    return this.words = [0],
                    this.length = 1,
                    this;
                this.length = Math.ceil(Mt.length / 3),
                this.words = new Array(this.length);
                for (var vt = 0; vt < this.length; vt++)
                    this.words[vt] = 0;
                var Et, Bt, Rt = 0;
                if (gt === "be")
                    for (vt = Mt.length - 1,
                    Et = 0; vt >= 0; vt -= 3)
                        Bt = Mt[vt] | Mt[vt - 1] << 8 | Mt[vt - 2] << 16,
                        this.words[Et] |= Bt << Rt & 67108863,
                        this.words[Et + 1] = Bt >>> 26 - Rt & 67108863,
                        Rt += 24,
                        Rt >= 26 && (Rt -= 26,
                        Et++);
                else if (gt === "le")
                    for (vt = 0,
                    Et = 0; vt < Mt.length; vt += 3)
                        Bt = Mt[vt] | Mt[vt + 1] << 8 | Mt[vt + 2] << 16,
                        this.words[Et] |= Bt << Rt & 67108863,
                        this.words[Et + 1] = Bt >>> 26 - Rt & 67108863,
                        Rt += 24,
                        Rt >= 26 && (Rt -= 26,
                        Et++);
                return this.strip()
            }
            ;
            function dt(Ht, Mt) {
                var _t = Ht.charCodeAt(Mt);
                return _t >= 65 && _t <= 70 ? _t - 55 : _t >= 97 && _t <= 102 ? _t - 87 : _t - 48 & 15
            }
            function mt(Ht, Mt, _t) {
                var gt = dt(Ht, _t);
                return _t - 1 >= Mt && (gt |= dt(Ht, _t - 1) << 4),
                gt
            }
            y.prototype._parseHex = function(Mt, _t, gt) {
                this.length = Math.ceil((Mt.length - _t) / 6),
                this.words = new Array(this.length);
                for (var vt = 0; vt < this.length; vt++)
                    this.words[vt] = 0;
                var Et = 0, Bt = 0, Rt;
                if (gt === "be")
                    for (vt = Mt.length - 1; vt >= _t; vt -= 2)
                        Rt = mt(Mt, _t, vt) << Et,
                        this.words[Bt] |= Rt & 67108863,
                        Et >= 18 ? (Et -= 18,
                        Bt += 1,
                        this.words[Bt] |= Rt >>> 26) : Et += 8;
                else {
                    var kt = Mt.length - _t;
                    for (vt = kt % 2 === 0 ? _t + 1 : _t; vt < Mt.length; vt += 2)
                        Rt = mt(Mt, _t, vt) << Et,
                        this.words[Bt] |= Rt & 67108863,
                        Et >= 18 ? (Et -= 18,
                        Bt += 1,
                        this.words[Bt] |= Rt >>> 26) : Et += 8
                }
                this.strip()
            }
            ;
            function yt(Ht, Mt, _t, gt) {
                for (var vt = 0, Et = Math.min(Ht.length, _t), Bt = Mt; Bt < Et; Bt++) {
                    var Rt = Ht.charCodeAt(Bt) - 48;
                    vt *= gt,
                    Rt >= 49 ? vt += Rt - 49 + 10 : Rt >= 17 ? vt += Rt - 17 + 10 : vt += Rt
                }
                return vt
            }
            y.prototype._parseBase = function(Mt, _t, gt) {
                this.words = [0],
                this.length = 1;
                for (var vt = 0, Et = 1; Et <= 67108863; Et *= _t)
                    vt++;
                vt--,
                Et = Et / _t | 0;
                for (var Bt = Mt.length - gt, Rt = Bt % vt, kt = Math.min(Bt, Bt - Rt) + gt, Tt = 0, It = gt; It < kt; It += vt)
                    Tt = yt(Mt, It, It + vt, _t),
                    this.imuln(Et),
                    this.words[0] + Tt < 67108864 ? this.words[0] += Tt : this._iaddn(Tt);
                if (Rt !== 0) {
                    var St = 1;
                    for (Tt = yt(Mt, It, Mt.length, _t),
                    It = 0; It < Rt; It++)
                        St *= _t;
                    this.imuln(St),
                    this.words[0] + Tt < 67108864 ? this.words[0] += Tt : this._iaddn(Tt)
                }
                this.strip()
            }
            ,
            y.prototype.copy = function(Mt) {
                Mt.words = new Array(this.length);
                for (var _t = 0; _t < this.length; _t++)
                    Mt.words[_t] = this.words[_t];
                Mt.length = this.length,
                Mt.negative = this.negative,
                Mt.red = this.red
            }
            ,
            y.prototype.clone = function() {
                var Mt = new y(null);
                return this.copy(Mt),
                Mt
            }
            ,
            y.prototype._expand = function(Mt) {
                for (; this.length < Mt; )
                    this.words[this.length++] = 0;
                return this
            }
            ,
            y.prototype.strip = function() {
                for (; this.length > 1 && this.words[this.length - 1] === 0; )
                    this.length--;
                return this._normSign()
            }
            ,
            y.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0),
                this
            }
            ,
            y.prototype.inspect = function() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
            }
            ;
            var pt = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
              , bt = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
              , wt = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
            y.prototype.toString = function(Mt, _t) {
                Mt = Mt || 10,
                _t = _t | 0 || 1;
                var gt;
                if (Mt === 16 || Mt === "hex") {
                    gt = "";
                    for (var vt = 0, Et = 0, Bt = 0; Bt < this.length; Bt++) {
                        var Rt = this.words[Bt]
                          , kt = ((Rt << vt | Et) & 16777215).toString(16);
                        Et = Rt >>> 24 - vt & 16777215,
                        Et !== 0 || Bt !== this.length - 1 ? gt = pt[6 - kt.length] + kt + gt : gt = kt + gt,
                        vt += 2,
                        vt >= 26 && (vt -= 26,
                        Bt--)
                    }
                    for (Et !== 0 && (gt = Et.toString(16) + gt); gt.length % _t !== 0; )
                        gt = "0" + gt;
                    return this.negative !== 0 && (gt = "-" + gt),
                    gt
                }
                if (Mt === (Mt | 0) && Mt >= 2 && Mt <= 36) {
                    var Tt = bt[Mt]
                      , It = wt[Mt];
                    gt = "";
                    var St = this.clone();
                    for (St.negative = 0; !St.isZero(); ) {
                        var qt = St.modn(It).toString(Mt);
                        St = St.idivn(It),
                        St.isZero() ? gt = qt + gt : gt = pt[Tt - qt.length] + qt + gt
                    }
                    for (this.isZero() && (gt = "0" + gt); gt.length % _t !== 0; )
                        gt = "0" + gt;
                    return this.negative !== 0 && (gt = "-" + gt),
                    gt
                }
                m(!1, "Base should be between 2 and 36")
            }
            ,
            y.prototype.toNumber = function() {
                var Mt = this.words[0];
                return this.length === 2 ? Mt += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? Mt += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && m(!1, "Number can only safely store up to 53 bits"),
                this.negative !== 0 ? -Mt : Mt
            }
            ,
            y.prototype.toJSON = function() {
                return this.toString(16)
            }
            ,
            y.prototype.toBuffer = function(Mt, _t) {
                return m(typeof ee < "u"),
                this.toArrayLike(ee, Mt, _t)
            }
            ,
            y.prototype.toArray = function(Mt, _t) {
                return this.toArrayLike(Array, Mt, _t)
            }
            ,
            y.prototype.toArrayLike = function(Mt, _t, gt) {
                var vt = this.byteLength()
                  , Et = gt || Math.max(1, vt);
                m(vt <= Et, "byte array longer than desired length"),
                m(Et > 0, "Requested array length <= 0"),
                this.strip();
                var Bt = _t === "le", Rt = new Mt(Et), kt, Tt, It = this.clone();
                if (Bt) {
                    for (Tt = 0; !It.isZero(); Tt++)
                        kt = It.andln(255),
                        It.iushrn(8),
                        Rt[Tt] = kt;
                    for (; Tt < Et; Tt++)
                        Rt[Tt] = 0
                } else {
                    for (Tt = 0; Tt < Et - vt; Tt++)
                        Rt[Tt] = 0;
                    for (Tt = 0; !It.isZero(); Tt++)
                        kt = It.andln(255),
                        It.iushrn(8),
                        Rt[Et - Tt - 1] = kt
                }
                return Rt
            }
            ,
            Math.clz32 ? y.prototype._countBits = function(Mt) {
                return 32 - Math.clz32(Mt)
            }
            : y.prototype._countBits = function(Mt) {
                var _t = Mt
                  , gt = 0;
                return _t >= 4096 && (gt += 13,
                _t >>>= 13),
                _t >= 64 && (gt += 7,
                _t >>>= 7),
                _t >= 8 && (gt += 4,
                _t >>>= 4),
                _t >= 2 && (gt += 2,
                _t >>>= 2),
                gt + _t
            }
            ,
            y.prototype._zeroBits = function(Mt) {
                if (Mt === 0)
                    return 26;
                var _t = Mt
                  , gt = 0;
                return _t & 8191 || (gt += 13,
                _t >>>= 13),
                _t & 127 || (gt += 7,
                _t >>>= 7),
                _t & 15 || (gt += 4,
                _t >>>= 4),
                _t & 3 || (gt += 2,
                _t >>>= 2),
                _t & 1 || gt++,
                gt
            }
            ,
            y.prototype.bitLength = function() {
                var Mt = this.words[this.length - 1]
                  , _t = this._countBits(Mt);
                return (this.length - 1) * 26 + _t
            }
            ;
            function xt(Ht) {
                for (var Mt = new Array(Ht.bitLength()), _t = 0; _t < Mt.length; _t++) {
                    var gt = _t / 26 | 0
                      , vt = _t % 26;
                    Mt[_t] = (Ht.words[gt] & 1 << vt) >>> vt
                }
                return Mt
            }
            y.prototype.zeroBits = function() {
                if (this.isZero())
                    return 0;
                for (var Mt = 0, _t = 0; _t < this.length; _t++) {
                    var gt = this._zeroBits(this.words[_t]);
                    if (Mt += gt,
                    gt !== 26)
                        break
                }
                return Mt
            }
            ,
            y.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8)
            }
            ,
            y.prototype.toTwos = function(Mt) {
                return this.negative !== 0 ? this.abs().inotn(Mt).iaddn(1) : this.clone()
            }
            ,
            y.prototype.fromTwos = function(Mt) {
                return this.testn(Mt - 1) ? this.notn(Mt).iaddn(1).ineg() : this.clone()
            }
            ,
            y.prototype.isNeg = function() {
                return this.negative !== 0
            }
            ,
            y.prototype.neg = function() {
                return this.clone().ineg()
            }
            ,
            y.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1),
                this
            }
            ,
            y.prototype.iuor = function(Mt) {
                for (; this.length < Mt.length; )
                    this.words[this.length++] = 0;
                for (var _t = 0; _t < Mt.length; _t++)
                    this.words[_t] = this.words[_t] | Mt.words[_t];
                return this.strip()
            }
            ,
            y.prototype.ior = function(Mt) {
                return m((this.negative | Mt.negative) === 0),
                this.iuor(Mt)
            }
            ,
            y.prototype.or = function(Mt) {
                return this.length > Mt.length ? this.clone().ior(Mt) : Mt.clone().ior(this)
            }
            ,
            y.prototype.uor = function(Mt) {
                return this.length > Mt.length ? this.clone().iuor(Mt) : Mt.clone().iuor(this)
            }
            ,
            y.prototype.iuand = function(Mt) {
                var _t;
                this.length > Mt.length ? _t = Mt : _t = this;
                for (var gt = 0; gt < _t.length; gt++)
                    this.words[gt] = this.words[gt] & Mt.words[gt];
                return this.length = _t.length,
                this.strip()
            }
            ,
            y.prototype.iand = function(Mt) {
                return m((this.negative | Mt.negative) === 0),
                this.iuand(Mt)
            }
            ,
            y.prototype.and = function(Mt) {
                return this.length > Mt.length ? this.clone().iand(Mt) : Mt.clone().iand(this)
            }
            ,
            y.prototype.uand = function(Mt) {
                return this.length > Mt.length ? this.clone().iuand(Mt) : Mt.clone().iuand(this)
            }
            ,
            y.prototype.iuxor = function(Mt) {
                var _t, gt;
                this.length > Mt.length ? (_t = this,
                gt = Mt) : (_t = Mt,
                gt = this);
                for (var vt = 0; vt < gt.length; vt++)
                    this.words[vt] = _t.words[vt] ^ gt.words[vt];
                if (this !== _t)
                    for (; vt < _t.length; vt++)
                        this.words[vt] = _t.words[vt];
                return this.length = _t.length,
                this.strip()
            }
            ,
            y.prototype.ixor = function(Mt) {
                return m((this.negative | Mt.negative) === 0),
                this.iuxor(Mt)
            }
            ,
            y.prototype.xor = function(Mt) {
                return this.length > Mt.length ? this.clone().ixor(Mt) : Mt.clone().ixor(this)
            }
            ,
            y.prototype.uxor = function(Mt) {
                return this.length > Mt.length ? this.clone().iuxor(Mt) : Mt.clone().iuxor(this)
            }
            ,
            y.prototype.inotn = function(Mt) {
                m(typeof Mt == "number" && Mt >= 0);
                var _t = Math.ceil(Mt / 26) | 0
                  , gt = Mt % 26;
                this._expand(_t),
                gt > 0 && _t--;
                for (var vt = 0; vt < _t; vt++)
                    this.words[vt] = ~this.words[vt] & 67108863;
                return gt > 0 && (this.words[vt] = ~this.words[vt] & 67108863 >> 26 - gt),
                this.strip()
            }
            ,
            y.prototype.notn = function(Mt) {
                return this.clone().inotn(Mt)
            }
            ,
            y.prototype.setn = function(Mt, _t) {
                m(typeof Mt == "number" && Mt >= 0);
                var gt = Mt / 26 | 0
                  , vt = Mt % 26;
                return this._expand(gt + 1),
                _t ? this.words[gt] = this.words[gt] | 1 << vt : this.words[gt] = this.words[gt] & ~(1 << vt),
                this.strip()
            }
            ,
            y.prototype.iadd = function(Mt) {
                var _t;
                if (this.negative !== 0 && Mt.negative === 0)
                    return this.negative = 0,
                    _t = this.isub(Mt),
                    this.negative ^= 1,
                    this._normSign();
                if (this.negative === 0 && Mt.negative !== 0)
                    return Mt.negative = 0,
                    _t = this.isub(Mt),
                    Mt.negative = 1,
                    _t._normSign();
                var gt, vt;
                this.length > Mt.length ? (gt = this,
                vt = Mt) : (gt = Mt,
                vt = this);
                for (var Et = 0, Bt = 0; Bt < vt.length; Bt++)
                    _t = (gt.words[Bt] | 0) + (vt.words[Bt] | 0) + Et,
                    this.words[Bt] = _t & 67108863,
                    Et = _t >>> 26;
                for (; Et !== 0 && Bt < gt.length; Bt++)
                    _t = (gt.words[Bt] | 0) + Et,
                    this.words[Bt] = _t & 67108863,
                    Et = _t >>> 26;
                if (this.length = gt.length,
                Et !== 0)
                    this.words[this.length] = Et,
                    this.length++;
                else if (gt !== this)
                    for (; Bt < gt.length; Bt++)
                        this.words[Bt] = gt.words[Bt];
                return this
            }
            ,
            y.prototype.add = function(Mt) {
                var _t;
                return Mt.negative !== 0 && this.negative === 0 ? (Mt.negative = 0,
                _t = this.sub(Mt),
                Mt.negative ^= 1,
                _t) : Mt.negative === 0 && this.negative !== 0 ? (this.negative = 0,
                _t = Mt.sub(this),
                this.negative = 1,
                _t) : this.length > Mt.length ? this.clone().iadd(Mt) : Mt.clone().iadd(this)
            }
            ,
            y.prototype.isub = function(Mt) {
                if (Mt.negative !== 0) {
                    Mt.negative = 0;
                    var _t = this.iadd(Mt);
                    return Mt.negative = 1,
                    _t._normSign()
                } else if (this.negative !== 0)
                    return this.negative = 0,
                    this.iadd(Mt),
                    this.negative = 1,
                    this._normSign();
                var gt = this.cmp(Mt);
                if (gt === 0)
                    return this.negative = 0,
                    this.length = 1,
                    this.words[0] = 0,
                    this;
                var vt, Et;
                gt > 0 ? (vt = this,
                Et = Mt) : (vt = Mt,
                Et = this);
                for (var Bt = 0, Rt = 0; Rt < Et.length; Rt++)
                    _t = (vt.words[Rt] | 0) - (Et.words[Rt] | 0) + Bt,
                    Bt = _t >> 26,
                    this.words[Rt] = _t & 67108863;
                for (; Bt !== 0 && Rt < vt.length; Rt++)
                    _t = (vt.words[Rt] | 0) + Bt,
                    Bt = _t >> 26,
                    this.words[Rt] = _t & 67108863;
                if (Bt === 0 && Rt < vt.length && vt !== this)
                    for (; Rt < vt.length; Rt++)
                        this.words[Rt] = vt.words[Rt];
                return this.length = Math.max(this.length, Rt),
                vt !== this && (this.negative = 1),
                this.strip()
            }
            ,
            y.prototype.sub = function(Mt) {
                return this.clone().isub(Mt)
            }
            ;
            function At(Ht, Mt, _t) {
                _t.negative = Mt.negative ^ Ht.negative;
                var gt = Ht.length + Mt.length | 0;
                _t.length = gt,
                gt = gt - 1 | 0;
                var vt = Ht.words[0] | 0
                  , Et = Mt.words[0] | 0
                  , Bt = vt * Et
                  , Rt = Bt & 67108863
                  , kt = Bt / 67108864 | 0;
                _t.words[0] = Rt;
                for (var Tt = 1; Tt < gt; Tt++) {
                    for (var It = kt >>> 26, St = kt & 67108863, qt = Math.min(Tt, Mt.length - 1), ur = Math.max(0, Tt - Ht.length + 1); ur <= qt; ur++) {
                        var gr = Tt - ur | 0;
                        vt = Ht.words[gr] | 0,
                        Et = Mt.words[ur] | 0,
                        Bt = vt * Et + St,
                        It += Bt / 67108864 | 0,
                        St = Bt & 67108863
                    }
                    _t.words[Tt] = St | 0,
                    kt = It | 0
                }
                return kt !== 0 ? _t.words[Tt] = kt | 0 : _t.length--,
                _t.strip()
            }
            var Ct = function(Mt, _t, gt) {
                var vt = Mt.words, Et = _t.words, Bt = gt.words, Rt = 0, kt, Tt, It, St = vt[0] | 0, qt = St & 8191, ur = St >>> 13, gr = vt[1] | 0, lr = gr & 8191, Zt = gr >>> 13, Vt = vt[2] | 0, rr = Vt & 8191, fr = Vt >>> 13, Yt = vt[3] | 0, Xt = Yt & 8191, Sr = Yt >>> 13, Rr = vt[4] | 0, qr = Rr & 8191, Nr = Rr >>> 13, Dr = vt[5] | 0, Or = Dr & 8191, $r = Dr >>> 13, Zr = vt[6] | 0, Hr = Zr & 8191, un = Zr >>> 13, Qr = vt[7] | 0, Gr = Qr & 8191, vr = Qr >>> 13, ar = vt[8] | 0, hr = ar & 8191, _r = ar >>> 13, Ar = vt[9] | 0, Ft = Ar & 8191, Ut = Ar >>> 13, Dt = Et[0] | 0, er = Dt & 8191, br = Dt >>> 13, Cr = Et[1] | 0, xr = Cr & 8191, Lr = Cr >>> 13, Ur = Et[2] | 0, Ir = Ur & 8191, Jr = Ur >>> 13, Wr = Et[3] | 0, Yr = Wr & 8191, Sn = Wr >>> 13, pn = Et[4] | 0, tn = pn & 8191, Bn = pn >>> 13, An = Et[5] | 0, dn = An & 8191, Rn = An >>> 13, En = Et[6] | 0, an = En & 8191, Un = En >>> 13, Jt = Et[7] | 0, nr = Jt & 8191, sr = Jt >>> 13, jt = Et[8] | 0, cr = jt & 8191, Tr = jt >>> 13, kr = Et[9] | 0, Pr = kr & 8191, zr = kr >>> 13;
                gt.negative = Mt.negative ^ _t.negative,
                gt.length = 19,
                kt = Math.imul(qt, er),
                Tt = Math.imul(qt, br),
                Tt = Tt + Math.imul(ur, er) | 0,
                It = Math.imul(ur, br);
                var Vr = (Rt + kt | 0) + ((Tt & 8191) << 13) | 0;
                Rt = (It + (Tt >>> 13) | 0) + (Vr >>> 26) | 0,
                Vr &= 67108863,
                kt = Math.imul(lr, er),
                Tt = Math.imul(lr, br),
                Tt = Tt + Math.imul(Zt, er) | 0,
                It = Math.imul(Zt, br),
                kt = kt + Math.imul(qt, xr) | 0,
                Tt = Tt + Math.imul(qt, Lr) | 0,
                Tt = Tt + Math.imul(ur, xr) | 0,
                It = It + Math.imul(ur, Lr) | 0;
                var jr = (Rt + kt | 0) + ((Tt & 8191) << 13) | 0;
                Rt = (It + (Tt >>> 13) | 0) + (jr >>> 26) | 0,
                jr &= 67108863,
                kt = Math.imul(rr, er),
                Tt = Math.imul(rr, br),
                Tt = Tt + Math.imul(fr, er) | 0,
                It = Math.imul(fr, br),
                kt = kt + Math.imul(lr, xr) | 0,
                Tt = Tt + Math.imul(lr, Lr) | 0,
                Tt = Tt + Math.imul(Zt, xr) | 0,
                It = It + Math.imul(Zt, Lr) | 0,
                kt = kt + Math.imul(qt, Ir) | 0,
                Tt = Tt + Math.imul(qt, Jr) | 0,
                Tt = Tt + Math.imul(ur, Ir) | 0,
                It = It + Math.imul(ur, Jr) | 0;
                var Mn = (Rt + kt | 0) + ((Tt & 8191) << 13) | 0;
                Rt = (It + (Tt >>> 13) | 0) + (Mn >>> 26) | 0,
                Mn &= 67108863,
                kt = Math.imul(Xt, er),
                Tt = Math.imul(Xt, br),
                Tt = Tt + Math.imul(Sr, er) | 0,
                It = Math.imul(Sr, br),
                kt = kt + Math.imul(rr, xr) | 0,
                Tt = Tt + Math.imul(rr, Lr) | 0,
                Tt = Tt + Math.imul(fr, xr) | 0,
                It = It + Math.imul(fr, Lr) | 0,
                kt = kt + Math.imul(lr, Ir) | 0,
                Tt = Tt + Math.imul(lr, Jr) | 0,
                Tt = Tt + Math.imul(Zt, Ir) | 0,
                It = It + Math.imul(Zt, Jr) | 0,
                kt = kt + Math.imul(qt, Yr) | 0,
                Tt = Tt + Math.imul(qt, Sn) | 0,
                Tt = Tt + Math.imul(ur, Yr) | 0,
                It = It + Math.imul(ur, Sn) | 0;
                var nn = (Rt + kt | 0) + ((Tt & 8191) << 13) | 0;
                Rt = (It + (Tt >>> 13) | 0) + (nn >>> 26) | 0,
                nn &= 67108863,
                kt = Math.imul(qr, er),
                Tt = Math.imul(qr, br),
                Tt = Tt + Math.imul(Nr, er) | 0,
                It = Math.imul(Nr, br),
                kt = kt + Math.imul(Xt, xr) | 0,
                Tt = Tt + Math.imul(Xt, Lr) | 0,
                Tt = Tt + Math.imul(Sr, xr) | 0,
                It = It + Math.imul(Sr, Lr) | 0,
                kt = kt + Math.imul(rr, Ir) | 0,
                Tt = Tt + Math.imul(rr, Jr) | 0,
                Tt = Tt + Math.imul(fr, Ir) | 0,
                It = It + Math.imul(fr, Jr) | 0,
                kt = kt + Math.imul(lr, Yr) | 0,
                Tt = Tt + Math.imul(lr, Sn) | 0,
                Tt = Tt + Math.imul(Zt, Yr) | 0,
                It = It + Math.imul(Zt, Sn) | 0,
                kt = kt + Math.imul(qt, tn) | 0,
                Tt = Tt + Math.imul(qt, Bn) | 0,
                Tt = Tt + Math.imul(ur, tn) | 0,
                It = It + Math.imul(ur, Bn) | 0;
                var gn = (Rt + kt | 0) + ((Tt & 8191) << 13) | 0;
                Rt = (It + (Tt >>> 13) | 0) + (gn >>> 26) | 0,
                gn &= 67108863,
                kt = Math.imul(Or, er),
                Tt = Math.imul(Or, br),
                Tt = Tt + Math.imul($r, er) | 0,
                It = Math.imul($r, br),
                kt = kt + Math.imul(qr, xr) | 0,
                Tt = Tt + Math.imul(qr, Lr) | 0,
                Tt = Tt + Math.imul(Nr, xr) | 0,
                It = It + Math.imul(Nr, Lr) | 0,
                kt = kt + Math.imul(Xt, Ir) | 0,
                Tt = Tt + Math.imul(Xt, Jr) | 0,
                Tt = Tt + Math.imul(Sr, Ir) | 0,
                It = It + Math.imul(Sr, Jr) | 0,
                kt = kt + Math.imul(rr, Yr) | 0,
                Tt = Tt + Math.imul(rr, Sn) | 0,
                Tt = Tt + Math.imul(fr, Yr) | 0,
                It = It + Math.imul(fr, Sn) | 0,
                kt = kt + Math.imul(lr, tn) | 0,
                Tt = Tt + Math.imul(lr, Bn) | 0,
                Tt = Tt + Math.imul(Zt, tn) | 0,
                It = It + Math.imul(Zt, Bn) | 0,
                kt = kt + Math.imul(qt, dn) | 0,
                Tt = Tt + Math.imul(qt, Rn) | 0,
                Tt = Tt + Math.imul(ur, dn) | 0,
                It = It + Math.imul(ur, Rn) | 0;
                var mn = (Rt + kt | 0) + ((Tt & 8191) << 13) | 0;
                Rt = (It + (Tt >>> 13) | 0) + (mn >>> 26) | 0,
                mn &= 67108863,
                kt = Math.imul(Hr, er),
                Tt = Math.imul(Hr, br),
                Tt = Tt + Math.imul(un, er) | 0,
                It = Math.imul(un, br),
                kt = kt + Math.imul(Or, xr) | 0,
                Tt = Tt + Math.imul(Or, Lr) | 0,
                Tt = Tt + Math.imul($r, xr) | 0,
                It = It + Math.imul($r, Lr) | 0,
                kt = kt + Math.imul(qr, Ir) | 0,
                Tt = Tt + Math.imul(qr, Jr) | 0,
                Tt = Tt + Math.imul(Nr, Ir) | 0,
                It = It + Math.imul(Nr, Jr) | 0,
                kt = kt + Math.imul(Xt, Yr) | 0,
                Tt = Tt + Math.imul(Xt, Sn) | 0,
                Tt = Tt + Math.imul(Sr, Yr) | 0,
                It = It + Math.imul(Sr, Sn) | 0,
                kt = kt + Math.imul(rr, tn) | 0,
                Tt = Tt + Math.imul(rr, Bn) | 0,
                Tt = Tt + Math.imul(fr, tn) | 0,
                It = It + Math.imul(fr, Bn) | 0,
                kt = kt + Math.imul(lr, dn) | 0,
                Tt = Tt + Math.imul(lr, Rn) | 0,
                Tt = Tt + Math.imul(Zt, dn) | 0,
                It = It + Math.imul(Zt, Rn) | 0,
                kt = kt + Math.imul(qt, an) | 0,
                Tt = Tt + Math.imul(qt, Un) | 0,
                Tt = Tt + Math.imul(ur, an) | 0,
                It = It + Math.imul(ur, Un) | 0;
                var xn = (Rt + kt | 0) + ((Tt & 8191) << 13) | 0;
                Rt = (It + (Tt >>> 13) | 0) + (xn >>> 26) | 0,
                xn &= 67108863,
                kt = Math.imul(Gr, er),
                Tt = Math.imul(Gr, br),
                Tt = Tt + Math.imul(vr, er) | 0,
                It = Math.imul(vr, br),
                kt = kt + Math.imul(Hr, xr) | 0,
                Tt = Tt + Math.imul(Hr, Lr) | 0,
                Tt = Tt + Math.imul(un, xr) | 0,
                It = It + Math.imul(un, Lr) | 0,
                kt = kt + Math.imul(Or, Ir) | 0,
                Tt = Tt + Math.imul(Or, Jr) | 0,
                Tt = Tt + Math.imul($r, Ir) | 0,
                It = It + Math.imul($r, Jr) | 0,
                kt = kt + Math.imul(qr, Yr) | 0,
                Tt = Tt + Math.imul(qr, Sn) | 0,
                Tt = Tt + Math.imul(Nr, Yr) | 0,
                It = It + Math.imul(Nr, Sn) | 0,
                kt = kt + Math.imul(Xt, tn) | 0,
                Tt = Tt + Math.imul(Xt, Bn) | 0,
                Tt = Tt + Math.imul(Sr, tn) | 0,
                It = It + Math.imul(Sr, Bn) | 0,
                kt = kt + Math.imul(rr, dn) | 0,
                Tt = Tt + Math.imul(rr, Rn) | 0,
                Tt = Tt + Math.imul(fr, dn) | 0,
                It = It + Math.imul(fr, Rn) | 0,
                kt = kt + Math.imul(lr, an) | 0,
                Tt = Tt + Math.imul(lr, Un) | 0,
                Tt = Tt + Math.imul(Zt, an) | 0,
                It = It + Math.imul(Zt, Un) | 0,
                kt = kt + Math.imul(qt, nr) | 0,
                Tt = Tt + Math.imul(qt, sr) | 0,
                Tt = Tt + Math.imul(ur, nr) | 0,
                It = It + Math.imul(ur, sr) | 0;
                var _n = (Rt + kt | 0) + ((Tt & 8191) << 13) | 0;
                Rt = (It + (Tt >>> 13) | 0) + (_n >>> 26) | 0,
                _n &= 67108863,
                kt = Math.imul(hr, er),
                Tt = Math.imul(hr, br),
                Tt = Tt + Math.imul(_r, er) | 0,
                It = Math.imul(_r, br),
                kt = kt + Math.imul(Gr, xr) | 0,
                Tt = Tt + Math.imul(Gr, Lr) | 0,
                Tt = Tt + Math.imul(vr, xr) | 0,
                It = It + Math.imul(vr, Lr) | 0,
                kt = kt + Math.imul(Hr, Ir) | 0,
                Tt = Tt + Math.imul(Hr, Jr) | 0,
                Tt = Tt + Math.imul(un, Ir) | 0,
                It = It + Math.imul(un, Jr) | 0,
                kt = kt + Math.imul(Or, Yr) | 0,
                Tt = Tt + Math.imul(Or, Sn) | 0,
                Tt = Tt + Math.imul($r, Yr) | 0,
                It = It + Math.imul($r, Sn) | 0,
                kt = kt + Math.imul(qr, tn) | 0,
                Tt = Tt + Math.imul(qr, Bn) | 0,
                Tt = Tt + Math.imul(Nr, tn) | 0,
                It = It + Math.imul(Nr, Bn) | 0,
                kt = kt + Math.imul(Xt, dn) | 0,
                Tt = Tt + Math.imul(Xt, Rn) | 0,
                Tt = Tt + Math.imul(Sr, dn) | 0,
                It = It + Math.imul(Sr, Rn) | 0,
                kt = kt + Math.imul(rr, an) | 0,
                Tt = Tt + Math.imul(rr, Un) | 0,
                Tt = Tt + Math.imul(fr, an) | 0,
                It = It + Math.imul(fr, Un) | 0,
                kt = kt + Math.imul(lr, nr) | 0,
                Tt = Tt + Math.imul(lr, sr) | 0,
                Tt = Tt + Math.imul(Zt, nr) | 0,
                It = It + Math.imul(Zt, sr) | 0,
                kt = kt + Math.imul(qt, cr) | 0,
                Tt = Tt + Math.imul(qt, Tr) | 0,
                Tt = Tt + Math.imul(ur, cr) | 0,
                It = It + Math.imul(ur, Tr) | 0;
                var yn = (Rt + kt | 0) + ((Tt & 8191) << 13) | 0;
                Rt = (It + (Tt >>> 13) | 0) + (yn >>> 26) | 0,
                yn &= 67108863,
                kt = Math.imul(Ft, er),
                Tt = Math.imul(Ft, br),
                Tt = Tt + Math.imul(Ut, er) | 0,
                It = Math.imul(Ut, br),
                kt = kt + Math.imul(hr, xr) | 0,
                Tt = Tt + Math.imul(hr, Lr) | 0,
                Tt = Tt + Math.imul(_r, xr) | 0,
                It = It + Math.imul(_r, Lr) | 0,
                kt = kt + Math.imul(Gr, Ir) | 0,
                Tt = Tt + Math.imul(Gr, Jr) | 0,
                Tt = Tt + Math.imul(vr, Ir) | 0,
                It = It + Math.imul(vr, Jr) | 0,
                kt = kt + Math.imul(Hr, Yr) | 0,
                Tt = Tt + Math.imul(Hr, Sn) | 0,
                Tt = Tt + Math.imul(un, Yr) | 0,
                It = It + Math.imul(un, Sn) | 0,
                kt = kt + Math.imul(Or, tn) | 0,
                Tt = Tt + Math.imul(Or, Bn) | 0,
                Tt = Tt + Math.imul($r, tn) | 0,
                It = It + Math.imul($r, Bn) | 0,
                kt = kt + Math.imul(qr, dn) | 0,
                Tt = Tt + Math.imul(qr, Rn) | 0,
                Tt = Tt + Math.imul(Nr, dn) | 0,
                It = It + Math.imul(Nr, Rn) | 0,
                kt = kt + Math.imul(Xt, an) | 0,
                Tt = Tt + Math.imul(Xt, Un) | 0,
                Tt = Tt + Math.imul(Sr, an) | 0,
                It = It + Math.imul(Sr, Un) | 0,
                kt = kt + Math.imul(rr, nr) | 0,
                Tt = Tt + Math.imul(rr, sr) | 0,
                Tt = Tt + Math.imul(fr, nr) | 0,
                It = It + Math.imul(fr, sr) | 0,
                kt = kt + Math.imul(lr, cr) | 0,
                Tt = Tt + Math.imul(lr, Tr) | 0,
                Tt = Tt + Math.imul(Zt, cr) | 0,
                It = It + Math.imul(Zt, Tr) | 0,
                kt = kt + Math.imul(qt, Pr) | 0,
                Tt = Tt + Math.imul(qt, zr) | 0,
                Tt = Tt + Math.imul(ur, Pr) | 0,
                It = It + Math.imul(ur, zr) | 0;
                var wn = (Rt + kt | 0) + ((Tt & 8191) << 13) | 0;
                Rt = (It + (Tt >>> 13) | 0) + (wn >>> 26) | 0,
                wn &= 67108863,
                kt = Math.imul(Ft, xr),
                Tt = Math.imul(Ft, Lr),
                Tt = Tt + Math.imul(Ut, xr) | 0,
                It = Math.imul(Ut, Lr),
                kt = kt + Math.imul(hr, Ir) | 0,
                Tt = Tt + Math.imul(hr, Jr) | 0,
                Tt = Tt + Math.imul(_r, Ir) | 0,
                It = It + Math.imul(_r, Jr) | 0,
                kt = kt + Math.imul(Gr, Yr) | 0,
                Tt = Tt + Math.imul(Gr, Sn) | 0,
                Tt = Tt + Math.imul(vr, Yr) | 0,
                It = It + Math.imul(vr, Sn) | 0,
                kt = kt + Math.imul(Hr, tn) | 0,
                Tt = Tt + Math.imul(Hr, Bn) | 0,
                Tt = Tt + Math.imul(un, tn) | 0,
                It = It + Math.imul(un, Bn) | 0,
                kt = kt + Math.imul(Or, dn) | 0,
                Tt = Tt + Math.imul(Or, Rn) | 0,
                Tt = Tt + Math.imul($r, dn) | 0,
                It = It + Math.imul($r, Rn) | 0,
                kt = kt + Math.imul(qr, an) | 0,
                Tt = Tt + Math.imul(qr, Un) | 0,
                Tt = Tt + Math.imul(Nr, an) | 0,
                It = It + Math.imul(Nr, Un) | 0,
                kt = kt + Math.imul(Xt, nr) | 0,
                Tt = Tt + Math.imul(Xt, sr) | 0,
                Tt = Tt + Math.imul(Sr, nr) | 0,
                It = It + Math.imul(Sr, sr) | 0,
                kt = kt + Math.imul(rr, cr) | 0,
                Tt = Tt + Math.imul(rr, Tr) | 0,
                Tt = Tt + Math.imul(fr, cr) | 0,
                It = It + Math.imul(fr, Tr) | 0,
                kt = kt + Math.imul(lr, Pr) | 0,
                Tt = Tt + Math.imul(lr, zr) | 0,
                Tt = Tt + Math.imul(Zt, Pr) | 0,
                It = It + Math.imul(Zt, zr) | 0;
                var vn = (Rt + kt | 0) + ((Tt & 8191) << 13) | 0;
                Rt = (It + (Tt >>> 13) | 0) + (vn >>> 26) | 0,
                vn &= 67108863,
                kt = Math.imul(Ft, Ir),
                Tt = Math.imul(Ft, Jr),
                Tt = Tt + Math.imul(Ut, Ir) | 0,
                It = Math.imul(Ut, Jr),
                kt = kt + Math.imul(hr, Yr) | 0,
                Tt = Tt + Math.imul(hr, Sn) | 0,
                Tt = Tt + Math.imul(_r, Yr) | 0,
                It = It + Math.imul(_r, Sn) | 0,
                kt = kt + Math.imul(Gr, tn) | 0,
                Tt = Tt + Math.imul(Gr, Bn) | 0,
                Tt = Tt + Math.imul(vr, tn) | 0,
                It = It + Math.imul(vr, Bn) | 0,
                kt = kt + Math.imul(Hr, dn) | 0,
                Tt = Tt + Math.imul(Hr, Rn) | 0,
                Tt = Tt + Math.imul(un, dn) | 0,
                It = It + Math.imul(un, Rn) | 0,
                kt = kt + Math.imul(Or, an) | 0,
                Tt = Tt + Math.imul(Or, Un) | 0,
                Tt = Tt + Math.imul($r, an) | 0,
                It = It + Math.imul($r, Un) | 0,
                kt = kt + Math.imul(qr, nr) | 0,
                Tt = Tt + Math.imul(qr, sr) | 0,
                Tt = Tt + Math.imul(Nr, nr) | 0,
                It = It + Math.imul(Nr, sr) | 0,
                kt = kt + Math.imul(Xt, cr) | 0,
                Tt = Tt + Math.imul(Xt, Tr) | 0,
                Tt = Tt + Math.imul(Sr, cr) | 0,
                It = It + Math.imul(Sr, Tr) | 0,
                kt = kt + Math.imul(rr, Pr) | 0,
                Tt = Tt + Math.imul(rr, zr) | 0,
                Tt = Tt + Math.imul(fr, Pr) | 0,
                It = It + Math.imul(fr, zr) | 0;
                var sn = (Rt + kt | 0) + ((Tt & 8191) << 13) | 0;
                Rt = (It + (Tt >>> 13) | 0) + (sn >>> 26) | 0,
                sn &= 67108863,
                kt = Math.imul(Ft, Yr),
                Tt = Math.imul(Ft, Sn),
                Tt = Tt + Math.imul(Ut, Yr) | 0,
                It = Math.imul(Ut, Sn),
                kt = kt + Math.imul(hr, tn) | 0,
                Tt = Tt + Math.imul(hr, Bn) | 0,
                Tt = Tt + Math.imul(_r, tn) | 0,
                It = It + Math.imul(_r, Bn) | 0,
                kt = kt + Math.imul(Gr, dn) | 0,
                Tt = Tt + Math.imul(Gr, Rn) | 0,
                Tt = Tt + Math.imul(vr, dn) | 0,
                It = It + Math.imul(vr, Rn) | 0,
                kt = kt + Math.imul(Hr, an) | 0,
                Tt = Tt + Math.imul(Hr, Un) | 0,
                Tt = Tt + Math.imul(un, an) | 0,
                It = It + Math.imul(un, Un) | 0,
                kt = kt + Math.imul(Or, nr) | 0,
                Tt = Tt + Math.imul(Or, sr) | 0,
                Tt = Tt + Math.imul($r, nr) | 0,
                It = It + Math.imul($r, sr) | 0,
                kt = kt + Math.imul(qr, cr) | 0,
                Tt = Tt + Math.imul(qr, Tr) | 0,
                Tt = Tt + Math.imul(Nr, cr) | 0,
                It = It + Math.imul(Nr, Tr) | 0,
                kt = kt + Math.imul(Xt, Pr) | 0,
                Tt = Tt + Math.imul(Xt, zr) | 0,
                Tt = Tt + Math.imul(Sr, Pr) | 0,
                It = It + Math.imul(Sr, zr) | 0;
                var hn = (Rt + kt | 0) + ((Tt & 8191) << 13) | 0;
                Rt = (It + (Tt >>> 13) | 0) + (hn >>> 26) | 0,
                hn &= 67108863,
                kt = Math.imul(Ft, tn),
                Tt = Math.imul(Ft, Bn),
                Tt = Tt + Math.imul(Ut, tn) | 0,
                It = Math.imul(Ut, Bn),
                kt = kt + Math.imul(hr, dn) | 0,
                Tt = Tt + Math.imul(hr, Rn) | 0,
                Tt = Tt + Math.imul(_r, dn) | 0,
                It = It + Math.imul(_r, Rn) | 0,
                kt = kt + Math.imul(Gr, an) | 0,
                Tt = Tt + Math.imul(Gr, Un) | 0,
                Tt = Tt + Math.imul(vr, an) | 0,
                It = It + Math.imul(vr, Un) | 0,
                kt = kt + Math.imul(Hr, nr) | 0,
                Tt = Tt + Math.imul(Hr, sr) | 0,
                Tt = Tt + Math.imul(un, nr) | 0,
                It = It + Math.imul(un, sr) | 0,
                kt = kt + Math.imul(Or, cr) | 0,
                Tt = Tt + Math.imul(Or, Tr) | 0,
                Tt = Tt + Math.imul($r, cr) | 0,
                It = It + Math.imul($r, Tr) | 0,
                kt = kt + Math.imul(qr, Pr) | 0,
                Tt = Tt + Math.imul(qr, zr) | 0,
                Tt = Tt + Math.imul(Nr, Pr) | 0,
                It = It + Math.imul(Nr, zr) | 0;
                var rn = (Rt + kt | 0) + ((Tt & 8191) << 13) | 0;
                Rt = (It + (Tt >>> 13) | 0) + (rn >>> 26) | 0,
                rn &= 67108863,
                kt = Math.imul(Ft, dn),
                Tt = Math.imul(Ft, Rn),
                Tt = Tt + Math.imul(Ut, dn) | 0,
                It = Math.imul(Ut, Rn),
                kt = kt + Math.imul(hr, an) | 0,
                Tt = Tt + Math.imul(hr, Un) | 0,
                Tt = Tt + Math.imul(_r, an) | 0,
                It = It + Math.imul(_r, Un) | 0,
                kt = kt + Math.imul(Gr, nr) | 0,
                Tt = Tt + Math.imul(Gr, sr) | 0,
                Tt = Tt + Math.imul(vr, nr) | 0,
                It = It + Math.imul(vr, sr) | 0,
                kt = kt + Math.imul(Hr, cr) | 0,
                Tt = Tt + Math.imul(Hr, Tr) | 0,
                Tt = Tt + Math.imul(un, cr) | 0,
                It = It + Math.imul(un, Tr) | 0,
                kt = kt + Math.imul(Or, Pr) | 0,
                Tt = Tt + Math.imul(Or, zr) | 0,
                Tt = Tt + Math.imul($r, Pr) | 0,
                It = It + Math.imul($r, zr) | 0;
                var ln = (Rt + kt | 0) + ((Tt & 8191) << 13) | 0;
                Rt = (It + (Tt >>> 13) | 0) + (ln >>> 26) | 0,
                ln &= 67108863,
                kt = Math.imul(Ft, an),
                Tt = Math.imul(Ft, Un),
                Tt = Tt + Math.imul(Ut, an) | 0,
                It = Math.imul(Ut, Un),
                kt = kt + Math.imul(hr, nr) | 0,
                Tt = Tt + Math.imul(hr, sr) | 0,
                Tt = Tt + Math.imul(_r, nr) | 0,
                It = It + Math.imul(_r, sr) | 0,
                kt = kt + Math.imul(Gr, cr) | 0,
                Tt = Tt + Math.imul(Gr, Tr) | 0,
                Tt = Tt + Math.imul(vr, cr) | 0,
                It = It + Math.imul(vr, Tr) | 0,
                kt = kt + Math.imul(Hr, Pr) | 0,
                Tt = Tt + Math.imul(Hr, zr) | 0,
                Tt = Tt + Math.imul(un, Pr) | 0,
                It = It + Math.imul(un, zr) | 0;
                var yr = (Rt + kt | 0) + ((Tt & 8191) << 13) | 0;
                Rt = (It + (Tt >>> 13) | 0) + (yr >>> 26) | 0,
                yr &= 67108863,
                kt = Math.imul(Ft, nr),
                Tt = Math.imul(Ft, sr),
                Tt = Tt + Math.imul(Ut, nr) | 0,
                It = Math.imul(Ut, sr),
                kt = kt + Math.imul(hr, cr) | 0,
                Tt = Tt + Math.imul(hr, Tr) | 0,
                Tt = Tt + Math.imul(_r, cr) | 0,
                It = It + Math.imul(_r, Tr) | 0,
                kt = kt + Math.imul(Gr, Pr) | 0,
                Tt = Tt + Math.imul(Gr, zr) | 0,
                Tt = Tt + Math.imul(vr, Pr) | 0,
                It = It + Math.imul(vr, zr) | 0;
                var Lt = (Rt + kt | 0) + ((Tt & 8191) << 13) | 0;
                Rt = (It + (Tt >>> 13) | 0) + (Lt >>> 26) | 0,
                Lt &= 67108863,
                kt = Math.imul(Ft, cr),
                Tt = Math.imul(Ft, Tr),
                Tt = Tt + Math.imul(Ut, cr) | 0,
                It = Math.imul(Ut, Tr),
                kt = kt + Math.imul(hr, Pr) | 0,
                Tt = Tt + Math.imul(hr, zr) | 0,
                Tt = Tt + Math.imul(_r, Pr) | 0,
                It = It + Math.imul(_r, zr) | 0;
                var Gt = (Rt + kt | 0) + ((Tt & 8191) << 13) | 0;
                Rt = (It + (Tt >>> 13) | 0) + (Gt >>> 26) | 0,
                Gt &= 67108863,
                kt = Math.imul(Ft, Pr),
                Tt = Math.imul(Ft, zr),
                Tt = Tt + Math.imul(Ut, Pr) | 0,
                It = Math.imul(Ut, zr);
                var Qt = (Rt + kt | 0) + ((Tt & 8191) << 13) | 0;
                return Rt = (It + (Tt >>> 13) | 0) + (Qt >>> 26) | 0,
                Qt &= 67108863,
                Bt[0] = Vr,
                Bt[1] = jr,
                Bt[2] = Mn,
                Bt[3] = nn,
                Bt[4] = gn,
                Bt[5] = mn,
                Bt[6] = xn,
                Bt[7] = _n,
                Bt[8] = yn,
                Bt[9] = wn,
                Bt[10] = vn,
                Bt[11] = sn,
                Bt[12] = hn,
                Bt[13] = rn,
                Bt[14] = ln,
                Bt[15] = yr,
                Bt[16] = Lt,
                Bt[17] = Gt,
                Bt[18] = Qt,
                Rt !== 0 && (Bt[19] = Rt,
                gt.length++),
                gt
            };
            Math.imul || (Ct = At);
            function Pt(Ht, Mt, _t) {
                _t.negative = Mt.negative ^ Ht.negative,
                _t.length = Ht.length + Mt.length;
                for (var gt = 0, vt = 0, Et = 0; Et < _t.length - 1; Et++) {
                    var Bt = vt;
                    vt = 0;
                    for (var Rt = gt & 67108863, kt = Math.min(Et, Mt.length - 1), Tt = Math.max(0, Et - Ht.length + 1); Tt <= kt; Tt++) {
                        var It = Et - Tt
                          , St = Ht.words[It] | 0
                          , qt = Mt.words[Tt] | 0
                          , ur = St * qt
                          , gr = ur & 67108863;
                        Bt = Bt + (ur / 67108864 | 0) | 0,
                        gr = gr + Rt | 0,
                        Rt = gr & 67108863,
                        Bt = Bt + (gr >>> 26) | 0,
                        vt += Bt >>> 26,
                        Bt &= 67108863
                    }
                    _t.words[Et] = Rt,
                    gt = Bt,
                    Bt = vt
                }
                return gt !== 0 ? _t.words[Et] = gt : _t.length--,
                _t.strip()
            }
            function $t(Ht, Mt, _t) {
                var gt = new Ot;
                return gt.mulp(Ht, Mt, _t)
            }
            y.prototype.mulTo = function(Mt, _t) {
                var gt, vt = this.length + Mt.length;
                return this.length === 10 && Mt.length === 10 ? gt = Ct(this, Mt, _t) : vt < 63 ? gt = At(this, Mt, _t) : vt < 1024 ? gt = Pt(this, Mt, _t) : gt = $t(this, Mt, _t),
                gt
            }
            ;
            function Ot(Ht, Mt) {
                this.x = Ht,
                this.y = Mt
            }
            Ot.prototype.makeRBT = function(Mt) {
                for (var _t = new Array(Mt), gt = y.prototype._countBits(Mt) - 1, vt = 0; vt < Mt; vt++)
                    _t[vt] = this.revBin(vt, gt, Mt);
                return _t
            }
            ,
            Ot.prototype.revBin = function(Mt, _t, gt) {
                if (Mt === 0 || Mt === gt - 1)
                    return Mt;
                for (var vt = 0, Et = 0; Et < _t; Et++)
                    vt |= (Mt & 1) << _t - Et - 1,
                    Mt >>= 1;
                return vt
            }
            ,
            Ot.prototype.permute = function(Mt, _t, gt, vt, Et, Bt) {
                for (var Rt = 0; Rt < Bt; Rt++)
                    vt[Rt] = _t[Mt[Rt]],
                    Et[Rt] = gt[Mt[Rt]]
            }
            ,
            Ot.prototype.transform = function(Mt, _t, gt, vt, Et, Bt) {
                this.permute(Bt, Mt, _t, gt, vt, Et);
                for (var Rt = 1; Rt < Et; Rt <<= 1)
                    for (var kt = Rt << 1, Tt = Math.cos(2 * Math.PI / kt), It = Math.sin(2 * Math.PI / kt), St = 0; St < Et; St += kt)
                        for (var qt = Tt, ur = It, gr = 0; gr < Rt; gr++) {
                            var lr = gt[St + gr]
                              , Zt = vt[St + gr]
                              , Vt = gt[St + gr + Rt]
                              , rr = vt[St + gr + Rt]
                              , fr = qt * Vt - ur * rr;
                            rr = qt * rr + ur * Vt,
                            Vt = fr,
                            gt[St + gr] = lr + Vt,
                            vt[St + gr] = Zt + rr,
                            gt[St + gr + Rt] = lr - Vt,
                            vt[St + gr + Rt] = Zt - rr,
                            gr !== kt && (fr = Tt * qt - It * ur,
                            ur = Tt * ur + It * qt,
                            qt = fr)
                        }
            }
            ,
            Ot.prototype.guessLen13b = function(Mt, _t) {
                var gt = Math.max(_t, Mt) | 1
                  , vt = gt & 1
                  , Et = 0;
                for (gt = gt / 2 | 0; gt; gt = gt >>> 1)
                    Et++;
                return 1 << Et + 1 + vt
            }
            ,
            Ot.prototype.conjugate = function(Mt, _t, gt) {
                if (!(gt <= 1))
                    for (var vt = 0; vt < gt / 2; vt++) {
                        var Et = Mt[vt];
                        Mt[vt] = Mt[gt - vt - 1],
                        Mt[gt - vt - 1] = Et,
                        Et = _t[vt],
                        _t[vt] = -_t[gt - vt - 1],
                        _t[gt - vt - 1] = -Et
                    }
            }
            ,
            Ot.prototype.normalize13b = function(Mt, _t) {
                for (var gt = 0, vt = 0; vt < _t / 2; vt++) {
                    var Et = Math.round(Mt[2 * vt + 1] / _t) * 8192 + Math.round(Mt[2 * vt] / _t) + gt;
                    Mt[vt] = Et & 67108863,
                    Et < 67108864 ? gt = 0 : gt = Et / 67108864 | 0
                }
                return Mt
            }
            ,
            Ot.prototype.convert13b = function(Mt, _t, gt, vt) {
                for (var Et = 0, Bt = 0; Bt < _t; Bt++)
                    Et = Et + (Mt[Bt] | 0),
                    gt[2 * Bt] = Et & 8191,
                    Et = Et >>> 13,
                    gt[2 * Bt + 1] = Et & 8191,
                    Et = Et >>> 13;
                for (Bt = 2 * _t; Bt < vt; ++Bt)
                    gt[Bt] = 0;
                m(Et === 0),
                m((Et & -8192) === 0)
            }
            ,
            Ot.prototype.stub = function(Mt) {
                for (var _t = new Array(Mt), gt = 0; gt < Mt; gt++)
                    _t[gt] = 0;
                return _t
            }
            ,
            Ot.prototype.mulp = function(Mt, _t, gt) {
                var vt = 2 * this.guessLen13b(Mt.length, _t.length)
                  , Et = this.makeRBT(vt)
                  , Bt = this.stub(vt)
                  , Rt = new Array(vt)
                  , kt = new Array(vt)
                  , Tt = new Array(vt)
                  , It = new Array(vt)
                  , St = new Array(vt)
                  , qt = new Array(vt)
                  , ur = gt.words;
                ur.length = vt,
                this.convert13b(Mt.words, Mt.length, Rt, vt),
                this.convert13b(_t.words, _t.length, It, vt),
                this.transform(Rt, Bt, kt, Tt, vt, Et),
                this.transform(It, Bt, St, qt, vt, Et);
                for (var gr = 0; gr < vt; gr++) {
                    var lr = kt[gr] * St[gr] - Tt[gr] * qt[gr];
                    Tt[gr] = kt[gr] * qt[gr] + Tt[gr] * St[gr],
                    kt[gr] = lr
                }
                return this.conjugate(kt, Tt, vt),
                this.transform(kt, Tt, ur, Bt, vt, Et),
                this.conjugate(ur, Bt, vt),
                this.normalize13b(ur, vt),
                gt.negative = Mt.negative ^ _t.negative,
                gt.length = Mt.length + _t.length,
                gt.strip()
            }
            ,
            y.prototype.mul = function(Mt) {
                var _t = new y(null);
                return _t.words = new Array(this.length + Mt.length),
                this.mulTo(Mt, _t)
            }
            ,
            y.prototype.mulf = function(Mt) {
                var _t = new y(null);
                return _t.words = new Array(this.length + Mt.length),
                $t(this, Mt, _t)
            }
            ,
            y.prototype.imul = function(Mt) {
                return this.clone().mulTo(Mt, this)
            }
            ,
            y.prototype.imuln = function(Mt) {
                m(typeof Mt == "number"),
                m(Mt < 67108864);
                for (var _t = 0, gt = 0; gt < this.length; gt++) {
                    var vt = (this.words[gt] | 0) * Mt
                      , Et = (vt & 67108863) + (_t & 67108863);
                    _t >>= 26,
                    _t += vt / 67108864 | 0,
                    _t += Et >>> 26,
                    this.words[gt] = Et & 67108863
                }
                return _t !== 0 && (this.words[gt] = _t,
                this.length++),
                this
            }
            ,
            y.prototype.muln = function(Mt) {
                return this.clone().imuln(Mt)
            }
            ,
            y.prototype.sqr = function() {
                return this.mul(this)
            }
            ,
            y.prototype.isqr = function() {
                return this.imul(this.clone())
            }
            ,
            y.prototype.pow = function(Mt) {
                var _t = xt(Mt);
                if (_t.length === 0)
                    return new y(1);
                for (var gt = this, vt = 0; vt < _t.length && _t[vt] === 0; vt++,
                gt = gt.sqr())
                    ;
                if (++vt < _t.length)
                    for (var Et = gt.sqr(); vt < _t.length; vt++,
                    Et = Et.sqr())
                        _t[vt] !== 0 && (gt = gt.mul(Et));
                return gt
            }
            ,
            y.prototype.iushln = function(Mt) {
                m(typeof Mt == "number" && Mt >= 0);
                var _t = Mt % 26, gt = (Mt - _t) / 26, vt = 67108863 >>> 26 - _t << 26 - _t, Et;
                if (_t !== 0) {
                    var Bt = 0;
                    for (Et = 0; Et < this.length; Et++) {
                        var Rt = this.words[Et] & vt
                          , kt = (this.words[Et] | 0) - Rt << _t;
                        this.words[Et] = kt | Bt,
                        Bt = Rt >>> 26 - _t
                    }
                    Bt && (this.words[Et] = Bt,
                    this.length++)
                }
                if (gt !== 0) {
                    for (Et = this.length - 1; Et >= 0; Et--)
                        this.words[Et + gt] = this.words[Et];
                    for (Et = 0; Et < gt; Et++)
                        this.words[Et] = 0;
                    this.length += gt
                }
                return this.strip()
            }
            ,
            y.prototype.ishln = function(Mt) {
                return m(this.negative === 0),
                this.iushln(Mt)
            }
            ,
            y.prototype.iushrn = function(Mt, _t, gt) {
                m(typeof Mt == "number" && Mt >= 0);
                var vt;
                _t ? vt = (_t - _t % 26) / 26 : vt = 0;
                var Et = Mt % 26
                  , Bt = Math.min((Mt - Et) / 26, this.length)
                  , Rt = 67108863 ^ 67108863 >>> Et << Et
                  , kt = gt;
                if (vt -= Bt,
                vt = Math.max(0, vt),
                kt) {
                    for (var Tt = 0; Tt < Bt; Tt++)
                        kt.words[Tt] = this.words[Tt];
                    kt.length = Bt
                }
                if (Bt !== 0)
                    if (this.length > Bt)
                        for (this.length -= Bt,
                        Tt = 0; Tt < this.length; Tt++)
                            this.words[Tt] = this.words[Tt + Bt];
                    else
                        this.words[0] = 0,
                        this.length = 1;
                var It = 0;
                for (Tt = this.length - 1; Tt >= 0 && (It !== 0 || Tt >= vt); Tt--) {
                    var St = this.words[Tt] | 0;
                    this.words[Tt] = It << 26 - Et | St >>> Et,
                    It = St & Rt
                }
                return kt && It !== 0 && (kt.words[kt.length++] = It),
                this.length === 0 && (this.words[0] = 0,
                this.length = 1),
                this.strip()
            }
            ,
            y.prototype.ishrn = function(Mt, _t, gt) {
                return m(this.negative === 0),
                this.iushrn(Mt, _t, gt)
            }
            ,
            y.prototype.shln = function(Mt) {
                return this.clone().ishln(Mt)
            }
            ,
            y.prototype.ushln = function(Mt) {
                return this.clone().iushln(Mt)
            }
            ,
            y.prototype.shrn = function(Mt) {
                return this.clone().ishrn(Mt)
            }
            ,
            y.prototype.ushrn = function(Mt) {
                return this.clone().iushrn(Mt)
            }
            ,
            y.prototype.testn = function(Mt) {
                m(typeof Mt == "number" && Mt >= 0);
                var _t = Mt % 26
                  , gt = (Mt - _t) / 26
                  , vt = 1 << _t;
                if (this.length <= gt)
                    return !1;
                var Et = this.words[gt];
                return !!(Et & vt)
            }
            ,
            y.prototype.imaskn = function(Mt) {
                m(typeof Mt == "number" && Mt >= 0);
                var _t = Mt % 26
                  , gt = (Mt - _t) / 26;
                if (m(this.negative === 0, "imaskn works only with positive numbers"),
                this.length <= gt)
                    return this;
                if (_t !== 0 && gt++,
                this.length = Math.min(gt, this.length),
                _t !== 0) {
                    var vt = 67108863 ^ 67108863 >>> _t << _t;
                    this.words[this.length - 1] &= vt
                }
                return this.strip()
            }
            ,
            y.prototype.maskn = function(Mt) {
                return this.clone().imaskn(Mt)
            }
            ,
            y.prototype.iaddn = function(Mt) {
                return m(typeof Mt == "number"),
                m(Mt < 67108864),
                Mt < 0 ? this.isubn(-Mt) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < Mt ? (this.words[0] = Mt - (this.words[0] | 0),
                this.negative = 0,
                this) : (this.negative = 0,
                this.isubn(Mt),
                this.negative = 1,
                this) : this._iaddn(Mt)
            }
            ,
            y.prototype._iaddn = function(Mt) {
                this.words[0] += Mt;
                for (var _t = 0; _t < this.length && this.words[_t] >= 67108864; _t++)
                    this.words[_t] -= 67108864,
                    _t === this.length - 1 ? this.words[_t + 1] = 1 : this.words[_t + 1]++;
                return this.length = Math.max(this.length, _t + 1),
                this
            }
            ,
            y.prototype.isubn = function(Mt) {
                if (m(typeof Mt == "number"),
                m(Mt < 67108864),
                Mt < 0)
                    return this.iaddn(-Mt);
                if (this.negative !== 0)
                    return this.negative = 0,
                    this.iaddn(Mt),
                    this.negative = 1,
                    this;
                if (this.words[0] -= Mt,
                this.length === 1 && this.words[0] < 0)
                    this.words[0] = -this.words[0],
                    this.negative = 1;
                else
                    for (var _t = 0; _t < this.length && this.words[_t] < 0; _t++)
                        this.words[_t] += 67108864,
                        this.words[_t + 1] -= 1;
                return this.strip()
            }
            ,
            y.prototype.addn = function(Mt) {
                return this.clone().iaddn(Mt)
            }
            ,
            y.prototype.subn = function(Mt) {
                return this.clone().isubn(Mt)
            }
            ,
            y.prototype.iabs = function() {
                return this.negative = 0,
                this
            }
            ,
            y.prototype.abs = function() {
                return this.clone().iabs()
            }
            ,
            y.prototype._ishlnsubmul = function(Mt, _t, gt) {
                var vt = Mt.length + gt, Et;
                this._expand(vt);
                var Bt, Rt = 0;
                for (Et = 0; Et < Mt.length; Et++) {
                    Bt = (this.words[Et + gt] | 0) + Rt;
                    var kt = (Mt.words[Et] | 0) * _t;
                    Bt -= kt & 67108863,
                    Rt = (Bt >> 26) - (kt / 67108864 | 0),
                    this.words[Et + gt] = Bt & 67108863
                }
                for (; Et < this.length - gt; Et++)
                    Bt = (this.words[Et + gt] | 0) + Rt,
                    Rt = Bt >> 26,
                    this.words[Et + gt] = Bt & 67108863;
                if (Rt === 0)
                    return this.strip();
                for (m(Rt === -1),
                Rt = 0,
                Et = 0; Et < this.length; Et++)
                    Bt = -(this.words[Et] | 0) + Rt,
                    Rt = Bt >> 26,
                    this.words[Et] = Bt & 67108863;
                return this.negative = 1,
                this.strip()
            }
            ,
            y.prototype._wordDiv = function(Mt, _t) {
                var gt = this.length - Mt.length
                  , vt = this.clone()
                  , Et = Mt
                  , Bt = Et.words[Et.length - 1] | 0
                  , Rt = this._countBits(Bt);
                gt = 26 - Rt,
                gt !== 0 && (Et = Et.ushln(gt),
                vt.iushln(gt),
                Bt = Et.words[Et.length - 1] | 0);
                var kt = vt.length - Et.length, Tt;
                if (_t !== "mod") {
                    Tt = new y(null),
                    Tt.length = kt + 1,
                    Tt.words = new Array(Tt.length);
                    for (var It = 0; It < Tt.length; It++)
                        Tt.words[It] = 0
                }
                var St = vt.clone()._ishlnsubmul(Et, 1, kt);
                St.negative === 0 && (vt = St,
                Tt && (Tt.words[kt] = 1));
                for (var qt = kt - 1; qt >= 0; qt--) {
                    var ur = (vt.words[Et.length + qt] | 0) * 67108864 + (vt.words[Et.length + qt - 1] | 0);
                    for (ur = Math.min(ur / Bt | 0, 67108863),
                    vt._ishlnsubmul(Et, ur, qt); vt.negative !== 0; )
                        ur--,
                        vt.negative = 0,
                        vt._ishlnsubmul(Et, 1, qt),
                        vt.isZero() || (vt.negative ^= 1);
                    Tt && (Tt.words[qt] = ur)
                }
                return Tt && Tt.strip(),
                vt.strip(),
                _t !== "div" && gt !== 0 && vt.iushrn(gt),
                {
                    div: Tt || null,
                    mod: vt
                }
            }
            ,
            y.prototype.divmod = function(Mt, _t, gt) {
                if (m(!Mt.isZero()),
                this.isZero())
                    return {
                        div: new y(0),
                        mod: new y(0)
                    };
                var vt, Et, Bt;
                return this.negative !== 0 && Mt.negative === 0 ? (Bt = this.neg().divmod(Mt, _t),
                _t !== "mod" && (vt = Bt.div.neg()),
                _t !== "div" && (Et = Bt.mod.neg(),
                gt && Et.negative !== 0 && Et.iadd(Mt)),
                {
                    div: vt,
                    mod: Et
                }) : this.negative === 0 && Mt.negative !== 0 ? (Bt = this.divmod(Mt.neg(), _t),
                _t !== "mod" && (vt = Bt.div.neg()),
                {
                    div: vt,
                    mod: Bt.mod
                }) : this.negative & Mt.negative ? (Bt = this.neg().divmod(Mt.neg(), _t),
                _t !== "div" && (Et = Bt.mod.neg(),
                gt && Et.negative !== 0 && Et.isub(Mt)),
                {
                    div: Bt.div,
                    mod: Et
                }) : Mt.length > this.length || this.cmp(Mt) < 0 ? {
                    div: new y(0),
                    mod: this
                } : Mt.length === 1 ? _t === "div" ? {
                    div: this.divn(Mt.words[0]),
                    mod: null
                } : _t === "mod" ? {
                    div: null,
                    mod: new y(this.modn(Mt.words[0]))
                } : {
                    div: this.divn(Mt.words[0]),
                    mod: new y(this.modn(Mt.words[0]))
                } : this._wordDiv(Mt, _t)
            }
            ,
            y.prototype.div = function(Mt) {
                return this.divmod(Mt, "div", !1).div
            }
            ,
            y.prototype.mod = function(Mt) {
                return this.divmod(Mt, "mod", !1).mod
            }
            ,
            y.prototype.umod = function(Mt) {
                return this.divmod(Mt, "mod", !0).mod
            }
            ,
            y.prototype.divRound = function(Mt) {
                var _t = this.divmod(Mt);
                if (_t.mod.isZero())
                    return _t.div;
                var gt = _t.div.negative !== 0 ? _t.mod.isub(Mt) : _t.mod
                  , vt = Mt.ushrn(1)
                  , Et = Mt.andln(1)
                  , Bt = gt.cmp(vt);
                return Bt < 0 || Et === 1 && Bt === 0 ? _t.div : _t.div.negative !== 0 ? _t.div.isubn(1) : _t.div.iaddn(1)
            }
            ,
            y.prototype.modn = function(Mt) {
                m(Mt <= 67108863);
                for (var _t = (1 << 26) % Mt, gt = 0, vt = this.length - 1; vt >= 0; vt--)
                    gt = (_t * gt + (this.words[vt] | 0)) % Mt;
                return gt
            }
            ,
            y.prototype.idivn = function(Mt) {
                m(Mt <= 67108863);
                for (var _t = 0, gt = this.length - 1; gt >= 0; gt--) {
                    var vt = (this.words[gt] | 0) + _t * 67108864;
                    this.words[gt] = vt / Mt | 0,
                    _t = vt % Mt
                }
                return this.strip()
            }
            ,
            y.prototype.divn = function(Mt) {
                return this.clone().idivn(Mt)
            }
            ,
            y.prototype.egcd = function(Mt) {
                m(Mt.negative === 0),
                m(!Mt.isZero());
                var _t = this
                  , gt = Mt.clone();
                _t.negative !== 0 ? _t = _t.umod(Mt) : _t = _t.clone();
                for (var vt = new y(1), Et = new y(0), Bt = new y(0), Rt = new y(1), kt = 0; _t.isEven() && gt.isEven(); )
                    _t.iushrn(1),
                    gt.iushrn(1),
                    ++kt;
                for (var Tt = gt.clone(), It = _t.clone(); !_t.isZero(); ) {
                    for (var St = 0, qt = 1; !(_t.words[0] & qt) && St < 26; ++St,
                    qt <<= 1)
                        ;
                    if (St > 0)
                        for (_t.iushrn(St); St-- > 0; )
                            (vt.isOdd() || Et.isOdd()) && (vt.iadd(Tt),
                            Et.isub(It)),
                            vt.iushrn(1),
                            Et.iushrn(1);
                    for (var ur = 0, gr = 1; !(gt.words[0] & gr) && ur < 26; ++ur,
                    gr <<= 1)
                        ;
                    if (ur > 0)
                        for (gt.iushrn(ur); ur-- > 0; )
                            (Bt.isOdd() || Rt.isOdd()) && (Bt.iadd(Tt),
                            Rt.isub(It)),
                            Bt.iushrn(1),
                            Rt.iushrn(1);
                    _t.cmp(gt) >= 0 ? (_t.isub(gt),
                    vt.isub(Bt),
                    Et.isub(Rt)) : (gt.isub(_t),
                    Bt.isub(vt),
                    Rt.isub(Et))
                }
                return {
                    a: Bt,
                    b: Rt,
                    gcd: gt.iushln(kt)
                }
            }
            ,
            y.prototype._invmp = function(Mt) {
                m(Mt.negative === 0),
                m(!Mt.isZero());
                var _t = this
                  , gt = Mt.clone();
                _t.negative !== 0 ? _t = _t.umod(Mt) : _t = _t.clone();
                for (var vt = new y(1), Et = new y(0), Bt = gt.clone(); _t.cmpn(1) > 0 && gt.cmpn(1) > 0; ) {
                    for (var Rt = 0, kt = 1; !(_t.words[0] & kt) && Rt < 26; ++Rt,
                    kt <<= 1)
                        ;
                    if (Rt > 0)
                        for (_t.iushrn(Rt); Rt-- > 0; )
                            vt.isOdd() && vt.iadd(Bt),
                            vt.iushrn(1);
                    for (var Tt = 0, It = 1; !(gt.words[0] & It) && Tt < 26; ++Tt,
                    It <<= 1)
                        ;
                    if (Tt > 0)
                        for (gt.iushrn(Tt); Tt-- > 0; )
                            Et.isOdd() && Et.iadd(Bt),
                            Et.iushrn(1);
                    _t.cmp(gt) >= 0 ? (_t.isub(gt),
                    vt.isub(Et)) : (gt.isub(_t),
                    Et.isub(vt))
                }
                var St;
                return _t.cmpn(1) === 0 ? St = vt : St = Et,
                St.cmpn(0) < 0 && St.iadd(Mt),
                St
            }
            ,
            y.prototype.gcd = function(Mt) {
                if (this.isZero())
                    return Mt.abs();
                if (Mt.isZero())
                    return this.abs();
                var _t = this.clone()
                  , gt = Mt.clone();
                _t.negative = 0,
                gt.negative = 0;
                for (var vt = 0; _t.isEven() && gt.isEven(); vt++)
                    _t.iushrn(1),
                    gt.iushrn(1);
                do {
                    for (; _t.isEven(); )
                        _t.iushrn(1);
                    for (; gt.isEven(); )
                        gt.iushrn(1);
                    var Et = _t.cmp(gt);
                    if (Et < 0) {
                        var Bt = _t;
                        _t = gt,
                        gt = Bt
                    } else if (Et === 0 || gt.cmpn(1) === 0)
                        break;
                    _t.isub(gt)
                } while (!0);
                return gt.iushln(vt)
            }
            ,
            y.prototype.invm = function(Mt) {
                return this.egcd(Mt).a.umod(Mt)
            }
            ,
            y.prototype.isEven = function() {
                return (this.words[0] & 1) === 0
            }
            ,
            y.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1
            }
            ,
            y.prototype.andln = function(Mt) {
                return this.words[0] & Mt
            }
            ,
            y.prototype.bincn = function(Mt) {
                m(typeof Mt == "number");
                var _t = Mt % 26
                  , gt = (Mt - _t) / 26
                  , vt = 1 << _t;
                if (this.length <= gt)
                    return this._expand(gt + 1),
                    this.words[gt] |= vt,
                    this;
                for (var Et = vt, Bt = gt; Et !== 0 && Bt < this.length; Bt++) {
                    var Rt = this.words[Bt] | 0;
                    Rt += Et,
                    Et = Rt >>> 26,
                    Rt &= 67108863,
                    this.words[Bt] = Rt
                }
                return Et !== 0 && (this.words[Bt] = Et,
                this.length++),
                this
            }
            ,
            y.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0
            }
            ,
            y.prototype.cmpn = function(Mt) {
                var _t = Mt < 0;
                if (this.negative !== 0 && !_t)
                    return -1;
                if (this.negative === 0 && _t)
                    return 1;
                this.strip();
                var gt;
                if (this.length > 1)
                    gt = 1;
                else {
                    _t && (Mt = -Mt),
                    m(Mt <= 67108863, "Number is too big");
                    var vt = this.words[0] | 0;
                    gt = vt === Mt ? 0 : vt < Mt ? -1 : 1
                }
                return this.negative !== 0 ? -gt | 0 : gt
            }
            ,
            y.prototype.cmp = function(Mt) {
                if (this.negative !== 0 && Mt.negative === 0)
                    return -1;
                if (this.negative === 0 && Mt.negative !== 0)
                    return 1;
                var _t = this.ucmp(Mt);
                return this.negative !== 0 ? -_t | 0 : _t
            }
            ,
            y.prototype.ucmp = function(Mt) {
                if (this.length > Mt.length)
                    return 1;
                if (this.length < Mt.length)
                    return -1;
                for (var _t = 0, gt = this.length - 1; gt >= 0; gt--) {
                    var vt = this.words[gt] | 0
                      , Et = Mt.words[gt] | 0;
                    if (vt !== Et) {
                        vt < Et ? _t = -1 : vt > Et && (_t = 1);
                        break
                    }
                }
                return _t
            }
            ,
            y.prototype.gtn = function(Mt) {
                return this.cmpn(Mt) === 1
            }
            ,
            y.prototype.gt = function(Mt) {
                return this.cmp(Mt) === 1
            }
            ,
            y.prototype.gten = function(Mt) {
                return this.cmpn(Mt) >= 0
            }
            ,
            y.prototype.gte = function(Mt) {
                return this.cmp(Mt) >= 0
            }
            ,
            y.prototype.ltn = function(Mt) {
                return this.cmpn(Mt) === -1
            }
            ,
            y.prototype.lt = function(Mt) {
                return this.cmp(Mt) === -1
            }
            ,
            y.prototype.lten = function(Mt) {
                return this.cmpn(Mt) <= 0
            }
            ,
            y.prototype.lte = function(Mt) {
                return this.cmp(Mt) <= 0
            }
            ,
            y.prototype.eqn = function(Mt) {
                return this.cmpn(Mt) === 0
            }
            ,
            y.prototype.eq = function(Mt) {
                return this.cmp(Mt) === 0
            }
            ,
            y.red = function(Mt) {
                return new tr(Mt)
            }
            ,
            y.prototype.toRed = function(Mt) {
                return m(!this.red, "Already a number in reduction context"),
                m(this.negative === 0, "red works only with positives"),
                Mt.convertTo(this)._forceRed(Mt)
            }
            ,
            y.prototype.fromRed = function() {
                return m(this.red, "fromRed works only with numbers in reduction context"),
                this.red.convertFrom(this)
            }
            ,
            y.prototype._forceRed = function(Mt) {
                return this.red = Mt,
                this
            }
            ,
            y.prototype.forceRed = function(Mt) {
                return m(!this.red, "Already a number in reduction context"),
                this._forceRed(Mt)
            }
            ,
            y.prototype.redAdd = function(Mt) {
                return m(this.red, "redAdd works only with red numbers"),
                this.red.add(this, Mt)
            }
            ,
            y.prototype.redIAdd = function(Mt) {
                return m(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, Mt)
            }
            ,
            y.prototype.redSub = function(Mt) {
                return m(this.red, "redSub works only with red numbers"),
                this.red.sub(this, Mt)
            }
            ,
            y.prototype.redISub = function(Mt) {
                return m(this.red, "redISub works only with red numbers"),
                this.red.isub(this, Mt)
            }
            ,
            y.prototype.redShl = function(Mt) {
                return m(this.red, "redShl works only with red numbers"),
                this.red.shl(this, Mt)
            }
            ,
            y.prototype.redMul = function(Mt) {
                return m(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, Mt),
                this.red.mul(this, Mt)
            }
            ,
            y.prototype.redIMul = function(Mt) {
                return m(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, Mt),
                this.red.imul(this, Mt)
            }
            ,
            y.prototype.redSqr = function() {
                return m(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
            }
            ,
            y.prototype.redISqr = function() {
                return m(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
            }
            ,
            y.prototype.redSqrt = function() {
                return m(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
            }
            ,
            y.prototype.redInvm = function() {
                return m(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
            }
            ,
            y.prototype.redNeg = function() {
                return m(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
            }
            ,
            y.prototype.redPow = function(Mt) {
                return m(this.red && !Mt.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, Mt)
            }
            ;
            var Nt = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function zt(Ht, Mt) {
                this.name = Ht,
                this.p = new y(Mt,16),
                this.n = this.p.bitLength(),
                this.k = new y(1).iushln(this.n).isub(this.p),
                this.tmp = this._tmp()
            }
            zt.prototype._tmp = function() {
                var Mt = new y(null);
                return Mt.words = new Array(Math.ceil(this.n / 13)),
                Mt
            }
            ,
            zt.prototype.ireduce = function(Mt) {
                var _t = Mt, gt;
                do
                    this.split(_t, this.tmp),
                    _t = this.imulK(_t),
                    _t = _t.iadd(this.tmp),
                    gt = _t.bitLength();
                while (gt > this.n);
                var vt = gt < this.n ? -1 : _t.ucmp(this.p);
                return vt === 0 ? (_t.words[0] = 0,
                _t.length = 1) : vt > 0 ? _t.isub(this.p) : _t.strip !== void 0 ? _t.strip() : _t._strip(),
                _t
            }
            ,
            zt.prototype.split = function(Mt, _t) {
                Mt.iushrn(this.n, 0, _t)
            }
            ,
            zt.prototype.imulK = function(Mt) {
                return Mt.imul(this.k)
            }
            ;
            function Wt() {
                zt.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
            }
            k(Wt, zt),
            Wt.prototype.split = function(Mt, _t) {
                for (var gt = 4194303, vt = Math.min(Mt.length, 9), Et = 0; Et < vt; Et++)
                    _t.words[Et] = Mt.words[Et];
                if (_t.length = vt,
                Mt.length <= 9) {
                    Mt.words[0] = 0,
                    Mt.length = 1;
                    return
                }
                var Bt = Mt.words[9];
                for (_t.words[_t.length++] = Bt & gt,
                Et = 10; Et < Mt.length; Et++) {
                    var Rt = Mt.words[Et] | 0;
                    Mt.words[Et - 10] = (Rt & gt) << 4 | Bt >>> 22,
                    Bt = Rt
                }
                Bt >>>= 22,
                Mt.words[Et - 10] = Bt,
                Bt === 0 && Mt.length > 10 ? Mt.length -= 10 : Mt.length -= 9
            }
            ,
            Wt.prototype.imulK = function(Mt) {
                Mt.words[Mt.length] = 0,
                Mt.words[Mt.length + 1] = 0,
                Mt.length += 2;
                for (var _t = 0, gt = 0; gt < Mt.length; gt++) {
                    var vt = Mt.words[gt] | 0;
                    _t += vt * 977,
                    Mt.words[gt] = _t & 67108863,
                    _t = vt * 64 + (_t / 67108864 | 0)
                }
                return Mt.words[Mt.length - 1] === 0 && (Mt.length--,
                Mt.words[Mt.length - 1] === 0 && Mt.length--),
                Mt
            }
            ;
            function Kt() {
                zt.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
            }
            k(Kt, zt);
            function ir() {
                zt.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
            }
            k(ir, zt);
            function or() {
                zt.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
            }
            k(or, zt),
            or.prototype.imulK = function(Mt) {
                for (var _t = 0, gt = 0; gt < Mt.length; gt++) {
                    var vt = (Mt.words[gt] | 0) * 19 + _t
                      , Et = vt & 67108863;
                    vt >>>= 26,
                    Mt.words[gt] = Et,
                    _t = vt
                }
                return _t !== 0 && (Mt.words[Mt.length++] = _t),
                Mt
            }
            ,
            y._prime = function(Mt) {
                if (Nt[Mt])
                    return Nt[Mt];
                var _t;
                if (Mt === "k256")
                    _t = new Wt;
                else if (Mt === "p224")
                    _t = new Kt;
                else if (Mt === "p192")
                    _t = new ir;
                else if (Mt === "p25519")
                    _t = new or;
                else
                    throw new Error("Unknown prime " + Mt);
                return Nt[Mt] = _t,
                _t
            }
            ;
            function tr(Ht) {
                if (typeof Ht == "string") {
                    var Mt = y._prime(Ht);
                    this.m = Mt.p,
                    this.prime = Mt
                } else
                    m(Ht.gtn(1), "modulus must be greater than 1"),
                    this.m = Ht,
                    this.prime = null
            }
            tr.prototype._verify1 = function(Mt) {
                m(Mt.negative === 0, "red works only with positives"),
                m(Mt.red, "red works only with red numbers")
            }
            ,
            tr.prototype._verify2 = function(Mt, _t) {
                m((Mt.negative | _t.negative) === 0, "red works only with positives"),
                m(Mt.red && Mt.red === _t.red, "red works only with red numbers")
            }
            ,
            tr.prototype.imod = function(Mt) {
                return this.prime ? this.prime.ireduce(Mt)._forceRed(this) : Mt.umod(this.m)._forceRed(this)
            }
            ,
            tr.prototype.neg = function(Mt) {
                return Mt.isZero() ? Mt.clone() : this.m.sub(Mt)._forceRed(this)
            }
            ,
            tr.prototype.add = function(Mt, _t) {
                this._verify2(Mt, _t);
                var gt = Mt.add(_t);
                return gt.cmp(this.m) >= 0 && gt.isub(this.m),
                gt._forceRed(this)
            }
            ,
            tr.prototype.iadd = function(Mt, _t) {
                this._verify2(Mt, _t);
                var gt = Mt.iadd(_t);
                return gt.cmp(this.m) >= 0 && gt.isub(this.m),
                gt
            }
            ,
            tr.prototype.sub = function(Mt, _t) {
                this._verify2(Mt, _t);
                var gt = Mt.sub(_t);
                return gt.cmpn(0) < 0 && gt.iadd(this.m),
                gt._forceRed(this)
            }
            ,
            tr.prototype.isub = function(Mt, _t) {
                this._verify2(Mt, _t);
                var gt = Mt.isub(_t);
                return gt.cmpn(0) < 0 && gt.iadd(this.m),
                gt
            }
            ,
            tr.prototype.shl = function(Mt, _t) {
                return this._verify1(Mt),
                this.imod(Mt.ushln(_t))
            }
            ,
            tr.prototype.imul = function(Mt, _t) {
                return this._verify2(Mt, _t),
                this.imod(Mt.imul(_t))
            }
            ,
            tr.prototype.mul = function(Mt, _t) {
                return this._verify2(Mt, _t),
                this.imod(Mt.mul(_t))
            }
            ,
            tr.prototype.isqr = function(Mt) {
                return this.imul(Mt, Mt.clone())
            }
            ,
            tr.prototype.sqr = function(Mt) {
                return this.mul(Mt, Mt)
            }
            ,
            tr.prototype.sqrt = function(Mt) {
                if (Mt.isZero())
                    return Mt.clone();
                var _t = this.m.andln(3);
                if (m(_t % 2 === 1),
                _t === 3) {
                    var gt = this.m.add(new y(1)).iushrn(2);
                    return this.pow(Mt, gt)
                }
                for (var vt = this.m.subn(1), Et = 0; !vt.isZero() && vt.andln(1) === 0; )
                    Et++,
                    vt.iushrn(1);
                m(!vt.isZero());
                var Bt = new y(1).toRed(this)
                  , Rt = Bt.redNeg()
                  , kt = this.m.subn(1).iushrn(1)
                  , Tt = this.m.bitLength();
                for (Tt = new y(2 * Tt * Tt).toRed(this); this.pow(Tt, kt).cmp(Rt) !== 0; )
                    Tt.redIAdd(Rt);
                for (var It = this.pow(Tt, vt), St = this.pow(Mt, vt.addn(1).iushrn(1)), qt = this.pow(Mt, vt), ur = Et; qt.cmp(Bt) !== 0; ) {
                    for (var gr = qt, lr = 0; gr.cmp(Bt) !== 0; lr++)
                        gr = gr.redSqr();
                    m(lr < ur);
                    var Zt = this.pow(It, new y(1).iushln(ur - lr - 1));
                    St = St.redMul(Zt),
                    It = Zt.redSqr(),
                    qt = qt.redMul(It),
                    ur = lr
                }
                return St
            }
            ,
            tr.prototype.invm = function(Mt) {
                var _t = Mt._invmp(this.m);
                return _t.negative !== 0 ? (_t.negative = 0,
                this.imod(_t).redNeg()) : this.imod(_t)
            }
            ,
            tr.prototype.pow = function(Mt, _t) {
                if (_t.isZero())
                    return new y(1).toRed(this);
                if (_t.cmpn(1) === 0)
                    return Mt.clone();
                var gt = 4
                  , vt = new Array(1 << gt);
                vt[0] = new y(1).toRed(this),
                vt[1] = Mt;
                for (var Et = 2; Et < vt.length; Et++)
                    vt[Et] = this.mul(vt[Et - 1], Mt);
                var Bt = vt[0]
                  , Rt = 0
                  , kt = 0
                  , Tt = _t.bitLength() % 26;
                for (Tt === 0 && (Tt = 26),
                Et = _t.length - 1; Et >= 0; Et--) {
                    for (var It = _t.words[Et], St = Tt - 1; St >= 0; St--) {
                        var qt = It >> St & 1;
                        if (Bt !== vt[0] && (Bt = this.sqr(Bt)),
                        qt === 0 && Rt === 0) {
                            kt = 0;
                            continue
                        }
                        Rt <<= 1,
                        Rt |= qt,
                        kt++,
                        !(kt !== gt && (Et !== 0 || St !== 0)) && (Bt = this.mul(Bt, vt[Rt]),
                        kt = 0,
                        Rt = 0)
                    }
                    Tt = 26
                }
                return Bt
            }
            ,
            tr.prototype.convertTo = function(Mt) {
                var _t = Mt.umod(this.m);
                return _t === Mt ? _t.clone() : _t
            }
            ,
            tr.prototype.convertFrom = function(Mt) {
                var _t = Mt.clone();
                return _t.red = null,
                _t
            }
            ,
            y.mont = function(Mt) {
                return new wr(Mt)
            }
            ;
            function wr(Ht) {
                tr.call(this, Ht),
                this.shift = this.m.bitLength(),
                this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26),
                this.r = new y(1).iushln(this.shift),
                this.r2 = this.imod(this.r.sqr()),
                this.rinv = this.r._invmp(this.m),
                this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
                this.minv = this.minv.umod(this.r),
                this.minv = this.r.sub(this.minv)
            }
            k(wr, tr),
            wr.prototype.convertTo = function(Mt) {
                return this.imod(Mt.ushln(this.shift))
            }
            ,
            wr.prototype.convertFrom = function(Mt) {
                var _t = this.imod(Mt.mul(this.rinv));
                return _t.red = null,
                _t
            }
            ,
            wr.prototype.imul = function(Mt, _t) {
                if (Mt.isZero() || _t.isZero())
                    return Mt.words[0] = 0,
                    Mt.length = 1,
                    Mt;
                var gt = Mt.imul(_t)
                  , vt = gt.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , Et = gt.isub(vt).iushrn(this.shift)
                  , Bt = Et;
                return Et.cmp(this.m) >= 0 ? Bt = Et.isub(this.m) : Et.cmpn(0) < 0 && (Bt = Et.iadd(this.m)),
                Bt._forceRed(this)
            }
            ,
            wr.prototype.mul = function(Mt, _t) {
                if (Mt.isZero() || _t.isZero())
                    return new y(0)._forceRed(this);
                var gt = Mt.mul(_t)
                  , vt = gt.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , Et = gt.isub(vt).iushrn(this.shift)
                  , Bt = Et;
                return Et.cmp(this.m) >= 0 ? Bt = Et.isub(this.m) : Et.cmpn(0) < 0 && (Bt = Et.iadd(this.m)),
                Bt._forceRed(this)
            }
            ,
            wr.prototype.invm = function(Mt) {
                var _t = this.imod(Mt._invmp(this.m).mul(this.r2));
                return _t._forceRed(this)
            }
        }
        )(r, commonjsGlobal)
    }(bn$2)),
    bn$2.exports
}
var brorand = {
    exports: {}
}, hasRequiredBrorand;
function requireBrorand() {
    if (hasRequiredBrorand)
        return brorand.exports;
    hasRequiredBrorand = 1;
    var r;
    brorand.exports = function(k) {
        return r || (r = new d(null)),
        r.generate(k)
    }
    ;
    function d(m) {
        this.rand = m
    }
    if (brorand.exports.Rand = d,
    d.prototype.generate = function(k) {
        return this._rand(k)
    }
    ,
    d.prototype._rand = function(k) {
        if (this.rand.getBytes)
            return this.rand.getBytes(k);
        for (var y = new Uint8Array(k), ee = 0; ee < y.length; ee++)
            y[ee] = this.rand.getByte();
        return y
    }
    ,
    typeof self == "object")
        self.crypto && self.crypto.getRandomValues ? d.prototype._rand = function(k) {
            var y = new Uint8Array(k);
            return self.crypto.getRandomValues(y),
            y
        }
        : self.msCrypto && self.msCrypto.getRandomValues ? d.prototype._rand = function(k) {
            var y = new Uint8Array(k);
            return self.msCrypto.getRandomValues(y),
            y
        }
        : typeof window == "object" && (d.prototype._rand = function() {
            throw new Error("Not implemented yet")
        }
        );
    else
        try {
            var f = requireCryptoBrowserify();
            if (typeof f.randomBytes != "function")
                throw new Error("Not supported");
            d.prototype._rand = function(k) {
                return f.randomBytes(k)
            }
        } catch {}
    return brorand.exports
}
var mr, hasRequiredMr;
function requireMr() {
    if (hasRequiredMr)
        return mr;
    hasRequiredMr = 1;
    var r = requireBn$2()
      , d = requireBrorand();
    function f(m) {
        this.rand = m || new d.Rand
    }
    return mr = f,
    f.create = function(k) {
        return new f(k)
    }
    ,
    f.prototype._randbelow = function(k) {
        var y = k.bitLength()
          , ee = Math.ceil(y / 8);
        do
            var dt = new r(this.rand.generate(ee));
        while (dt.cmp(k) >= 0);
        return dt
    }
    ,
    f.prototype._randrange = function(k, y) {
        var ee = y.sub(k);
        return k.add(this._randbelow(ee))
    }
    ,
    f.prototype.test = function(k, y, ee) {
        var dt = k.bitLength()
          , mt = r.mont(k)
          , yt = new r(1).toRed(mt);
        y || (y = Math.max(1, dt / 48 | 0));
        for (var pt = k.subn(1), bt = 0; !pt.testn(bt); bt++)
            ;
        for (var wt = k.shrn(bt), xt = pt.toRed(mt), At = !0; y > 0; y--) {
            var Ct = this._randrange(new r(2), pt);
            ee && ee(Ct);
            var Pt = Ct.toRed(mt).redPow(wt);
            if (!(Pt.cmp(yt) === 0 || Pt.cmp(xt) === 0)) {
                for (var $t = 1; $t < bt; $t++) {
                    if (Pt = Pt.redSqr(),
                    Pt.cmp(yt) === 0)
                        return !1;
                    if (Pt.cmp(xt) === 0)
                        break
                }
                if ($t === bt)
                    return !1
            }
        }
        return At
    }
    ,
    f.prototype.getDivisor = function(k, y) {
        var ee = k.bitLength()
          , dt = r.mont(k)
          , mt = new r(1).toRed(dt);
        y || (y = Math.max(1, ee / 48 | 0));
        for (var yt = k.subn(1), pt = 0; !yt.testn(pt); pt++)
            ;
        for (var bt = k.shrn(pt), wt = yt.toRed(dt); y > 0; y--) {
            var xt = this._randrange(new r(2), yt)
              , At = k.gcd(xt);
            if (At.cmpn(1) !== 0)
                return At;
            var Ct = xt.toRed(dt).redPow(bt);
            if (!(Ct.cmp(mt) === 0 || Ct.cmp(wt) === 0)) {
                for (var Pt = 1; Pt < pt; Pt++) {
                    if (Ct = Ct.redSqr(),
                    Ct.cmp(mt) === 0)
                        return Ct.fromRed().subn(1).gcd(k);
                    if (Ct.cmp(wt) === 0)
                        break
                }
                if (Pt === pt)
                    return Ct = Ct.redSqr(),
                    Ct.fromRed().subn(1).gcd(k)
            }
        }
        return !1
    }
    ,
    mr
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
    if (hasRequiredGeneratePrime)
        return generatePrime;
    hasRequiredGeneratePrime = 1;
    var r = requireBrowser$b();
    generatePrime = Pt,
    Pt.simpleSieve = At,
    Pt.fermatTest = Ct;
    var d = requireBn$2()
      , f = new d(24)
      , m = requireMr()
      , k = new m
      , y = new d(1)
      , ee = new d(2)
      , dt = new d(5);
    new d(16),
    new d(8);
    var mt = new d(10)
      , yt = new d(3);
    new d(7);
    var pt = new d(11)
      , bt = new d(4);
    new d(12);
    var wt = null;
    function xt() {
        if (wt !== null)
            return wt;
        var $t = 1048576
          , Ot = [];
        Ot[0] = 2;
        for (var Nt = 1, zt = 3; zt < $t; zt += 2) {
            for (var Wt = Math.ceil(Math.sqrt(zt)), Kt = 0; Kt < Nt && Ot[Kt] <= Wt && zt % Ot[Kt] !== 0; Kt++)
                ;
            Nt !== Kt && Ot[Kt] <= Wt || (Ot[Nt++] = zt)
        }
        return wt = Ot,
        Ot
    }
    function At($t) {
        for (var Ot = xt(), Nt = 0; Nt < Ot.length; Nt++)
            if ($t.modn(Ot[Nt]) === 0)
                return $t.cmpn(Ot[Nt]) === 0;
        return !0
    }
    function Ct($t) {
        var Ot = d.mont($t);
        return ee.toRed(Ot).redPow($t.subn(1)).fromRed().cmpn(1) === 0
    }
    function Pt($t, Ot) {
        if ($t < 16)
            return Ot === 2 || Ot === 5 ? new d([140, 123]) : new d([140, 39]);
        Ot = new d(Ot);
        for (var Nt, zt; ; ) {
            for (Nt = new d(r(Math.ceil($t / 8))); Nt.bitLength() > $t; )
                Nt.ishrn(1);
            if (Nt.isEven() && Nt.iadd(y),
            Nt.testn(1) || Nt.iadd(ee),
            Ot.cmp(ee)) {
                if (!Ot.cmp(dt))
                    for (; Nt.mod(mt).cmp(yt); )
                        Nt.iadd(bt)
            } else
                for (; Nt.mod(f).cmp(pt); )
                    Nt.iadd(bt);
            if (zt = Nt.shrn(1),
            At(zt) && At(Nt) && Ct(zt) && Ct(Nt) && k.test(zt) && k.test(Nt))
                return Nt
        }
    }
    return generatePrime
}
const modp1 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}
  , modp2 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}
  , modp5 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}
  , modp14 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}
  , modp15 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}
  , modp16 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}
  , modp17 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}
  , modp18 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}
  , require$$1$1 = {
    modp1,
    modp2,
    modp5,
    modp14,
    modp15,
    modp16,
    modp17,
    modp18
};
var dh, hasRequiredDh;
function requireDh() {
    if (hasRequiredDh)
        return dh;
    hasRequiredDh = 1;
    var r = requireBn$2()
      , d = requireMr()
      , f = new d
      , m = new r(24)
      , k = new r(11)
      , y = new r(10)
      , ee = new r(3)
      , dt = new r(7)
      , mt = requireGeneratePrime()
      , yt = requireBrowser$b();
    dh = At;
    function pt(Pt, $t) {
        return $t = $t || "utf8",
        Buffer.isBuffer(Pt) || (Pt = new Buffer(Pt,$t)),
        this._pub = new r(Pt),
        this
    }
    function bt(Pt, $t) {
        return $t = $t || "utf8",
        Buffer.isBuffer(Pt) || (Pt = new Buffer(Pt,$t)),
        this._priv = new r(Pt),
        this
    }
    var wt = {};
    function xt(Pt, $t) {
        var Ot = $t.toString("hex")
          , Nt = [Ot, Pt.toString(16)].join("_");
        if (Nt in wt)
            return wt[Nt];
        var zt = 0;
        if (Pt.isEven() || !mt.simpleSieve || !mt.fermatTest(Pt) || !f.test(Pt))
            return zt += 1,
            Ot === "02" || Ot === "05" ? zt += 8 : zt += 4,
            wt[Nt] = zt,
            zt;
        f.test(Pt.shrn(1)) || (zt += 2);
        var Wt;
        switch (Ot) {
        case "02":
            Pt.mod(m).cmp(k) && (zt += 8);
            break;
        case "05":
            Wt = Pt.mod(y),
            Wt.cmp(ee) && Wt.cmp(dt) && (zt += 8);
            break;
        default:
            zt += 4
        }
        return wt[Nt] = zt,
        zt
    }
    function At(Pt, $t, Ot) {
        this.setGenerator($t),
        this.__prime = new r(Pt),
        this._prime = r.mont(this.__prime),
        this._primeLen = Pt.length,
        this._pub = void 0,
        this._priv = void 0,
        this._primeCode = void 0,
        Ot ? (this.setPublicKey = pt,
        this.setPrivateKey = bt) : this._primeCode = 8
    }
    Object.defineProperty(At.prototype, "verifyError", {
        enumerable: !0,
        get: function() {
            return typeof this._primeCode != "number" && (this._primeCode = xt(this.__prime, this.__gen)),
            this._primeCode
        }
    }),
    At.prototype.generateKeys = function() {
        return this._priv || (this._priv = new r(yt(this._primeLen))),
        this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(),
        this.getPublicKey()
    }
    ,
    At.prototype.computeSecret = function(Pt) {
        Pt = new r(Pt),
        Pt = Pt.toRed(this._prime);
        var $t = Pt.redPow(this._priv).fromRed()
          , Ot = new Buffer($t.toArray())
          , Nt = this.getPrime();
        if (Ot.length < Nt.length) {
            var zt = new Buffer(Nt.length - Ot.length);
            zt.fill(0),
            Ot = Buffer.concat([zt, Ot])
        }
        return Ot
    }
    ,
    At.prototype.getPublicKey = function($t) {
        return Ct(this._pub, $t)
    }
    ,
    At.prototype.getPrivateKey = function($t) {
        return Ct(this._priv, $t)
    }
    ,
    At.prototype.getPrime = function(Pt) {
        return Ct(this.__prime, Pt)
    }
    ,
    At.prototype.getGenerator = function(Pt) {
        return Ct(this._gen, Pt)
    }
    ,
    At.prototype.setGenerator = function(Pt, $t) {
        return $t = $t || "utf8",
        Buffer.isBuffer(Pt) || (Pt = new Buffer(Pt,$t)),
        this.__gen = Pt,
        this._gen = new r(Pt),
        this
    }
    ;
    function Ct(Pt, $t) {
        var Ot = new Buffer(Pt.toArray());
        return $t ? Ot.toString($t) : Ot
    }
    return dh
}
var hasRequiredBrowser$4;
function requireBrowser$4() {
    if (hasRequiredBrowser$4)
        return browser$5;
    hasRequiredBrowser$4 = 1;
    var r = requireGeneratePrime()
      , d = require$$1$1
      , f = requireDh();
    function m(ee) {
        var dt = new Buffer(d[ee].prime,"hex")
          , mt = new Buffer(d[ee].gen,"hex");
        return new f(dt,mt)
    }
    var k = {
        binary: !0,
        hex: !0,
        base64: !0
    };
    function y(ee, dt, mt, yt) {
        return Buffer.isBuffer(dt) || k[dt] === void 0 ? y(ee, "binary", dt, mt) : (dt = dt || "binary",
        yt = yt || "binary",
        mt = mt || new Buffer([2]),
        Buffer.isBuffer(mt) || (mt = new Buffer(mt,yt)),
        typeof ee == "number" ? new f(r(ee, mt),mt,!0) : (Buffer.isBuffer(ee) || (ee = new Buffer(ee,dt)),
        new f(ee,mt,!0)))
    }
    return browser$5.DiffieHellmanGroup = browser$5.createDiffieHellmanGroup = browser$5.getDiffieHellman = m,
    browser$5.createDiffieHellman = browser$5.DiffieHellman = y,
    browser$5
}
var readableBrowser = {
    exports: {}
}, processNextickArgs = {
    exports: {}
}, hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
    if (hasRequiredProcessNextickArgs)
        return processNextickArgs.exports;
    hasRequiredProcessNextickArgs = 1,
    typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = {
        nextTick: r
    } : processNextickArgs.exports = process$1;
    function r(d, f, m, k) {
        if (typeof d != "function")
            throw new TypeError('"callback" argument must be a function');
        var y = arguments.length, ee, dt;
        switch (y) {
        case 0:
        case 1:
            return process$1.nextTick(d);
        case 2:
            return process$1.nextTick(function() {
                d.call(null, f)
            });
        case 3:
            return process$1.nextTick(function() {
                d.call(null, f, m)
            });
        case 4:
            return process$1.nextTick(function() {
                d.call(null, f, m, k)
            });
        default:
            for (ee = new Array(y - 1),
            dt = 0; dt < ee.length; )
                ee[dt++] = arguments[dt];
            return process$1.nextTick(function() {
                d.apply(null, ee)
            })
        }
    }
    return processNextickArgs.exports
}
var isarray, hasRequiredIsarray;
function requireIsarray() {
    if (hasRequiredIsarray)
        return isarray;
    hasRequiredIsarray = 1;
    var r = {}.toString;
    return isarray = Array.isArray || function(d) {
        return r.call(d) == "[object Array]"
    }
    ,
    isarray
}
var streamBrowser, hasRequiredStreamBrowser;
function requireStreamBrowser() {
    return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1,
    streamBrowser = requireEvents().EventEmitter),
    streamBrowser
}
var safeBuffer = {
    exports: {}
}, hasRequiredSafeBuffer;
function requireSafeBuffer() {
    return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1,
    function(r, d) {
        var f = require$$1$2
          , m = f.Buffer;
        function k(ee, dt) {
            for (var mt in ee)
                dt[mt] = ee[mt]
        }
        m.from && m.alloc && m.allocUnsafe && m.allocUnsafeSlow ? r.exports = f : (k(f, d),
        d.Buffer = y);
        function y(ee, dt, mt) {
            return m(ee, dt, mt)
        }
        k(m, y),
        y.from = function(ee, dt, mt) {
            if (typeof ee == "number")
                throw new TypeError("Argument must not be a number");
            return m(ee, dt, mt)
        }
        ,
        y.alloc = function(ee, dt, mt) {
            if (typeof ee != "number")
                throw new TypeError("Argument must be a number");
            var yt = m(ee);
            return dt !== void 0 ? typeof mt == "string" ? yt.fill(dt, mt) : yt.fill(dt) : yt.fill(0),
            yt
        }
        ,
        y.allocUnsafe = function(ee) {
            if (typeof ee != "number")
                throw new TypeError("Argument must be a number");
            return m(ee)
        }
        ,
        y.allocUnsafeSlow = function(ee) {
            if (typeof ee != "number")
                throw new TypeError("Argument must be a number");
            return f.SlowBuffer(ee)
        }
    }(safeBuffer, safeBuffer.exports)),
    safeBuffer.exports
}
var util$1 = {}, hasRequiredUtil;
function requireUtil() {
    if (hasRequiredUtil)
        return util$1;
    hasRequiredUtil = 1;
    function r(Ct) {
        return Array.isArray ? Array.isArray(Ct) : At(Ct) === "[object Array]"
    }
    util$1.isArray = r;
    function d(Ct) {
        return typeof Ct == "boolean"
    }
    util$1.isBoolean = d;
    function f(Ct) {
        return Ct === null
    }
    util$1.isNull = f;
    function m(Ct) {
        return Ct == null
    }
    util$1.isNullOrUndefined = m;
    function k(Ct) {
        return typeof Ct == "number"
    }
    util$1.isNumber = k;
    function y(Ct) {
        return typeof Ct == "string"
    }
    util$1.isString = y;
    function ee(Ct) {
        return typeof Ct == "symbol"
    }
    util$1.isSymbol = ee;
    function dt(Ct) {
        return Ct === void 0
    }
    util$1.isUndefined = dt;
    function mt(Ct) {
        return At(Ct) === "[object RegExp]"
    }
    util$1.isRegExp = mt;
    function yt(Ct) {
        return typeof Ct == "object" && Ct !== null
    }
    util$1.isObject = yt;
    function pt(Ct) {
        return At(Ct) === "[object Date]"
    }
    util$1.isDate = pt;
    function bt(Ct) {
        return At(Ct) === "[object Error]" || Ct instanceof Error
    }
    util$1.isError = bt;
    function wt(Ct) {
        return typeof Ct == "function"
    }
    util$1.isFunction = wt;
    function xt(Ct) {
        return Ct === null || typeof Ct == "boolean" || typeof Ct == "number" || typeof Ct == "string" || typeof Ct == "symbol" || typeof Ct > "u"
    }
    util$1.isPrimitive = xt,
    util$1.isBuffer = require$$1$2.Buffer.isBuffer;
    function At(Ct) {
        return Object.prototype.toString.call(Ct)
    }
    return util$1
}
var BufferList = {
    exports: {}
}, hasRequiredBufferList;
function requireBufferList() {
    return hasRequiredBufferList || (hasRequiredBufferList = 1,
    function(r) {
        function d(y, ee) {
            if (!(y instanceof ee))
                throw new TypeError("Cannot call a class as a function")
        }
        var f = requireSafeBuffer().Buffer
          , m = requireUtil$1();
        function k(y, ee, dt) {
            y.copy(ee, dt)
        }
        r.exports = function() {
            function y() {
                d(this, y),
                this.head = null,
                this.tail = null,
                this.length = 0
            }
            return y.prototype.push = function(dt) {
                var mt = {
                    data: dt,
                    next: null
                };
                this.length > 0 ? this.tail.next = mt : this.head = mt,
                this.tail = mt,
                ++this.length
            }
            ,
            y.prototype.unshift = function(dt) {
                var mt = {
                    data: dt,
                    next: this.head
                };
                this.length === 0 && (this.tail = mt),
                this.head = mt,
                ++this.length
            }
            ,
            y.prototype.shift = function() {
                if (this.length !== 0) {
                    var dt = this.head.data;
                    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next,
                    --this.length,
                    dt
                }
            }
            ,
            y.prototype.clear = function() {
                this.head = this.tail = null,
                this.length = 0
            }
            ,
            y.prototype.join = function(dt) {
                if (this.length === 0)
                    return "";
                for (var mt = this.head, yt = "" + mt.data; mt = mt.next; )
                    yt += dt + mt.data;
                return yt
            }
            ,
            y.prototype.concat = function(dt) {
                if (this.length === 0)
                    return f.alloc(0);
                for (var mt = f.allocUnsafe(dt >>> 0), yt = this.head, pt = 0; yt; )
                    k(yt.data, mt, pt),
                    pt += yt.data.length,
                    yt = yt.next;
                return mt
            }
            ,
            y
        }(),
        m && m.inspect && m.inspect.custom && (r.exports.prototype[m.inspect.custom] = function() {
            var y = m.inspect({
                length: this.length
            });
            return this.constructor.name + " " + y
        }
        )
    }(BufferList)),
    BufferList.exports
}
var destroy_1, hasRequiredDestroy;
function requireDestroy() {
    if (hasRequiredDestroy)
        return destroy_1;
    hasRequiredDestroy = 1;
    var r = requireProcessNextickArgs();
    function d(k, y) {
        var ee = this
          , dt = this._readableState && this._readableState.destroyed
          , mt = this._writableState && this._writableState.destroyed;
        return dt || mt ? (y ? y(k) : k && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0,
        r.nextTick(m, this, k)) : r.nextTick(m, this, k)),
        this) : (this._readableState && (this._readableState.destroyed = !0),
        this._writableState && (this._writableState.destroyed = !0),
        this._destroy(k || null, function(yt) {
            !y && yt ? ee._writableState ? ee._writableState.errorEmitted || (ee._writableState.errorEmitted = !0,
            r.nextTick(m, ee, yt)) : r.nextTick(m, ee, yt) : y && y(yt)
        }),
        this)
    }
    function f() {
        this._readableState && (this._readableState.destroyed = !1,
        this._readableState.reading = !1,
        this._readableState.ended = !1,
        this._readableState.endEmitted = !1),
        this._writableState && (this._writableState.destroyed = !1,
        this._writableState.ended = !1,
        this._writableState.ending = !1,
        this._writableState.finalCalled = !1,
        this._writableState.prefinished = !1,
        this._writableState.finished = !1,
        this._writableState.errorEmitted = !1)
    }
    function m(k, y) {
        k.emit("error", y)
    }
    return destroy_1 = {
        destroy: d,
        undestroy: f
    },
    destroy_1
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
    if (hasRequired_stream_writable)
        return _stream_writable;
    hasRequired_stream_writable = 1;
    var r = requireProcessNextickArgs();
    _stream_writable = Ct;
    function d(Bt) {
        var Rt = this;
        this.next = null,
        this.entry = null,
        this.finish = function() {
            Et(Rt, Bt)
        }
    }
    var f = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : r.nextTick, m;
    Ct.WritableState = xt;
    var k = Object.create(requireUtil());
    k.inherits = requireInherits_browser();
    var y = {
        deprecate: requireBrowser$a()
    }
      , ee = requireStreamBrowser()
      , dt = requireSafeBuffer().Buffer
      , mt = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {}
    ;
    function yt(Bt) {
        return dt.from(Bt)
    }
    function pt(Bt) {
        return dt.isBuffer(Bt) || Bt instanceof mt
    }
    var bt = requireDestroy();
    k.inherits(Ct, ee);
    function wt() {}
    function xt(Bt, Rt) {
        m = m || require_stream_duplex(),
        Bt = Bt || {};
        var kt = Rt instanceof m;
        this.objectMode = !!Bt.objectMode,
        kt && (this.objectMode = this.objectMode || !!Bt.writableObjectMode);
        var Tt = Bt.highWaterMark
          , It = Bt.writableHighWaterMark
          , St = this.objectMode ? 16 : 16 * 1024;
        Tt || Tt === 0 ? this.highWaterMark = Tt : kt && (It || It === 0) ? this.highWaterMark = It : this.highWaterMark = St,
        this.highWaterMark = Math.floor(this.highWaterMark),
        this.finalCalled = !1,
        this.needDrain = !1,
        this.ending = !1,
        this.ended = !1,
        this.finished = !1,
        this.destroyed = !1;
        var qt = Bt.decodeStrings === !1;
        this.decodeStrings = !qt,
        this.defaultEncoding = Bt.defaultEncoding || "utf8",
        this.length = 0,
        this.writing = !1,
        this.corked = 0,
        this.sync = !0,
        this.bufferProcessing = !1,
        this.onwrite = function(ur) {
            ir(Rt, ur)
        }
        ,
        this.writecb = null,
        this.writelen = 0,
        this.bufferedRequest = null,
        this.lastBufferedRequest = null,
        this.pendingcb = 0,
        this.prefinished = !1,
        this.errorEmitted = !1,
        this.bufferedRequestCount = 0,
        this.corkedRequestsFree = new d(this)
    }
    xt.prototype.getBuffer = function() {
        for (var Rt = this.bufferedRequest, kt = []; Rt; )
            kt.push(Rt),
            Rt = Rt.next;
        return kt
    }
    ,
    function() {
        try {
            Object.defineProperty(xt.prototype, "buffer", {
                get: y.deprecate(function() {
                    return this.getBuffer()
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
            })
        } catch {}
    }();
    var At;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (At = Function.prototype[Symbol.hasInstance],
    Object.defineProperty(Ct, Symbol.hasInstance, {
        value: function(Bt) {
            return At.call(this, Bt) ? !0 : this !== Ct ? !1 : Bt && Bt._writableState instanceof xt
        }
    })) : At = function(Bt) {
        return Bt instanceof this
    }
    ;
    function Ct(Bt) {
        if (m = m || require_stream_duplex(),
        !At.call(Ct, this) && !(this instanceof m))
            return new Ct(Bt);
        this._writableState = new xt(Bt,this),
        this.writable = !0,
        Bt && (typeof Bt.write == "function" && (this._write = Bt.write),
        typeof Bt.writev == "function" && (this._writev = Bt.writev),
        typeof Bt.destroy == "function" && (this._destroy = Bt.destroy),
        typeof Bt.final == "function" && (this._final = Bt.final)),
        ee.call(this)
    }
    Ct.prototype.pipe = function() {
        this.emit("error", new Error("Cannot pipe, not readable"))
    }
    ;
    function Pt(Bt, Rt) {
        var kt = new Error("write after end");
        Bt.emit("error", kt),
        r.nextTick(Rt, kt)
    }
    function $t(Bt, Rt, kt, Tt) {
        var It = !0
          , St = !1;
        return kt === null ? St = new TypeError("May not write null values to stream") : typeof kt != "string" && kt !== void 0 && !Rt.objectMode && (St = new TypeError("Invalid non-string/buffer chunk")),
        St && (Bt.emit("error", St),
        r.nextTick(Tt, St),
        It = !1),
        It
    }
    Ct.prototype.write = function(Bt, Rt, kt) {
        var Tt = this._writableState
          , It = !1
          , St = !Tt.objectMode && pt(Bt);
        return St && !dt.isBuffer(Bt) && (Bt = yt(Bt)),
        typeof Rt == "function" && (kt = Rt,
        Rt = null),
        St ? Rt = "buffer" : Rt || (Rt = Tt.defaultEncoding),
        typeof kt != "function" && (kt = wt),
        Tt.ended ? Pt(this, kt) : (St || $t(this, Tt, Bt, kt)) && (Tt.pendingcb++,
        It = Nt(this, Tt, St, Bt, Rt, kt)),
        It
    }
    ,
    Ct.prototype.cork = function() {
        var Bt = this._writableState;
        Bt.corked++
    }
    ,
    Ct.prototype.uncork = function() {
        var Bt = this._writableState;
        Bt.corked && (Bt.corked--,
        !Bt.writing && !Bt.corked && !Bt.bufferProcessing && Bt.bufferedRequest && wr(this, Bt))
    }
    ,
    Ct.prototype.setDefaultEncoding = function(Rt) {
        if (typeof Rt == "string" && (Rt = Rt.toLowerCase()),
        !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Rt + "").toLowerCase()) > -1))
            throw new TypeError("Unknown encoding: " + Rt);
        return this._writableState.defaultEncoding = Rt,
        this
    }
    ;
    function Ot(Bt, Rt, kt) {
        return !Bt.objectMode && Bt.decodeStrings !== !1 && typeof Rt == "string" && (Rt = dt.from(Rt, kt)),
        Rt
    }
    Object.defineProperty(Ct.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark
        }
    });
    function Nt(Bt, Rt, kt, Tt, It, St) {
        if (!kt) {
            var qt = Ot(Rt, Tt, It);
            Tt !== qt && (kt = !0,
            It = "buffer",
            Tt = qt)
        }
        var ur = Rt.objectMode ? 1 : Tt.length;
        Rt.length += ur;
        var gr = Rt.length < Rt.highWaterMark;
        if (gr || (Rt.needDrain = !0),
        Rt.writing || Rt.corked) {
            var lr = Rt.lastBufferedRequest;
            Rt.lastBufferedRequest = {
                chunk: Tt,
                encoding: It,
                isBuf: kt,
                callback: St,
                next: null
            },
            lr ? lr.next = Rt.lastBufferedRequest : Rt.bufferedRequest = Rt.lastBufferedRequest,
            Rt.bufferedRequestCount += 1
        } else
            zt(Bt, Rt, !1, ur, Tt, It, St);
        return gr
    }
    function zt(Bt, Rt, kt, Tt, It, St, qt) {
        Rt.writelen = Tt,
        Rt.writecb = qt,
        Rt.writing = !0,
        Rt.sync = !0,
        kt ? Bt._writev(It, Rt.onwrite) : Bt._write(It, St, Rt.onwrite),
        Rt.sync = !1
    }
    function Wt(Bt, Rt, kt, Tt, It) {
        --Rt.pendingcb,
        kt ? (r.nextTick(It, Tt),
        r.nextTick(gt, Bt, Rt),
        Bt._writableState.errorEmitted = !0,
        Bt.emit("error", Tt)) : (It(Tt),
        Bt._writableState.errorEmitted = !0,
        Bt.emit("error", Tt),
        gt(Bt, Rt))
    }
    function Kt(Bt) {
        Bt.writing = !1,
        Bt.writecb = null,
        Bt.length -= Bt.writelen,
        Bt.writelen = 0
    }
    function ir(Bt, Rt) {
        var kt = Bt._writableState
          , Tt = kt.sync
          , It = kt.writecb;
        if (Kt(kt),
        Rt)
            Wt(Bt, kt, Tt, Rt, It);
        else {
            var St = Ht(kt);
            !St && !kt.corked && !kt.bufferProcessing && kt.bufferedRequest && wr(Bt, kt),
            Tt ? f(or, Bt, kt, St, It) : or(Bt, kt, St, It)
        }
    }
    function or(Bt, Rt, kt, Tt) {
        kt || tr(Bt, Rt),
        Rt.pendingcb--,
        Tt(),
        gt(Bt, Rt)
    }
    function tr(Bt, Rt) {
        Rt.length === 0 && Rt.needDrain && (Rt.needDrain = !1,
        Bt.emit("drain"))
    }
    function wr(Bt, Rt) {
        Rt.bufferProcessing = !0;
        var kt = Rt.bufferedRequest;
        if (Bt._writev && kt && kt.next) {
            var Tt = Rt.bufferedRequestCount
              , It = new Array(Tt)
              , St = Rt.corkedRequestsFree;
            St.entry = kt;
            for (var qt = 0, ur = !0; kt; )
                It[qt] = kt,
                kt.isBuf || (ur = !1),
                kt = kt.next,
                qt += 1;
            It.allBuffers = ur,
            zt(Bt, Rt, !0, Rt.length, It, "", St.finish),
            Rt.pendingcb++,
            Rt.lastBufferedRequest = null,
            St.next ? (Rt.corkedRequestsFree = St.next,
            St.next = null) : Rt.corkedRequestsFree = new d(Rt),
            Rt.bufferedRequestCount = 0
        } else {
            for (; kt; ) {
                var gr = kt.chunk
                  , lr = kt.encoding
                  , Zt = kt.callback
                  , Vt = Rt.objectMode ? 1 : gr.length;
                if (zt(Bt, Rt, !1, Vt, gr, lr, Zt),
                kt = kt.next,
                Rt.bufferedRequestCount--,
                Rt.writing)
                    break
            }
            kt === null && (Rt.lastBufferedRequest = null)
        }
        Rt.bufferedRequest = kt,
        Rt.bufferProcessing = !1
    }
    Ct.prototype._write = function(Bt, Rt, kt) {
        kt(new Error("_write() is not implemented"))
    }
    ,
    Ct.prototype._writev = null,
    Ct.prototype.end = function(Bt, Rt, kt) {
        var Tt = this._writableState;
        typeof Bt == "function" ? (kt = Bt,
        Bt = null,
        Rt = null) : typeof Rt == "function" && (kt = Rt,
        Rt = null),
        Bt != null && this.write(Bt, Rt),
        Tt.corked && (Tt.corked = 1,
        this.uncork()),
        Tt.ending || vt(this, Tt, kt)
    }
    ;
    function Ht(Bt) {
        return Bt.ending && Bt.length === 0 && Bt.bufferedRequest === null && !Bt.finished && !Bt.writing
    }
    function Mt(Bt, Rt) {
        Bt._final(function(kt) {
            Rt.pendingcb--,
            kt && Bt.emit("error", kt),
            Rt.prefinished = !0,
            Bt.emit("prefinish"),
            gt(Bt, Rt)
        })
    }
    function _t(Bt, Rt) {
        !Rt.prefinished && !Rt.finalCalled && (typeof Bt._final == "function" ? (Rt.pendingcb++,
        Rt.finalCalled = !0,
        r.nextTick(Mt, Bt, Rt)) : (Rt.prefinished = !0,
        Bt.emit("prefinish")))
    }
    function gt(Bt, Rt) {
        var kt = Ht(Rt);
        return kt && (_t(Bt, Rt),
        Rt.pendingcb === 0 && (Rt.finished = !0,
        Bt.emit("finish"))),
        kt
    }
    function vt(Bt, Rt, kt) {
        Rt.ending = !0,
        gt(Bt, Rt),
        kt && (Rt.finished ? r.nextTick(kt) : Bt.once("finish", kt)),
        Rt.ended = !0,
        Bt.writable = !1
    }
    function Et(Bt, Rt, kt) {
        var Tt = Bt.entry;
        for (Bt.entry = null; Tt; ) {
            var It = Tt.callback;
            Rt.pendingcb--,
            It(kt),
            Tt = Tt.next
        }
        Rt.corkedRequestsFree.next = Bt
    }
    return Object.defineProperty(Ct.prototype, "destroyed", {
        get: function() {
            return this._writableState === void 0 ? !1 : this._writableState.destroyed
        },
        set: function(Bt) {
            this._writableState && (this._writableState.destroyed = Bt)
        }
    }),
    Ct.prototype.destroy = bt.destroy,
    Ct.prototype._undestroy = bt.undestroy,
    Ct.prototype._destroy = function(Bt, Rt) {
        this.end(),
        Rt(Bt)
    }
    ,
    _stream_writable
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
    if (hasRequired_stream_duplex)
        return _stream_duplex;
    hasRequired_stream_duplex = 1;
    var r = requireProcessNextickArgs()
      , d = Object.keys || function(bt) {
        var wt = [];
        for (var xt in bt)
            wt.push(xt);
        return wt
    }
    ;
    _stream_duplex = mt;
    var f = Object.create(requireUtil());
    f.inherits = requireInherits_browser();
    var m = require_stream_readable()
      , k = require_stream_writable();
    f.inherits(mt, m);
    for (var y = d(k.prototype), ee = 0; ee < y.length; ee++) {
        var dt = y[ee];
        mt.prototype[dt] || (mt.prototype[dt] = k.prototype[dt])
    }
    function mt(bt) {
        if (!(this instanceof mt))
            return new mt(bt);
        m.call(this, bt),
        k.call(this, bt),
        bt && bt.readable === !1 && (this.readable = !1),
        bt && bt.writable === !1 && (this.writable = !1),
        this.allowHalfOpen = !0,
        bt && bt.allowHalfOpen === !1 && (this.allowHalfOpen = !1),
        this.once("end", yt)
    }
    Object.defineProperty(mt.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark
        }
    });
    function yt() {
        this.allowHalfOpen || this._writableState.ended || r.nextTick(pt, this)
    }
    function pt(bt) {
        bt.end()
    }
    return Object.defineProperty(mt.prototype, "destroyed", {
        get: function() {
            return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed
        },
        set: function(bt) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = bt,
            this._writableState.destroyed = bt)
        }
    }),
    mt.prototype._destroy = function(bt, wt) {
        this.push(null),
        this.end(),
        r.nextTick(wt, bt)
    }
    ,
    _stream_duplex
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
    if (hasRequired_stream_readable)
        return _stream_readable;
    hasRequired_stream_readable = 1;
    var r = requireProcessNextickArgs();
    _stream_readable = Ot;
    var d = requireIsarray(), f;
    Ot.ReadableState = $t,
    requireEvents().EventEmitter;
    var m = function(Zt, Vt) {
        return Zt.listeners(Vt).length
    }
      , k = requireStreamBrowser()
      , y = requireSafeBuffer().Buffer
      , ee = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {}
    ;
    function dt(Zt) {
        return y.from(Zt)
    }
    function mt(Zt) {
        return y.isBuffer(Zt) || Zt instanceof ee
    }
    var yt = Object.create(requireUtil());
    yt.inherits = requireInherits_browser();
    var pt = requireUtil$1()
      , bt = void 0;
    pt && pt.debuglog ? bt = pt.debuglog("stream") : bt = function() {}
    ;
    var wt = requireBufferList(), xt = requireDestroy(), At;
    yt.inherits(Ot, k);
    var Ct = ["error", "close", "destroy", "pause", "resume"];
    function Pt(Zt, Vt, rr) {
        if (typeof Zt.prependListener == "function")
            return Zt.prependListener(Vt, rr);
        !Zt._events || !Zt._events[Vt] ? Zt.on(Vt, rr) : d(Zt._events[Vt]) ? Zt._events[Vt].unshift(rr) : Zt._events[Vt] = [rr, Zt._events[Vt]]
    }
    function $t(Zt, Vt) {
        f = f || require_stream_duplex(),
        Zt = Zt || {};
        var rr = Vt instanceof f;
        this.objectMode = !!Zt.objectMode,
        rr && (this.objectMode = this.objectMode || !!Zt.readableObjectMode);
        var fr = Zt.highWaterMark
          , Yt = Zt.readableHighWaterMark
          , Xt = this.objectMode ? 16 : 16 * 1024;
        fr || fr === 0 ? this.highWaterMark = fr : rr && (Yt || Yt === 0) ? this.highWaterMark = Yt : this.highWaterMark = Xt,
        this.highWaterMark = Math.floor(this.highWaterMark),
        this.buffer = new wt,
        this.length = 0,
        this.pipes = null,
        this.pipesCount = 0,
        this.flowing = null,
        this.ended = !1,
        this.endEmitted = !1,
        this.reading = !1,
        this.sync = !0,
        this.needReadable = !1,
        this.emittedReadable = !1,
        this.readableListening = !1,
        this.resumeScheduled = !1,
        this.destroyed = !1,
        this.defaultEncoding = Zt.defaultEncoding || "utf8",
        this.awaitDrain = 0,
        this.readingMore = !1,
        this.decoder = null,
        this.encoding = null,
        Zt.encoding && (At || (At = requireString_decoder().StringDecoder),
        this.decoder = new At(Zt.encoding),
        this.encoding = Zt.encoding)
    }
    function Ot(Zt) {
        if (f = f || require_stream_duplex(),
        !(this instanceof Ot))
            return new Ot(Zt);
        this._readableState = new $t(Zt,this),
        this.readable = !0,
        Zt && (typeof Zt.read == "function" && (this._read = Zt.read),
        typeof Zt.destroy == "function" && (this._destroy = Zt.destroy)),
        k.call(this)
    }
    Object.defineProperty(Ot.prototype, "destroyed", {
        get: function() {
            return this._readableState === void 0 ? !1 : this._readableState.destroyed
        },
        set: function(Zt) {
            this._readableState && (this._readableState.destroyed = Zt)
        }
    }),
    Ot.prototype.destroy = xt.destroy,
    Ot.prototype._undestroy = xt.undestroy,
    Ot.prototype._destroy = function(Zt, Vt) {
        this.push(null),
        Vt(Zt)
    }
    ,
    Ot.prototype.push = function(Zt, Vt) {
        var rr = this._readableState, fr;
        return rr.objectMode ? fr = !0 : typeof Zt == "string" && (Vt = Vt || rr.defaultEncoding,
        Vt !== rr.encoding && (Zt = y.from(Zt, Vt),
        Vt = ""),
        fr = !0),
        Nt(this, Zt, Vt, !1, fr)
    }
    ,
    Ot.prototype.unshift = function(Zt) {
        return Nt(this, Zt, null, !0, !1)
    }
    ;
    function Nt(Zt, Vt, rr, fr, Yt) {
        var Xt = Zt._readableState;
        if (Vt === null)
            Xt.reading = !1,
            wr(Zt, Xt);
        else {
            var Sr;
            Yt || (Sr = Wt(Xt, Vt)),
            Sr ? Zt.emit("error", Sr) : Xt.objectMode || Vt && Vt.length > 0 ? (typeof Vt != "string" && !Xt.objectMode && Object.getPrototypeOf(Vt) !== y.prototype && (Vt = dt(Vt)),
            fr ? Xt.endEmitted ? Zt.emit("error", new Error("stream.unshift() after end event")) : zt(Zt, Xt, Vt, !0) : Xt.ended ? Zt.emit("error", new Error("stream.push() after EOF")) : (Xt.reading = !1,
            Xt.decoder && !rr ? (Vt = Xt.decoder.write(Vt),
            Xt.objectMode || Vt.length !== 0 ? zt(Zt, Xt, Vt, !1) : _t(Zt, Xt)) : zt(Zt, Xt, Vt, !1))) : fr || (Xt.reading = !1)
        }
        return Kt(Xt)
    }
    function zt(Zt, Vt, rr, fr) {
        Vt.flowing && Vt.length === 0 && !Vt.sync ? (Zt.emit("data", rr),
        Zt.read(0)) : (Vt.length += Vt.objectMode ? 1 : rr.length,
        fr ? Vt.buffer.unshift(rr) : Vt.buffer.push(rr),
        Vt.needReadable && Ht(Zt)),
        _t(Zt, Vt)
    }
    function Wt(Zt, Vt) {
        var rr;
        return !mt(Vt) && typeof Vt != "string" && Vt !== void 0 && !Zt.objectMode && (rr = new TypeError("Invalid non-string/buffer chunk")),
        rr
    }
    function Kt(Zt) {
        return !Zt.ended && (Zt.needReadable || Zt.length < Zt.highWaterMark || Zt.length === 0)
    }
    Ot.prototype.isPaused = function() {
        return this._readableState.flowing === !1
    }
    ,
    Ot.prototype.setEncoding = function(Zt) {
        return At || (At = requireString_decoder().StringDecoder),
        this._readableState.decoder = new At(Zt),
        this._readableState.encoding = Zt,
        this
    }
    ;
    var ir = 8388608;
    function or(Zt) {
        return Zt >= ir ? Zt = ir : (Zt--,
        Zt |= Zt >>> 1,
        Zt |= Zt >>> 2,
        Zt |= Zt >>> 4,
        Zt |= Zt >>> 8,
        Zt |= Zt >>> 16,
        Zt++),
        Zt
    }
    function tr(Zt, Vt) {
        return Zt <= 0 || Vt.length === 0 && Vt.ended ? 0 : Vt.objectMode ? 1 : Zt !== Zt ? Vt.flowing && Vt.length ? Vt.buffer.head.data.length : Vt.length : (Zt > Vt.highWaterMark && (Vt.highWaterMark = or(Zt)),
        Zt <= Vt.length ? Zt : Vt.ended ? Vt.length : (Vt.needReadable = !0,
        0))
    }
    Ot.prototype.read = function(Zt) {
        bt("read", Zt),
        Zt = parseInt(Zt, 10);
        var Vt = this._readableState
          , rr = Zt;
        if (Zt !== 0 && (Vt.emittedReadable = !1),
        Zt === 0 && Vt.needReadable && (Vt.length >= Vt.highWaterMark || Vt.ended))
            return bt("read: emitReadable", Vt.length, Vt.ended),
            Vt.length === 0 && Vt.ended ? ur(this) : Ht(this),
            null;
        if (Zt = tr(Zt, Vt),
        Zt === 0 && Vt.ended)
            return Vt.length === 0 && ur(this),
            null;
        var fr = Vt.needReadable;
        bt("need readable", fr),
        (Vt.length === 0 || Vt.length - Zt < Vt.highWaterMark) && (fr = !0,
        bt("length less than watermark", fr)),
        Vt.ended || Vt.reading ? (fr = !1,
        bt("reading or ended", fr)) : fr && (bt("do read"),
        Vt.reading = !0,
        Vt.sync = !0,
        Vt.length === 0 && (Vt.needReadable = !0),
        this._read(Vt.highWaterMark),
        Vt.sync = !1,
        Vt.reading || (Zt = tr(rr, Vt)));
        var Yt;
        return Zt > 0 ? Yt = Tt(Zt, Vt) : Yt = null,
        Yt === null ? (Vt.needReadable = !0,
        Zt = 0) : Vt.length -= Zt,
        Vt.length === 0 && (Vt.ended || (Vt.needReadable = !0),
        rr !== Zt && Vt.ended && ur(this)),
        Yt !== null && this.emit("data", Yt),
        Yt
    }
    ;
    function wr(Zt, Vt) {
        if (!Vt.ended) {
            if (Vt.decoder) {
                var rr = Vt.decoder.end();
                rr && rr.length && (Vt.buffer.push(rr),
                Vt.length += Vt.objectMode ? 1 : rr.length)
            }
            Vt.ended = !0,
            Ht(Zt)
        }
    }
    function Ht(Zt) {
        var Vt = Zt._readableState;
        Vt.needReadable = !1,
        Vt.emittedReadable || (bt("emitReadable", Vt.flowing),
        Vt.emittedReadable = !0,
        Vt.sync ? r.nextTick(Mt, Zt) : Mt(Zt))
    }
    function Mt(Zt) {
        bt("emit readable"),
        Zt.emit("readable"),
        kt(Zt)
    }
    function _t(Zt, Vt) {
        Vt.readingMore || (Vt.readingMore = !0,
        r.nextTick(gt, Zt, Vt))
    }
    function gt(Zt, Vt) {
        for (var rr = Vt.length; !Vt.reading && !Vt.flowing && !Vt.ended && Vt.length < Vt.highWaterMark && (bt("maybeReadMore read 0"),
        Zt.read(0),
        rr !== Vt.length); )
            rr = Vt.length;
        Vt.readingMore = !1
    }
    Ot.prototype._read = function(Zt) {
        this.emit("error", new Error("_read() is not implemented"))
    }
    ,
    Ot.prototype.pipe = function(Zt, Vt) {
        var rr = this
          , fr = this._readableState;
        switch (fr.pipesCount) {
        case 0:
            fr.pipes = Zt;
            break;
        case 1:
            fr.pipes = [fr.pipes, Zt];
            break;
        default:
            fr.pipes.push(Zt);
            break
        }
        fr.pipesCount += 1,
        bt("pipe count=%d opts=%j", fr.pipesCount, Vt);
        var Yt = (!Vt || Vt.end !== !1) && Zt !== process$1.stdout && Zt !== process$1.stderr
          , Xt = Yt ? Rr : Qr;
        fr.endEmitted ? r.nextTick(Xt) : rr.once("end", Xt),
        Zt.on("unpipe", Sr);
        function Sr(Gr, vr) {
            bt("onunpipe"),
            Gr === rr && vr && vr.hasUnpiped === !1 && (vr.hasUnpiped = !0,
            Dr())
        }
        function Rr() {
            bt("onend"),
            Zt.end()
        }
        var qr = vt(rr);
        Zt.on("drain", qr);
        var Nr = !1;
        function Dr() {
            bt("cleanup"),
            Zt.removeListener("close", Hr),
            Zt.removeListener("finish", un),
            Zt.removeListener("drain", qr),
            Zt.removeListener("error", Zr),
            Zt.removeListener("unpipe", Sr),
            rr.removeListener("end", Rr),
            rr.removeListener("end", Qr),
            rr.removeListener("data", $r),
            Nr = !0,
            fr.awaitDrain && (!Zt._writableState || Zt._writableState.needDrain) && qr()
        }
        var Or = !1;
        rr.on("data", $r);
        function $r(Gr) {
            bt("ondata"),
            Or = !1;
            var vr = Zt.write(Gr);
            vr === !1 && !Or && ((fr.pipesCount === 1 && fr.pipes === Zt || fr.pipesCount > 1 && lr(fr.pipes, Zt) !== -1) && !Nr && (bt("false write response, pause", fr.awaitDrain),
            fr.awaitDrain++,
            Or = !0),
            rr.pause())
        }
        function Zr(Gr) {
            bt("onerror", Gr),
            Qr(),
            Zt.removeListener("error", Zr),
            m(Zt, "error") === 0 && Zt.emit("error", Gr)
        }
        Pt(Zt, "error", Zr);
        function Hr() {
            Zt.removeListener("finish", un),
            Qr()
        }
        Zt.once("close", Hr);
        function un() {
            bt("onfinish"),
            Zt.removeListener("close", Hr),
            Qr()
        }
        Zt.once("finish", un);
        function Qr() {
            bt("unpipe"),
            rr.unpipe(Zt)
        }
        return Zt.emit("pipe", rr),
        fr.flowing || (bt("pipe resume"),
        rr.resume()),
        Zt
    }
    ;
    function vt(Zt) {
        return function() {
            var Vt = Zt._readableState;
            bt("pipeOnDrain", Vt.awaitDrain),
            Vt.awaitDrain && Vt.awaitDrain--,
            Vt.awaitDrain === 0 && m(Zt, "data") && (Vt.flowing = !0,
            kt(Zt))
        }
    }
    Ot.prototype.unpipe = function(Zt) {
        var Vt = this._readableState
          , rr = {
            hasUnpiped: !1
        };
        if (Vt.pipesCount === 0)
            return this;
        if (Vt.pipesCount === 1)
            return Zt && Zt !== Vt.pipes ? this : (Zt || (Zt = Vt.pipes),
            Vt.pipes = null,
            Vt.pipesCount = 0,
            Vt.flowing = !1,
            Zt && Zt.emit("unpipe", this, rr),
            this);
        if (!Zt) {
            var fr = Vt.pipes
              , Yt = Vt.pipesCount;
            Vt.pipes = null,
            Vt.pipesCount = 0,
            Vt.flowing = !1;
            for (var Xt = 0; Xt < Yt; Xt++)
                fr[Xt].emit("unpipe", this, {
                    hasUnpiped: !1
                });
            return this
        }
        var Sr = lr(Vt.pipes, Zt);
        return Sr === -1 ? this : (Vt.pipes.splice(Sr, 1),
        Vt.pipesCount -= 1,
        Vt.pipesCount === 1 && (Vt.pipes = Vt.pipes[0]),
        Zt.emit("unpipe", this, rr),
        this)
    }
    ,
    Ot.prototype.on = function(Zt, Vt) {
        var rr = k.prototype.on.call(this, Zt, Vt);
        if (Zt === "data")
            this._readableState.flowing !== !1 && this.resume();
        else if (Zt === "readable") {
            var fr = this._readableState;
            !fr.endEmitted && !fr.readableListening && (fr.readableListening = fr.needReadable = !0,
            fr.emittedReadable = !1,
            fr.reading ? fr.length && Ht(this) : r.nextTick(Et, this))
        }
        return rr
    }
    ,
    Ot.prototype.addListener = Ot.prototype.on;
    function Et(Zt) {
        bt("readable nexttick read 0"),
        Zt.read(0)
    }
    Ot.prototype.resume = function() {
        var Zt = this._readableState;
        return Zt.flowing || (bt("resume"),
        Zt.flowing = !0,
        Bt(this, Zt)),
        this
    }
    ;
    function Bt(Zt, Vt) {
        Vt.resumeScheduled || (Vt.resumeScheduled = !0,
        r.nextTick(Rt, Zt, Vt))
    }
    function Rt(Zt, Vt) {
        Vt.reading || (bt("resume read 0"),
        Zt.read(0)),
        Vt.resumeScheduled = !1,
        Vt.awaitDrain = 0,
        Zt.emit("resume"),
        kt(Zt),
        Vt.flowing && !Vt.reading && Zt.read(0)
    }
    Ot.prototype.pause = function() {
        return bt("call pause flowing=%j", this._readableState.flowing),
        this._readableState.flowing !== !1 && (bt("pause"),
        this._readableState.flowing = !1,
        this.emit("pause")),
        this
    }
    ;
    function kt(Zt) {
        var Vt = Zt._readableState;
        for (bt("flow", Vt.flowing); Vt.flowing && Zt.read() !== null; )
            ;
    }
    Ot.prototype.wrap = function(Zt) {
        var Vt = this
          , rr = this._readableState
          , fr = !1;
        Zt.on("end", function() {
            if (bt("wrapped end"),
            rr.decoder && !rr.ended) {
                var Sr = rr.decoder.end();
                Sr && Sr.length && Vt.push(Sr)
            }
            Vt.push(null)
        }),
        Zt.on("data", function(Sr) {
            if (bt("wrapped data"),
            rr.decoder && (Sr = rr.decoder.write(Sr)),
            !(rr.objectMode && Sr == null) && !(!rr.objectMode && (!Sr || !Sr.length))) {
                var Rr = Vt.push(Sr);
                Rr || (fr = !0,
                Zt.pause())
            }
        });
        for (var Yt in Zt)
            this[Yt] === void 0 && typeof Zt[Yt] == "function" && (this[Yt] = function(Sr) {
                return function() {
                    return Zt[Sr].apply(Zt, arguments)
                }
            }(Yt));
        for (var Xt = 0; Xt < Ct.length; Xt++)
            Zt.on(Ct[Xt], this.emit.bind(this, Ct[Xt]));
        return this._read = function(Sr) {
            bt("wrapped _read", Sr),
            fr && (fr = !1,
            Zt.resume())
        }
        ,
        this
    }
    ,
    Object.defineProperty(Ot.prototype, "readableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._readableState.highWaterMark
        }
    }),
    Ot._fromList = Tt;
    function Tt(Zt, Vt) {
        if (Vt.length === 0)
            return null;
        var rr;
        return Vt.objectMode ? rr = Vt.buffer.shift() : !Zt || Zt >= Vt.length ? (Vt.decoder ? rr = Vt.buffer.join("") : Vt.buffer.length === 1 ? rr = Vt.buffer.head.data : rr = Vt.buffer.concat(Vt.length),
        Vt.buffer.clear()) : rr = It(Zt, Vt.buffer, Vt.decoder),
        rr
    }
    function It(Zt, Vt, rr) {
        var fr;
        return Zt < Vt.head.data.length ? (fr = Vt.head.data.slice(0, Zt),
        Vt.head.data = Vt.head.data.slice(Zt)) : Zt === Vt.head.data.length ? fr = Vt.shift() : fr = rr ? St(Zt, Vt) : qt(Zt, Vt),
        fr
    }
    function St(Zt, Vt) {
        var rr = Vt.head
          , fr = 1
          , Yt = rr.data;
        for (Zt -= Yt.length; rr = rr.next; ) {
            var Xt = rr.data
              , Sr = Zt > Xt.length ? Xt.length : Zt;
            if (Sr === Xt.length ? Yt += Xt : Yt += Xt.slice(0, Zt),
            Zt -= Sr,
            Zt === 0) {
                Sr === Xt.length ? (++fr,
                rr.next ? Vt.head = rr.next : Vt.head = Vt.tail = null) : (Vt.head = rr,
                rr.data = Xt.slice(Sr));
                break
            }
            ++fr
        }
        return Vt.length -= fr,
        Yt
    }
    function qt(Zt, Vt) {
        var rr = y.allocUnsafe(Zt)
          , fr = Vt.head
          , Yt = 1;
        for (fr.data.copy(rr),
        Zt -= fr.data.length; fr = fr.next; ) {
            var Xt = fr.data
              , Sr = Zt > Xt.length ? Xt.length : Zt;
            if (Xt.copy(rr, rr.length - Zt, 0, Sr),
            Zt -= Sr,
            Zt === 0) {
                Sr === Xt.length ? (++Yt,
                fr.next ? Vt.head = fr.next : Vt.head = Vt.tail = null) : (Vt.head = fr,
                fr.data = Xt.slice(Sr));
                break
            }
            ++Yt
        }
        return Vt.length -= Yt,
        rr
    }
    function ur(Zt) {
        var Vt = Zt._readableState;
        if (Vt.length > 0)
            throw new Error('"endReadable()" called on non-empty stream');
        Vt.endEmitted || (Vt.ended = !0,
        r.nextTick(gr, Vt, Zt))
    }
    function gr(Zt, Vt) {
        !Zt.endEmitted && Zt.length === 0 && (Zt.endEmitted = !0,
        Vt.readable = !1,
        Vt.emit("end"))
    }
    function lr(Zt, Vt) {
        for (var rr = 0, fr = Zt.length; rr < fr; rr++)
            if (Zt[rr] === Vt)
                return rr;
        return -1
    }
    return _stream_readable
}
var _stream_transform, hasRequired_stream_transform;
function require_stream_transform() {
    if (hasRequired_stream_transform)
        return _stream_transform;
    hasRequired_stream_transform = 1,
    _stream_transform = m;
    var r = require_stream_duplex()
      , d = Object.create(requireUtil());
    d.inherits = requireInherits_browser(),
    d.inherits(m, r);
    function f(ee, dt) {
        var mt = this._transformState;
        mt.transforming = !1;
        var yt = mt.writecb;
        if (!yt)
            return this.emit("error", new Error("write callback called multiple times"));
        mt.writechunk = null,
        mt.writecb = null,
        dt != null && this.push(dt),
        yt(ee);
        var pt = this._readableState;
        pt.reading = !1,
        (pt.needReadable || pt.length < pt.highWaterMark) && this._read(pt.highWaterMark)
    }
    function m(ee) {
        if (!(this instanceof m))
            return new m(ee);
        r.call(this, ee),
        this._transformState = {
            afterTransform: f.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
        },
        this._readableState.needReadable = !0,
        this._readableState.sync = !1,
        ee && (typeof ee.transform == "function" && (this._transform = ee.transform),
        typeof ee.flush == "function" && (this._flush = ee.flush)),
        this.on("prefinish", k)
    }
    function k() {
        var ee = this;
        typeof this._flush == "function" ? this._flush(function(dt, mt) {
            y(ee, dt, mt)
        }) : y(this, null, null)
    }
    m.prototype.push = function(ee, dt) {
        return this._transformState.needTransform = !1,
        r.prototype.push.call(this, ee, dt)
    }
    ,
    m.prototype._transform = function(ee, dt, mt) {
        throw new Error("_transform() is not implemented")
    }
    ,
    m.prototype._write = function(ee, dt, mt) {
        var yt = this._transformState;
        if (yt.writecb = mt,
        yt.writechunk = ee,
        yt.writeencoding = dt,
        !yt.transforming) {
            var pt = this._readableState;
            (yt.needTransform || pt.needReadable || pt.length < pt.highWaterMark) && this._read(pt.highWaterMark)
        }
    }
    ,
    m.prototype._read = function(ee) {
        var dt = this._transformState;
        dt.writechunk !== null && dt.writecb && !dt.transforming ? (dt.transforming = !0,
        this._transform(dt.writechunk, dt.writeencoding, dt.afterTransform)) : dt.needTransform = !0
    }
    ,
    m.prototype._destroy = function(ee, dt) {
        var mt = this;
        r.prototype._destroy.call(this, ee, function(yt) {
            dt(yt),
            mt.emit("close")
        })
    }
    ;
    function y(ee, dt, mt) {
        if (dt)
            return ee.emit("error", dt);
        if (mt != null && ee.push(mt),
        ee._writableState.length)
            throw new Error("Calling transform done when ws.length != 0");
        if (ee._transformState.transforming)
            throw new Error("Calling transform done when still transforming");
        return ee.push(null)
    }
    return _stream_transform
}
var _stream_passthrough, hasRequired_stream_passthrough;
function require_stream_passthrough() {
    if (hasRequired_stream_passthrough)
        return _stream_passthrough;
    hasRequired_stream_passthrough = 1,
    _stream_passthrough = f;
    var r = require_stream_transform()
      , d = Object.create(requireUtil());
    d.inherits = requireInherits_browser(),
    d.inherits(f, r);
    function f(m) {
        if (!(this instanceof f))
            return new f(m);
        r.call(this, m)
    }
    return f.prototype._transform = function(m, k, y) {
        y(null, m)
    }
    ,
    _stream_passthrough
}
var hasRequiredReadableBrowser;
function requireReadableBrowser() {
    return hasRequiredReadableBrowser || (hasRequiredReadableBrowser = 1,
    function(r, d) {
        d = r.exports = require_stream_readable(),
        d.Stream = d,
        d.Readable = d,
        d.Writable = require_stream_writable(),
        d.Duplex = require_stream_duplex(),
        d.Transform = require_stream_transform(),
        d.PassThrough = require_stream_passthrough()
    }(readableBrowser, readableBrowser.exports)),
    readableBrowser.exports
}
var sign$1 = {
    exports: {}
}
  , bn$1 = {
    exports: {}
};
bn$1.exports;
var hasRequiredBn$1;
function requireBn$1() {
    return hasRequiredBn$1 || (hasRequiredBn$1 = 1,
    function(r) {
        (function(d, f) {
            function m(_t, gt) {
                if (!_t)
                    throw new Error(gt || "Assertion failed")
            }
            function k(_t, gt) {
                _t.super_ = gt;
                var vt = function() {};
                vt.prototype = gt.prototype,
                _t.prototype = new vt,
                _t.prototype.constructor = _t
            }
            function y(_t, gt, vt) {
                if (y.isBN(_t))
                    return _t;
                this.negative = 0,
                this.words = null,
                this.length = 0,
                this.red = null,
                _t !== null && ((gt === "le" || gt === "be") && (vt = gt,
                gt = 10),
                this._init(_t || 0, gt || 10, vt || "be"))
            }
            typeof d == "object" ? d.exports = y : f.BN = y,
            y.BN = y,
            y.wordSize = 26;
            var ee;
            try {
                typeof window < "u" && typeof window.Buffer < "u" ? ee = window.Buffer : ee = require$$1$2.Buffer
            } catch {}
            y.isBN = function(gt) {
                return gt instanceof y ? !0 : gt !== null && typeof gt == "object" && gt.constructor.wordSize === y.wordSize && Array.isArray(gt.words)
            }
            ,
            y.max = function(gt, vt) {
                return gt.cmp(vt) > 0 ? gt : vt
            }
            ,
            y.min = function(gt, vt) {
                return gt.cmp(vt) < 0 ? gt : vt
            }
            ,
            y.prototype._init = function(gt, vt, Et) {
                if (typeof gt == "number")
                    return this._initNumber(gt, vt, Et);
                if (typeof gt == "object")
                    return this._initArray(gt, vt, Et);
                vt === "hex" && (vt = 16),
                m(vt === (vt | 0) && vt >= 2 && vt <= 36),
                gt = gt.toString().replace(/\s+/g, "");
                var Bt = 0;
                gt[0] === "-" && (Bt++,
                this.negative = 1),
                Bt < gt.length && (vt === 16 ? this._parseHex(gt, Bt, Et) : (this._parseBase(gt, vt, Bt),
                Et === "le" && this._initArray(this.toArray(), vt, Et)))
            }
            ,
            y.prototype._initNumber = function(gt, vt, Et) {
                gt < 0 && (this.negative = 1,
                gt = -gt),
                gt < 67108864 ? (this.words = [gt & 67108863],
                this.length = 1) : gt < 4503599627370496 ? (this.words = [gt & 67108863, gt / 67108864 & 67108863],
                this.length = 2) : (m(gt < 9007199254740992),
                this.words = [gt & 67108863, gt / 67108864 & 67108863, 1],
                this.length = 3),
                Et === "le" && this._initArray(this.toArray(), vt, Et)
            }
            ,
            y.prototype._initArray = function(gt, vt, Et) {
                if (m(typeof gt.length == "number"),
                gt.length <= 0)
                    return this.words = [0],
                    this.length = 1,
                    this;
                this.length = Math.ceil(gt.length / 3),
                this.words = new Array(this.length);
                for (var Bt = 0; Bt < this.length; Bt++)
                    this.words[Bt] = 0;
                var Rt, kt, Tt = 0;
                if (Et === "be")
                    for (Bt = gt.length - 1,
                    Rt = 0; Bt >= 0; Bt -= 3)
                        kt = gt[Bt] | gt[Bt - 1] << 8 | gt[Bt - 2] << 16,
                        this.words[Rt] |= kt << Tt & 67108863,
                        this.words[Rt + 1] = kt >>> 26 - Tt & 67108863,
                        Tt += 24,
                        Tt >= 26 && (Tt -= 26,
                        Rt++);
                else if (Et === "le")
                    for (Bt = 0,
                    Rt = 0; Bt < gt.length; Bt += 3)
                        kt = gt[Bt] | gt[Bt + 1] << 8 | gt[Bt + 2] << 16,
                        this.words[Rt] |= kt << Tt & 67108863,
                        this.words[Rt + 1] = kt >>> 26 - Tt & 67108863,
                        Tt += 24,
                        Tt >= 26 && (Tt -= 26,
                        Rt++);
                return this._strip()
            }
            ;
            function dt(_t, gt) {
                var vt = _t.charCodeAt(gt);
                if (vt >= 48 && vt <= 57)
                    return vt - 48;
                if (vt >= 65 && vt <= 70)
                    return vt - 55;
                if (vt >= 97 && vt <= 102)
                    return vt - 87;
                m(!1, "Invalid character in " + _t)
            }
            function mt(_t, gt, vt) {
                var Et = dt(_t, vt);
                return vt - 1 >= gt && (Et |= dt(_t, vt - 1) << 4),
                Et
            }
            y.prototype._parseHex = function(gt, vt, Et) {
                this.length = Math.ceil((gt.length - vt) / 6),
                this.words = new Array(this.length);
                for (var Bt = 0; Bt < this.length; Bt++)
                    this.words[Bt] = 0;
                var Rt = 0, kt = 0, Tt;
                if (Et === "be")
                    for (Bt = gt.length - 1; Bt >= vt; Bt -= 2)
                        Tt = mt(gt, vt, Bt) << Rt,
                        this.words[kt] |= Tt & 67108863,
                        Rt >= 18 ? (Rt -= 18,
                        kt += 1,
                        this.words[kt] |= Tt >>> 26) : Rt += 8;
                else {
                    var It = gt.length - vt;
                    for (Bt = It % 2 === 0 ? vt + 1 : vt; Bt < gt.length; Bt += 2)
                        Tt = mt(gt, vt, Bt) << Rt,
                        this.words[kt] |= Tt & 67108863,
                        Rt >= 18 ? (Rt -= 18,
                        kt += 1,
                        this.words[kt] |= Tt >>> 26) : Rt += 8
                }
                this._strip()
            }
            ;
            function yt(_t, gt, vt, Et) {
                for (var Bt = 0, Rt = 0, kt = Math.min(_t.length, vt), Tt = gt; Tt < kt; Tt++) {
                    var It = _t.charCodeAt(Tt) - 48;
                    Bt *= Et,
                    It >= 49 ? Rt = It - 49 + 10 : It >= 17 ? Rt = It - 17 + 10 : Rt = It,
                    m(It >= 0 && Rt < Et, "Invalid character"),
                    Bt += Rt
                }
                return Bt
            }
            y.prototype._parseBase = function(gt, vt, Et) {
                this.words = [0],
                this.length = 1;
                for (var Bt = 0, Rt = 1; Rt <= 67108863; Rt *= vt)
                    Bt++;
                Bt--,
                Rt = Rt / vt | 0;
                for (var kt = gt.length - Et, Tt = kt % Bt, It = Math.min(kt, kt - Tt) + Et, St = 0, qt = Et; qt < It; qt += Bt)
                    St = yt(gt, qt, qt + Bt, vt),
                    this.imuln(Rt),
                    this.words[0] + St < 67108864 ? this.words[0] += St : this._iaddn(St);
                if (Tt !== 0) {
                    var ur = 1;
                    for (St = yt(gt, qt, gt.length, vt),
                    qt = 0; qt < Tt; qt++)
                        ur *= vt;
                    this.imuln(ur),
                    this.words[0] + St < 67108864 ? this.words[0] += St : this._iaddn(St)
                }
                this._strip()
            }
            ,
            y.prototype.copy = function(gt) {
                gt.words = new Array(this.length);
                for (var vt = 0; vt < this.length; vt++)
                    gt.words[vt] = this.words[vt];
                gt.length = this.length,
                gt.negative = this.negative,
                gt.red = this.red
            }
            ;
            function pt(_t, gt) {
                _t.words = gt.words,
                _t.length = gt.length,
                _t.negative = gt.negative,
                _t.red = gt.red
            }
            if (y.prototype._move = function(gt) {
                pt(gt, this)
            }
            ,
            y.prototype.clone = function() {
                var gt = new y(null);
                return this.copy(gt),
                gt
            }
            ,
            y.prototype._expand = function(gt) {
                for (; this.length < gt; )
                    this.words[this.length++] = 0;
                return this
            }
            ,
            y.prototype._strip = function() {
                for (; this.length > 1 && this.words[this.length - 1] === 0; )
                    this.length--;
                return this._normSign()
            }
            ,
            y.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0),
                this
            }
            ,
            typeof Symbol < "u" && typeof Symbol.for == "function")
                try {
                    y.prototype[Symbol.for("nodejs.util.inspect.custom")] = bt
                } catch {
                    y.prototype.inspect = bt
                }
            else
                y.prototype.inspect = bt;
            function bt() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
            }
            var wt = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
              , xt = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
              , At = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
            y.prototype.toString = function(gt, vt) {
                gt = gt || 10,
                vt = vt | 0 || 1;
                var Et;
                if (gt === 16 || gt === "hex") {
                    Et = "";
                    for (var Bt = 0, Rt = 0, kt = 0; kt < this.length; kt++) {
                        var Tt = this.words[kt]
                          , It = ((Tt << Bt | Rt) & 16777215).toString(16);
                        Rt = Tt >>> 24 - Bt & 16777215,
                        Bt += 2,
                        Bt >= 26 && (Bt -= 26,
                        kt--),
                        Rt !== 0 || kt !== this.length - 1 ? Et = wt[6 - It.length] + It + Et : Et = It + Et
                    }
                    for (Rt !== 0 && (Et = Rt.toString(16) + Et); Et.length % vt !== 0; )
                        Et = "0" + Et;
                    return this.negative !== 0 && (Et = "-" + Et),
                    Et
                }
                if (gt === (gt | 0) && gt >= 2 && gt <= 36) {
                    var St = xt[gt]
                      , qt = At[gt];
                    Et = "";
                    var ur = this.clone();
                    for (ur.negative = 0; !ur.isZero(); ) {
                        var gr = ur.modrn(qt).toString(gt);
                        ur = ur.idivn(qt),
                        ur.isZero() ? Et = gr + Et : Et = wt[St - gr.length] + gr + Et
                    }
                    for (this.isZero() && (Et = "0" + Et); Et.length % vt !== 0; )
                        Et = "0" + Et;
                    return this.negative !== 0 && (Et = "-" + Et),
                    Et
                }
                m(!1, "Base should be between 2 and 36")
            }
            ,
            y.prototype.toNumber = function() {
                var gt = this.words[0];
                return this.length === 2 ? gt += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? gt += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && m(!1, "Number can only safely store up to 53 bits"),
                this.negative !== 0 ? -gt : gt
            }
            ,
            y.prototype.toJSON = function() {
                return this.toString(16, 2)
            }
            ,
            ee && (y.prototype.toBuffer = function(gt, vt) {
                return this.toArrayLike(ee, gt, vt)
            }
            ),
            y.prototype.toArray = function(gt, vt) {
                return this.toArrayLike(Array, gt, vt)
            }
            ;
            var Ct = function(gt, vt) {
                return gt.allocUnsafe ? gt.allocUnsafe(vt) : new gt(vt)
            };
            y.prototype.toArrayLike = function(gt, vt, Et) {
                this._strip();
                var Bt = this.byteLength()
                  , Rt = Et || Math.max(1, Bt);
                m(Bt <= Rt, "byte array longer than desired length"),
                m(Rt > 0, "Requested array length <= 0");
                var kt = Ct(gt, Rt)
                  , Tt = vt === "le" ? "LE" : "BE";
                return this["_toArrayLike" + Tt](kt, Bt),
                kt
            }
            ,
            y.prototype._toArrayLikeLE = function(gt, vt) {
                for (var Et = 0, Bt = 0, Rt = 0, kt = 0; Rt < this.length; Rt++) {
                    var Tt = this.words[Rt] << kt | Bt;
                    gt[Et++] = Tt & 255,
                    Et < gt.length && (gt[Et++] = Tt >> 8 & 255),
                    Et < gt.length && (gt[Et++] = Tt >> 16 & 255),
                    kt === 6 ? (Et < gt.length && (gt[Et++] = Tt >> 24 & 255),
                    Bt = 0,
                    kt = 0) : (Bt = Tt >>> 24,
                    kt += 2)
                }
                if (Et < gt.length)
                    for (gt[Et++] = Bt; Et < gt.length; )
                        gt[Et++] = 0
            }
            ,
            y.prototype._toArrayLikeBE = function(gt, vt) {
                for (var Et = gt.length - 1, Bt = 0, Rt = 0, kt = 0; Rt < this.length; Rt++) {
                    var Tt = this.words[Rt] << kt | Bt;
                    gt[Et--] = Tt & 255,
                    Et >= 0 && (gt[Et--] = Tt >> 8 & 255),
                    Et >= 0 && (gt[Et--] = Tt >> 16 & 255),
                    kt === 6 ? (Et >= 0 && (gt[Et--] = Tt >> 24 & 255),
                    Bt = 0,
                    kt = 0) : (Bt = Tt >>> 24,
                    kt += 2)
                }
                if (Et >= 0)
                    for (gt[Et--] = Bt; Et >= 0; )
                        gt[Et--] = 0
            }
            ,
            Math.clz32 ? y.prototype._countBits = function(gt) {
                return 32 - Math.clz32(gt)
            }
            : y.prototype._countBits = function(gt) {
                var vt = gt
                  , Et = 0;
                return vt >= 4096 && (Et += 13,
                vt >>>= 13),
                vt >= 64 && (Et += 7,
                vt >>>= 7),
                vt >= 8 && (Et += 4,
                vt >>>= 4),
                vt >= 2 && (Et += 2,
                vt >>>= 2),
                Et + vt
            }
            ,
            y.prototype._zeroBits = function(gt) {
                if (gt === 0)
                    return 26;
                var vt = gt
                  , Et = 0;
                return vt & 8191 || (Et += 13,
                vt >>>= 13),
                vt & 127 || (Et += 7,
                vt >>>= 7),
                vt & 15 || (Et += 4,
                vt >>>= 4),
                vt & 3 || (Et += 2,
                vt >>>= 2),
                vt & 1 || Et++,
                Et
            }
            ,
            y.prototype.bitLength = function() {
                var gt = this.words[this.length - 1]
                  , vt = this._countBits(gt);
                return (this.length - 1) * 26 + vt
            }
            ;
            function Pt(_t) {
                for (var gt = new Array(_t.bitLength()), vt = 0; vt < gt.length; vt++) {
                    var Et = vt / 26 | 0
                      , Bt = vt % 26;
                    gt[vt] = _t.words[Et] >>> Bt & 1
                }
                return gt
            }
            y.prototype.zeroBits = function() {
                if (this.isZero())
                    return 0;
                for (var gt = 0, vt = 0; vt < this.length; vt++) {
                    var Et = this._zeroBits(this.words[vt]);
                    if (gt += Et,
                    Et !== 26)
                        break
                }
                return gt
            }
            ,
            y.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8)
            }
            ,
            y.prototype.toTwos = function(gt) {
                return this.negative !== 0 ? this.abs().inotn(gt).iaddn(1) : this.clone()
            }
            ,
            y.prototype.fromTwos = function(gt) {
                return this.testn(gt - 1) ? this.notn(gt).iaddn(1).ineg() : this.clone()
            }
            ,
            y.prototype.isNeg = function() {
                return this.negative !== 0
            }
            ,
            y.prototype.neg = function() {
                return this.clone().ineg()
            }
            ,
            y.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1),
                this
            }
            ,
            y.prototype.iuor = function(gt) {
                for (; this.length < gt.length; )
                    this.words[this.length++] = 0;
                for (var vt = 0; vt < gt.length; vt++)
                    this.words[vt] = this.words[vt] | gt.words[vt];
                return this._strip()
            }
            ,
            y.prototype.ior = function(gt) {
                return m((this.negative | gt.negative) === 0),
                this.iuor(gt)
            }
            ,
            y.prototype.or = function(gt) {
                return this.length > gt.length ? this.clone().ior(gt) : gt.clone().ior(this)
            }
            ,
            y.prototype.uor = function(gt) {
                return this.length > gt.length ? this.clone().iuor(gt) : gt.clone().iuor(this)
            }
            ,
            y.prototype.iuand = function(gt) {
                var vt;
                this.length > gt.length ? vt = gt : vt = this;
                for (var Et = 0; Et < vt.length; Et++)
                    this.words[Et] = this.words[Et] & gt.words[Et];
                return this.length = vt.length,
                this._strip()
            }
            ,
            y.prototype.iand = function(gt) {
                return m((this.negative | gt.negative) === 0),
                this.iuand(gt)
            }
            ,
            y.prototype.and = function(gt) {
                return this.length > gt.length ? this.clone().iand(gt) : gt.clone().iand(this)
            }
            ,
            y.prototype.uand = function(gt) {
                return this.length > gt.length ? this.clone().iuand(gt) : gt.clone().iuand(this)
            }
            ,
            y.prototype.iuxor = function(gt) {
                var vt, Et;
                this.length > gt.length ? (vt = this,
                Et = gt) : (vt = gt,
                Et = this);
                for (var Bt = 0; Bt < Et.length; Bt++)
                    this.words[Bt] = vt.words[Bt] ^ Et.words[Bt];
                if (this !== vt)
                    for (; Bt < vt.length; Bt++)
                        this.words[Bt] = vt.words[Bt];
                return this.length = vt.length,
                this._strip()
            }
            ,
            y.prototype.ixor = function(gt) {
                return m((this.negative | gt.negative) === 0),
                this.iuxor(gt)
            }
            ,
            y.prototype.xor = function(gt) {
                return this.length > gt.length ? this.clone().ixor(gt) : gt.clone().ixor(this)
            }
            ,
            y.prototype.uxor = function(gt) {
                return this.length > gt.length ? this.clone().iuxor(gt) : gt.clone().iuxor(this)
            }
            ,
            y.prototype.inotn = function(gt) {
                m(typeof gt == "number" && gt >= 0);
                var vt = Math.ceil(gt / 26) | 0
                  , Et = gt % 26;
                this._expand(vt),
                Et > 0 && vt--;
                for (var Bt = 0; Bt < vt; Bt++)
                    this.words[Bt] = ~this.words[Bt] & 67108863;
                return Et > 0 && (this.words[Bt] = ~this.words[Bt] & 67108863 >> 26 - Et),
                this._strip()
            }
            ,
            y.prototype.notn = function(gt) {
                return this.clone().inotn(gt)
            }
            ,
            y.prototype.setn = function(gt, vt) {
                m(typeof gt == "number" && gt >= 0);
                var Et = gt / 26 | 0
                  , Bt = gt % 26;
                return this._expand(Et + 1),
                vt ? this.words[Et] = this.words[Et] | 1 << Bt : this.words[Et] = this.words[Et] & ~(1 << Bt),
                this._strip()
            }
            ,
            y.prototype.iadd = function(gt) {
                var vt;
                if (this.negative !== 0 && gt.negative === 0)
                    return this.negative = 0,
                    vt = this.isub(gt),
                    this.negative ^= 1,
                    this._normSign();
                if (this.negative === 0 && gt.negative !== 0)
                    return gt.negative = 0,
                    vt = this.isub(gt),
                    gt.negative = 1,
                    vt._normSign();
                var Et, Bt;
                this.length > gt.length ? (Et = this,
                Bt = gt) : (Et = gt,
                Bt = this);
                for (var Rt = 0, kt = 0; kt < Bt.length; kt++)
                    vt = (Et.words[kt] | 0) + (Bt.words[kt] | 0) + Rt,
                    this.words[kt] = vt & 67108863,
                    Rt = vt >>> 26;
                for (; Rt !== 0 && kt < Et.length; kt++)
                    vt = (Et.words[kt] | 0) + Rt,
                    this.words[kt] = vt & 67108863,
                    Rt = vt >>> 26;
                if (this.length = Et.length,
                Rt !== 0)
                    this.words[this.length] = Rt,
                    this.length++;
                else if (Et !== this)
                    for (; kt < Et.length; kt++)
                        this.words[kt] = Et.words[kt];
                return this
            }
            ,
            y.prototype.add = function(gt) {
                var vt;
                return gt.negative !== 0 && this.negative === 0 ? (gt.negative = 0,
                vt = this.sub(gt),
                gt.negative ^= 1,
                vt) : gt.negative === 0 && this.negative !== 0 ? (this.negative = 0,
                vt = gt.sub(this),
                this.negative = 1,
                vt) : this.length > gt.length ? this.clone().iadd(gt) : gt.clone().iadd(this)
            }
            ,
            y.prototype.isub = function(gt) {
                if (gt.negative !== 0) {
                    gt.negative = 0;
                    var vt = this.iadd(gt);
                    return gt.negative = 1,
                    vt._normSign()
                } else if (this.negative !== 0)
                    return this.negative = 0,
                    this.iadd(gt),
                    this.negative = 1,
                    this._normSign();
                var Et = this.cmp(gt);
                if (Et === 0)
                    return this.negative = 0,
                    this.length = 1,
                    this.words[0] = 0,
                    this;
                var Bt, Rt;
                Et > 0 ? (Bt = this,
                Rt = gt) : (Bt = gt,
                Rt = this);
                for (var kt = 0, Tt = 0; Tt < Rt.length; Tt++)
                    vt = (Bt.words[Tt] | 0) - (Rt.words[Tt] | 0) + kt,
                    kt = vt >> 26,
                    this.words[Tt] = vt & 67108863;
                for (; kt !== 0 && Tt < Bt.length; Tt++)
                    vt = (Bt.words[Tt] | 0) + kt,
                    kt = vt >> 26,
                    this.words[Tt] = vt & 67108863;
                if (kt === 0 && Tt < Bt.length && Bt !== this)
                    for (; Tt < Bt.length; Tt++)
                        this.words[Tt] = Bt.words[Tt];
                return this.length = Math.max(this.length, Tt),
                Bt !== this && (this.negative = 1),
                this._strip()
            }
            ,
            y.prototype.sub = function(gt) {
                return this.clone().isub(gt)
            }
            ;
            function $t(_t, gt, vt) {
                vt.negative = gt.negative ^ _t.negative;
                var Et = _t.length + gt.length | 0;
                vt.length = Et,
                Et = Et - 1 | 0;
                var Bt = _t.words[0] | 0
                  , Rt = gt.words[0] | 0
                  , kt = Bt * Rt
                  , Tt = kt & 67108863
                  , It = kt / 67108864 | 0;
                vt.words[0] = Tt;
                for (var St = 1; St < Et; St++) {
                    for (var qt = It >>> 26, ur = It & 67108863, gr = Math.min(St, gt.length - 1), lr = Math.max(0, St - _t.length + 1); lr <= gr; lr++) {
                        var Zt = St - lr | 0;
                        Bt = _t.words[Zt] | 0,
                        Rt = gt.words[lr] | 0,
                        kt = Bt * Rt + ur,
                        qt += kt / 67108864 | 0,
                        ur = kt & 67108863
                    }
                    vt.words[St] = ur | 0,
                    It = qt | 0
                }
                return It !== 0 ? vt.words[St] = It | 0 : vt.length--,
                vt._strip()
            }
            var Ot = function(gt, vt, Et) {
                var Bt = gt.words, Rt = vt.words, kt = Et.words, Tt = 0, It, St, qt, ur = Bt[0] | 0, gr = ur & 8191, lr = ur >>> 13, Zt = Bt[1] | 0, Vt = Zt & 8191, rr = Zt >>> 13, fr = Bt[2] | 0, Yt = fr & 8191, Xt = fr >>> 13, Sr = Bt[3] | 0, Rr = Sr & 8191, qr = Sr >>> 13, Nr = Bt[4] | 0, Dr = Nr & 8191, Or = Nr >>> 13, $r = Bt[5] | 0, Zr = $r & 8191, Hr = $r >>> 13, un = Bt[6] | 0, Qr = un & 8191, Gr = un >>> 13, vr = Bt[7] | 0, ar = vr & 8191, hr = vr >>> 13, _r = Bt[8] | 0, Ar = _r & 8191, Ft = _r >>> 13, Ut = Bt[9] | 0, Dt = Ut & 8191, er = Ut >>> 13, br = Rt[0] | 0, Cr = br & 8191, xr = br >>> 13, Lr = Rt[1] | 0, Ur = Lr & 8191, Ir = Lr >>> 13, Jr = Rt[2] | 0, Wr = Jr & 8191, Yr = Jr >>> 13, Sn = Rt[3] | 0, pn = Sn & 8191, tn = Sn >>> 13, Bn = Rt[4] | 0, An = Bn & 8191, dn = Bn >>> 13, Rn = Rt[5] | 0, En = Rn & 8191, an = Rn >>> 13, Un = Rt[6] | 0, Jt = Un & 8191, nr = Un >>> 13, sr = Rt[7] | 0, jt = sr & 8191, cr = sr >>> 13, Tr = Rt[8] | 0, kr = Tr & 8191, Pr = Tr >>> 13, zr = Rt[9] | 0, Vr = zr & 8191, jr = zr >>> 13;
                Et.negative = gt.negative ^ vt.negative,
                Et.length = 19,
                It = Math.imul(gr, Cr),
                St = Math.imul(gr, xr),
                St = St + Math.imul(lr, Cr) | 0,
                qt = Math.imul(lr, xr);
                var Mn = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (Mn >>> 26) | 0,
                Mn &= 67108863,
                It = Math.imul(Vt, Cr),
                St = Math.imul(Vt, xr),
                St = St + Math.imul(rr, Cr) | 0,
                qt = Math.imul(rr, xr),
                It = It + Math.imul(gr, Ur) | 0,
                St = St + Math.imul(gr, Ir) | 0,
                St = St + Math.imul(lr, Ur) | 0,
                qt = qt + Math.imul(lr, Ir) | 0;
                var nn = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (nn >>> 26) | 0,
                nn &= 67108863,
                It = Math.imul(Yt, Cr),
                St = Math.imul(Yt, xr),
                St = St + Math.imul(Xt, Cr) | 0,
                qt = Math.imul(Xt, xr),
                It = It + Math.imul(Vt, Ur) | 0,
                St = St + Math.imul(Vt, Ir) | 0,
                St = St + Math.imul(rr, Ur) | 0,
                qt = qt + Math.imul(rr, Ir) | 0,
                It = It + Math.imul(gr, Wr) | 0,
                St = St + Math.imul(gr, Yr) | 0,
                St = St + Math.imul(lr, Wr) | 0,
                qt = qt + Math.imul(lr, Yr) | 0;
                var gn = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (gn >>> 26) | 0,
                gn &= 67108863,
                It = Math.imul(Rr, Cr),
                St = Math.imul(Rr, xr),
                St = St + Math.imul(qr, Cr) | 0,
                qt = Math.imul(qr, xr),
                It = It + Math.imul(Yt, Ur) | 0,
                St = St + Math.imul(Yt, Ir) | 0,
                St = St + Math.imul(Xt, Ur) | 0,
                qt = qt + Math.imul(Xt, Ir) | 0,
                It = It + Math.imul(Vt, Wr) | 0,
                St = St + Math.imul(Vt, Yr) | 0,
                St = St + Math.imul(rr, Wr) | 0,
                qt = qt + Math.imul(rr, Yr) | 0,
                It = It + Math.imul(gr, pn) | 0,
                St = St + Math.imul(gr, tn) | 0,
                St = St + Math.imul(lr, pn) | 0,
                qt = qt + Math.imul(lr, tn) | 0;
                var mn = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (mn >>> 26) | 0,
                mn &= 67108863,
                It = Math.imul(Dr, Cr),
                St = Math.imul(Dr, xr),
                St = St + Math.imul(Or, Cr) | 0,
                qt = Math.imul(Or, xr),
                It = It + Math.imul(Rr, Ur) | 0,
                St = St + Math.imul(Rr, Ir) | 0,
                St = St + Math.imul(qr, Ur) | 0,
                qt = qt + Math.imul(qr, Ir) | 0,
                It = It + Math.imul(Yt, Wr) | 0,
                St = St + Math.imul(Yt, Yr) | 0,
                St = St + Math.imul(Xt, Wr) | 0,
                qt = qt + Math.imul(Xt, Yr) | 0,
                It = It + Math.imul(Vt, pn) | 0,
                St = St + Math.imul(Vt, tn) | 0,
                St = St + Math.imul(rr, pn) | 0,
                qt = qt + Math.imul(rr, tn) | 0,
                It = It + Math.imul(gr, An) | 0,
                St = St + Math.imul(gr, dn) | 0,
                St = St + Math.imul(lr, An) | 0,
                qt = qt + Math.imul(lr, dn) | 0;
                var xn = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (xn >>> 26) | 0,
                xn &= 67108863,
                It = Math.imul(Zr, Cr),
                St = Math.imul(Zr, xr),
                St = St + Math.imul(Hr, Cr) | 0,
                qt = Math.imul(Hr, xr),
                It = It + Math.imul(Dr, Ur) | 0,
                St = St + Math.imul(Dr, Ir) | 0,
                St = St + Math.imul(Or, Ur) | 0,
                qt = qt + Math.imul(Or, Ir) | 0,
                It = It + Math.imul(Rr, Wr) | 0,
                St = St + Math.imul(Rr, Yr) | 0,
                St = St + Math.imul(qr, Wr) | 0,
                qt = qt + Math.imul(qr, Yr) | 0,
                It = It + Math.imul(Yt, pn) | 0,
                St = St + Math.imul(Yt, tn) | 0,
                St = St + Math.imul(Xt, pn) | 0,
                qt = qt + Math.imul(Xt, tn) | 0,
                It = It + Math.imul(Vt, An) | 0,
                St = St + Math.imul(Vt, dn) | 0,
                St = St + Math.imul(rr, An) | 0,
                qt = qt + Math.imul(rr, dn) | 0,
                It = It + Math.imul(gr, En) | 0,
                St = St + Math.imul(gr, an) | 0,
                St = St + Math.imul(lr, En) | 0,
                qt = qt + Math.imul(lr, an) | 0;
                var _n = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (_n >>> 26) | 0,
                _n &= 67108863,
                It = Math.imul(Qr, Cr),
                St = Math.imul(Qr, xr),
                St = St + Math.imul(Gr, Cr) | 0,
                qt = Math.imul(Gr, xr),
                It = It + Math.imul(Zr, Ur) | 0,
                St = St + Math.imul(Zr, Ir) | 0,
                St = St + Math.imul(Hr, Ur) | 0,
                qt = qt + Math.imul(Hr, Ir) | 0,
                It = It + Math.imul(Dr, Wr) | 0,
                St = St + Math.imul(Dr, Yr) | 0,
                St = St + Math.imul(Or, Wr) | 0,
                qt = qt + Math.imul(Or, Yr) | 0,
                It = It + Math.imul(Rr, pn) | 0,
                St = St + Math.imul(Rr, tn) | 0,
                St = St + Math.imul(qr, pn) | 0,
                qt = qt + Math.imul(qr, tn) | 0,
                It = It + Math.imul(Yt, An) | 0,
                St = St + Math.imul(Yt, dn) | 0,
                St = St + Math.imul(Xt, An) | 0,
                qt = qt + Math.imul(Xt, dn) | 0,
                It = It + Math.imul(Vt, En) | 0,
                St = St + Math.imul(Vt, an) | 0,
                St = St + Math.imul(rr, En) | 0,
                qt = qt + Math.imul(rr, an) | 0,
                It = It + Math.imul(gr, Jt) | 0,
                St = St + Math.imul(gr, nr) | 0,
                St = St + Math.imul(lr, Jt) | 0,
                qt = qt + Math.imul(lr, nr) | 0;
                var yn = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (yn >>> 26) | 0,
                yn &= 67108863,
                It = Math.imul(ar, Cr),
                St = Math.imul(ar, xr),
                St = St + Math.imul(hr, Cr) | 0,
                qt = Math.imul(hr, xr),
                It = It + Math.imul(Qr, Ur) | 0,
                St = St + Math.imul(Qr, Ir) | 0,
                St = St + Math.imul(Gr, Ur) | 0,
                qt = qt + Math.imul(Gr, Ir) | 0,
                It = It + Math.imul(Zr, Wr) | 0,
                St = St + Math.imul(Zr, Yr) | 0,
                St = St + Math.imul(Hr, Wr) | 0,
                qt = qt + Math.imul(Hr, Yr) | 0,
                It = It + Math.imul(Dr, pn) | 0,
                St = St + Math.imul(Dr, tn) | 0,
                St = St + Math.imul(Or, pn) | 0,
                qt = qt + Math.imul(Or, tn) | 0,
                It = It + Math.imul(Rr, An) | 0,
                St = St + Math.imul(Rr, dn) | 0,
                St = St + Math.imul(qr, An) | 0,
                qt = qt + Math.imul(qr, dn) | 0,
                It = It + Math.imul(Yt, En) | 0,
                St = St + Math.imul(Yt, an) | 0,
                St = St + Math.imul(Xt, En) | 0,
                qt = qt + Math.imul(Xt, an) | 0,
                It = It + Math.imul(Vt, Jt) | 0,
                St = St + Math.imul(Vt, nr) | 0,
                St = St + Math.imul(rr, Jt) | 0,
                qt = qt + Math.imul(rr, nr) | 0,
                It = It + Math.imul(gr, jt) | 0,
                St = St + Math.imul(gr, cr) | 0,
                St = St + Math.imul(lr, jt) | 0,
                qt = qt + Math.imul(lr, cr) | 0;
                var wn = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (wn >>> 26) | 0,
                wn &= 67108863,
                It = Math.imul(Ar, Cr),
                St = Math.imul(Ar, xr),
                St = St + Math.imul(Ft, Cr) | 0,
                qt = Math.imul(Ft, xr),
                It = It + Math.imul(ar, Ur) | 0,
                St = St + Math.imul(ar, Ir) | 0,
                St = St + Math.imul(hr, Ur) | 0,
                qt = qt + Math.imul(hr, Ir) | 0,
                It = It + Math.imul(Qr, Wr) | 0,
                St = St + Math.imul(Qr, Yr) | 0,
                St = St + Math.imul(Gr, Wr) | 0,
                qt = qt + Math.imul(Gr, Yr) | 0,
                It = It + Math.imul(Zr, pn) | 0,
                St = St + Math.imul(Zr, tn) | 0,
                St = St + Math.imul(Hr, pn) | 0,
                qt = qt + Math.imul(Hr, tn) | 0,
                It = It + Math.imul(Dr, An) | 0,
                St = St + Math.imul(Dr, dn) | 0,
                St = St + Math.imul(Or, An) | 0,
                qt = qt + Math.imul(Or, dn) | 0,
                It = It + Math.imul(Rr, En) | 0,
                St = St + Math.imul(Rr, an) | 0,
                St = St + Math.imul(qr, En) | 0,
                qt = qt + Math.imul(qr, an) | 0,
                It = It + Math.imul(Yt, Jt) | 0,
                St = St + Math.imul(Yt, nr) | 0,
                St = St + Math.imul(Xt, Jt) | 0,
                qt = qt + Math.imul(Xt, nr) | 0,
                It = It + Math.imul(Vt, jt) | 0,
                St = St + Math.imul(Vt, cr) | 0,
                St = St + Math.imul(rr, jt) | 0,
                qt = qt + Math.imul(rr, cr) | 0,
                It = It + Math.imul(gr, kr) | 0,
                St = St + Math.imul(gr, Pr) | 0,
                St = St + Math.imul(lr, kr) | 0,
                qt = qt + Math.imul(lr, Pr) | 0;
                var vn = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (vn >>> 26) | 0,
                vn &= 67108863,
                It = Math.imul(Dt, Cr),
                St = Math.imul(Dt, xr),
                St = St + Math.imul(er, Cr) | 0,
                qt = Math.imul(er, xr),
                It = It + Math.imul(Ar, Ur) | 0,
                St = St + Math.imul(Ar, Ir) | 0,
                St = St + Math.imul(Ft, Ur) | 0,
                qt = qt + Math.imul(Ft, Ir) | 0,
                It = It + Math.imul(ar, Wr) | 0,
                St = St + Math.imul(ar, Yr) | 0,
                St = St + Math.imul(hr, Wr) | 0,
                qt = qt + Math.imul(hr, Yr) | 0,
                It = It + Math.imul(Qr, pn) | 0,
                St = St + Math.imul(Qr, tn) | 0,
                St = St + Math.imul(Gr, pn) | 0,
                qt = qt + Math.imul(Gr, tn) | 0,
                It = It + Math.imul(Zr, An) | 0,
                St = St + Math.imul(Zr, dn) | 0,
                St = St + Math.imul(Hr, An) | 0,
                qt = qt + Math.imul(Hr, dn) | 0,
                It = It + Math.imul(Dr, En) | 0,
                St = St + Math.imul(Dr, an) | 0,
                St = St + Math.imul(Or, En) | 0,
                qt = qt + Math.imul(Or, an) | 0,
                It = It + Math.imul(Rr, Jt) | 0,
                St = St + Math.imul(Rr, nr) | 0,
                St = St + Math.imul(qr, Jt) | 0,
                qt = qt + Math.imul(qr, nr) | 0,
                It = It + Math.imul(Yt, jt) | 0,
                St = St + Math.imul(Yt, cr) | 0,
                St = St + Math.imul(Xt, jt) | 0,
                qt = qt + Math.imul(Xt, cr) | 0,
                It = It + Math.imul(Vt, kr) | 0,
                St = St + Math.imul(Vt, Pr) | 0,
                St = St + Math.imul(rr, kr) | 0,
                qt = qt + Math.imul(rr, Pr) | 0,
                It = It + Math.imul(gr, Vr) | 0,
                St = St + Math.imul(gr, jr) | 0,
                St = St + Math.imul(lr, Vr) | 0,
                qt = qt + Math.imul(lr, jr) | 0;
                var sn = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (sn >>> 26) | 0,
                sn &= 67108863,
                It = Math.imul(Dt, Ur),
                St = Math.imul(Dt, Ir),
                St = St + Math.imul(er, Ur) | 0,
                qt = Math.imul(er, Ir),
                It = It + Math.imul(Ar, Wr) | 0,
                St = St + Math.imul(Ar, Yr) | 0,
                St = St + Math.imul(Ft, Wr) | 0,
                qt = qt + Math.imul(Ft, Yr) | 0,
                It = It + Math.imul(ar, pn) | 0,
                St = St + Math.imul(ar, tn) | 0,
                St = St + Math.imul(hr, pn) | 0,
                qt = qt + Math.imul(hr, tn) | 0,
                It = It + Math.imul(Qr, An) | 0,
                St = St + Math.imul(Qr, dn) | 0,
                St = St + Math.imul(Gr, An) | 0,
                qt = qt + Math.imul(Gr, dn) | 0,
                It = It + Math.imul(Zr, En) | 0,
                St = St + Math.imul(Zr, an) | 0,
                St = St + Math.imul(Hr, En) | 0,
                qt = qt + Math.imul(Hr, an) | 0,
                It = It + Math.imul(Dr, Jt) | 0,
                St = St + Math.imul(Dr, nr) | 0,
                St = St + Math.imul(Or, Jt) | 0,
                qt = qt + Math.imul(Or, nr) | 0,
                It = It + Math.imul(Rr, jt) | 0,
                St = St + Math.imul(Rr, cr) | 0,
                St = St + Math.imul(qr, jt) | 0,
                qt = qt + Math.imul(qr, cr) | 0,
                It = It + Math.imul(Yt, kr) | 0,
                St = St + Math.imul(Yt, Pr) | 0,
                St = St + Math.imul(Xt, kr) | 0,
                qt = qt + Math.imul(Xt, Pr) | 0,
                It = It + Math.imul(Vt, Vr) | 0,
                St = St + Math.imul(Vt, jr) | 0,
                St = St + Math.imul(rr, Vr) | 0,
                qt = qt + Math.imul(rr, jr) | 0;
                var hn = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (hn >>> 26) | 0,
                hn &= 67108863,
                It = Math.imul(Dt, Wr),
                St = Math.imul(Dt, Yr),
                St = St + Math.imul(er, Wr) | 0,
                qt = Math.imul(er, Yr),
                It = It + Math.imul(Ar, pn) | 0,
                St = St + Math.imul(Ar, tn) | 0,
                St = St + Math.imul(Ft, pn) | 0,
                qt = qt + Math.imul(Ft, tn) | 0,
                It = It + Math.imul(ar, An) | 0,
                St = St + Math.imul(ar, dn) | 0,
                St = St + Math.imul(hr, An) | 0,
                qt = qt + Math.imul(hr, dn) | 0,
                It = It + Math.imul(Qr, En) | 0,
                St = St + Math.imul(Qr, an) | 0,
                St = St + Math.imul(Gr, En) | 0,
                qt = qt + Math.imul(Gr, an) | 0,
                It = It + Math.imul(Zr, Jt) | 0,
                St = St + Math.imul(Zr, nr) | 0,
                St = St + Math.imul(Hr, Jt) | 0,
                qt = qt + Math.imul(Hr, nr) | 0,
                It = It + Math.imul(Dr, jt) | 0,
                St = St + Math.imul(Dr, cr) | 0,
                St = St + Math.imul(Or, jt) | 0,
                qt = qt + Math.imul(Or, cr) | 0,
                It = It + Math.imul(Rr, kr) | 0,
                St = St + Math.imul(Rr, Pr) | 0,
                St = St + Math.imul(qr, kr) | 0,
                qt = qt + Math.imul(qr, Pr) | 0,
                It = It + Math.imul(Yt, Vr) | 0,
                St = St + Math.imul(Yt, jr) | 0,
                St = St + Math.imul(Xt, Vr) | 0,
                qt = qt + Math.imul(Xt, jr) | 0;
                var rn = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (rn >>> 26) | 0,
                rn &= 67108863,
                It = Math.imul(Dt, pn),
                St = Math.imul(Dt, tn),
                St = St + Math.imul(er, pn) | 0,
                qt = Math.imul(er, tn),
                It = It + Math.imul(Ar, An) | 0,
                St = St + Math.imul(Ar, dn) | 0,
                St = St + Math.imul(Ft, An) | 0,
                qt = qt + Math.imul(Ft, dn) | 0,
                It = It + Math.imul(ar, En) | 0,
                St = St + Math.imul(ar, an) | 0,
                St = St + Math.imul(hr, En) | 0,
                qt = qt + Math.imul(hr, an) | 0,
                It = It + Math.imul(Qr, Jt) | 0,
                St = St + Math.imul(Qr, nr) | 0,
                St = St + Math.imul(Gr, Jt) | 0,
                qt = qt + Math.imul(Gr, nr) | 0,
                It = It + Math.imul(Zr, jt) | 0,
                St = St + Math.imul(Zr, cr) | 0,
                St = St + Math.imul(Hr, jt) | 0,
                qt = qt + Math.imul(Hr, cr) | 0,
                It = It + Math.imul(Dr, kr) | 0,
                St = St + Math.imul(Dr, Pr) | 0,
                St = St + Math.imul(Or, kr) | 0,
                qt = qt + Math.imul(Or, Pr) | 0,
                It = It + Math.imul(Rr, Vr) | 0,
                St = St + Math.imul(Rr, jr) | 0,
                St = St + Math.imul(qr, Vr) | 0,
                qt = qt + Math.imul(qr, jr) | 0;
                var ln = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (ln >>> 26) | 0,
                ln &= 67108863,
                It = Math.imul(Dt, An),
                St = Math.imul(Dt, dn),
                St = St + Math.imul(er, An) | 0,
                qt = Math.imul(er, dn),
                It = It + Math.imul(Ar, En) | 0,
                St = St + Math.imul(Ar, an) | 0,
                St = St + Math.imul(Ft, En) | 0,
                qt = qt + Math.imul(Ft, an) | 0,
                It = It + Math.imul(ar, Jt) | 0,
                St = St + Math.imul(ar, nr) | 0,
                St = St + Math.imul(hr, Jt) | 0,
                qt = qt + Math.imul(hr, nr) | 0,
                It = It + Math.imul(Qr, jt) | 0,
                St = St + Math.imul(Qr, cr) | 0,
                St = St + Math.imul(Gr, jt) | 0,
                qt = qt + Math.imul(Gr, cr) | 0,
                It = It + Math.imul(Zr, kr) | 0,
                St = St + Math.imul(Zr, Pr) | 0,
                St = St + Math.imul(Hr, kr) | 0,
                qt = qt + Math.imul(Hr, Pr) | 0,
                It = It + Math.imul(Dr, Vr) | 0,
                St = St + Math.imul(Dr, jr) | 0,
                St = St + Math.imul(Or, Vr) | 0,
                qt = qt + Math.imul(Or, jr) | 0;
                var yr = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (yr >>> 26) | 0,
                yr &= 67108863,
                It = Math.imul(Dt, En),
                St = Math.imul(Dt, an),
                St = St + Math.imul(er, En) | 0,
                qt = Math.imul(er, an),
                It = It + Math.imul(Ar, Jt) | 0,
                St = St + Math.imul(Ar, nr) | 0,
                St = St + Math.imul(Ft, Jt) | 0,
                qt = qt + Math.imul(Ft, nr) | 0,
                It = It + Math.imul(ar, jt) | 0,
                St = St + Math.imul(ar, cr) | 0,
                St = St + Math.imul(hr, jt) | 0,
                qt = qt + Math.imul(hr, cr) | 0,
                It = It + Math.imul(Qr, kr) | 0,
                St = St + Math.imul(Qr, Pr) | 0,
                St = St + Math.imul(Gr, kr) | 0,
                qt = qt + Math.imul(Gr, Pr) | 0,
                It = It + Math.imul(Zr, Vr) | 0,
                St = St + Math.imul(Zr, jr) | 0,
                St = St + Math.imul(Hr, Vr) | 0,
                qt = qt + Math.imul(Hr, jr) | 0;
                var Lt = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (Lt >>> 26) | 0,
                Lt &= 67108863,
                It = Math.imul(Dt, Jt),
                St = Math.imul(Dt, nr),
                St = St + Math.imul(er, Jt) | 0,
                qt = Math.imul(er, nr),
                It = It + Math.imul(Ar, jt) | 0,
                St = St + Math.imul(Ar, cr) | 0,
                St = St + Math.imul(Ft, jt) | 0,
                qt = qt + Math.imul(Ft, cr) | 0,
                It = It + Math.imul(ar, kr) | 0,
                St = St + Math.imul(ar, Pr) | 0,
                St = St + Math.imul(hr, kr) | 0,
                qt = qt + Math.imul(hr, Pr) | 0,
                It = It + Math.imul(Qr, Vr) | 0,
                St = St + Math.imul(Qr, jr) | 0,
                St = St + Math.imul(Gr, Vr) | 0,
                qt = qt + Math.imul(Gr, jr) | 0;
                var Gt = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (Gt >>> 26) | 0,
                Gt &= 67108863,
                It = Math.imul(Dt, jt),
                St = Math.imul(Dt, cr),
                St = St + Math.imul(er, jt) | 0,
                qt = Math.imul(er, cr),
                It = It + Math.imul(Ar, kr) | 0,
                St = St + Math.imul(Ar, Pr) | 0,
                St = St + Math.imul(Ft, kr) | 0,
                qt = qt + Math.imul(Ft, Pr) | 0,
                It = It + Math.imul(ar, Vr) | 0,
                St = St + Math.imul(ar, jr) | 0,
                St = St + Math.imul(hr, Vr) | 0,
                qt = qt + Math.imul(hr, jr) | 0;
                var Qt = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (Qt >>> 26) | 0,
                Qt &= 67108863,
                It = Math.imul(Dt, kr),
                St = Math.imul(Dt, Pr),
                St = St + Math.imul(er, kr) | 0,
                qt = Math.imul(er, Pr),
                It = It + Math.imul(Ar, Vr) | 0,
                St = St + Math.imul(Ar, jr) | 0,
                St = St + Math.imul(Ft, Vr) | 0,
                qt = qt + Math.imul(Ft, jr) | 0;
                var pr = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (pr >>> 26) | 0,
                pr &= 67108863,
                It = Math.imul(Dt, Vr),
                St = Math.imul(Dt, jr),
                St = St + Math.imul(er, Vr) | 0,
                qt = Math.imul(er, jr);
                var dr = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                return Tt = (qt + (St >>> 13) | 0) + (dr >>> 26) | 0,
                dr &= 67108863,
                kt[0] = Mn,
                kt[1] = nn,
                kt[2] = gn,
                kt[3] = mn,
                kt[4] = xn,
                kt[5] = _n,
                kt[6] = yn,
                kt[7] = wn,
                kt[8] = vn,
                kt[9] = sn,
                kt[10] = hn,
                kt[11] = rn,
                kt[12] = ln,
                kt[13] = yr,
                kt[14] = Lt,
                kt[15] = Gt,
                kt[16] = Qt,
                kt[17] = pr,
                kt[18] = dr,
                Tt !== 0 && (kt[19] = Tt,
                Et.length++),
                Et
            };
            Math.imul || (Ot = $t);
            function Nt(_t, gt, vt) {
                vt.negative = gt.negative ^ _t.negative,
                vt.length = _t.length + gt.length;
                for (var Et = 0, Bt = 0, Rt = 0; Rt < vt.length - 1; Rt++) {
                    var kt = Bt;
                    Bt = 0;
                    for (var Tt = Et & 67108863, It = Math.min(Rt, gt.length - 1), St = Math.max(0, Rt - _t.length + 1); St <= It; St++) {
                        var qt = Rt - St
                          , ur = _t.words[qt] | 0
                          , gr = gt.words[St] | 0
                          , lr = ur * gr
                          , Zt = lr & 67108863;
                        kt = kt + (lr / 67108864 | 0) | 0,
                        Zt = Zt + Tt | 0,
                        Tt = Zt & 67108863,
                        kt = kt + (Zt >>> 26) | 0,
                        Bt += kt >>> 26,
                        kt &= 67108863
                    }
                    vt.words[Rt] = Tt,
                    Et = kt,
                    kt = Bt
                }
                return Et !== 0 ? vt.words[Rt] = Et : vt.length--,
                vt._strip()
            }
            function zt(_t, gt, vt) {
                return Nt(_t, gt, vt)
            }
            y.prototype.mulTo = function(gt, vt) {
                var Et, Bt = this.length + gt.length;
                return this.length === 10 && gt.length === 10 ? Et = Ot(this, gt, vt) : Bt < 63 ? Et = $t(this, gt, vt) : Bt < 1024 ? Et = Nt(this, gt, vt) : Et = zt(this, gt, vt),
                Et
            }
            ,
            y.prototype.mul = function(gt) {
                var vt = new y(null);
                return vt.words = new Array(this.length + gt.length),
                this.mulTo(gt, vt)
            }
            ,
            y.prototype.mulf = function(gt) {
                var vt = new y(null);
                return vt.words = new Array(this.length + gt.length),
                zt(this, gt, vt)
            }
            ,
            y.prototype.imul = function(gt) {
                return this.clone().mulTo(gt, this)
            }
            ,
            y.prototype.imuln = function(gt) {
                var vt = gt < 0;
                vt && (gt = -gt),
                m(typeof gt == "number"),
                m(gt < 67108864);
                for (var Et = 0, Bt = 0; Bt < this.length; Bt++) {
                    var Rt = (this.words[Bt] | 0) * gt
                      , kt = (Rt & 67108863) + (Et & 67108863);
                    Et >>= 26,
                    Et += Rt / 67108864 | 0,
                    Et += kt >>> 26,
                    this.words[Bt] = kt & 67108863
                }
                return Et !== 0 && (this.words[Bt] = Et,
                this.length++),
                vt ? this.ineg() : this
            }
            ,
            y.prototype.muln = function(gt) {
                return this.clone().imuln(gt)
            }
            ,
            y.prototype.sqr = function() {
                return this.mul(this)
            }
            ,
            y.prototype.isqr = function() {
                return this.imul(this.clone())
            }
            ,
            y.prototype.pow = function(gt) {
                var vt = Pt(gt);
                if (vt.length === 0)
                    return new y(1);
                for (var Et = this, Bt = 0; Bt < vt.length && vt[Bt] === 0; Bt++,
                Et = Et.sqr())
                    ;
                if (++Bt < vt.length)
                    for (var Rt = Et.sqr(); Bt < vt.length; Bt++,
                    Rt = Rt.sqr())
                        vt[Bt] !== 0 && (Et = Et.mul(Rt));
                return Et
            }
            ,
            y.prototype.iushln = function(gt) {
                m(typeof gt == "number" && gt >= 0);
                var vt = gt % 26, Et = (gt - vt) / 26, Bt = 67108863 >>> 26 - vt << 26 - vt, Rt;
                if (vt !== 0) {
                    var kt = 0;
                    for (Rt = 0; Rt < this.length; Rt++) {
                        var Tt = this.words[Rt] & Bt
                          , It = (this.words[Rt] | 0) - Tt << vt;
                        this.words[Rt] = It | kt,
                        kt = Tt >>> 26 - vt
                    }
                    kt && (this.words[Rt] = kt,
                    this.length++)
                }
                if (Et !== 0) {
                    for (Rt = this.length - 1; Rt >= 0; Rt--)
                        this.words[Rt + Et] = this.words[Rt];
                    for (Rt = 0; Rt < Et; Rt++)
                        this.words[Rt] = 0;
                    this.length += Et
                }
                return this._strip()
            }
            ,
            y.prototype.ishln = function(gt) {
                return m(this.negative === 0),
                this.iushln(gt)
            }
            ,
            y.prototype.iushrn = function(gt, vt, Et) {
                m(typeof gt == "number" && gt >= 0);
                var Bt;
                vt ? Bt = (vt - vt % 26) / 26 : Bt = 0;
                var Rt = gt % 26
                  , kt = Math.min((gt - Rt) / 26, this.length)
                  , Tt = 67108863 ^ 67108863 >>> Rt << Rt
                  , It = Et;
                if (Bt -= kt,
                Bt = Math.max(0, Bt),
                It) {
                    for (var St = 0; St < kt; St++)
                        It.words[St] = this.words[St];
                    It.length = kt
                }
                if (kt !== 0)
                    if (this.length > kt)
                        for (this.length -= kt,
                        St = 0; St < this.length; St++)
                            this.words[St] = this.words[St + kt];
                    else
                        this.words[0] = 0,
                        this.length = 1;
                var qt = 0;
                for (St = this.length - 1; St >= 0 && (qt !== 0 || St >= Bt); St--) {
                    var ur = this.words[St] | 0;
                    this.words[St] = qt << 26 - Rt | ur >>> Rt,
                    qt = ur & Tt
                }
                return It && qt !== 0 && (It.words[It.length++] = qt),
                this.length === 0 && (this.words[0] = 0,
                this.length = 1),
                this._strip()
            }
            ,
            y.prototype.ishrn = function(gt, vt, Et) {
                return m(this.negative === 0),
                this.iushrn(gt, vt, Et)
            }
            ,
            y.prototype.shln = function(gt) {
                return this.clone().ishln(gt)
            }
            ,
            y.prototype.ushln = function(gt) {
                return this.clone().iushln(gt)
            }
            ,
            y.prototype.shrn = function(gt) {
                return this.clone().ishrn(gt)
            }
            ,
            y.prototype.ushrn = function(gt) {
                return this.clone().iushrn(gt)
            }
            ,
            y.prototype.testn = function(gt) {
                m(typeof gt == "number" && gt >= 0);
                var vt = gt % 26
                  , Et = (gt - vt) / 26
                  , Bt = 1 << vt;
                if (this.length <= Et)
                    return !1;
                var Rt = this.words[Et];
                return !!(Rt & Bt)
            }
            ,
            y.prototype.imaskn = function(gt) {
                m(typeof gt == "number" && gt >= 0);
                var vt = gt % 26
                  , Et = (gt - vt) / 26;
                if (m(this.negative === 0, "imaskn works only with positive numbers"),
                this.length <= Et)
                    return this;
                if (vt !== 0 && Et++,
                this.length = Math.min(Et, this.length),
                vt !== 0) {
                    var Bt = 67108863 ^ 67108863 >>> vt << vt;
                    this.words[this.length - 1] &= Bt
                }
                return this._strip()
            }
            ,
            y.prototype.maskn = function(gt) {
                return this.clone().imaskn(gt)
            }
            ,
            y.prototype.iaddn = function(gt) {
                return m(typeof gt == "number"),
                m(gt < 67108864),
                gt < 0 ? this.isubn(-gt) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= gt ? (this.words[0] = gt - (this.words[0] | 0),
                this.negative = 0,
                this) : (this.negative = 0,
                this.isubn(gt),
                this.negative = 1,
                this) : this._iaddn(gt)
            }
            ,
            y.prototype._iaddn = function(gt) {
                this.words[0] += gt;
                for (var vt = 0; vt < this.length && this.words[vt] >= 67108864; vt++)
                    this.words[vt] -= 67108864,
                    vt === this.length - 1 ? this.words[vt + 1] = 1 : this.words[vt + 1]++;
                return this.length = Math.max(this.length, vt + 1),
                this
            }
            ,
            y.prototype.isubn = function(gt) {
                if (m(typeof gt == "number"),
                m(gt < 67108864),
                gt < 0)
                    return this.iaddn(-gt);
                if (this.negative !== 0)
                    return this.negative = 0,
                    this.iaddn(gt),
                    this.negative = 1,
                    this;
                if (this.words[0] -= gt,
                this.length === 1 && this.words[0] < 0)
                    this.words[0] = -this.words[0],
                    this.negative = 1;
                else
                    for (var vt = 0; vt < this.length && this.words[vt] < 0; vt++)
                        this.words[vt] += 67108864,
                        this.words[vt + 1] -= 1;
                return this._strip()
            }
            ,
            y.prototype.addn = function(gt) {
                return this.clone().iaddn(gt)
            }
            ,
            y.prototype.subn = function(gt) {
                return this.clone().isubn(gt)
            }
            ,
            y.prototype.iabs = function() {
                return this.negative = 0,
                this
            }
            ,
            y.prototype.abs = function() {
                return this.clone().iabs()
            }
            ,
            y.prototype._ishlnsubmul = function(gt, vt, Et) {
                var Bt = gt.length + Et, Rt;
                this._expand(Bt);
                var kt, Tt = 0;
                for (Rt = 0; Rt < gt.length; Rt++) {
                    kt = (this.words[Rt + Et] | 0) + Tt;
                    var It = (gt.words[Rt] | 0) * vt;
                    kt -= It & 67108863,
                    Tt = (kt >> 26) - (It / 67108864 | 0),
                    this.words[Rt + Et] = kt & 67108863
                }
                for (; Rt < this.length - Et; Rt++)
                    kt = (this.words[Rt + Et] | 0) + Tt,
                    Tt = kt >> 26,
                    this.words[Rt + Et] = kt & 67108863;
                if (Tt === 0)
                    return this._strip();
                for (m(Tt === -1),
                Tt = 0,
                Rt = 0; Rt < this.length; Rt++)
                    kt = -(this.words[Rt] | 0) + Tt,
                    Tt = kt >> 26,
                    this.words[Rt] = kt & 67108863;
                return this.negative = 1,
                this._strip()
            }
            ,
            y.prototype._wordDiv = function(gt, vt) {
                var Et = this.length - gt.length
                  , Bt = this.clone()
                  , Rt = gt
                  , kt = Rt.words[Rt.length - 1] | 0
                  , Tt = this._countBits(kt);
                Et = 26 - Tt,
                Et !== 0 && (Rt = Rt.ushln(Et),
                Bt.iushln(Et),
                kt = Rt.words[Rt.length - 1] | 0);
                var It = Bt.length - Rt.length, St;
                if (vt !== "mod") {
                    St = new y(null),
                    St.length = It + 1,
                    St.words = new Array(St.length);
                    for (var qt = 0; qt < St.length; qt++)
                        St.words[qt] = 0
                }
                var ur = Bt.clone()._ishlnsubmul(Rt, 1, It);
                ur.negative === 0 && (Bt = ur,
                St && (St.words[It] = 1));
                for (var gr = It - 1; gr >= 0; gr--) {
                    var lr = (Bt.words[Rt.length + gr] | 0) * 67108864 + (Bt.words[Rt.length + gr - 1] | 0);
                    for (lr = Math.min(lr / kt | 0, 67108863),
                    Bt._ishlnsubmul(Rt, lr, gr); Bt.negative !== 0; )
                        lr--,
                        Bt.negative = 0,
                        Bt._ishlnsubmul(Rt, 1, gr),
                        Bt.isZero() || (Bt.negative ^= 1);
                    St && (St.words[gr] = lr)
                }
                return St && St._strip(),
                Bt._strip(),
                vt !== "div" && Et !== 0 && Bt.iushrn(Et),
                {
                    div: St || null,
                    mod: Bt
                }
            }
            ,
            y.prototype.divmod = function(gt, vt, Et) {
                if (m(!gt.isZero()),
                this.isZero())
                    return {
                        div: new y(0),
                        mod: new y(0)
                    };
                var Bt, Rt, kt;
                return this.negative !== 0 && gt.negative === 0 ? (kt = this.neg().divmod(gt, vt),
                vt !== "mod" && (Bt = kt.div.neg()),
                vt !== "div" && (Rt = kt.mod.neg(),
                Et && Rt.negative !== 0 && Rt.iadd(gt)),
                {
                    div: Bt,
                    mod: Rt
                }) : this.negative === 0 && gt.negative !== 0 ? (kt = this.divmod(gt.neg(), vt),
                vt !== "mod" && (Bt = kt.div.neg()),
                {
                    div: Bt,
                    mod: kt.mod
                }) : this.negative & gt.negative ? (kt = this.neg().divmod(gt.neg(), vt),
                vt !== "div" && (Rt = kt.mod.neg(),
                Et && Rt.negative !== 0 && Rt.isub(gt)),
                {
                    div: kt.div,
                    mod: Rt
                }) : gt.length > this.length || this.cmp(gt) < 0 ? {
                    div: new y(0),
                    mod: this
                } : gt.length === 1 ? vt === "div" ? {
                    div: this.divn(gt.words[0]),
                    mod: null
                } : vt === "mod" ? {
                    div: null,
                    mod: new y(this.modrn(gt.words[0]))
                } : {
                    div: this.divn(gt.words[0]),
                    mod: new y(this.modrn(gt.words[0]))
                } : this._wordDiv(gt, vt)
            }
            ,
            y.prototype.div = function(gt) {
                return this.divmod(gt, "div", !1).div
            }
            ,
            y.prototype.mod = function(gt) {
                return this.divmod(gt, "mod", !1).mod
            }
            ,
            y.prototype.umod = function(gt) {
                return this.divmod(gt, "mod", !0).mod
            }
            ,
            y.prototype.divRound = function(gt) {
                var vt = this.divmod(gt);
                if (vt.mod.isZero())
                    return vt.div;
                var Et = vt.div.negative !== 0 ? vt.mod.isub(gt) : vt.mod
                  , Bt = gt.ushrn(1)
                  , Rt = gt.andln(1)
                  , kt = Et.cmp(Bt);
                return kt < 0 || Rt === 1 && kt === 0 ? vt.div : vt.div.negative !== 0 ? vt.div.isubn(1) : vt.div.iaddn(1)
            }
            ,
            y.prototype.modrn = function(gt) {
                var vt = gt < 0;
                vt && (gt = -gt),
                m(gt <= 67108863);
                for (var Et = (1 << 26) % gt, Bt = 0, Rt = this.length - 1; Rt >= 0; Rt--)
                    Bt = (Et * Bt + (this.words[Rt] | 0)) % gt;
                return vt ? -Bt : Bt
            }
            ,
            y.prototype.modn = function(gt) {
                return this.modrn(gt)
            }
            ,
            y.prototype.idivn = function(gt) {
                var vt = gt < 0;
                vt && (gt = -gt),
                m(gt <= 67108863);
                for (var Et = 0, Bt = this.length - 1; Bt >= 0; Bt--) {
                    var Rt = (this.words[Bt] | 0) + Et * 67108864;
                    this.words[Bt] = Rt / gt | 0,
                    Et = Rt % gt
                }
                return this._strip(),
                vt ? this.ineg() : this
            }
            ,
            y.prototype.divn = function(gt) {
                return this.clone().idivn(gt)
            }
            ,
            y.prototype.egcd = function(gt) {
                m(gt.negative === 0),
                m(!gt.isZero());
                var vt = this
                  , Et = gt.clone();
                vt.negative !== 0 ? vt = vt.umod(gt) : vt = vt.clone();
                for (var Bt = new y(1), Rt = new y(0), kt = new y(0), Tt = new y(1), It = 0; vt.isEven() && Et.isEven(); )
                    vt.iushrn(1),
                    Et.iushrn(1),
                    ++It;
                for (var St = Et.clone(), qt = vt.clone(); !vt.isZero(); ) {
                    for (var ur = 0, gr = 1; !(vt.words[0] & gr) && ur < 26; ++ur,
                    gr <<= 1)
                        ;
                    if (ur > 0)
                        for (vt.iushrn(ur); ur-- > 0; )
                            (Bt.isOdd() || Rt.isOdd()) && (Bt.iadd(St),
                            Rt.isub(qt)),
                            Bt.iushrn(1),
                            Rt.iushrn(1);
                    for (var lr = 0, Zt = 1; !(Et.words[0] & Zt) && lr < 26; ++lr,
                    Zt <<= 1)
                        ;
                    if (lr > 0)
                        for (Et.iushrn(lr); lr-- > 0; )
                            (kt.isOdd() || Tt.isOdd()) && (kt.iadd(St),
                            Tt.isub(qt)),
                            kt.iushrn(1),
                            Tt.iushrn(1);
                    vt.cmp(Et) >= 0 ? (vt.isub(Et),
                    Bt.isub(kt),
                    Rt.isub(Tt)) : (Et.isub(vt),
                    kt.isub(Bt),
                    Tt.isub(Rt))
                }
                return {
                    a: kt,
                    b: Tt,
                    gcd: Et.iushln(It)
                }
            }
            ,
            y.prototype._invmp = function(gt) {
                m(gt.negative === 0),
                m(!gt.isZero());
                var vt = this
                  , Et = gt.clone();
                vt.negative !== 0 ? vt = vt.umod(gt) : vt = vt.clone();
                for (var Bt = new y(1), Rt = new y(0), kt = Et.clone(); vt.cmpn(1) > 0 && Et.cmpn(1) > 0; ) {
                    for (var Tt = 0, It = 1; !(vt.words[0] & It) && Tt < 26; ++Tt,
                    It <<= 1)
                        ;
                    if (Tt > 0)
                        for (vt.iushrn(Tt); Tt-- > 0; )
                            Bt.isOdd() && Bt.iadd(kt),
                            Bt.iushrn(1);
                    for (var St = 0, qt = 1; !(Et.words[0] & qt) && St < 26; ++St,
                    qt <<= 1)
                        ;
                    if (St > 0)
                        for (Et.iushrn(St); St-- > 0; )
                            Rt.isOdd() && Rt.iadd(kt),
                            Rt.iushrn(1);
                    vt.cmp(Et) >= 0 ? (vt.isub(Et),
                    Bt.isub(Rt)) : (Et.isub(vt),
                    Rt.isub(Bt))
                }
                var ur;
                return vt.cmpn(1) === 0 ? ur = Bt : ur = Rt,
                ur.cmpn(0) < 0 && ur.iadd(gt),
                ur
            }
            ,
            y.prototype.gcd = function(gt) {
                if (this.isZero())
                    return gt.abs();
                if (gt.isZero())
                    return this.abs();
                var vt = this.clone()
                  , Et = gt.clone();
                vt.negative = 0,
                Et.negative = 0;
                for (var Bt = 0; vt.isEven() && Et.isEven(); Bt++)
                    vt.iushrn(1),
                    Et.iushrn(1);
                do {
                    for (; vt.isEven(); )
                        vt.iushrn(1);
                    for (; Et.isEven(); )
                        Et.iushrn(1);
                    var Rt = vt.cmp(Et);
                    if (Rt < 0) {
                        var kt = vt;
                        vt = Et,
                        Et = kt
                    } else if (Rt === 0 || Et.cmpn(1) === 0)
                        break;
                    vt.isub(Et)
                } while (!0);
                return Et.iushln(Bt)
            }
            ,
            y.prototype.invm = function(gt) {
                return this.egcd(gt).a.umod(gt)
            }
            ,
            y.prototype.isEven = function() {
                return (this.words[0] & 1) === 0
            }
            ,
            y.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1
            }
            ,
            y.prototype.andln = function(gt) {
                return this.words[0] & gt
            }
            ,
            y.prototype.bincn = function(gt) {
                m(typeof gt == "number");
                var vt = gt % 26
                  , Et = (gt - vt) / 26
                  , Bt = 1 << vt;
                if (this.length <= Et)
                    return this._expand(Et + 1),
                    this.words[Et] |= Bt,
                    this;
                for (var Rt = Bt, kt = Et; Rt !== 0 && kt < this.length; kt++) {
                    var Tt = this.words[kt] | 0;
                    Tt += Rt,
                    Rt = Tt >>> 26,
                    Tt &= 67108863,
                    this.words[kt] = Tt
                }
                return Rt !== 0 && (this.words[kt] = Rt,
                this.length++),
                this
            }
            ,
            y.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0
            }
            ,
            y.prototype.cmpn = function(gt) {
                var vt = gt < 0;
                if (this.negative !== 0 && !vt)
                    return -1;
                if (this.negative === 0 && vt)
                    return 1;
                this._strip();
                var Et;
                if (this.length > 1)
                    Et = 1;
                else {
                    vt && (gt = -gt),
                    m(gt <= 67108863, "Number is too big");
                    var Bt = this.words[0] | 0;
                    Et = Bt === gt ? 0 : Bt < gt ? -1 : 1
                }
                return this.negative !== 0 ? -Et | 0 : Et
            }
            ,
            y.prototype.cmp = function(gt) {
                if (this.negative !== 0 && gt.negative === 0)
                    return -1;
                if (this.negative === 0 && gt.negative !== 0)
                    return 1;
                var vt = this.ucmp(gt);
                return this.negative !== 0 ? -vt | 0 : vt
            }
            ,
            y.prototype.ucmp = function(gt) {
                if (this.length > gt.length)
                    return 1;
                if (this.length < gt.length)
                    return -1;
                for (var vt = 0, Et = this.length - 1; Et >= 0; Et--) {
                    var Bt = this.words[Et] | 0
                      , Rt = gt.words[Et] | 0;
                    if (Bt !== Rt) {
                        Bt < Rt ? vt = -1 : Bt > Rt && (vt = 1);
                        break
                    }
                }
                return vt
            }
            ,
            y.prototype.gtn = function(gt) {
                return this.cmpn(gt) === 1
            }
            ,
            y.prototype.gt = function(gt) {
                return this.cmp(gt) === 1
            }
            ,
            y.prototype.gten = function(gt) {
                return this.cmpn(gt) >= 0
            }
            ,
            y.prototype.gte = function(gt) {
                return this.cmp(gt) >= 0
            }
            ,
            y.prototype.ltn = function(gt) {
                return this.cmpn(gt) === -1
            }
            ,
            y.prototype.lt = function(gt) {
                return this.cmp(gt) === -1
            }
            ,
            y.prototype.lten = function(gt) {
                return this.cmpn(gt) <= 0
            }
            ,
            y.prototype.lte = function(gt) {
                return this.cmp(gt) <= 0
            }
            ,
            y.prototype.eqn = function(gt) {
                return this.cmpn(gt) === 0
            }
            ,
            y.prototype.eq = function(gt) {
                return this.cmp(gt) === 0
            }
            ,
            y.red = function(gt) {
                return new Ht(gt)
            }
            ,
            y.prototype.toRed = function(gt) {
                return m(!this.red, "Already a number in reduction context"),
                m(this.negative === 0, "red works only with positives"),
                gt.convertTo(this)._forceRed(gt)
            }
            ,
            y.prototype.fromRed = function() {
                return m(this.red, "fromRed works only with numbers in reduction context"),
                this.red.convertFrom(this)
            }
            ,
            y.prototype._forceRed = function(gt) {
                return this.red = gt,
                this
            }
            ,
            y.prototype.forceRed = function(gt) {
                return m(!this.red, "Already a number in reduction context"),
                this._forceRed(gt)
            }
            ,
            y.prototype.redAdd = function(gt) {
                return m(this.red, "redAdd works only with red numbers"),
                this.red.add(this, gt)
            }
            ,
            y.prototype.redIAdd = function(gt) {
                return m(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, gt)
            }
            ,
            y.prototype.redSub = function(gt) {
                return m(this.red, "redSub works only with red numbers"),
                this.red.sub(this, gt)
            }
            ,
            y.prototype.redISub = function(gt) {
                return m(this.red, "redISub works only with red numbers"),
                this.red.isub(this, gt)
            }
            ,
            y.prototype.redShl = function(gt) {
                return m(this.red, "redShl works only with red numbers"),
                this.red.shl(this, gt)
            }
            ,
            y.prototype.redMul = function(gt) {
                return m(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, gt),
                this.red.mul(this, gt)
            }
            ,
            y.prototype.redIMul = function(gt) {
                return m(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, gt),
                this.red.imul(this, gt)
            }
            ,
            y.prototype.redSqr = function() {
                return m(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
            }
            ,
            y.prototype.redISqr = function() {
                return m(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
            }
            ,
            y.prototype.redSqrt = function() {
                return m(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
            }
            ,
            y.prototype.redInvm = function() {
                return m(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
            }
            ,
            y.prototype.redNeg = function() {
                return m(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
            }
            ,
            y.prototype.redPow = function(gt) {
                return m(this.red && !gt.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, gt)
            }
            ;
            var Wt = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function Kt(_t, gt) {
                this.name = _t,
                this.p = new y(gt,16),
                this.n = this.p.bitLength(),
                this.k = new y(1).iushln(this.n).isub(this.p),
                this.tmp = this._tmp()
            }
            Kt.prototype._tmp = function() {
                var gt = new y(null);
                return gt.words = new Array(Math.ceil(this.n / 13)),
                gt
            }
            ,
            Kt.prototype.ireduce = function(gt) {
                var vt = gt, Et;
                do
                    this.split(vt, this.tmp),
                    vt = this.imulK(vt),
                    vt = vt.iadd(this.tmp),
                    Et = vt.bitLength();
                while (Et > this.n);
                var Bt = Et < this.n ? -1 : vt.ucmp(this.p);
                return Bt === 0 ? (vt.words[0] = 0,
                vt.length = 1) : Bt > 0 ? vt.isub(this.p) : vt.strip !== void 0 ? vt.strip() : vt._strip(),
                vt
            }
            ,
            Kt.prototype.split = function(gt, vt) {
                gt.iushrn(this.n, 0, vt)
            }
            ,
            Kt.prototype.imulK = function(gt) {
                return gt.imul(this.k)
            }
            ;
            function ir() {
                Kt.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
            }
            k(ir, Kt),
            ir.prototype.split = function(gt, vt) {
                for (var Et = 4194303, Bt = Math.min(gt.length, 9), Rt = 0; Rt < Bt; Rt++)
                    vt.words[Rt] = gt.words[Rt];
                if (vt.length = Bt,
                gt.length <= 9) {
                    gt.words[0] = 0,
                    gt.length = 1;
                    return
                }
                var kt = gt.words[9];
                for (vt.words[vt.length++] = kt & Et,
                Rt = 10; Rt < gt.length; Rt++) {
                    var Tt = gt.words[Rt] | 0;
                    gt.words[Rt - 10] = (Tt & Et) << 4 | kt >>> 22,
                    kt = Tt
                }
                kt >>>= 22,
                gt.words[Rt - 10] = kt,
                kt === 0 && gt.length > 10 ? gt.length -= 10 : gt.length -= 9
            }
            ,
            ir.prototype.imulK = function(gt) {
                gt.words[gt.length] = 0,
                gt.words[gt.length + 1] = 0,
                gt.length += 2;
                for (var vt = 0, Et = 0; Et < gt.length; Et++) {
                    var Bt = gt.words[Et] | 0;
                    vt += Bt * 977,
                    gt.words[Et] = vt & 67108863,
                    vt = Bt * 64 + (vt / 67108864 | 0)
                }
                return gt.words[gt.length - 1] === 0 && (gt.length--,
                gt.words[gt.length - 1] === 0 && gt.length--),
                gt
            }
            ;
            function or() {
                Kt.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
            }
            k(or, Kt);
            function tr() {
                Kt.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
            }
            k(tr, Kt);
            function wr() {
                Kt.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
            }
            k(wr, Kt),
            wr.prototype.imulK = function(gt) {
                for (var vt = 0, Et = 0; Et < gt.length; Et++) {
                    var Bt = (gt.words[Et] | 0) * 19 + vt
                      , Rt = Bt & 67108863;
                    Bt >>>= 26,
                    gt.words[Et] = Rt,
                    vt = Bt
                }
                return vt !== 0 && (gt.words[gt.length++] = vt),
                gt
            }
            ,
            y._prime = function(gt) {
                if (Wt[gt])
                    return Wt[gt];
                var vt;
                if (gt === "k256")
                    vt = new ir;
                else if (gt === "p224")
                    vt = new or;
                else if (gt === "p192")
                    vt = new tr;
                else if (gt === "p25519")
                    vt = new wr;
                else
                    throw new Error("Unknown prime " + gt);
                return Wt[gt] = vt,
                vt
            }
            ;
            function Ht(_t) {
                if (typeof _t == "string") {
                    var gt = y._prime(_t);
                    this.m = gt.p,
                    this.prime = gt
                } else
                    m(_t.gtn(1), "modulus must be greater than 1"),
                    this.m = _t,
                    this.prime = null
            }
            Ht.prototype._verify1 = function(gt) {
                m(gt.negative === 0, "red works only with positives"),
                m(gt.red, "red works only with red numbers")
            }
            ,
            Ht.prototype._verify2 = function(gt, vt) {
                m((gt.negative | vt.negative) === 0, "red works only with positives"),
                m(gt.red && gt.red === vt.red, "red works only with red numbers")
            }
            ,
            Ht.prototype.imod = function(gt) {
                return this.prime ? this.prime.ireduce(gt)._forceRed(this) : (pt(gt, gt.umod(this.m)._forceRed(this)),
                gt)
            }
            ,
            Ht.prototype.neg = function(gt) {
                return gt.isZero() ? gt.clone() : this.m.sub(gt)._forceRed(this)
            }
            ,
            Ht.prototype.add = function(gt, vt) {
                this._verify2(gt, vt);
                var Et = gt.add(vt);
                return Et.cmp(this.m) >= 0 && Et.isub(this.m),
                Et._forceRed(this)
            }
            ,
            Ht.prototype.iadd = function(gt, vt) {
                this._verify2(gt, vt);
                var Et = gt.iadd(vt);
                return Et.cmp(this.m) >= 0 && Et.isub(this.m),
                Et
            }
            ,
            Ht.prototype.sub = function(gt, vt) {
                this._verify2(gt, vt);
                var Et = gt.sub(vt);
                return Et.cmpn(0) < 0 && Et.iadd(this.m),
                Et._forceRed(this)
            }
            ,
            Ht.prototype.isub = function(gt, vt) {
                this._verify2(gt, vt);
                var Et = gt.isub(vt);
                return Et.cmpn(0) < 0 && Et.iadd(this.m),
                Et
            }
            ,
            Ht.prototype.shl = function(gt, vt) {
                return this._verify1(gt),
                this.imod(gt.ushln(vt))
            }
            ,
            Ht.prototype.imul = function(gt, vt) {
                return this._verify2(gt, vt),
                this.imod(gt.imul(vt))
            }
            ,
            Ht.prototype.mul = function(gt, vt) {
                return this._verify2(gt, vt),
                this.imod(gt.mul(vt))
            }
            ,
            Ht.prototype.isqr = function(gt) {
                return this.imul(gt, gt.clone())
            }
            ,
            Ht.prototype.sqr = function(gt) {
                return this.mul(gt, gt)
            }
            ,
            Ht.prototype.sqrt = function(gt) {
                if (gt.isZero())
                    return gt.clone();
                var vt = this.m.andln(3);
                if (m(vt % 2 === 1),
                vt === 3) {
                    var Et = this.m.add(new y(1)).iushrn(2);
                    return this.pow(gt, Et)
                }
                for (var Bt = this.m.subn(1), Rt = 0; !Bt.isZero() && Bt.andln(1) === 0; )
                    Rt++,
                    Bt.iushrn(1);
                m(!Bt.isZero());
                var kt = new y(1).toRed(this)
                  , Tt = kt.redNeg()
                  , It = this.m.subn(1).iushrn(1)
                  , St = this.m.bitLength();
                for (St = new y(2 * St * St).toRed(this); this.pow(St, It).cmp(Tt) !== 0; )
                    St.redIAdd(Tt);
                for (var qt = this.pow(St, Bt), ur = this.pow(gt, Bt.addn(1).iushrn(1)), gr = this.pow(gt, Bt), lr = Rt; gr.cmp(kt) !== 0; ) {
                    for (var Zt = gr, Vt = 0; Zt.cmp(kt) !== 0; Vt++)
                        Zt = Zt.redSqr();
                    m(Vt < lr);
                    var rr = this.pow(qt, new y(1).iushln(lr - Vt - 1));
                    ur = ur.redMul(rr),
                    qt = rr.redSqr(),
                    gr = gr.redMul(qt),
                    lr = Vt
                }
                return ur
            }
            ,
            Ht.prototype.invm = function(gt) {
                var vt = gt._invmp(this.m);
                return vt.negative !== 0 ? (vt.negative = 0,
                this.imod(vt).redNeg()) : this.imod(vt)
            }
            ,
            Ht.prototype.pow = function(gt, vt) {
                if (vt.isZero())
                    return new y(1).toRed(this);
                if (vt.cmpn(1) === 0)
                    return gt.clone();
                var Et = 4
                  , Bt = new Array(1 << Et);
                Bt[0] = new y(1).toRed(this),
                Bt[1] = gt;
                for (var Rt = 2; Rt < Bt.length; Rt++)
                    Bt[Rt] = this.mul(Bt[Rt - 1], gt);
                var kt = Bt[0]
                  , Tt = 0
                  , It = 0
                  , St = vt.bitLength() % 26;
                for (St === 0 && (St = 26),
                Rt = vt.length - 1; Rt >= 0; Rt--) {
                    for (var qt = vt.words[Rt], ur = St - 1; ur >= 0; ur--) {
                        var gr = qt >> ur & 1;
                        if (kt !== Bt[0] && (kt = this.sqr(kt)),
                        gr === 0 && Tt === 0) {
                            It = 0;
                            continue
                        }
                        Tt <<= 1,
                        Tt |= gr,
                        It++,
                        !(It !== Et && (Rt !== 0 || ur !== 0)) && (kt = this.mul(kt, Bt[Tt]),
                        It = 0,
                        Tt = 0)
                    }
                    St = 26
                }
                return kt
            }
            ,
            Ht.prototype.convertTo = function(gt) {
                var vt = gt.umod(this.m);
                return vt === gt ? vt.clone() : vt
            }
            ,
            Ht.prototype.convertFrom = function(gt) {
                var vt = gt.clone();
                return vt.red = null,
                vt
            }
            ,
            y.mont = function(gt) {
                return new Mt(gt)
            }
            ;
            function Mt(_t) {
                Ht.call(this, _t),
                this.shift = this.m.bitLength(),
                this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26),
                this.r = new y(1).iushln(this.shift),
                this.r2 = this.imod(this.r.sqr()),
                this.rinv = this.r._invmp(this.m),
                this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
                this.minv = this.minv.umod(this.r),
                this.minv = this.r.sub(this.minv)
            }
            k(Mt, Ht),
            Mt.prototype.convertTo = function(gt) {
                return this.imod(gt.ushln(this.shift))
            }
            ,
            Mt.prototype.convertFrom = function(gt) {
                var vt = this.imod(gt.mul(this.rinv));
                return vt.red = null,
                vt
            }
            ,
            Mt.prototype.imul = function(gt, vt) {
                if (gt.isZero() || vt.isZero())
                    return gt.words[0] = 0,
                    gt.length = 1,
                    gt;
                var Et = gt.imul(vt)
                  , Bt = Et.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , Rt = Et.isub(Bt).iushrn(this.shift)
                  , kt = Rt;
                return Rt.cmp(this.m) >= 0 ? kt = Rt.isub(this.m) : Rt.cmpn(0) < 0 && (kt = Rt.iadd(this.m)),
                kt._forceRed(this)
            }
            ,
            Mt.prototype.mul = function(gt, vt) {
                if (gt.isZero() || vt.isZero())
                    return new y(0)._forceRed(this);
                var Et = gt.mul(vt)
                  , Bt = Et.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , Rt = Et.isub(Bt).iushrn(this.shift)
                  , kt = Rt;
                return Rt.cmp(this.m) >= 0 ? kt = Rt.isub(this.m) : Rt.cmpn(0) < 0 && (kt = Rt.iadd(this.m)),
                kt._forceRed(this)
            }
            ,
            Mt.prototype.invm = function(gt) {
                var vt = this.imod(gt._invmp(this.m).mul(this.r2));
                return vt._forceRed(this)
            }
        }
        )(r, commonjsGlobal)
    }(bn$1)),
    bn$1.exports
}
var browserifyRsa, hasRequiredBrowserifyRsa;
function requireBrowserifyRsa() {
    if (hasRequiredBrowserifyRsa)
        return browserifyRsa;
    hasRequiredBrowserifyRsa = 1;
    var r = requireBn$1()
      , d = requireBrowser$b();
    function f(y) {
        var ee = m(y)
          , dt = ee.toRed(r.mont(y.modulus)).redPow(new r(y.publicExponent)).fromRed();
        return {
            blinder: dt,
            unblinder: ee.invm(y.modulus)
        }
    }
    function m(y) {
        var ee = y.modulus.byteLength(), dt;
        do
            dt = new r(d(ee));
        while (dt.cmp(y.modulus) >= 0 || !dt.umod(y.prime1) || !dt.umod(y.prime2));
        return dt
    }
    function k(y, ee) {
        var dt = f(ee)
          , mt = ee.modulus.byteLength()
          , yt = new r(y).mul(dt.blinder).umod(ee.modulus)
          , pt = yt.toRed(r.mont(ee.prime1))
          , bt = yt.toRed(r.mont(ee.prime2))
          , wt = ee.coefficient
          , xt = ee.prime1
          , At = ee.prime2
          , Ct = pt.redPow(ee.exponent1).fromRed()
          , Pt = bt.redPow(ee.exponent2).fromRed()
          , $t = Ct.isub(Pt).imul(wt).umod(xt).imul(At);
        return Pt.iadd($t).imul(dt.unblinder).umod(ee.modulus).toArrayLike(Buffer, "be", mt)
    }
    return k.getr = m,
    browserifyRsa = k,
    browserifyRsa
}
var elliptic = {};
const name$1 = "elliptic"
  , version$2 = "6.5.5"
  , description = "EC cryptography"
  , main$1 = "lib/elliptic.js"
  , files$1 = ["lib"]
  , scripts$1 = {
    lint: "eslint lib test",
    "lint:fix": "npm run lint -- --fix",
    unit: "istanbul test _mocha --reporter=spec test/index.js",
    test: "npm run lint && npm run unit",
    version: "grunt dist && git add dist/"
}
  , repository$1 = {
    type: "git",
    url: "git@github.com:indutny/elliptic"
}
  , keywords = ["EC", "Elliptic", "curve", "Cryptography"]
  , author$1 = "Fedor Indutny <fedor@indutny.com>"
  , license$1 = "MIT"
  , bugs = {
    url: "https://github.com/indutny/elliptic/issues"
}
  , homepage = "https://github.com/indutny/elliptic"
  , devDependencies$1 = {
    brfs: "^2.0.2",
    coveralls: "^3.1.0",
    eslint: "^7.6.0",
    grunt: "^1.2.1",
    "grunt-browserify": "^5.3.0",
    "grunt-cli": "^1.3.2",
    "grunt-contrib-connect": "^3.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^5.0.0",
    "grunt-mocha-istanbul": "^5.0.2",
    "grunt-saucelabs": "^9.0.1",
    istanbul: "^0.4.5",
    mocha: "^8.0.1"
}
  , dependencies$1 = {
    "bn.js": "^4.11.9",
    brorand: "^1.1.0",
    "hash.js": "^1.0.0",
    "hmac-drbg": "^1.0.1",
    inherits: "^2.0.4",
    "minimalistic-assert": "^1.0.1",
    "minimalistic-crypto-utils": "^1.0.1"
}
  , require$$0 = {
    name: name$1,
    version: version$2,
    description,
    main: main$1,
    files: files$1,
    scripts: scripts$1,
    repository: repository$1,
    keywords,
    author: author$1,
    license: license$1,
    bugs,
    homepage,
    devDependencies: devDependencies$1,
    dependencies: dependencies$1
};
var utils$4 = {}, utils$3 = {}, hasRequiredUtils$2;
function requireUtils$2() {
    return hasRequiredUtils$2 || (hasRequiredUtils$2 = 1,
    function(r) {
        var d = r;
        function f(y, ee) {
            if (Array.isArray(y))
                return y.slice();
            if (!y)
                return [];
            var dt = [];
            if (typeof y != "string") {
                for (var mt = 0; mt < y.length; mt++)
                    dt[mt] = y[mt] | 0;
                return dt
            }
            if (ee === "hex") {
                y = y.replace(/[^a-z0-9]+/ig, ""),
                y.length % 2 !== 0 && (y = "0" + y);
                for (var mt = 0; mt < y.length; mt += 2)
                    dt.push(parseInt(y[mt] + y[mt + 1], 16))
            } else
                for (var mt = 0; mt < y.length; mt++) {
                    var yt = y.charCodeAt(mt)
                      , pt = yt >> 8
                      , bt = yt & 255;
                    pt ? dt.push(pt, bt) : dt.push(bt)
                }
            return dt
        }
        d.toArray = f;
        function m(y) {
            return y.length === 1 ? "0" + y : y
        }
        d.zero2 = m;
        function k(y) {
            for (var ee = "", dt = 0; dt < y.length; dt++)
                ee += m(y[dt].toString(16));
            return ee
        }
        d.toHex = k,
        d.encode = function(ee, dt) {
            return dt === "hex" ? k(ee) : ee
        }
    }(utils$3)),
    utils$3
}
var hasRequiredUtils$1;
function requireUtils$1() {
    return hasRequiredUtils$1 || (hasRequiredUtils$1 = 1,
    function(r) {
        var d = r
          , f = requireBn$2()
          , m = requireMinimalisticAssert()
          , k = requireUtils$2();
        d.assert = m,
        d.toArray = k.toArray,
        d.zero2 = k.zero2,
        d.toHex = k.toHex,
        d.encode = k.encode;
        function y(pt, bt, wt) {
            var xt = new Array(Math.max(pt.bitLength(), wt) + 1), At;
            for (At = 0; At < xt.length; At += 1)
                xt[At] = 0;
            var Ct = 1 << bt + 1
              , Pt = pt.clone();
            for (At = 0; At < xt.length; At++) {
                var $t, Ot = Pt.andln(Ct - 1);
                Pt.isOdd() ? (Ot > (Ct >> 1) - 1 ? $t = (Ct >> 1) - Ot : $t = Ot,
                Pt.isubn($t)) : $t = 0,
                xt[At] = $t,
                Pt.iushrn(1)
            }
            return xt
        }
        d.getNAF = y;
        function ee(pt, bt) {
            var wt = [[], []];
            pt = pt.clone(),
            bt = bt.clone();
            for (var xt = 0, At = 0, Ct; pt.cmpn(-xt) > 0 || bt.cmpn(-At) > 0; ) {
                var Pt = pt.andln(3) + xt & 3
                  , $t = bt.andln(3) + At & 3;
                Pt === 3 && (Pt = -1),
                $t === 3 && ($t = -1);
                var Ot;
                Pt & 1 ? (Ct = pt.andln(7) + xt & 7,
                (Ct === 3 || Ct === 5) && $t === 2 ? Ot = -Pt : Ot = Pt) : Ot = 0,
                wt[0].push(Ot);
                var Nt;
                $t & 1 ? (Ct = bt.andln(7) + At & 7,
                (Ct === 3 || Ct === 5) && Pt === 2 ? Nt = -$t : Nt = $t) : Nt = 0,
                wt[1].push(Nt),
                2 * xt === Ot + 1 && (xt = 1 - xt),
                2 * At === Nt + 1 && (At = 1 - At),
                pt.iushrn(1),
                bt.iushrn(1)
            }
            return wt
        }
        d.getJSF = ee;
        function dt(pt, bt, wt) {
            var xt = "_" + bt;
            pt.prototype[bt] = function() {
                return this[xt] !== void 0 ? this[xt] : this[xt] = wt.call(this)
            }
        }
        d.cachedProperty = dt;
        function mt(pt) {
            return typeof pt == "string" ? d.toArray(pt, "hex") : pt
        }
        d.parseBytes = mt;
        function yt(pt) {
            return new f(pt,"hex","le")
        }
        d.intFromLE = yt
    }(utils$4)),
    utils$4
}
var curve = {}, base$1, hasRequiredBase$1;
function requireBase$1() {
    if (hasRequiredBase$1)
        return base$1;
    hasRequiredBase$1 = 1;
    var r = requireBn$2()
      , d = requireUtils$1()
      , f = d.getNAF
      , m = d.getJSF
      , k = d.assert;
    function y(dt, mt) {
        this.type = dt,
        this.p = new r(mt.p,16),
        this.red = mt.prime ? r.red(mt.prime) : r.mont(this.p),
        this.zero = new r(0).toRed(this.red),
        this.one = new r(1).toRed(this.red),
        this.two = new r(2).toRed(this.red),
        this.n = mt.n && new r(mt.n,16),
        this.g = mt.g && this.pointFromJSON(mt.g, mt.gRed),
        this._wnafT1 = new Array(4),
        this._wnafT2 = new Array(4),
        this._wnafT3 = new Array(4),
        this._wnafT4 = new Array(4),
        this._bitLength = this.n ? this.n.bitLength() : 0;
        var yt = this.n && this.p.div(this.n);
        !yt || yt.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0,
        this.redN = this.n.toRed(this.red))
    }
    base$1 = y,
    y.prototype.point = function() {
        throw new Error("Not implemented")
    }
    ,
    y.prototype.validate = function() {
        throw new Error("Not implemented")
    }
    ,
    y.prototype._fixedNafMul = function(mt, yt) {
        k(mt.precomputed);
        var pt = mt._getDoubles()
          , bt = f(yt, 1, this._bitLength)
          , wt = (1 << pt.step + 1) - (pt.step % 2 === 0 ? 2 : 1);
        wt /= 3;
        var xt = [], At, Ct;
        for (At = 0; At < bt.length; At += pt.step) {
            Ct = 0;
            for (var Pt = At + pt.step - 1; Pt >= At; Pt--)
                Ct = (Ct << 1) + bt[Pt];
            xt.push(Ct)
        }
        for (var $t = this.jpoint(null, null, null), Ot = this.jpoint(null, null, null), Nt = wt; Nt > 0; Nt--) {
            for (At = 0; At < xt.length; At++)
                Ct = xt[At],
                Ct === Nt ? Ot = Ot.mixedAdd(pt.points[At]) : Ct === -Nt && (Ot = Ot.mixedAdd(pt.points[At].neg()));
            $t = $t.add(Ot)
        }
        return $t.toP()
    }
    ,
    y.prototype._wnafMul = function(mt, yt) {
        var pt = 4
          , bt = mt._getNAFPoints(pt);
        pt = bt.wnd;
        for (var wt = bt.points, xt = f(yt, pt, this._bitLength), At = this.jpoint(null, null, null), Ct = xt.length - 1; Ct >= 0; Ct--) {
            for (var Pt = 0; Ct >= 0 && xt[Ct] === 0; Ct--)
                Pt++;
            if (Ct >= 0 && Pt++,
            At = At.dblp(Pt),
            Ct < 0)
                break;
            var $t = xt[Ct];
            k($t !== 0),
            mt.type === "affine" ? $t > 0 ? At = At.mixedAdd(wt[$t - 1 >> 1]) : At = At.mixedAdd(wt[-$t - 1 >> 1].neg()) : $t > 0 ? At = At.add(wt[$t - 1 >> 1]) : At = At.add(wt[-$t - 1 >> 1].neg())
        }
        return mt.type === "affine" ? At.toP() : At
    }
    ,
    y.prototype._wnafMulAdd = function(mt, yt, pt, bt, wt) {
        var xt = this._wnafT1, At = this._wnafT2, Ct = this._wnafT3, Pt = 0, $t, Ot, Nt;
        for ($t = 0; $t < bt; $t++) {
            Nt = yt[$t];
            var zt = Nt._getNAFPoints(mt);
            xt[$t] = zt.wnd,
            At[$t] = zt.points
        }
        for ($t = bt - 1; $t >= 1; $t -= 2) {
            var Wt = $t - 1
              , Kt = $t;
            if (xt[Wt] !== 1 || xt[Kt] !== 1) {
                Ct[Wt] = f(pt[Wt], xt[Wt], this._bitLength),
                Ct[Kt] = f(pt[Kt], xt[Kt], this._bitLength),
                Pt = Math.max(Ct[Wt].length, Pt),
                Pt = Math.max(Ct[Kt].length, Pt);
                continue
            }
            var ir = [yt[Wt], null, null, yt[Kt]];
            yt[Wt].y.cmp(yt[Kt].y) === 0 ? (ir[1] = yt[Wt].add(yt[Kt]),
            ir[2] = yt[Wt].toJ().mixedAdd(yt[Kt].neg())) : yt[Wt].y.cmp(yt[Kt].y.redNeg()) === 0 ? (ir[1] = yt[Wt].toJ().mixedAdd(yt[Kt]),
            ir[2] = yt[Wt].add(yt[Kt].neg())) : (ir[1] = yt[Wt].toJ().mixedAdd(yt[Kt]),
            ir[2] = yt[Wt].toJ().mixedAdd(yt[Kt].neg()));
            var or = [-3, -1, -5, -7, 0, 7, 5, 1, 3]
              , tr = m(pt[Wt], pt[Kt]);
            for (Pt = Math.max(tr[0].length, Pt),
            Ct[Wt] = new Array(Pt),
            Ct[Kt] = new Array(Pt),
            Ot = 0; Ot < Pt; Ot++) {
                var wr = tr[0][Ot] | 0
                  , Ht = tr[1][Ot] | 0;
                Ct[Wt][Ot] = or[(wr + 1) * 3 + (Ht + 1)],
                Ct[Kt][Ot] = 0,
                At[Wt] = ir
            }
        }
        var Mt = this.jpoint(null, null, null)
          , _t = this._wnafT4;
        for ($t = Pt; $t >= 0; $t--) {
            for (var gt = 0; $t >= 0; ) {
                var vt = !0;
                for (Ot = 0; Ot < bt; Ot++)
                    _t[Ot] = Ct[Ot][$t] | 0,
                    _t[Ot] !== 0 && (vt = !1);
                if (!vt)
                    break;
                gt++,
                $t--
            }
            if ($t >= 0 && gt++,
            Mt = Mt.dblp(gt),
            $t < 0)
                break;
            for (Ot = 0; Ot < bt; Ot++) {
                var Et = _t[Ot];
                Et !== 0 && (Et > 0 ? Nt = At[Ot][Et - 1 >> 1] : Et < 0 && (Nt = At[Ot][-Et - 1 >> 1].neg()),
                Nt.type === "affine" ? Mt = Mt.mixedAdd(Nt) : Mt = Mt.add(Nt))
            }
        }
        for ($t = 0; $t < bt; $t++)
            At[$t] = null;
        return wt ? Mt : Mt.toP()
    }
    ;
    function ee(dt, mt) {
        this.curve = dt,
        this.type = mt,
        this.precomputed = null
    }
    return y.BasePoint = ee,
    ee.prototype.eq = function() {
        throw new Error("Not implemented")
    }
    ,
    ee.prototype.validate = function() {
        return this.curve.validate(this)
    }
    ,
    y.prototype.decodePoint = function(mt, yt) {
        mt = d.toArray(mt, yt);
        var pt = this.p.byteLength();
        if ((mt[0] === 4 || mt[0] === 6 || mt[0] === 7) && mt.length - 1 === 2 * pt) {
            mt[0] === 6 ? k(mt[mt.length - 1] % 2 === 0) : mt[0] === 7 && k(mt[mt.length - 1] % 2 === 1);
            var bt = this.point(mt.slice(1, 1 + pt), mt.slice(1 + pt, 1 + 2 * pt));
            return bt
        } else if ((mt[0] === 2 || mt[0] === 3) && mt.length - 1 === pt)
            return this.pointFromX(mt.slice(1, 1 + pt), mt[0] === 3);
        throw new Error("Unknown point format")
    }
    ,
    ee.prototype.encodeCompressed = function(mt) {
        return this.encode(mt, !0)
    }
    ,
    ee.prototype._encode = function(mt) {
        var yt = this.curve.p.byteLength()
          , pt = this.getX().toArray("be", yt);
        return mt ? [this.getY().isEven() ? 2 : 3].concat(pt) : [4].concat(pt, this.getY().toArray("be", yt))
    }
    ,
    ee.prototype.encode = function(mt, yt) {
        return d.encode(this._encode(yt), mt)
    }
    ,
    ee.prototype.precompute = function(mt) {
        if (this.precomputed)
            return this;
        var yt = {
            doubles: null,
            naf: null,
            beta: null
        };
        return yt.naf = this._getNAFPoints(8),
        yt.doubles = this._getDoubles(4, mt),
        yt.beta = this._getBeta(),
        this.precomputed = yt,
        this
    }
    ,
    ee.prototype._hasDoubles = function(mt) {
        if (!this.precomputed)
            return !1;
        var yt = this.precomputed.doubles;
        return yt ? yt.points.length >= Math.ceil((mt.bitLength() + 1) / yt.step) : !1
    }
    ,
    ee.prototype._getDoubles = function(mt, yt) {
        if (this.precomputed && this.precomputed.doubles)
            return this.precomputed.doubles;
        for (var pt = [this], bt = this, wt = 0; wt < yt; wt += mt) {
            for (var xt = 0; xt < mt; xt++)
                bt = bt.dbl();
            pt.push(bt)
        }
        return {
            step: mt,
            points: pt
        }
    }
    ,
    ee.prototype._getNAFPoints = function(mt) {
        if (this.precomputed && this.precomputed.naf)
            return this.precomputed.naf;
        for (var yt = [this], pt = (1 << mt) - 1, bt = pt === 1 ? null : this.dbl(), wt = 1; wt < pt; wt++)
            yt[wt] = yt[wt - 1].add(bt);
        return {
            wnd: mt,
            points: yt
        }
    }
    ,
    ee.prototype._getBeta = function() {
        return null
    }
    ,
    ee.prototype.dblp = function(mt) {
        for (var yt = this, pt = 0; pt < mt; pt++)
            yt = yt.dbl();
        return yt
    }
    ,
    base$1
}
var short, hasRequiredShort;
function requireShort() {
    if (hasRequiredShort)
        return short;
    hasRequiredShort = 1;
    var r = requireUtils$1()
      , d = requireBn$2()
      , f = requireInherits_browser()
      , m = requireBase$1()
      , k = r.assert;
    function y(mt) {
        m.call(this, "short", mt),
        this.a = new d(mt.a,16).toRed(this.red),
        this.b = new d(mt.b,16).toRed(this.red),
        this.tinv = this.two.redInvm(),
        this.zeroA = this.a.fromRed().cmpn(0) === 0,
        this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0,
        this.endo = this._getEndomorphism(mt),
        this._endoWnafT1 = new Array(4),
        this._endoWnafT2 = new Array(4)
    }
    f(y, m),
    short = y,
    y.prototype._getEndomorphism = function(yt) {
        if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
            var pt, bt;
            if (yt.beta)
                pt = new d(yt.beta,16).toRed(this.red);
            else {
                var wt = this._getEndoRoots(this.p);
                pt = wt[0].cmp(wt[1]) < 0 ? wt[0] : wt[1],
                pt = pt.toRed(this.red)
            }
            if (yt.lambda)
                bt = new d(yt.lambda,16);
            else {
                var xt = this._getEndoRoots(this.n);
                this.g.mul(xt[0]).x.cmp(this.g.x.redMul(pt)) === 0 ? bt = xt[0] : (bt = xt[1],
                k(this.g.mul(bt).x.cmp(this.g.x.redMul(pt)) === 0))
            }
            var At;
            return yt.basis ? At = yt.basis.map(function(Ct) {
                return {
                    a: new d(Ct.a,16),
                    b: new d(Ct.b,16)
                }
            }) : At = this._getEndoBasis(bt),
            {
                beta: pt,
                lambda: bt,
                basis: At
            }
        }
    }
    ,
    y.prototype._getEndoRoots = function(yt) {
        var pt = yt === this.p ? this.red : d.mont(yt)
          , bt = new d(2).toRed(pt).redInvm()
          , wt = bt.redNeg()
          , xt = new d(3).toRed(pt).redNeg().redSqrt().redMul(bt)
          , At = wt.redAdd(xt).fromRed()
          , Ct = wt.redSub(xt).fromRed();
        return [At, Ct]
    }
    ,
    y.prototype._getEndoBasis = function(yt) {
        for (var pt = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), bt = yt, wt = this.n.clone(), xt = new d(1), At = new d(0), Ct = new d(0), Pt = new d(1), $t, Ot, Nt, zt, Wt, Kt, ir, or = 0, tr, wr; bt.cmpn(0) !== 0; ) {
            var Ht = wt.div(bt);
            tr = wt.sub(Ht.mul(bt)),
            wr = Ct.sub(Ht.mul(xt));
            var Mt = Pt.sub(Ht.mul(At));
            if (!Nt && tr.cmp(pt) < 0)
                $t = ir.neg(),
                Ot = xt,
                Nt = tr.neg(),
                zt = wr;
            else if (Nt && ++or === 2)
                break;
            ir = tr,
            wt = bt,
            bt = tr,
            Ct = xt,
            xt = wr,
            Pt = At,
            At = Mt
        }
        Wt = tr.neg(),
        Kt = wr;
        var _t = Nt.sqr().add(zt.sqr())
          , gt = Wt.sqr().add(Kt.sqr());
        return gt.cmp(_t) >= 0 && (Wt = $t,
        Kt = Ot),
        Nt.negative && (Nt = Nt.neg(),
        zt = zt.neg()),
        Wt.negative && (Wt = Wt.neg(),
        Kt = Kt.neg()),
        [{
            a: Nt,
            b: zt
        }, {
            a: Wt,
            b: Kt
        }]
    }
    ,
    y.prototype._endoSplit = function(yt) {
        var pt = this.endo.basis
          , bt = pt[0]
          , wt = pt[1]
          , xt = wt.b.mul(yt).divRound(this.n)
          , At = bt.b.neg().mul(yt).divRound(this.n)
          , Ct = xt.mul(bt.a)
          , Pt = At.mul(wt.a)
          , $t = xt.mul(bt.b)
          , Ot = At.mul(wt.b)
          , Nt = yt.sub(Ct).sub(Pt)
          , zt = $t.add(Ot).neg();
        return {
            k1: Nt,
            k2: zt
        }
    }
    ,
    y.prototype.pointFromX = function(yt, pt) {
        yt = new d(yt,16),
        yt.red || (yt = yt.toRed(this.red));
        var bt = yt.redSqr().redMul(yt).redIAdd(yt.redMul(this.a)).redIAdd(this.b)
          , wt = bt.redSqrt();
        if (wt.redSqr().redSub(bt).cmp(this.zero) !== 0)
            throw new Error("invalid point");
        var xt = wt.fromRed().isOdd();
        return (pt && !xt || !pt && xt) && (wt = wt.redNeg()),
        this.point(yt, wt)
    }
    ,
    y.prototype.validate = function(yt) {
        if (yt.inf)
            return !0;
        var pt = yt.x
          , bt = yt.y
          , wt = this.a.redMul(pt)
          , xt = pt.redSqr().redMul(pt).redIAdd(wt).redIAdd(this.b);
        return bt.redSqr().redISub(xt).cmpn(0) === 0
    }
    ,
    y.prototype._endoWnafMulAdd = function(yt, pt, bt) {
        for (var wt = this._endoWnafT1, xt = this._endoWnafT2, At = 0; At < yt.length; At++) {
            var Ct = this._endoSplit(pt[At])
              , Pt = yt[At]
              , $t = Pt._getBeta();
            Ct.k1.negative && (Ct.k1.ineg(),
            Pt = Pt.neg(!0)),
            Ct.k2.negative && (Ct.k2.ineg(),
            $t = $t.neg(!0)),
            wt[At * 2] = Pt,
            wt[At * 2 + 1] = $t,
            xt[At * 2] = Ct.k1,
            xt[At * 2 + 1] = Ct.k2
        }
        for (var Ot = this._wnafMulAdd(1, wt, xt, At * 2, bt), Nt = 0; Nt < At * 2; Nt++)
            wt[Nt] = null,
            xt[Nt] = null;
        return Ot
    }
    ;
    function ee(mt, yt, pt, bt) {
        m.BasePoint.call(this, mt, "affine"),
        yt === null && pt === null ? (this.x = null,
        this.y = null,
        this.inf = !0) : (this.x = new d(yt,16),
        this.y = new d(pt,16),
        bt && (this.x.forceRed(this.curve.red),
        this.y.forceRed(this.curve.red)),
        this.x.red || (this.x = this.x.toRed(this.curve.red)),
        this.y.red || (this.y = this.y.toRed(this.curve.red)),
        this.inf = !1)
    }
    f(ee, m.BasePoint),
    y.prototype.point = function(yt, pt, bt) {
        return new ee(this,yt,pt,bt)
    }
    ,
    y.prototype.pointFromJSON = function(yt, pt) {
        return ee.fromJSON(this, yt, pt)
    }
    ,
    ee.prototype._getBeta = function() {
        if (this.curve.endo) {
            var yt = this.precomputed;
            if (yt && yt.beta)
                return yt.beta;
            var pt = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
            if (yt) {
                var bt = this.curve
                  , wt = function(xt) {
                    return bt.point(xt.x.redMul(bt.endo.beta), xt.y)
                };
                yt.beta = pt,
                pt.precomputed = {
                    beta: null,
                    naf: yt.naf && {
                        wnd: yt.naf.wnd,
                        points: yt.naf.points.map(wt)
                    },
                    doubles: yt.doubles && {
                        step: yt.doubles.step,
                        points: yt.doubles.points.map(wt)
                    }
                }
            }
            return pt
        }
    }
    ,
    ee.prototype.toJSON = function() {
        return this.precomputed ? [this.x, this.y, this.precomputed && {
            doubles: this.precomputed.doubles && {
                step: this.precomputed.doubles.step,
                points: this.precomputed.doubles.points.slice(1)
            },
            naf: this.precomputed.naf && {
                wnd: this.precomputed.naf.wnd,
                points: this.precomputed.naf.points.slice(1)
            }
        }] : [this.x, this.y]
    }
    ,
    ee.fromJSON = function(yt, pt, bt) {
        typeof pt == "string" && (pt = JSON.parse(pt));
        var wt = yt.point(pt[0], pt[1], bt);
        if (!pt[2])
            return wt;
        function xt(Ct) {
            return yt.point(Ct[0], Ct[1], bt)
        }
        var At = pt[2];
        return wt.precomputed = {
            beta: null,
            doubles: At.doubles && {
                step: At.doubles.step,
                points: [wt].concat(At.doubles.points.map(xt))
            },
            naf: At.naf && {
                wnd: At.naf.wnd,
                points: [wt].concat(At.naf.points.map(xt))
            }
        },
        wt
    }
    ,
    ee.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
    }
    ,
    ee.prototype.isInfinity = function() {
        return this.inf
    }
    ,
    ee.prototype.add = function(yt) {
        if (this.inf)
            return yt;
        if (yt.inf)
            return this;
        if (this.eq(yt))
            return this.dbl();
        if (this.neg().eq(yt))
            return this.curve.point(null, null);
        if (this.x.cmp(yt.x) === 0)
            return this.curve.point(null, null);
        var pt = this.y.redSub(yt.y);
        pt.cmpn(0) !== 0 && (pt = pt.redMul(this.x.redSub(yt.x).redInvm()));
        var bt = pt.redSqr().redISub(this.x).redISub(yt.x)
          , wt = pt.redMul(this.x.redSub(bt)).redISub(this.y);
        return this.curve.point(bt, wt)
    }
    ,
    ee.prototype.dbl = function() {
        if (this.inf)
            return this;
        var yt = this.y.redAdd(this.y);
        if (yt.cmpn(0) === 0)
            return this.curve.point(null, null);
        var pt = this.curve.a
          , bt = this.x.redSqr()
          , wt = yt.redInvm()
          , xt = bt.redAdd(bt).redIAdd(bt).redIAdd(pt).redMul(wt)
          , At = xt.redSqr().redISub(this.x.redAdd(this.x))
          , Ct = xt.redMul(this.x.redSub(At)).redISub(this.y);
        return this.curve.point(At, Ct)
    }
    ,
    ee.prototype.getX = function() {
        return this.x.fromRed()
    }
    ,
    ee.prototype.getY = function() {
        return this.y.fromRed()
    }
    ,
    ee.prototype.mul = function(yt) {
        return yt = new d(yt,16),
        this.isInfinity() ? this : this._hasDoubles(yt) ? this.curve._fixedNafMul(this, yt) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [yt]) : this.curve._wnafMul(this, yt)
    }
    ,
    ee.prototype.mulAdd = function(yt, pt, bt) {
        var wt = [this, pt]
          , xt = [yt, bt];
        return this.curve.endo ? this.curve._endoWnafMulAdd(wt, xt) : this.curve._wnafMulAdd(1, wt, xt, 2)
    }
    ,
    ee.prototype.jmulAdd = function(yt, pt, bt) {
        var wt = [this, pt]
          , xt = [yt, bt];
        return this.curve.endo ? this.curve._endoWnafMulAdd(wt, xt, !0) : this.curve._wnafMulAdd(1, wt, xt, 2, !0)
    }
    ,
    ee.prototype.eq = function(yt) {
        return this === yt || this.inf === yt.inf && (this.inf || this.x.cmp(yt.x) === 0 && this.y.cmp(yt.y) === 0)
    }
    ,
    ee.prototype.neg = function(yt) {
        if (this.inf)
            return this;
        var pt = this.curve.point(this.x, this.y.redNeg());
        if (yt && this.precomputed) {
            var bt = this.precomputed
              , wt = function(xt) {
                return xt.neg()
            };
            pt.precomputed = {
                naf: bt.naf && {
                    wnd: bt.naf.wnd,
                    points: bt.naf.points.map(wt)
                },
                doubles: bt.doubles && {
                    step: bt.doubles.step,
                    points: bt.doubles.points.map(wt)
                }
            }
        }
        return pt
    }
    ,
    ee.prototype.toJ = function() {
        if (this.inf)
            return this.curve.jpoint(null, null, null);
        var yt = this.curve.jpoint(this.x, this.y, this.curve.one);
        return yt
    }
    ;
    function dt(mt, yt, pt, bt) {
        m.BasePoint.call(this, mt, "jacobian"),
        yt === null && pt === null && bt === null ? (this.x = this.curve.one,
        this.y = this.curve.one,
        this.z = new d(0)) : (this.x = new d(yt,16),
        this.y = new d(pt,16),
        this.z = new d(bt,16)),
        this.x.red || (this.x = this.x.toRed(this.curve.red)),
        this.y.red || (this.y = this.y.toRed(this.curve.red)),
        this.z.red || (this.z = this.z.toRed(this.curve.red)),
        this.zOne = this.z === this.curve.one
    }
    return f(dt, m.BasePoint),
    y.prototype.jpoint = function(yt, pt, bt) {
        return new dt(this,yt,pt,bt)
    }
    ,
    dt.prototype.toP = function() {
        if (this.isInfinity())
            return this.curve.point(null, null);
        var yt = this.z.redInvm()
          , pt = yt.redSqr()
          , bt = this.x.redMul(pt)
          , wt = this.y.redMul(pt).redMul(yt);
        return this.curve.point(bt, wt)
    }
    ,
    dt.prototype.neg = function() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
    }
    ,
    dt.prototype.add = function(yt) {
        if (this.isInfinity())
            return yt;
        if (yt.isInfinity())
            return this;
        var pt = yt.z.redSqr()
          , bt = this.z.redSqr()
          , wt = this.x.redMul(pt)
          , xt = yt.x.redMul(bt)
          , At = this.y.redMul(pt.redMul(yt.z))
          , Ct = yt.y.redMul(bt.redMul(this.z))
          , Pt = wt.redSub(xt)
          , $t = At.redSub(Ct);
        if (Pt.cmpn(0) === 0)
            return $t.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
        var Ot = Pt.redSqr()
          , Nt = Ot.redMul(Pt)
          , zt = wt.redMul(Ot)
          , Wt = $t.redSqr().redIAdd(Nt).redISub(zt).redISub(zt)
          , Kt = $t.redMul(zt.redISub(Wt)).redISub(At.redMul(Nt))
          , ir = this.z.redMul(yt.z).redMul(Pt);
        return this.curve.jpoint(Wt, Kt, ir)
    }
    ,
    dt.prototype.mixedAdd = function(yt) {
        if (this.isInfinity())
            return yt.toJ();
        if (yt.isInfinity())
            return this;
        var pt = this.z.redSqr()
          , bt = this.x
          , wt = yt.x.redMul(pt)
          , xt = this.y
          , At = yt.y.redMul(pt).redMul(this.z)
          , Ct = bt.redSub(wt)
          , Pt = xt.redSub(At);
        if (Ct.cmpn(0) === 0)
            return Pt.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
        var $t = Ct.redSqr()
          , Ot = $t.redMul(Ct)
          , Nt = bt.redMul($t)
          , zt = Pt.redSqr().redIAdd(Ot).redISub(Nt).redISub(Nt)
          , Wt = Pt.redMul(Nt.redISub(zt)).redISub(xt.redMul(Ot))
          , Kt = this.z.redMul(Ct);
        return this.curve.jpoint(zt, Wt, Kt)
    }
    ,
    dt.prototype.dblp = function(yt) {
        if (yt === 0)
            return this;
        if (this.isInfinity())
            return this;
        if (!yt)
            return this.dbl();
        var pt;
        if (this.curve.zeroA || this.curve.threeA) {
            var bt = this;
            for (pt = 0; pt < yt; pt++)
                bt = bt.dbl();
            return bt
        }
        var wt = this.curve.a
          , xt = this.curve.tinv
          , At = this.x
          , Ct = this.y
          , Pt = this.z
          , $t = Pt.redSqr().redSqr()
          , Ot = Ct.redAdd(Ct);
        for (pt = 0; pt < yt; pt++) {
            var Nt = At.redSqr()
              , zt = Ot.redSqr()
              , Wt = zt.redSqr()
              , Kt = Nt.redAdd(Nt).redIAdd(Nt).redIAdd(wt.redMul($t))
              , ir = At.redMul(zt)
              , or = Kt.redSqr().redISub(ir.redAdd(ir))
              , tr = ir.redISub(or)
              , wr = Kt.redMul(tr);
            wr = wr.redIAdd(wr).redISub(Wt);
            var Ht = Ot.redMul(Pt);
            pt + 1 < yt && ($t = $t.redMul(Wt)),
            At = or,
            Pt = Ht,
            Ot = wr
        }
        return this.curve.jpoint(At, Ot.redMul(xt), Pt)
    }
    ,
    dt.prototype.dbl = function() {
        return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
    }
    ,
    dt.prototype._zeroDbl = function() {
        var yt, pt, bt;
        if (this.zOne) {
            var wt = this.x.redSqr()
              , xt = this.y.redSqr()
              , At = xt.redSqr()
              , Ct = this.x.redAdd(xt).redSqr().redISub(wt).redISub(At);
            Ct = Ct.redIAdd(Ct);
            var Pt = wt.redAdd(wt).redIAdd(wt)
              , $t = Pt.redSqr().redISub(Ct).redISub(Ct)
              , Ot = At.redIAdd(At);
            Ot = Ot.redIAdd(Ot),
            Ot = Ot.redIAdd(Ot),
            yt = $t,
            pt = Pt.redMul(Ct.redISub($t)).redISub(Ot),
            bt = this.y.redAdd(this.y)
        } else {
            var Nt = this.x.redSqr()
              , zt = this.y.redSqr()
              , Wt = zt.redSqr()
              , Kt = this.x.redAdd(zt).redSqr().redISub(Nt).redISub(Wt);
            Kt = Kt.redIAdd(Kt);
            var ir = Nt.redAdd(Nt).redIAdd(Nt)
              , or = ir.redSqr()
              , tr = Wt.redIAdd(Wt);
            tr = tr.redIAdd(tr),
            tr = tr.redIAdd(tr),
            yt = or.redISub(Kt).redISub(Kt),
            pt = ir.redMul(Kt.redISub(yt)).redISub(tr),
            bt = this.y.redMul(this.z),
            bt = bt.redIAdd(bt)
        }
        return this.curve.jpoint(yt, pt, bt)
    }
    ,
    dt.prototype._threeDbl = function() {
        var yt, pt, bt;
        if (this.zOne) {
            var wt = this.x.redSqr()
              , xt = this.y.redSqr()
              , At = xt.redSqr()
              , Ct = this.x.redAdd(xt).redSqr().redISub(wt).redISub(At);
            Ct = Ct.redIAdd(Ct);
            var Pt = wt.redAdd(wt).redIAdd(wt).redIAdd(this.curve.a)
              , $t = Pt.redSqr().redISub(Ct).redISub(Ct);
            yt = $t;
            var Ot = At.redIAdd(At);
            Ot = Ot.redIAdd(Ot),
            Ot = Ot.redIAdd(Ot),
            pt = Pt.redMul(Ct.redISub($t)).redISub(Ot),
            bt = this.y.redAdd(this.y)
        } else {
            var Nt = this.z.redSqr()
              , zt = this.y.redSqr()
              , Wt = this.x.redMul(zt)
              , Kt = this.x.redSub(Nt).redMul(this.x.redAdd(Nt));
            Kt = Kt.redAdd(Kt).redIAdd(Kt);
            var ir = Wt.redIAdd(Wt);
            ir = ir.redIAdd(ir);
            var or = ir.redAdd(ir);
            yt = Kt.redSqr().redISub(or),
            bt = this.y.redAdd(this.z).redSqr().redISub(zt).redISub(Nt);
            var tr = zt.redSqr();
            tr = tr.redIAdd(tr),
            tr = tr.redIAdd(tr),
            tr = tr.redIAdd(tr),
            pt = Kt.redMul(ir.redISub(yt)).redISub(tr)
        }
        return this.curve.jpoint(yt, pt, bt)
    }
    ,
    dt.prototype._dbl = function() {
        var yt = this.curve.a
          , pt = this.x
          , bt = this.y
          , wt = this.z
          , xt = wt.redSqr().redSqr()
          , At = pt.redSqr()
          , Ct = bt.redSqr()
          , Pt = At.redAdd(At).redIAdd(At).redIAdd(yt.redMul(xt))
          , $t = pt.redAdd(pt);
        $t = $t.redIAdd($t);
        var Ot = $t.redMul(Ct)
          , Nt = Pt.redSqr().redISub(Ot.redAdd(Ot))
          , zt = Ot.redISub(Nt)
          , Wt = Ct.redSqr();
        Wt = Wt.redIAdd(Wt),
        Wt = Wt.redIAdd(Wt),
        Wt = Wt.redIAdd(Wt);
        var Kt = Pt.redMul(zt).redISub(Wt)
          , ir = bt.redAdd(bt).redMul(wt);
        return this.curve.jpoint(Nt, Kt, ir)
    }
    ,
    dt.prototype.trpl = function() {
        if (!this.curve.zeroA)
            return this.dbl().add(this);
        var yt = this.x.redSqr()
          , pt = this.y.redSqr()
          , bt = this.z.redSqr()
          , wt = pt.redSqr()
          , xt = yt.redAdd(yt).redIAdd(yt)
          , At = xt.redSqr()
          , Ct = this.x.redAdd(pt).redSqr().redISub(yt).redISub(wt);
        Ct = Ct.redIAdd(Ct),
        Ct = Ct.redAdd(Ct).redIAdd(Ct),
        Ct = Ct.redISub(At);
        var Pt = Ct.redSqr()
          , $t = wt.redIAdd(wt);
        $t = $t.redIAdd($t),
        $t = $t.redIAdd($t),
        $t = $t.redIAdd($t);
        var Ot = xt.redIAdd(Ct).redSqr().redISub(At).redISub(Pt).redISub($t)
          , Nt = pt.redMul(Ot);
        Nt = Nt.redIAdd(Nt),
        Nt = Nt.redIAdd(Nt);
        var zt = this.x.redMul(Pt).redISub(Nt);
        zt = zt.redIAdd(zt),
        zt = zt.redIAdd(zt);
        var Wt = this.y.redMul(Ot.redMul($t.redISub(Ot)).redISub(Ct.redMul(Pt)));
        Wt = Wt.redIAdd(Wt),
        Wt = Wt.redIAdd(Wt),
        Wt = Wt.redIAdd(Wt);
        var Kt = this.z.redAdd(Ct).redSqr().redISub(bt).redISub(Pt);
        return this.curve.jpoint(zt, Wt, Kt)
    }
    ,
    dt.prototype.mul = function(yt, pt) {
        return yt = new d(yt,pt),
        this.curve._wnafMul(this, yt)
    }
    ,
    dt.prototype.eq = function(yt) {
        if (yt.type === "affine")
            return this.eq(yt.toJ());
        if (this === yt)
            return !0;
        var pt = this.z.redSqr()
          , bt = yt.z.redSqr();
        if (this.x.redMul(bt).redISub(yt.x.redMul(pt)).cmpn(0) !== 0)
            return !1;
        var wt = pt.redMul(this.z)
          , xt = bt.redMul(yt.z);
        return this.y.redMul(xt).redISub(yt.y.redMul(wt)).cmpn(0) === 0
    }
    ,
    dt.prototype.eqXToP = function(yt) {
        var pt = this.z.redSqr()
          , bt = yt.toRed(this.curve.red).redMul(pt);
        if (this.x.cmp(bt) === 0)
            return !0;
        for (var wt = yt.clone(), xt = this.curve.redN.redMul(pt); ; ) {
            if (wt.iadd(this.curve.n),
            wt.cmp(this.curve.p) >= 0)
                return !1;
            if (bt.redIAdd(xt),
            this.x.cmp(bt) === 0)
                return !0
        }
    }
    ,
    dt.prototype.inspect = function() {
        return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
    }
    ,
    dt.prototype.isInfinity = function() {
        return this.z.cmpn(0) === 0
    }
    ,
    short
}
var mont, hasRequiredMont;
function requireMont() {
    if (hasRequiredMont)
        return mont;
    hasRequiredMont = 1;
    var r = requireBn$2()
      , d = requireInherits_browser()
      , f = requireBase$1()
      , m = requireUtils$1();
    function k(ee) {
        f.call(this, "mont", ee),
        this.a = new r(ee.a,16).toRed(this.red),
        this.b = new r(ee.b,16).toRed(this.red),
        this.i4 = new r(4).toRed(this.red).redInvm(),
        this.two = new r(2).toRed(this.red),
        this.a24 = this.i4.redMul(this.a.redAdd(this.two))
    }
    d(k, f),
    mont = k,
    k.prototype.validate = function(dt) {
        var mt = dt.normalize().x
          , yt = mt.redSqr()
          , pt = yt.redMul(mt).redAdd(yt.redMul(this.a)).redAdd(mt)
          , bt = pt.redSqrt();
        return bt.redSqr().cmp(pt) === 0
    }
    ;
    function y(ee, dt, mt) {
        f.BasePoint.call(this, ee, "projective"),
        dt === null && mt === null ? (this.x = this.curve.one,
        this.z = this.curve.zero) : (this.x = new r(dt,16),
        this.z = new r(mt,16),
        this.x.red || (this.x = this.x.toRed(this.curve.red)),
        this.z.red || (this.z = this.z.toRed(this.curve.red)))
    }
    return d(y, f.BasePoint),
    k.prototype.decodePoint = function(dt, mt) {
        return this.point(m.toArray(dt, mt), 1)
    }
    ,
    k.prototype.point = function(dt, mt) {
        return new y(this,dt,mt)
    }
    ,
    k.prototype.pointFromJSON = function(dt) {
        return y.fromJSON(this, dt)
    }
    ,
    y.prototype.precompute = function() {}
    ,
    y.prototype._encode = function() {
        return this.getX().toArray("be", this.curve.p.byteLength())
    }
    ,
    y.fromJSON = function(dt, mt) {
        return new y(dt,mt[0],mt[1] || dt.one)
    }
    ,
    y.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
    }
    ,
    y.prototype.isInfinity = function() {
        return this.z.cmpn(0) === 0
    }
    ,
    y.prototype.dbl = function() {
        var dt = this.x.redAdd(this.z)
          , mt = dt.redSqr()
          , yt = this.x.redSub(this.z)
          , pt = yt.redSqr()
          , bt = mt.redSub(pt)
          , wt = mt.redMul(pt)
          , xt = bt.redMul(pt.redAdd(this.curve.a24.redMul(bt)));
        return this.curve.point(wt, xt)
    }
    ,
    y.prototype.add = function() {
        throw new Error("Not supported on Montgomery curve")
    }
    ,
    y.prototype.diffAdd = function(dt, mt) {
        var yt = this.x.redAdd(this.z)
          , pt = this.x.redSub(this.z)
          , bt = dt.x.redAdd(dt.z)
          , wt = dt.x.redSub(dt.z)
          , xt = wt.redMul(yt)
          , At = bt.redMul(pt)
          , Ct = mt.z.redMul(xt.redAdd(At).redSqr())
          , Pt = mt.x.redMul(xt.redISub(At).redSqr());
        return this.curve.point(Ct, Pt)
    }
    ,
    y.prototype.mul = function(dt) {
        for (var mt = dt.clone(), yt = this, pt = this.curve.point(null, null), bt = this, wt = []; mt.cmpn(0) !== 0; mt.iushrn(1))
            wt.push(mt.andln(1));
        for (var xt = wt.length - 1; xt >= 0; xt--)
            wt[xt] === 0 ? (yt = yt.diffAdd(pt, bt),
            pt = pt.dbl()) : (pt = yt.diffAdd(pt, bt),
            yt = yt.dbl());
        return pt
    }
    ,
    y.prototype.mulAdd = function() {
        throw new Error("Not supported on Montgomery curve")
    }
    ,
    y.prototype.jumlAdd = function() {
        throw new Error("Not supported on Montgomery curve")
    }
    ,
    y.prototype.eq = function(dt) {
        return this.getX().cmp(dt.getX()) === 0
    }
    ,
    y.prototype.normalize = function() {
        return this.x = this.x.redMul(this.z.redInvm()),
        this.z = this.curve.one,
        this
    }
    ,
    y.prototype.getX = function() {
        return this.normalize(),
        this.x.fromRed()
    }
    ,
    mont
}
var edwards, hasRequiredEdwards;
function requireEdwards() {
    if (hasRequiredEdwards)
        return edwards;
    hasRequiredEdwards = 1;
    var r = requireUtils$1()
      , d = requireBn$2()
      , f = requireInherits_browser()
      , m = requireBase$1()
      , k = r.assert;
    function y(dt) {
        this.twisted = (dt.a | 0) !== 1,
        this.mOneA = this.twisted && (dt.a | 0) === -1,
        this.extended = this.mOneA,
        m.call(this, "edwards", dt),
        this.a = new d(dt.a,16).umod(this.red.m),
        this.a = this.a.toRed(this.red),
        this.c = new d(dt.c,16).toRed(this.red),
        this.c2 = this.c.redSqr(),
        this.d = new d(dt.d,16).toRed(this.red),
        this.dd = this.d.redAdd(this.d),
        k(!this.twisted || this.c.fromRed().cmpn(1) === 0),
        this.oneC = (dt.c | 0) === 1
    }
    f(y, m),
    edwards = y,
    y.prototype._mulA = function(mt) {
        return this.mOneA ? mt.redNeg() : this.a.redMul(mt)
    }
    ,
    y.prototype._mulC = function(mt) {
        return this.oneC ? mt : this.c.redMul(mt)
    }
    ,
    y.prototype.jpoint = function(mt, yt, pt, bt) {
        return this.point(mt, yt, pt, bt)
    }
    ,
    y.prototype.pointFromX = function(mt, yt) {
        mt = new d(mt,16),
        mt.red || (mt = mt.toRed(this.red));
        var pt = mt.redSqr()
          , bt = this.c2.redSub(this.a.redMul(pt))
          , wt = this.one.redSub(this.c2.redMul(this.d).redMul(pt))
          , xt = bt.redMul(wt.redInvm())
          , At = xt.redSqrt();
        if (At.redSqr().redSub(xt).cmp(this.zero) !== 0)
            throw new Error("invalid point");
        var Ct = At.fromRed().isOdd();
        return (yt && !Ct || !yt && Ct) && (At = At.redNeg()),
        this.point(mt, At)
    }
    ,
    y.prototype.pointFromY = function(mt, yt) {
        mt = new d(mt,16),
        mt.red || (mt = mt.toRed(this.red));
        var pt = mt.redSqr()
          , bt = pt.redSub(this.c2)
          , wt = pt.redMul(this.d).redMul(this.c2).redSub(this.a)
          , xt = bt.redMul(wt.redInvm());
        if (xt.cmp(this.zero) === 0) {
            if (yt)
                throw new Error("invalid point");
            return this.point(this.zero, mt)
        }
        var At = xt.redSqrt();
        if (At.redSqr().redSub(xt).cmp(this.zero) !== 0)
            throw new Error("invalid point");
        return At.fromRed().isOdd() !== yt && (At = At.redNeg()),
        this.point(At, mt)
    }
    ,
    y.prototype.validate = function(mt) {
        if (mt.isInfinity())
            return !0;
        mt.normalize();
        var yt = mt.x.redSqr()
          , pt = mt.y.redSqr()
          , bt = yt.redMul(this.a).redAdd(pt)
          , wt = this.c2.redMul(this.one.redAdd(this.d.redMul(yt).redMul(pt)));
        return bt.cmp(wt) === 0
    }
    ;
    function ee(dt, mt, yt, pt, bt) {
        m.BasePoint.call(this, dt, "projective"),
        mt === null && yt === null && pt === null ? (this.x = this.curve.zero,
        this.y = this.curve.one,
        this.z = this.curve.one,
        this.t = this.curve.zero,
        this.zOne = !0) : (this.x = new d(mt,16),
        this.y = new d(yt,16),
        this.z = pt ? new d(pt,16) : this.curve.one,
        this.t = bt && new d(bt,16),
        this.x.red || (this.x = this.x.toRed(this.curve.red)),
        this.y.red || (this.y = this.y.toRed(this.curve.red)),
        this.z.red || (this.z = this.z.toRed(this.curve.red)),
        this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)),
        this.zOne = this.z === this.curve.one,
        this.curve.extended && !this.t && (this.t = this.x.redMul(this.y),
        this.zOne || (this.t = this.t.redMul(this.z.redInvm()))))
    }
    return f(ee, m.BasePoint),
    y.prototype.pointFromJSON = function(mt) {
        return ee.fromJSON(this, mt)
    }
    ,
    y.prototype.point = function(mt, yt, pt, bt) {
        return new ee(this,mt,yt,pt,bt)
    }
    ,
    ee.fromJSON = function(mt, yt) {
        return new ee(mt,yt[0],yt[1],yt[2])
    }
    ,
    ee.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
    }
    ,
    ee.prototype.isInfinity = function() {
        return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0)
    }
    ,
    ee.prototype._extDbl = function() {
        var mt = this.x.redSqr()
          , yt = this.y.redSqr()
          , pt = this.z.redSqr();
        pt = pt.redIAdd(pt);
        var bt = this.curve._mulA(mt)
          , wt = this.x.redAdd(this.y).redSqr().redISub(mt).redISub(yt)
          , xt = bt.redAdd(yt)
          , At = xt.redSub(pt)
          , Ct = bt.redSub(yt)
          , Pt = wt.redMul(At)
          , $t = xt.redMul(Ct)
          , Ot = wt.redMul(Ct)
          , Nt = At.redMul(xt);
        return this.curve.point(Pt, $t, Nt, Ot)
    }
    ,
    ee.prototype._projDbl = function() {
        var mt = this.x.redAdd(this.y).redSqr(), yt = this.x.redSqr(), pt = this.y.redSqr(), bt, wt, xt, At, Ct, Pt;
        if (this.curve.twisted) {
            At = this.curve._mulA(yt);
            var $t = At.redAdd(pt);
            this.zOne ? (bt = mt.redSub(yt).redSub(pt).redMul($t.redSub(this.curve.two)),
            wt = $t.redMul(At.redSub(pt)),
            xt = $t.redSqr().redSub($t).redSub($t)) : (Ct = this.z.redSqr(),
            Pt = $t.redSub(Ct).redISub(Ct),
            bt = mt.redSub(yt).redISub(pt).redMul(Pt),
            wt = $t.redMul(At.redSub(pt)),
            xt = $t.redMul(Pt))
        } else
            At = yt.redAdd(pt),
            Ct = this.curve._mulC(this.z).redSqr(),
            Pt = At.redSub(Ct).redSub(Ct),
            bt = this.curve._mulC(mt.redISub(At)).redMul(Pt),
            wt = this.curve._mulC(At).redMul(yt.redISub(pt)),
            xt = At.redMul(Pt);
        return this.curve.point(bt, wt, xt)
    }
    ,
    ee.prototype.dbl = function() {
        return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl()
    }
    ,
    ee.prototype._extAdd = function(mt) {
        var yt = this.y.redSub(this.x).redMul(mt.y.redSub(mt.x))
          , pt = this.y.redAdd(this.x).redMul(mt.y.redAdd(mt.x))
          , bt = this.t.redMul(this.curve.dd).redMul(mt.t)
          , wt = this.z.redMul(mt.z.redAdd(mt.z))
          , xt = pt.redSub(yt)
          , At = wt.redSub(bt)
          , Ct = wt.redAdd(bt)
          , Pt = pt.redAdd(yt)
          , $t = xt.redMul(At)
          , Ot = Ct.redMul(Pt)
          , Nt = xt.redMul(Pt)
          , zt = At.redMul(Ct);
        return this.curve.point($t, Ot, zt, Nt)
    }
    ,
    ee.prototype._projAdd = function(mt) {
        var yt = this.z.redMul(mt.z), pt = yt.redSqr(), bt = this.x.redMul(mt.x), wt = this.y.redMul(mt.y), xt = this.curve.d.redMul(bt).redMul(wt), At = pt.redSub(xt), Ct = pt.redAdd(xt), Pt = this.x.redAdd(this.y).redMul(mt.x.redAdd(mt.y)).redISub(bt).redISub(wt), $t = yt.redMul(At).redMul(Pt), Ot, Nt;
        return this.curve.twisted ? (Ot = yt.redMul(Ct).redMul(wt.redSub(this.curve._mulA(bt))),
        Nt = At.redMul(Ct)) : (Ot = yt.redMul(Ct).redMul(wt.redSub(bt)),
        Nt = this.curve._mulC(At).redMul(Ct)),
        this.curve.point($t, Ot, Nt)
    }
    ,
    ee.prototype.add = function(mt) {
        return this.isInfinity() ? mt : mt.isInfinity() ? this : this.curve.extended ? this._extAdd(mt) : this._projAdd(mt)
    }
    ,
    ee.prototype.mul = function(mt) {
        return this._hasDoubles(mt) ? this.curve._fixedNafMul(this, mt) : this.curve._wnafMul(this, mt)
    }
    ,
    ee.prototype.mulAdd = function(mt, yt, pt) {
        return this.curve._wnafMulAdd(1, [this, yt], [mt, pt], 2, !1)
    }
    ,
    ee.prototype.jmulAdd = function(mt, yt, pt) {
        return this.curve._wnafMulAdd(1, [this, yt], [mt, pt], 2, !0)
    }
    ,
    ee.prototype.normalize = function() {
        if (this.zOne)
            return this;
        var mt = this.z.redInvm();
        return this.x = this.x.redMul(mt),
        this.y = this.y.redMul(mt),
        this.t && (this.t = this.t.redMul(mt)),
        this.z = this.curve.one,
        this.zOne = !0,
        this
    }
    ,
    ee.prototype.neg = function() {
        return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg())
    }
    ,
    ee.prototype.getX = function() {
        return this.normalize(),
        this.x.fromRed()
    }
    ,
    ee.prototype.getY = function() {
        return this.normalize(),
        this.y.fromRed()
    }
    ,
    ee.prototype.eq = function(mt) {
        return this === mt || this.getX().cmp(mt.getX()) === 0 && this.getY().cmp(mt.getY()) === 0
    }
    ,
    ee.prototype.eqXToP = function(mt) {
        var yt = mt.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(yt) === 0)
            return !0;
        for (var pt = mt.clone(), bt = this.curve.redN.redMul(this.z); ; ) {
            if (pt.iadd(this.curve.n),
            pt.cmp(this.curve.p) >= 0)
                return !1;
            if (yt.redIAdd(bt),
            this.x.cmp(yt) === 0)
                return !0
        }
    }
    ,
    ee.prototype.toP = ee.prototype.normalize,
    ee.prototype.mixedAdd = ee.prototype.add,
    edwards
}
var hasRequiredCurve;
function requireCurve() {
    return hasRequiredCurve || (hasRequiredCurve = 1,
    function(r) {
        var d = r;
        d.base = requireBase$1(),
        d.short = requireShort(),
        d.mont = requireMont(),
        d.edwards = requireEdwards()
    }(curve)),
    curve
}
var curves = {}, hash = {}, utils$2 = {}, hasRequiredUtils;
function requireUtils() {
    if (hasRequiredUtils)
        return utils$2;
    hasRequiredUtils = 1;
    var r = requireMinimalisticAssert()
      , d = requireInherits_browser();
    utils$2.inherits = d;
    function f(Mt, _t) {
        return (Mt.charCodeAt(_t) & 64512) !== 55296 || _t < 0 || _t + 1 >= Mt.length ? !1 : (Mt.charCodeAt(_t + 1) & 64512) === 56320
    }
    function m(Mt, _t) {
        if (Array.isArray(Mt))
            return Mt.slice();
        if (!Mt)
            return [];
        var gt = [];
        if (typeof Mt == "string")
            if (_t) {
                if (_t === "hex")
                    for (Mt = Mt.replace(/[^a-z0-9]+/ig, ""),
                    Mt.length % 2 !== 0 && (Mt = "0" + Mt),
                    Et = 0; Et < Mt.length; Et += 2)
                        gt.push(parseInt(Mt[Et] + Mt[Et + 1], 16))
            } else
                for (var vt = 0, Et = 0; Et < Mt.length; Et++) {
                    var Bt = Mt.charCodeAt(Et);
                    Bt < 128 ? gt[vt++] = Bt : Bt < 2048 ? (gt[vt++] = Bt >> 6 | 192,
                    gt[vt++] = Bt & 63 | 128) : f(Mt, Et) ? (Bt = 65536 + ((Bt & 1023) << 10) + (Mt.charCodeAt(++Et) & 1023),
                    gt[vt++] = Bt >> 18 | 240,
                    gt[vt++] = Bt >> 12 & 63 | 128,
                    gt[vt++] = Bt >> 6 & 63 | 128,
                    gt[vt++] = Bt & 63 | 128) : (gt[vt++] = Bt >> 12 | 224,
                    gt[vt++] = Bt >> 6 & 63 | 128,
                    gt[vt++] = Bt & 63 | 128)
                }
        else
            for (Et = 0; Et < Mt.length; Et++)
                gt[Et] = Mt[Et] | 0;
        return gt
    }
    utils$2.toArray = m;
    function k(Mt) {
        for (var _t = "", gt = 0; gt < Mt.length; gt++)
            _t += dt(Mt[gt].toString(16));
        return _t
    }
    utils$2.toHex = k;
    function y(Mt) {
        var _t = Mt >>> 24 | Mt >>> 8 & 65280 | Mt << 8 & 16711680 | (Mt & 255) << 24;
        return _t >>> 0
    }
    utils$2.htonl = y;
    function ee(Mt, _t) {
        for (var gt = "", vt = 0; vt < Mt.length; vt++) {
            var Et = Mt[vt];
            _t === "little" && (Et = y(Et)),
            gt += mt(Et.toString(16))
        }
        return gt
    }
    utils$2.toHex32 = ee;
    function dt(Mt) {
        return Mt.length === 1 ? "0" + Mt : Mt
    }
    utils$2.zero2 = dt;
    function mt(Mt) {
        return Mt.length === 7 ? "0" + Mt : Mt.length === 6 ? "00" + Mt : Mt.length === 5 ? "000" + Mt : Mt.length === 4 ? "0000" + Mt : Mt.length === 3 ? "00000" + Mt : Mt.length === 2 ? "000000" + Mt : Mt.length === 1 ? "0000000" + Mt : Mt
    }
    utils$2.zero8 = mt;
    function yt(Mt, _t, gt, vt) {
        var Et = gt - _t;
        r(Et % 4 === 0);
        for (var Bt = new Array(Et / 4), Rt = 0, kt = _t; Rt < Bt.length; Rt++,
        kt += 4) {
            var Tt;
            vt === "big" ? Tt = Mt[kt] << 24 | Mt[kt + 1] << 16 | Mt[kt + 2] << 8 | Mt[kt + 3] : Tt = Mt[kt + 3] << 24 | Mt[kt + 2] << 16 | Mt[kt + 1] << 8 | Mt[kt],
            Bt[Rt] = Tt >>> 0
        }
        return Bt
    }
    utils$2.join32 = yt;
    function pt(Mt, _t) {
        for (var gt = new Array(Mt.length * 4), vt = 0, Et = 0; vt < Mt.length; vt++,
        Et += 4) {
            var Bt = Mt[vt];
            _t === "big" ? (gt[Et] = Bt >>> 24,
            gt[Et + 1] = Bt >>> 16 & 255,
            gt[Et + 2] = Bt >>> 8 & 255,
            gt[Et + 3] = Bt & 255) : (gt[Et + 3] = Bt >>> 24,
            gt[Et + 2] = Bt >>> 16 & 255,
            gt[Et + 1] = Bt >>> 8 & 255,
            gt[Et] = Bt & 255)
        }
        return gt
    }
    utils$2.split32 = pt;
    function bt(Mt, _t) {
        return Mt >>> _t | Mt << 32 - _t
    }
    utils$2.rotr32 = bt;
    function wt(Mt, _t) {
        return Mt << _t | Mt >>> 32 - _t
    }
    utils$2.rotl32 = wt;
    function xt(Mt, _t) {
        return Mt + _t >>> 0
    }
    utils$2.sum32 = xt;
    function At(Mt, _t, gt) {
        return Mt + _t + gt >>> 0
    }
    utils$2.sum32_3 = At;
    function Ct(Mt, _t, gt, vt) {
        return Mt + _t + gt + vt >>> 0
    }
    utils$2.sum32_4 = Ct;
    function Pt(Mt, _t, gt, vt, Et) {
        return Mt + _t + gt + vt + Et >>> 0
    }
    utils$2.sum32_5 = Pt;
    function $t(Mt, _t, gt, vt) {
        var Et = Mt[_t]
          , Bt = Mt[_t + 1]
          , Rt = vt + Bt >>> 0
          , kt = (Rt < vt ? 1 : 0) + gt + Et;
        Mt[_t] = kt >>> 0,
        Mt[_t + 1] = Rt
    }
    utils$2.sum64 = $t;
    function Ot(Mt, _t, gt, vt) {
        var Et = _t + vt >>> 0
          , Bt = (Et < _t ? 1 : 0) + Mt + gt;
        return Bt >>> 0
    }
    utils$2.sum64_hi = Ot;
    function Nt(Mt, _t, gt, vt) {
        var Et = _t + vt;
        return Et >>> 0
    }
    utils$2.sum64_lo = Nt;
    function zt(Mt, _t, gt, vt, Et, Bt, Rt, kt) {
        var Tt = 0
          , It = _t;
        It = It + vt >>> 0,
        Tt += It < _t ? 1 : 0,
        It = It + Bt >>> 0,
        Tt += It < Bt ? 1 : 0,
        It = It + kt >>> 0,
        Tt += It < kt ? 1 : 0;
        var St = Mt + gt + Et + Rt + Tt;
        return St >>> 0
    }
    utils$2.sum64_4_hi = zt;
    function Wt(Mt, _t, gt, vt, Et, Bt, Rt, kt) {
        var Tt = _t + vt + Bt + kt;
        return Tt >>> 0
    }
    utils$2.sum64_4_lo = Wt;
    function Kt(Mt, _t, gt, vt, Et, Bt, Rt, kt, Tt, It) {
        var St = 0
          , qt = _t;
        qt = qt + vt >>> 0,
        St += qt < _t ? 1 : 0,
        qt = qt + Bt >>> 0,
        St += qt < Bt ? 1 : 0,
        qt = qt + kt >>> 0,
        St += qt < kt ? 1 : 0,
        qt = qt + It >>> 0,
        St += qt < It ? 1 : 0;
        var ur = Mt + gt + Et + Rt + Tt + St;
        return ur >>> 0
    }
    utils$2.sum64_5_hi = Kt;
    function ir(Mt, _t, gt, vt, Et, Bt, Rt, kt, Tt, It) {
        var St = _t + vt + Bt + kt + It;
        return St >>> 0
    }
    utils$2.sum64_5_lo = ir;
    function or(Mt, _t, gt) {
        var vt = _t << 32 - gt | Mt >>> gt;
        return vt >>> 0
    }
    utils$2.rotr64_hi = or;
    function tr(Mt, _t, gt) {
        var vt = Mt << 32 - gt | _t >>> gt;
        return vt >>> 0
    }
    utils$2.rotr64_lo = tr;
    function wr(Mt, _t, gt) {
        return Mt >>> gt
    }
    utils$2.shr64_hi = wr;
    function Ht(Mt, _t, gt) {
        var vt = Mt << 32 - gt | _t >>> gt;
        return vt >>> 0
    }
    return utils$2.shr64_lo = Ht,
    utils$2
}
var common$3 = {}, hasRequiredCommon$1;
function requireCommon$1() {
    if (hasRequiredCommon$1)
        return common$3;
    hasRequiredCommon$1 = 1;
    var r = requireUtils()
      , d = requireMinimalisticAssert();
    function f() {
        this.pending = null,
        this.pendingTotal = 0,
        this.blockSize = this.constructor.blockSize,
        this.outSize = this.constructor.outSize,
        this.hmacStrength = this.constructor.hmacStrength,
        this.padLength = this.constructor.padLength / 8,
        this.endian = "big",
        this._delta8 = this.blockSize / 8,
        this._delta32 = this.blockSize / 32
    }
    return common$3.BlockHash = f,
    f.prototype.update = function(k, y) {
        if (k = r.toArray(k, y),
        this.pending ? this.pending = this.pending.concat(k) : this.pending = k,
        this.pendingTotal += k.length,
        this.pending.length >= this._delta8) {
            k = this.pending;
            var ee = k.length % this._delta8;
            this.pending = k.slice(k.length - ee, k.length),
            this.pending.length === 0 && (this.pending = null),
            k = r.join32(k, 0, k.length - ee, this.endian);
            for (var dt = 0; dt < k.length; dt += this._delta32)
                this._update(k, dt, dt + this._delta32)
        }
        return this
    }
    ,
    f.prototype.digest = function(k) {
        return this.update(this._pad()),
        d(this.pending === null),
        this._digest(k)
    }
    ,
    f.prototype._pad = function() {
        var k = this.pendingTotal
          , y = this._delta8
          , ee = y - (k + this.padLength) % y
          , dt = new Array(ee + this.padLength);
        dt[0] = 128;
        for (var mt = 1; mt < ee; mt++)
            dt[mt] = 0;
        if (k <<= 3,
        this.endian === "big") {
            for (var yt = 8; yt < this.padLength; yt++)
                dt[mt++] = 0;
            dt[mt++] = 0,
            dt[mt++] = 0,
            dt[mt++] = 0,
            dt[mt++] = 0,
            dt[mt++] = k >>> 24 & 255,
            dt[mt++] = k >>> 16 & 255,
            dt[mt++] = k >>> 8 & 255,
            dt[mt++] = k & 255
        } else
            for (dt[mt++] = k & 255,
            dt[mt++] = k >>> 8 & 255,
            dt[mt++] = k >>> 16 & 255,
            dt[mt++] = k >>> 24 & 255,
            dt[mt++] = 0,
            dt[mt++] = 0,
            dt[mt++] = 0,
            dt[mt++] = 0,
            yt = 8; yt < this.padLength; yt++)
                dt[mt++] = 0;
        return dt
    }
    ,
    common$3
}
var sha$1 = {}, common$2 = {}, hasRequiredCommon;
function requireCommon() {
    if (hasRequiredCommon)
        return common$2;
    hasRequiredCommon = 1;
    var r = requireUtils()
      , d = r.rotr32;
    function f(pt, bt, wt, xt) {
        if (pt === 0)
            return m(bt, wt, xt);
        if (pt === 1 || pt === 3)
            return y(bt, wt, xt);
        if (pt === 2)
            return k(bt, wt, xt)
    }
    common$2.ft_1 = f;
    function m(pt, bt, wt) {
        return pt & bt ^ ~pt & wt
    }
    common$2.ch32 = m;
    function k(pt, bt, wt) {
        return pt & bt ^ pt & wt ^ bt & wt
    }
    common$2.maj32 = k;
    function y(pt, bt, wt) {
        return pt ^ bt ^ wt
    }
    common$2.p32 = y;
    function ee(pt) {
        return d(pt, 2) ^ d(pt, 13) ^ d(pt, 22)
    }
    common$2.s0_256 = ee;
    function dt(pt) {
        return d(pt, 6) ^ d(pt, 11) ^ d(pt, 25)
    }
    common$2.s1_256 = dt;
    function mt(pt) {
        return d(pt, 7) ^ d(pt, 18) ^ pt >>> 3
    }
    common$2.g0_256 = mt;
    function yt(pt) {
        return d(pt, 17) ^ d(pt, 19) ^ pt >>> 10
    }
    return common$2.g1_256 = yt,
    common$2
}
var _1, hasRequired_1;
function require_1() {
    if (hasRequired_1)
        return _1;
    hasRequired_1 = 1;
    var r = requireUtils()
      , d = requireCommon$1()
      , f = requireCommon()
      , m = r.rotl32
      , k = r.sum32
      , y = r.sum32_5
      , ee = f.ft_1
      , dt = d.BlockHash
      , mt = [1518500249, 1859775393, 2400959708, 3395469782];
    function yt() {
        if (!(this instanceof yt))
            return new yt;
        dt.call(this),
        this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520],
        this.W = new Array(80)
    }
    return r.inherits(yt, dt),
    _1 = yt,
    yt.blockSize = 512,
    yt.outSize = 160,
    yt.hmacStrength = 80,
    yt.padLength = 64,
    yt.prototype._update = function(bt, wt) {
        for (var xt = this.W, At = 0; At < 16; At++)
            xt[At] = bt[wt + At];
        for (; At < xt.length; At++)
            xt[At] = m(xt[At - 3] ^ xt[At - 8] ^ xt[At - 14] ^ xt[At - 16], 1);
        var Ct = this.h[0]
          , Pt = this.h[1]
          , $t = this.h[2]
          , Ot = this.h[3]
          , Nt = this.h[4];
        for (At = 0; At < xt.length; At++) {
            var zt = ~~(At / 20)
              , Wt = y(m(Ct, 5), ee(zt, Pt, $t, Ot), Nt, xt[At], mt[zt]);
            Nt = Ot,
            Ot = $t,
            $t = m(Pt, 30),
            Pt = Ct,
            Ct = Wt
        }
        this.h[0] = k(this.h[0], Ct),
        this.h[1] = k(this.h[1], Pt),
        this.h[2] = k(this.h[2], $t),
        this.h[3] = k(this.h[3], Ot),
        this.h[4] = k(this.h[4], Nt)
    }
    ,
    yt.prototype._digest = function(bt) {
        return bt === "hex" ? r.toHex32(this.h, "big") : r.split32(this.h, "big")
    }
    ,
    _1
}
var _256, hasRequired_256;
function require_256() {
    if (hasRequired_256)
        return _256;
    hasRequired_256 = 1;
    var r = requireUtils()
      , d = requireCommon$1()
      , f = requireCommon()
      , m = requireMinimalisticAssert()
      , k = r.sum32
      , y = r.sum32_4
      , ee = r.sum32_5
      , dt = f.ch32
      , mt = f.maj32
      , yt = f.s0_256
      , pt = f.s1_256
      , bt = f.g0_256
      , wt = f.g1_256
      , xt = d.BlockHash
      , At = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    function Ct() {
        if (!(this instanceof Ct))
            return new Ct;
        xt.call(this),
        this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225],
        this.k = At,
        this.W = new Array(64)
    }
    return r.inherits(Ct, xt),
    _256 = Ct,
    Ct.blockSize = 512,
    Ct.outSize = 256,
    Ct.hmacStrength = 192,
    Ct.padLength = 64,
    Ct.prototype._update = function($t, Ot) {
        for (var Nt = this.W, zt = 0; zt < 16; zt++)
            Nt[zt] = $t[Ot + zt];
        for (; zt < Nt.length; zt++)
            Nt[zt] = y(wt(Nt[zt - 2]), Nt[zt - 7], bt(Nt[zt - 15]), Nt[zt - 16]);
        var Wt = this.h[0]
          , Kt = this.h[1]
          , ir = this.h[2]
          , or = this.h[3]
          , tr = this.h[4]
          , wr = this.h[5]
          , Ht = this.h[6]
          , Mt = this.h[7];
        for (m(this.k.length === Nt.length),
        zt = 0; zt < Nt.length; zt++) {
            var _t = ee(Mt, pt(tr), dt(tr, wr, Ht), this.k[zt], Nt[zt])
              , gt = k(yt(Wt), mt(Wt, Kt, ir));
            Mt = Ht,
            Ht = wr,
            wr = tr,
            tr = k(or, _t),
            or = ir,
            ir = Kt,
            Kt = Wt,
            Wt = k(_t, gt)
        }
        this.h[0] = k(this.h[0], Wt),
        this.h[1] = k(this.h[1], Kt),
        this.h[2] = k(this.h[2], ir),
        this.h[3] = k(this.h[3], or),
        this.h[4] = k(this.h[4], tr),
        this.h[5] = k(this.h[5], wr),
        this.h[6] = k(this.h[6], Ht),
        this.h[7] = k(this.h[7], Mt)
    }
    ,
    Ct.prototype._digest = function($t) {
        return $t === "hex" ? r.toHex32(this.h, "big") : r.split32(this.h, "big")
    }
    ,
    _256
}
var _224, hasRequired_224;
function require_224() {
    if (hasRequired_224)
        return _224;
    hasRequired_224 = 1;
    var r = requireUtils()
      , d = require_256();
    function f() {
        if (!(this instanceof f))
            return new f;
        d.call(this),
        this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
    }
    return r.inherits(f, d),
    _224 = f,
    f.blockSize = 512,
    f.outSize = 224,
    f.hmacStrength = 192,
    f.padLength = 64,
    f.prototype._digest = function(k) {
        return k === "hex" ? r.toHex32(this.h.slice(0, 7), "big") : r.split32(this.h.slice(0, 7), "big")
    }
    ,
    _224
}
var _512, hasRequired_512;
function require_512() {
    if (hasRequired_512)
        return _512;
    hasRequired_512 = 1;
    var r = requireUtils()
      , d = requireCommon$1()
      , f = requireMinimalisticAssert()
      , m = r.rotr64_hi
      , k = r.rotr64_lo
      , y = r.shr64_hi
      , ee = r.shr64_lo
      , dt = r.sum64
      , mt = r.sum64_hi
      , yt = r.sum64_lo
      , pt = r.sum64_4_hi
      , bt = r.sum64_4_lo
      , wt = r.sum64_5_hi
      , xt = r.sum64_5_lo
      , At = d.BlockHash
      , Ct = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function Pt() {
        if (!(this instanceof Pt))
            return new Pt;
        At.call(this),
        this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209],
        this.k = Ct,
        this.W = new Array(160)
    }
    r.inherits(Pt, At),
    _512 = Pt,
    Pt.blockSize = 1024,
    Pt.outSize = 512,
    Pt.hmacStrength = 192,
    Pt.padLength = 128,
    Pt.prototype._prepareBlock = function(gt, vt) {
        for (var Et = this.W, Bt = 0; Bt < 32; Bt++)
            Et[Bt] = gt[vt + Bt];
        for (; Bt < Et.length; Bt += 2) {
            var Rt = Ht(Et[Bt - 4], Et[Bt - 3])
              , kt = Mt(Et[Bt - 4], Et[Bt - 3])
              , Tt = Et[Bt - 14]
              , It = Et[Bt - 13]
              , St = tr(Et[Bt - 30], Et[Bt - 29])
              , qt = wr(Et[Bt - 30], Et[Bt - 29])
              , ur = Et[Bt - 32]
              , gr = Et[Bt - 31];
            Et[Bt] = pt(Rt, kt, Tt, It, St, qt, ur, gr),
            Et[Bt + 1] = bt(Rt, kt, Tt, It, St, qt, ur, gr)
        }
    }
    ,
    Pt.prototype._update = function(gt, vt) {
        this._prepareBlock(gt, vt);
        var Et = this.W
          , Bt = this.h[0]
          , Rt = this.h[1]
          , kt = this.h[2]
          , Tt = this.h[3]
          , It = this.h[4]
          , St = this.h[5]
          , qt = this.h[6]
          , ur = this.h[7]
          , gr = this.h[8]
          , lr = this.h[9]
          , Zt = this.h[10]
          , Vt = this.h[11]
          , rr = this.h[12]
          , fr = this.h[13]
          , Yt = this.h[14]
          , Xt = this.h[15];
        f(this.k.length === Et.length);
        for (var Sr = 0; Sr < Et.length; Sr += 2) {
            var Rr = Yt
              , qr = Xt
              , Nr = ir(gr, lr)
              , Dr = or(gr, lr)
              , Or = $t(gr, lr, Zt, Vt, rr)
              , $r = Ot(gr, lr, Zt, Vt, rr, fr)
              , Zr = this.k[Sr]
              , Hr = this.k[Sr + 1]
              , un = Et[Sr]
              , Qr = Et[Sr + 1]
              , Gr = wt(Rr, qr, Nr, Dr, Or, $r, Zr, Hr, un, Qr)
              , vr = xt(Rr, qr, Nr, Dr, Or, $r, Zr, Hr, un, Qr);
            Rr = Wt(Bt, Rt),
            qr = Kt(Bt, Rt),
            Nr = Nt(Bt, Rt, kt, Tt, It),
            Dr = zt(Bt, Rt, kt, Tt, It, St);
            var ar = mt(Rr, qr, Nr, Dr)
              , hr = yt(Rr, qr, Nr, Dr);
            Yt = rr,
            Xt = fr,
            rr = Zt,
            fr = Vt,
            Zt = gr,
            Vt = lr,
            gr = mt(qt, ur, Gr, vr),
            lr = yt(ur, ur, Gr, vr),
            qt = It,
            ur = St,
            It = kt,
            St = Tt,
            kt = Bt,
            Tt = Rt,
            Bt = mt(Gr, vr, ar, hr),
            Rt = yt(Gr, vr, ar, hr)
        }
        dt(this.h, 0, Bt, Rt),
        dt(this.h, 2, kt, Tt),
        dt(this.h, 4, It, St),
        dt(this.h, 6, qt, ur),
        dt(this.h, 8, gr, lr),
        dt(this.h, 10, Zt, Vt),
        dt(this.h, 12, rr, fr),
        dt(this.h, 14, Yt, Xt)
    }
    ,
    Pt.prototype._digest = function(gt) {
        return gt === "hex" ? r.toHex32(this.h, "big") : r.split32(this.h, "big")
    }
    ;
    function $t(_t, gt, vt, Et, Bt) {
        var Rt = _t & vt ^ ~_t & Bt;
        return Rt < 0 && (Rt += 4294967296),
        Rt
    }
    function Ot(_t, gt, vt, Et, Bt, Rt) {
        var kt = gt & Et ^ ~gt & Rt;
        return kt < 0 && (kt += 4294967296),
        kt
    }
    function Nt(_t, gt, vt, Et, Bt) {
        var Rt = _t & vt ^ _t & Bt ^ vt & Bt;
        return Rt < 0 && (Rt += 4294967296),
        Rt
    }
    function zt(_t, gt, vt, Et, Bt, Rt) {
        var kt = gt & Et ^ gt & Rt ^ Et & Rt;
        return kt < 0 && (kt += 4294967296),
        kt
    }
    function Wt(_t, gt) {
        var vt = m(_t, gt, 28)
          , Et = m(gt, _t, 2)
          , Bt = m(gt, _t, 7)
          , Rt = vt ^ Et ^ Bt;
        return Rt < 0 && (Rt += 4294967296),
        Rt
    }
    function Kt(_t, gt) {
        var vt = k(_t, gt, 28)
          , Et = k(gt, _t, 2)
          , Bt = k(gt, _t, 7)
          , Rt = vt ^ Et ^ Bt;
        return Rt < 0 && (Rt += 4294967296),
        Rt
    }
    function ir(_t, gt) {
        var vt = m(_t, gt, 14)
          , Et = m(_t, gt, 18)
          , Bt = m(gt, _t, 9)
          , Rt = vt ^ Et ^ Bt;
        return Rt < 0 && (Rt += 4294967296),
        Rt
    }
    function or(_t, gt) {
        var vt = k(_t, gt, 14)
          , Et = k(_t, gt, 18)
          , Bt = k(gt, _t, 9)
          , Rt = vt ^ Et ^ Bt;
        return Rt < 0 && (Rt += 4294967296),
        Rt
    }
    function tr(_t, gt) {
        var vt = m(_t, gt, 1)
          , Et = m(_t, gt, 8)
          , Bt = y(_t, gt, 7)
          , Rt = vt ^ Et ^ Bt;
        return Rt < 0 && (Rt += 4294967296),
        Rt
    }
    function wr(_t, gt) {
        var vt = k(_t, gt, 1)
          , Et = k(_t, gt, 8)
          , Bt = ee(_t, gt, 7)
          , Rt = vt ^ Et ^ Bt;
        return Rt < 0 && (Rt += 4294967296),
        Rt
    }
    function Ht(_t, gt) {
        var vt = m(_t, gt, 19)
          , Et = m(gt, _t, 29)
          , Bt = y(_t, gt, 6)
          , Rt = vt ^ Et ^ Bt;
        return Rt < 0 && (Rt += 4294967296),
        Rt
    }
    function Mt(_t, gt) {
        var vt = k(_t, gt, 19)
          , Et = k(gt, _t, 29)
          , Bt = ee(_t, gt, 6)
          , Rt = vt ^ Et ^ Bt;
        return Rt < 0 && (Rt += 4294967296),
        Rt
    }
    return _512
}
var _384, hasRequired_384;
function require_384() {
    if (hasRequired_384)
        return _384;
    hasRequired_384 = 1;
    var r = requireUtils()
      , d = require_512();
    function f() {
        if (!(this instanceof f))
            return new f;
        d.call(this),
        this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]
    }
    return r.inherits(f, d),
    _384 = f,
    f.blockSize = 1024,
    f.outSize = 384,
    f.hmacStrength = 192,
    f.padLength = 128,
    f.prototype._digest = function(k) {
        return k === "hex" ? r.toHex32(this.h.slice(0, 12), "big") : r.split32(this.h.slice(0, 12), "big")
    }
    ,
    _384
}
var hasRequiredSha;
function requireSha() {
    return hasRequiredSha || (hasRequiredSha = 1,
    sha$1.sha1 = require_1(),
    sha$1.sha224 = require_224(),
    sha$1.sha256 = require_256(),
    sha$1.sha384 = require_384(),
    sha$1.sha512 = require_512()),
    sha$1
}
var ripemd = {}, hasRequiredRipemd;
function requireRipemd() {
    if (hasRequiredRipemd)
        return ripemd;
    hasRequiredRipemd = 1;
    var r = requireUtils()
      , d = requireCommon$1()
      , f = r.rotl32
      , m = r.sum32
      , k = r.sum32_3
      , y = r.sum32_4
      , ee = d.BlockHash;
    function dt() {
        if (!(this instanceof dt))
            return new dt;
        ee.call(this),
        this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520],
        this.endian = "little"
    }
    r.inherits(dt, ee),
    ripemd.ripemd160 = dt,
    dt.blockSize = 512,
    dt.outSize = 160,
    dt.hmacStrength = 192,
    dt.padLength = 64,
    dt.prototype._update = function(Pt, $t) {
        for (var Ot = this.h[0], Nt = this.h[1], zt = this.h[2], Wt = this.h[3], Kt = this.h[4], ir = Ot, or = Nt, tr = zt, wr = Wt, Ht = Kt, Mt = 0; Mt < 80; Mt++) {
            var _t = m(f(y(Ot, mt(Mt, Nt, zt, Wt), Pt[bt[Mt] + $t], yt(Mt)), xt[Mt]), Kt);
            Ot = Kt,
            Kt = Wt,
            Wt = f(zt, 10),
            zt = Nt,
            Nt = _t,
            _t = m(f(y(ir, mt(79 - Mt, or, tr, wr), Pt[wt[Mt] + $t], pt(Mt)), At[Mt]), Ht),
            ir = Ht,
            Ht = wr,
            wr = f(tr, 10),
            tr = or,
            or = _t
        }
        _t = k(this.h[1], zt, wr),
        this.h[1] = k(this.h[2], Wt, Ht),
        this.h[2] = k(this.h[3], Kt, ir),
        this.h[3] = k(this.h[4], Ot, or),
        this.h[4] = k(this.h[0], Nt, tr),
        this.h[0] = _t
    }
    ,
    dt.prototype._digest = function(Pt) {
        return Pt === "hex" ? r.toHex32(this.h, "little") : r.split32(this.h, "little")
    }
    ;
    function mt(Ct, Pt, $t, Ot) {
        return Ct <= 15 ? Pt ^ $t ^ Ot : Ct <= 31 ? Pt & $t | ~Pt & Ot : Ct <= 47 ? (Pt | ~$t) ^ Ot : Ct <= 63 ? Pt & Ot | $t & ~Ot : Pt ^ ($t | ~Ot)
    }
    function yt(Ct) {
        return Ct <= 15 ? 0 : Ct <= 31 ? 1518500249 : Ct <= 47 ? 1859775393 : Ct <= 63 ? 2400959708 : 2840853838
    }
    function pt(Ct) {
        return Ct <= 15 ? 1352829926 : Ct <= 31 ? 1548603684 : Ct <= 47 ? 1836072691 : Ct <= 63 ? 2053994217 : 0
    }
    var bt = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]
      , wt = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]
      , xt = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]
      , At = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
    return ripemd
}
var hmac, hasRequiredHmac;
function requireHmac() {
    if (hasRequiredHmac)
        return hmac;
    hasRequiredHmac = 1;
    var r = requireUtils()
      , d = requireMinimalisticAssert();
    function f(m, k, y) {
        if (!(this instanceof f))
            return new f(m,k,y);
        this.Hash = m,
        this.blockSize = m.blockSize / 8,
        this.outSize = m.outSize / 8,
        this.inner = null,
        this.outer = null,
        this._init(r.toArray(k, y))
    }
    return hmac = f,
    f.prototype._init = function(k) {
        k.length > this.blockSize && (k = new this.Hash().update(k).digest()),
        d(k.length <= this.blockSize);
        for (var y = k.length; y < this.blockSize; y++)
            k.push(0);
        for (y = 0; y < k.length; y++)
            k[y] ^= 54;
        for (this.inner = new this.Hash().update(k),
        y = 0; y < k.length; y++)
            k[y] ^= 106;
        this.outer = new this.Hash().update(k)
    }
    ,
    f.prototype.update = function(k, y) {
        return this.inner.update(k, y),
        this
    }
    ,
    f.prototype.digest = function(k) {
        return this.outer.update(this.inner.digest()),
        this.outer.digest(k)
    }
    ,
    hmac
}
var hasRequiredHash;
function requireHash() {
    return hasRequiredHash || (hasRequiredHash = 1,
    function(r) {
        var d = r;
        d.utils = requireUtils(),
        d.common = requireCommon$1(),
        d.sha = requireSha(),
        d.ripemd = requireRipemd(),
        d.hmac = requireHmac(),
        d.sha1 = d.sha.sha1,
        d.sha256 = d.sha.sha256,
        d.sha224 = d.sha.sha224,
        d.sha384 = d.sha.sha384,
        d.sha512 = d.sha.sha512,
        d.ripemd160 = d.ripemd.ripemd160
    }(hash)),
    hash
}
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
    return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1,
    secp256k1 = {
        doubles: {
            step: 4,
            points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]]
        },
        naf: {
            wnd: 7,
            points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]]
        }
    }),
    secp256k1
}
var hasRequiredCurves;
function requireCurves() {
    return hasRequiredCurves || (hasRequiredCurves = 1,
    function(r) {
        var d = r
          , f = requireHash()
          , m = requireCurve()
          , k = requireUtils$1()
          , y = k.assert;
        function ee(yt) {
            yt.type === "short" ? this.curve = new m.short(yt) : yt.type === "edwards" ? this.curve = new m.edwards(yt) : this.curve = new m.mont(yt),
            this.g = this.curve.g,
            this.n = this.curve.n,
            this.hash = yt.hash,
            y(this.g.validate(), "Invalid curve"),
            y(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
        }
        d.PresetCurve = ee;
        function dt(yt, pt) {
            Object.defineProperty(d, yt, {
                configurable: !0,
                enumerable: !0,
                get: function() {
                    var bt = new ee(pt);
                    return Object.defineProperty(d, yt, {
                        configurable: !0,
                        enumerable: !0,
                        value: bt
                    }),
                    bt
                }
            })
        }
        dt("p192", {
            type: "short",
            prime: "p192",
            p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
            b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
            n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
            hash: f.sha256,
            gRed: !1,
            g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
        }),
        dt("p224", {
            type: "short",
            prime: "p224",
            p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
            b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
            n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
            hash: f.sha256,
            gRed: !1,
            g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
        }),
        dt("p256", {
            type: "short",
            prime: null,
            p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
            a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
            b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
            n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
            hash: f.sha256,
            gRed: !1,
            g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
        }),
        dt("p384", {
            type: "short",
            prime: null,
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
            a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
            b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
            n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
            hash: f.sha384,
            gRed: !1,
            g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
        }),
        dt("p521", {
            type: "short",
            prime: null,
            p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
            a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
            b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
            n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
            hash: f.sha512,
            gRed: !1,
            g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
        }),
        dt("curve25519", {
            type: "mont",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "76d06",
            b: "1",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: f.sha256,
            gRed: !1,
            g: ["9"]
        }),
        dt("ed25519", {
            type: "edwards",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "-1",
            c: "1",
            d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: f.sha256,
            gRed: !1,
            g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
        });
        var mt;
        try {
            mt = requireSecp256k1()
        } catch {
            mt = void 0
        }
        dt("secp256k1", {
            type: "short",
            prime: "k256",
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            a: "0",
            b: "7",
            n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
            h: "1",
            hash: f.sha256,
            beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
            lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
            basis: [{
                a: "3086d221a7d46bcde86c90e49284eb15",
                b: "-e4437ed6010e88286f547fa90abfe4c3"
            }, {
                a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
                b: "3086d221a7d46bcde86c90e49284eb15"
            }],
            gRed: !1,
            g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", mt]
        })
    }(curves)),
    curves
}
var hmacDrbg, hasRequiredHmacDrbg;
function requireHmacDrbg() {
    if (hasRequiredHmacDrbg)
        return hmacDrbg;
    hasRequiredHmacDrbg = 1;
    var r = requireHash()
      , d = requireUtils$2()
      , f = requireMinimalisticAssert();
    function m(k) {
        if (!(this instanceof m))
            return new m(k);
        this.hash = k.hash,
        this.predResist = !!k.predResist,
        this.outLen = this.hash.outSize,
        this.minEntropy = k.minEntropy || this.hash.hmacStrength,
        this._reseed = null,
        this.reseedInterval = null,
        this.K = null,
        this.V = null;
        var y = d.toArray(k.entropy, k.entropyEnc || "hex")
          , ee = d.toArray(k.nonce, k.nonceEnc || "hex")
          , dt = d.toArray(k.pers, k.persEnc || "hex");
        f(y.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"),
        this._init(y, ee, dt)
    }
    return hmacDrbg = m,
    m.prototype._init = function(y, ee, dt) {
        var mt = y.concat(ee).concat(dt);
        this.K = new Array(this.outLen / 8),
        this.V = new Array(this.outLen / 8);
        for (var yt = 0; yt < this.V.length; yt++)
            this.K[yt] = 0,
            this.V[yt] = 1;
        this._update(mt),
        this._reseed = 1,
        this.reseedInterval = 281474976710656
    }
    ,
    m.prototype._hmac = function() {
        return new r.hmac(this.hash,this.K)
    }
    ,
    m.prototype._update = function(y) {
        var ee = this._hmac().update(this.V).update([0]);
        y && (ee = ee.update(y)),
        this.K = ee.digest(),
        this.V = this._hmac().update(this.V).digest(),
        y && (this.K = this._hmac().update(this.V).update([1]).update(y).digest(),
        this.V = this._hmac().update(this.V).digest())
    }
    ,
    m.prototype.reseed = function(y, ee, dt, mt) {
        typeof ee != "string" && (mt = dt,
        dt = ee,
        ee = null),
        y = d.toArray(y, ee),
        dt = d.toArray(dt, mt),
        f(y.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"),
        this._update(y.concat(dt || [])),
        this._reseed = 1
    }
    ,
    m.prototype.generate = function(y, ee, dt, mt) {
        if (this._reseed > this.reseedInterval)
            throw new Error("Reseed is required");
        typeof ee != "string" && (mt = dt,
        dt = ee,
        ee = null),
        dt && (dt = d.toArray(dt, mt || "hex"),
        this._update(dt));
        for (var yt = []; yt.length < y; )
            this.V = this._hmac().update(this.V).digest(),
            yt = yt.concat(this.V);
        var pt = yt.slice(0, y);
        return this._update(dt),
        this._reseed++,
        d.encode(pt, ee)
    }
    ,
    hmacDrbg
}
var key$1, hasRequiredKey$1;
function requireKey$1() {
    if (hasRequiredKey$1)
        return key$1;
    hasRequiredKey$1 = 1;
    var r = requireBn$2()
      , d = requireUtils$1()
      , f = d.assert;
    function m(k, y) {
        this.ec = k,
        this.priv = null,
        this.pub = null,
        y.priv && this._importPrivate(y.priv, y.privEnc),
        y.pub && this._importPublic(y.pub, y.pubEnc)
    }
    return key$1 = m,
    m.fromPublic = function(y, ee, dt) {
        return ee instanceof m ? ee : new m(y,{
            pub: ee,
            pubEnc: dt
        })
    }
    ,
    m.fromPrivate = function(y, ee, dt) {
        return ee instanceof m ? ee : new m(y,{
            priv: ee,
            privEnc: dt
        })
    }
    ,
    m.prototype.validate = function() {
        var y = this.getPublic();
        return y.isInfinity() ? {
            result: !1,
            reason: "Invalid public key"
        } : y.validate() ? y.mul(this.ec.curve.n).isInfinity() ? {
            result: !0,
            reason: null
        } : {
            result: !1,
            reason: "Public key * N != O"
        } : {
            result: !1,
            reason: "Public key is not a point"
        }
    }
    ,
    m.prototype.getPublic = function(y, ee) {
        return typeof y == "string" && (ee = y,
        y = null),
        this.pub || (this.pub = this.ec.g.mul(this.priv)),
        ee ? this.pub.encode(ee, y) : this.pub
    }
    ,
    m.prototype.getPrivate = function(y) {
        return y === "hex" ? this.priv.toString(16, 2) : this.priv
    }
    ,
    m.prototype._importPrivate = function(y, ee) {
        this.priv = new r(y,ee || 16),
        this.priv = this.priv.umod(this.ec.curve.n)
    }
    ,
    m.prototype._importPublic = function(y, ee) {
        if (y.x || y.y) {
            this.ec.curve.type === "mont" ? f(y.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && f(y.x && y.y, "Need both x and y coordinate"),
            this.pub = this.ec.curve.point(y.x, y.y);
            return
        }
        this.pub = this.ec.curve.decodePoint(y, ee)
    }
    ,
    m.prototype.derive = function(y) {
        return y.validate() || f(y.validate(), "public point not validated"),
        y.mul(this.priv).getX()
    }
    ,
    m.prototype.sign = function(y, ee, dt) {
        return this.ec.sign(y, this, ee, dt)
    }
    ,
    m.prototype.verify = function(y, ee) {
        return this.ec.verify(y, ee, this)
    }
    ,
    m.prototype.inspect = function() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
    }
    ,
    key$1
}
var signature$1, hasRequiredSignature$1;
function requireSignature$1() {
    if (hasRequiredSignature$1)
        return signature$1;
    hasRequiredSignature$1 = 1;
    var r = requireBn$2()
      , d = requireUtils$1()
      , f = d.assert;
    function m(mt, yt) {
        if (mt instanceof m)
            return mt;
        this._importDER(mt, yt) || (f(mt.r && mt.s, "Signature without r or s"),
        this.r = new r(mt.r,16),
        this.s = new r(mt.s,16),
        mt.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = mt.recoveryParam)
    }
    signature$1 = m;
    function k() {
        this.place = 0
    }
    function y(mt, yt) {
        var pt = mt[yt.place++];
        if (!(pt & 128))
            return pt;
        var bt = pt & 15;
        if (bt === 0 || bt > 4)
            return !1;
        for (var wt = 0, xt = 0, At = yt.place; xt < bt; xt++,
        At++)
            wt <<= 8,
            wt |= mt[At],
            wt >>>= 0;
        return wt <= 127 ? !1 : (yt.place = At,
        wt)
    }
    function ee(mt) {
        for (var yt = 0, pt = mt.length - 1; !mt[yt] && !(mt[yt + 1] & 128) && yt < pt; )
            yt++;
        return yt === 0 ? mt : mt.slice(yt)
    }
    m.prototype._importDER = function(yt, pt) {
        yt = d.toArray(yt, pt);
        var bt = new k;
        if (yt[bt.place++] !== 48)
            return !1;
        var wt = y(yt, bt);
        if (wt === !1 || wt + bt.place !== yt.length || yt[bt.place++] !== 2)
            return !1;
        var xt = y(yt, bt);
        if (xt === !1)
            return !1;
        var At = yt.slice(bt.place, xt + bt.place);
        if (bt.place += xt,
        yt[bt.place++] !== 2)
            return !1;
        var Ct = y(yt, bt);
        if (Ct === !1 || yt.length !== Ct + bt.place)
            return !1;
        var Pt = yt.slice(bt.place, Ct + bt.place);
        if (At[0] === 0)
            if (At[1] & 128)
                At = At.slice(1);
            else
                return !1;
        if (Pt[0] === 0)
            if (Pt[1] & 128)
                Pt = Pt.slice(1);
            else
                return !1;
        return this.r = new r(At),
        this.s = new r(Pt),
        this.recoveryParam = null,
        !0
    }
    ;
    function dt(mt, yt) {
        if (yt < 128) {
            mt.push(yt);
            return
        }
        var pt = 1 + (Math.log(yt) / Math.LN2 >>> 3);
        for (mt.push(pt | 128); --pt; )
            mt.push(yt >>> (pt << 3) & 255);
        mt.push(yt)
    }
    return m.prototype.toDER = function(yt) {
        var pt = this.r.toArray()
          , bt = this.s.toArray();
        for (pt[0] & 128 && (pt = [0].concat(pt)),
        bt[0] & 128 && (bt = [0].concat(bt)),
        pt = ee(pt),
        bt = ee(bt); !bt[0] && !(bt[1] & 128); )
            bt = bt.slice(1);
        var wt = [2];
        dt(wt, pt.length),
        wt = wt.concat(pt),
        wt.push(2),
        dt(wt, bt.length);
        var xt = wt.concat(bt)
          , At = [48];
        return dt(At, xt.length),
        At = At.concat(xt),
        d.encode(At, yt)
    }
    ,
    signature$1
}
var ec, hasRequiredEc;
function requireEc() {
    if (hasRequiredEc)
        return ec;
    hasRequiredEc = 1;
    var r = requireBn$2()
      , d = requireHmacDrbg()
      , f = requireUtils$1()
      , m = requireCurves()
      , k = requireBrorand()
      , y = f.assert
      , ee = requireKey$1()
      , dt = requireSignature$1();
    function mt(yt) {
        if (!(this instanceof mt))
            return new mt(yt);
        typeof yt == "string" && (y(Object.prototype.hasOwnProperty.call(m, yt), "Unknown curve " + yt),
        yt = m[yt]),
        yt instanceof m.PresetCurve && (yt = {
            curve: yt
        }),
        this.curve = yt.curve.curve,
        this.n = this.curve.n,
        this.nh = this.n.ushrn(1),
        this.g = this.curve.g,
        this.g = yt.curve.g,
        this.g.precompute(yt.curve.n.bitLength() + 1),
        this.hash = yt.hash || yt.curve.hash
    }
    return ec = mt,
    mt.prototype.keyPair = function(pt) {
        return new ee(this,pt)
    }
    ,
    mt.prototype.keyFromPrivate = function(pt, bt) {
        return ee.fromPrivate(this, pt, bt)
    }
    ,
    mt.prototype.keyFromPublic = function(pt, bt) {
        return ee.fromPublic(this, pt, bt)
    }
    ,
    mt.prototype.genKeyPair = function(pt) {
        pt || (pt = {});
        for (var bt = new d({
            hash: this.hash,
            pers: pt.pers,
            persEnc: pt.persEnc || "utf8",
            entropy: pt.entropy || k(this.hash.hmacStrength),
            entropyEnc: pt.entropy && pt.entropyEnc || "utf8",
            nonce: this.n.toArray()
        }), wt = this.n.byteLength(), xt = this.n.sub(new r(2)); ; ) {
            var At = new r(bt.generate(wt));
            if (!(At.cmp(xt) > 0))
                return At.iaddn(1),
                this.keyFromPrivate(At)
        }
    }
    ,
    mt.prototype._truncateToN = function(pt, bt) {
        var wt = pt.byteLength() * 8 - this.n.bitLength();
        return wt > 0 && (pt = pt.ushrn(wt)),
        !bt && pt.cmp(this.n) >= 0 ? pt.sub(this.n) : pt
    }
    ,
    mt.prototype.sign = function(pt, bt, wt, xt) {
        typeof wt == "object" && (xt = wt,
        wt = null),
        xt || (xt = {}),
        bt = this.keyFromPrivate(bt, wt),
        pt = this._truncateToN(new r(pt,16));
        for (var At = this.n.byteLength(), Ct = bt.getPrivate().toArray("be", At), Pt = pt.toArray("be", At), $t = new d({
            hash: this.hash,
            entropy: Ct,
            nonce: Pt,
            pers: xt.pers,
            persEnc: xt.persEnc || "utf8"
        }), Ot = this.n.sub(new r(1)), Nt = 0; ; Nt++) {
            var zt = xt.k ? xt.k(Nt) : new r($t.generate(this.n.byteLength()));
            if (zt = this._truncateToN(zt, !0),
            !(zt.cmpn(1) <= 0 || zt.cmp(Ot) >= 0)) {
                var Wt = this.g.mul(zt);
                if (!Wt.isInfinity()) {
                    var Kt = Wt.getX()
                      , ir = Kt.umod(this.n);
                    if (ir.cmpn(0) !== 0) {
                        var or = zt.invm(this.n).mul(ir.mul(bt.getPrivate()).iadd(pt));
                        if (or = or.umod(this.n),
                        or.cmpn(0) !== 0) {
                            var tr = (Wt.getY().isOdd() ? 1 : 0) | (Kt.cmp(ir) !== 0 ? 2 : 0);
                            return xt.canonical && or.cmp(this.nh) > 0 && (or = this.n.sub(or),
                            tr ^= 1),
                            new dt({
                                r: ir,
                                s: or,
                                recoveryParam: tr
                            })
                        }
                    }
                }
            }
        }
    }
    ,
    mt.prototype.verify = function(pt, bt, wt, xt) {
        pt = this._truncateToN(new r(pt,16)),
        wt = this.keyFromPublic(wt, xt),
        bt = new dt(bt,"hex");
        var At = bt.r
          , Ct = bt.s;
        if (At.cmpn(1) < 0 || At.cmp(this.n) >= 0 || Ct.cmpn(1) < 0 || Ct.cmp(this.n) >= 0)
            return !1;
        var Pt = Ct.invm(this.n), $t = Pt.mul(pt).umod(this.n), Ot = Pt.mul(At).umod(this.n), Nt;
        return this.curve._maxwellTrick ? (Nt = this.g.jmulAdd($t, wt.getPublic(), Ot),
        Nt.isInfinity() ? !1 : Nt.eqXToP(At)) : (Nt = this.g.mulAdd($t, wt.getPublic(), Ot),
        Nt.isInfinity() ? !1 : Nt.getX().umod(this.n).cmp(At) === 0)
    }
    ,
    mt.prototype.recoverPubKey = function(yt, pt, bt, wt) {
        y((3 & bt) === bt, "The recovery param is more than two bits"),
        pt = new dt(pt,wt);
        var xt = this.n
          , At = new r(yt)
          , Ct = pt.r
          , Pt = pt.s
          , $t = bt & 1
          , Ot = bt >> 1;
        if (Ct.cmp(this.curve.p.umod(this.curve.n)) >= 0 && Ot)
            throw new Error("Unable to find sencond key candinate");
        Ot ? Ct = this.curve.pointFromX(Ct.add(this.curve.n), $t) : Ct = this.curve.pointFromX(Ct, $t);
        var Nt = pt.r.invm(xt)
          , zt = xt.sub(At).mul(Nt).umod(xt)
          , Wt = Pt.mul(Nt).umod(xt);
        return this.g.mulAdd(zt, Ct, Wt)
    }
    ,
    mt.prototype.getKeyRecoveryParam = function(yt, pt, bt, wt) {
        if (pt = new dt(pt,wt),
        pt.recoveryParam !== null)
            return pt.recoveryParam;
        for (var xt = 0; xt < 4; xt++) {
            var At;
            try {
                At = this.recoverPubKey(yt, pt, xt)
            } catch {
                continue
            }
            if (At.eq(bt))
                return xt
        }
        throw new Error("Unable to find valid recovery factor")
    }
    ,
    ec
}
var key, hasRequiredKey;
function requireKey() {
    if (hasRequiredKey)
        return key;
    hasRequiredKey = 1;
    var r = requireUtils$1()
      , d = r.assert
      , f = r.parseBytes
      , m = r.cachedProperty;
    function k(y, ee) {
        this.eddsa = y,
        this._secret = f(ee.secret),
        y.isPoint(ee.pub) ? this._pub = ee.pub : this._pubBytes = f(ee.pub)
    }
    return k.fromPublic = function(ee, dt) {
        return dt instanceof k ? dt : new k(ee,{
            pub: dt
        })
    }
    ,
    k.fromSecret = function(ee, dt) {
        return dt instanceof k ? dt : new k(ee,{
            secret: dt
        })
    }
    ,
    k.prototype.secret = function() {
        return this._secret
    }
    ,
    m(k, "pubBytes", function() {
        return this.eddsa.encodePoint(this.pub())
    }),
    m(k, "pub", function() {
        return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv())
    }),
    m(k, "privBytes", function() {
        var ee = this.eddsa
          , dt = this.hash()
          , mt = ee.encodingLength - 1
          , yt = dt.slice(0, ee.encodingLength);
        return yt[0] &= 248,
        yt[mt] &= 127,
        yt[mt] |= 64,
        yt
    }),
    m(k, "priv", function() {
        return this.eddsa.decodeInt(this.privBytes())
    }),
    m(k, "hash", function() {
        return this.eddsa.hash().update(this.secret()).digest()
    }),
    m(k, "messagePrefix", function() {
        return this.hash().slice(this.eddsa.encodingLength)
    }),
    k.prototype.sign = function(ee) {
        return d(this._secret, "KeyPair can only verify"),
        this.eddsa.sign(ee, this)
    }
    ,
    k.prototype.verify = function(ee, dt) {
        return this.eddsa.verify(ee, dt, this)
    }
    ,
    k.prototype.getSecret = function(ee) {
        return d(this._secret, "KeyPair is public only"),
        r.encode(this.secret(), ee)
    }
    ,
    k.prototype.getPublic = function(ee) {
        return r.encode(this.pubBytes(), ee)
    }
    ,
    key = k,
    key
}
var signature, hasRequiredSignature;
function requireSignature() {
    if (hasRequiredSignature)
        return signature;
    hasRequiredSignature = 1;
    var r = requireBn$2()
      , d = requireUtils$1()
      , f = d.assert
      , m = d.cachedProperty
      , k = d.parseBytes;
    function y(ee, dt) {
        this.eddsa = ee,
        typeof dt != "object" && (dt = k(dt)),
        Array.isArray(dt) && (dt = {
            R: dt.slice(0, ee.encodingLength),
            S: dt.slice(ee.encodingLength)
        }),
        f(dt.R && dt.S, "Signature without R or S"),
        ee.isPoint(dt.R) && (this._R = dt.R),
        dt.S instanceof r && (this._S = dt.S),
        this._Rencoded = Array.isArray(dt.R) ? dt.R : dt.Rencoded,
        this._Sencoded = Array.isArray(dt.S) ? dt.S : dt.Sencoded
    }
    return m(y, "S", function() {
        return this.eddsa.decodeInt(this.Sencoded())
    }),
    m(y, "R", function() {
        return this.eddsa.decodePoint(this.Rencoded())
    }),
    m(y, "Rencoded", function() {
        return this.eddsa.encodePoint(this.R())
    }),
    m(y, "Sencoded", function() {
        return this.eddsa.encodeInt(this.S())
    }),
    y.prototype.toBytes = function() {
        return this.Rencoded().concat(this.Sencoded())
    }
    ,
    y.prototype.toHex = function() {
        return d.encode(this.toBytes(), "hex").toUpperCase()
    }
    ,
    signature = y,
    signature
}
var eddsa, hasRequiredEddsa;
function requireEddsa() {
    if (hasRequiredEddsa)
        return eddsa;
    hasRequiredEddsa = 1;
    var r = requireHash()
      , d = requireCurves()
      , f = requireUtils$1()
      , m = f.assert
      , k = f.parseBytes
      , y = requireKey()
      , ee = requireSignature();
    function dt(mt) {
        if (m(mt === "ed25519", "only tested with ed25519 so far"),
        !(this instanceof dt))
            return new dt(mt);
        mt = d[mt].curve,
        this.curve = mt,
        this.g = mt.g,
        this.g.precompute(mt.n.bitLength() + 1),
        this.pointClass = mt.point().constructor,
        this.encodingLength = Math.ceil(mt.n.bitLength() / 8),
        this.hash = r.sha512
    }
    return eddsa = dt,
    dt.prototype.sign = function(yt, pt) {
        yt = k(yt);
        var bt = this.keyFromSecret(pt)
          , wt = this.hashInt(bt.messagePrefix(), yt)
          , xt = this.g.mul(wt)
          , At = this.encodePoint(xt)
          , Ct = this.hashInt(At, bt.pubBytes(), yt).mul(bt.priv())
          , Pt = wt.add(Ct).umod(this.curve.n);
        return this.makeSignature({
            R: xt,
            S: Pt,
            Rencoded: At
        })
    }
    ,
    dt.prototype.verify = function(yt, pt, bt) {
        yt = k(yt),
        pt = this.makeSignature(pt);
        var wt = this.keyFromPublic(bt)
          , xt = this.hashInt(pt.Rencoded(), wt.pubBytes(), yt)
          , At = this.g.mul(pt.S())
          , Ct = pt.R().add(wt.pub().mul(xt));
        return Ct.eq(At)
    }
    ,
    dt.prototype.hashInt = function() {
        for (var yt = this.hash(), pt = 0; pt < arguments.length; pt++)
            yt.update(arguments[pt]);
        return f.intFromLE(yt.digest()).umod(this.curve.n)
    }
    ,
    dt.prototype.keyFromPublic = function(yt) {
        return y.fromPublic(this, yt)
    }
    ,
    dt.prototype.keyFromSecret = function(yt) {
        return y.fromSecret(this, yt)
    }
    ,
    dt.prototype.makeSignature = function(yt) {
        return yt instanceof ee ? yt : new ee(this,yt)
    }
    ,
    dt.prototype.encodePoint = function(yt) {
        var pt = yt.getY().toArray("le", this.encodingLength);
        return pt[this.encodingLength - 1] |= yt.getX().isOdd() ? 128 : 0,
        pt
    }
    ,
    dt.prototype.decodePoint = function(yt) {
        yt = f.parseBytes(yt);
        var pt = yt.length - 1
          , bt = yt.slice(0, pt).concat(yt[pt] & -129)
          , wt = (yt[pt] & 128) !== 0
          , xt = f.intFromLE(bt);
        return this.curve.pointFromY(xt, wt)
    }
    ,
    dt.prototype.encodeInt = function(yt) {
        return yt.toArray("le", this.encodingLength)
    }
    ,
    dt.prototype.decodeInt = function(yt) {
        return f.intFromLE(yt)
    }
    ,
    dt.prototype.isPoint = function(yt) {
        return yt instanceof this.pointClass
    }
    ,
    eddsa
}
var hasRequiredElliptic;
function requireElliptic() {
    return hasRequiredElliptic || (hasRequiredElliptic = 1,
    function(r) {
        var d = r;
        d.version = require$$0.version,
        d.utils = requireUtils$1(),
        d.rand = requireBrorand(),
        d.curve = requireCurve(),
        d.curves = requireCurves(),
        d.ec = requireEc(),
        d.eddsa = requireEddsa()
    }(elliptic)),
    elliptic
}
var bn = {
    exports: {}
};
bn.exports;
var hasRequiredBn;
function requireBn() {
    return hasRequiredBn || (hasRequiredBn = 1,
    function(r) {
        (function(d, f) {
            function m(_t, gt) {
                if (!_t)
                    throw new Error(gt || "Assertion failed")
            }
            function k(_t, gt) {
                _t.super_ = gt;
                var vt = function() {};
                vt.prototype = gt.prototype,
                _t.prototype = new vt,
                _t.prototype.constructor = _t
            }
            function y(_t, gt, vt) {
                if (y.isBN(_t))
                    return _t;
                this.negative = 0,
                this.words = null,
                this.length = 0,
                this.red = null,
                _t !== null && ((gt === "le" || gt === "be") && (vt = gt,
                gt = 10),
                this._init(_t || 0, gt || 10, vt || "be"))
            }
            typeof d == "object" ? d.exports = y : f.BN = y,
            y.BN = y,
            y.wordSize = 26;
            var ee;
            try {
                typeof window < "u" && typeof window.Buffer < "u" ? ee = window.Buffer : ee = require$$1$2.Buffer
            } catch {}
            y.isBN = function(gt) {
                return gt instanceof y ? !0 : gt !== null && typeof gt == "object" && gt.constructor.wordSize === y.wordSize && Array.isArray(gt.words)
            }
            ,
            y.max = function(gt, vt) {
                return gt.cmp(vt) > 0 ? gt : vt
            }
            ,
            y.min = function(gt, vt) {
                return gt.cmp(vt) < 0 ? gt : vt
            }
            ,
            y.prototype._init = function(gt, vt, Et) {
                if (typeof gt == "number")
                    return this._initNumber(gt, vt, Et);
                if (typeof gt == "object")
                    return this._initArray(gt, vt, Et);
                vt === "hex" && (vt = 16),
                m(vt === (vt | 0) && vt >= 2 && vt <= 36),
                gt = gt.toString().replace(/\s+/g, "");
                var Bt = 0;
                gt[0] === "-" && (Bt++,
                this.negative = 1),
                Bt < gt.length && (vt === 16 ? this._parseHex(gt, Bt, Et) : (this._parseBase(gt, vt, Bt),
                Et === "le" && this._initArray(this.toArray(), vt, Et)))
            }
            ,
            y.prototype._initNumber = function(gt, vt, Et) {
                gt < 0 && (this.negative = 1,
                gt = -gt),
                gt < 67108864 ? (this.words = [gt & 67108863],
                this.length = 1) : gt < 4503599627370496 ? (this.words = [gt & 67108863, gt / 67108864 & 67108863],
                this.length = 2) : (m(gt < 9007199254740992),
                this.words = [gt & 67108863, gt / 67108864 & 67108863, 1],
                this.length = 3),
                Et === "le" && this._initArray(this.toArray(), vt, Et)
            }
            ,
            y.prototype._initArray = function(gt, vt, Et) {
                if (m(typeof gt.length == "number"),
                gt.length <= 0)
                    return this.words = [0],
                    this.length = 1,
                    this;
                this.length = Math.ceil(gt.length / 3),
                this.words = new Array(this.length);
                for (var Bt = 0; Bt < this.length; Bt++)
                    this.words[Bt] = 0;
                var Rt, kt, Tt = 0;
                if (Et === "be")
                    for (Bt = gt.length - 1,
                    Rt = 0; Bt >= 0; Bt -= 3)
                        kt = gt[Bt] | gt[Bt - 1] << 8 | gt[Bt - 2] << 16,
                        this.words[Rt] |= kt << Tt & 67108863,
                        this.words[Rt + 1] = kt >>> 26 - Tt & 67108863,
                        Tt += 24,
                        Tt >= 26 && (Tt -= 26,
                        Rt++);
                else if (Et === "le")
                    for (Bt = 0,
                    Rt = 0; Bt < gt.length; Bt += 3)
                        kt = gt[Bt] | gt[Bt + 1] << 8 | gt[Bt + 2] << 16,
                        this.words[Rt] |= kt << Tt & 67108863,
                        this.words[Rt + 1] = kt >>> 26 - Tt & 67108863,
                        Tt += 24,
                        Tt >= 26 && (Tt -= 26,
                        Rt++);
                return this._strip()
            }
            ;
            function dt(_t, gt) {
                var vt = _t.charCodeAt(gt);
                if (vt >= 48 && vt <= 57)
                    return vt - 48;
                if (vt >= 65 && vt <= 70)
                    return vt - 55;
                if (vt >= 97 && vt <= 102)
                    return vt - 87;
                m(!1, "Invalid character in " + _t)
            }
            function mt(_t, gt, vt) {
                var Et = dt(_t, vt);
                return vt - 1 >= gt && (Et |= dt(_t, vt - 1) << 4),
                Et
            }
            y.prototype._parseHex = function(gt, vt, Et) {
                this.length = Math.ceil((gt.length - vt) / 6),
                this.words = new Array(this.length);
                for (var Bt = 0; Bt < this.length; Bt++)
                    this.words[Bt] = 0;
                var Rt = 0, kt = 0, Tt;
                if (Et === "be")
                    for (Bt = gt.length - 1; Bt >= vt; Bt -= 2)
                        Tt = mt(gt, vt, Bt) << Rt,
                        this.words[kt] |= Tt & 67108863,
                        Rt >= 18 ? (Rt -= 18,
                        kt += 1,
                        this.words[kt] |= Tt >>> 26) : Rt += 8;
                else {
                    var It = gt.length - vt;
                    for (Bt = It % 2 === 0 ? vt + 1 : vt; Bt < gt.length; Bt += 2)
                        Tt = mt(gt, vt, Bt) << Rt,
                        this.words[kt] |= Tt & 67108863,
                        Rt >= 18 ? (Rt -= 18,
                        kt += 1,
                        this.words[kt] |= Tt >>> 26) : Rt += 8
                }
                this._strip()
            }
            ;
            function yt(_t, gt, vt, Et) {
                for (var Bt = 0, Rt = 0, kt = Math.min(_t.length, vt), Tt = gt; Tt < kt; Tt++) {
                    var It = _t.charCodeAt(Tt) - 48;
                    Bt *= Et,
                    It >= 49 ? Rt = It - 49 + 10 : It >= 17 ? Rt = It - 17 + 10 : Rt = It,
                    m(It >= 0 && Rt < Et, "Invalid character"),
                    Bt += Rt
                }
                return Bt
            }
            y.prototype._parseBase = function(gt, vt, Et) {
                this.words = [0],
                this.length = 1;
                for (var Bt = 0, Rt = 1; Rt <= 67108863; Rt *= vt)
                    Bt++;
                Bt--,
                Rt = Rt / vt | 0;
                for (var kt = gt.length - Et, Tt = kt % Bt, It = Math.min(kt, kt - Tt) + Et, St = 0, qt = Et; qt < It; qt += Bt)
                    St = yt(gt, qt, qt + Bt, vt),
                    this.imuln(Rt),
                    this.words[0] + St < 67108864 ? this.words[0] += St : this._iaddn(St);
                if (Tt !== 0) {
                    var ur = 1;
                    for (St = yt(gt, qt, gt.length, vt),
                    qt = 0; qt < Tt; qt++)
                        ur *= vt;
                    this.imuln(ur),
                    this.words[0] + St < 67108864 ? this.words[0] += St : this._iaddn(St)
                }
                this._strip()
            }
            ,
            y.prototype.copy = function(gt) {
                gt.words = new Array(this.length);
                for (var vt = 0; vt < this.length; vt++)
                    gt.words[vt] = this.words[vt];
                gt.length = this.length,
                gt.negative = this.negative,
                gt.red = this.red
            }
            ;
            function pt(_t, gt) {
                _t.words = gt.words,
                _t.length = gt.length,
                _t.negative = gt.negative,
                _t.red = gt.red
            }
            if (y.prototype._move = function(gt) {
                pt(gt, this)
            }
            ,
            y.prototype.clone = function() {
                var gt = new y(null);
                return this.copy(gt),
                gt
            }
            ,
            y.prototype._expand = function(gt) {
                for (; this.length < gt; )
                    this.words[this.length++] = 0;
                return this
            }
            ,
            y.prototype._strip = function() {
                for (; this.length > 1 && this.words[this.length - 1] === 0; )
                    this.length--;
                return this._normSign()
            }
            ,
            y.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0),
                this
            }
            ,
            typeof Symbol < "u" && typeof Symbol.for == "function")
                try {
                    y.prototype[Symbol.for("nodejs.util.inspect.custom")] = bt
                } catch {
                    y.prototype.inspect = bt
                }
            else
                y.prototype.inspect = bt;
            function bt() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
            }
            var wt = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
              , xt = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
              , At = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
            y.prototype.toString = function(gt, vt) {
                gt = gt || 10,
                vt = vt | 0 || 1;
                var Et;
                if (gt === 16 || gt === "hex") {
                    Et = "";
                    for (var Bt = 0, Rt = 0, kt = 0; kt < this.length; kt++) {
                        var Tt = this.words[kt]
                          , It = ((Tt << Bt | Rt) & 16777215).toString(16);
                        Rt = Tt >>> 24 - Bt & 16777215,
                        Bt += 2,
                        Bt >= 26 && (Bt -= 26,
                        kt--),
                        Rt !== 0 || kt !== this.length - 1 ? Et = wt[6 - It.length] + It + Et : Et = It + Et
                    }
                    for (Rt !== 0 && (Et = Rt.toString(16) + Et); Et.length % vt !== 0; )
                        Et = "0" + Et;
                    return this.negative !== 0 && (Et = "-" + Et),
                    Et
                }
                if (gt === (gt | 0) && gt >= 2 && gt <= 36) {
                    var St = xt[gt]
                      , qt = At[gt];
                    Et = "";
                    var ur = this.clone();
                    for (ur.negative = 0; !ur.isZero(); ) {
                        var gr = ur.modrn(qt).toString(gt);
                        ur = ur.idivn(qt),
                        ur.isZero() ? Et = gr + Et : Et = wt[St - gr.length] + gr + Et
                    }
                    for (this.isZero() && (Et = "0" + Et); Et.length % vt !== 0; )
                        Et = "0" + Et;
                    return this.negative !== 0 && (Et = "-" + Et),
                    Et
                }
                m(!1, "Base should be between 2 and 36")
            }
            ,
            y.prototype.toNumber = function() {
                var gt = this.words[0];
                return this.length === 2 ? gt += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? gt += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && m(!1, "Number can only safely store up to 53 bits"),
                this.negative !== 0 ? -gt : gt
            }
            ,
            y.prototype.toJSON = function() {
                return this.toString(16, 2)
            }
            ,
            ee && (y.prototype.toBuffer = function(gt, vt) {
                return this.toArrayLike(ee, gt, vt)
            }
            ),
            y.prototype.toArray = function(gt, vt) {
                return this.toArrayLike(Array, gt, vt)
            }
            ;
            var Ct = function(gt, vt) {
                return gt.allocUnsafe ? gt.allocUnsafe(vt) : new gt(vt)
            };
            y.prototype.toArrayLike = function(gt, vt, Et) {
                this._strip();
                var Bt = this.byteLength()
                  , Rt = Et || Math.max(1, Bt);
                m(Bt <= Rt, "byte array longer than desired length"),
                m(Rt > 0, "Requested array length <= 0");
                var kt = Ct(gt, Rt)
                  , Tt = vt === "le" ? "LE" : "BE";
                return this["_toArrayLike" + Tt](kt, Bt),
                kt
            }
            ,
            y.prototype._toArrayLikeLE = function(gt, vt) {
                for (var Et = 0, Bt = 0, Rt = 0, kt = 0; Rt < this.length; Rt++) {
                    var Tt = this.words[Rt] << kt | Bt;
                    gt[Et++] = Tt & 255,
                    Et < gt.length && (gt[Et++] = Tt >> 8 & 255),
                    Et < gt.length && (gt[Et++] = Tt >> 16 & 255),
                    kt === 6 ? (Et < gt.length && (gt[Et++] = Tt >> 24 & 255),
                    Bt = 0,
                    kt = 0) : (Bt = Tt >>> 24,
                    kt += 2)
                }
                if (Et < gt.length)
                    for (gt[Et++] = Bt; Et < gt.length; )
                        gt[Et++] = 0
            }
            ,
            y.prototype._toArrayLikeBE = function(gt, vt) {
                for (var Et = gt.length - 1, Bt = 0, Rt = 0, kt = 0; Rt < this.length; Rt++) {
                    var Tt = this.words[Rt] << kt | Bt;
                    gt[Et--] = Tt & 255,
                    Et >= 0 && (gt[Et--] = Tt >> 8 & 255),
                    Et >= 0 && (gt[Et--] = Tt >> 16 & 255),
                    kt === 6 ? (Et >= 0 && (gt[Et--] = Tt >> 24 & 255),
                    Bt = 0,
                    kt = 0) : (Bt = Tt >>> 24,
                    kt += 2)
                }
                if (Et >= 0)
                    for (gt[Et--] = Bt; Et >= 0; )
                        gt[Et--] = 0
            }
            ,
            Math.clz32 ? y.prototype._countBits = function(gt) {
                return 32 - Math.clz32(gt)
            }
            : y.prototype._countBits = function(gt) {
                var vt = gt
                  , Et = 0;
                return vt >= 4096 && (Et += 13,
                vt >>>= 13),
                vt >= 64 && (Et += 7,
                vt >>>= 7),
                vt >= 8 && (Et += 4,
                vt >>>= 4),
                vt >= 2 && (Et += 2,
                vt >>>= 2),
                Et + vt
            }
            ,
            y.prototype._zeroBits = function(gt) {
                if (gt === 0)
                    return 26;
                var vt = gt
                  , Et = 0;
                return vt & 8191 || (Et += 13,
                vt >>>= 13),
                vt & 127 || (Et += 7,
                vt >>>= 7),
                vt & 15 || (Et += 4,
                vt >>>= 4),
                vt & 3 || (Et += 2,
                vt >>>= 2),
                vt & 1 || Et++,
                Et
            }
            ,
            y.prototype.bitLength = function() {
                var gt = this.words[this.length - 1]
                  , vt = this._countBits(gt);
                return (this.length - 1) * 26 + vt
            }
            ;
            function Pt(_t) {
                for (var gt = new Array(_t.bitLength()), vt = 0; vt < gt.length; vt++) {
                    var Et = vt / 26 | 0
                      , Bt = vt % 26;
                    gt[vt] = _t.words[Et] >>> Bt & 1
                }
                return gt
            }
            y.prototype.zeroBits = function() {
                if (this.isZero())
                    return 0;
                for (var gt = 0, vt = 0; vt < this.length; vt++) {
                    var Et = this._zeroBits(this.words[vt]);
                    if (gt += Et,
                    Et !== 26)
                        break
                }
                return gt
            }
            ,
            y.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8)
            }
            ,
            y.prototype.toTwos = function(gt) {
                return this.negative !== 0 ? this.abs().inotn(gt).iaddn(1) : this.clone()
            }
            ,
            y.prototype.fromTwos = function(gt) {
                return this.testn(gt - 1) ? this.notn(gt).iaddn(1).ineg() : this.clone()
            }
            ,
            y.prototype.isNeg = function() {
                return this.negative !== 0
            }
            ,
            y.prototype.neg = function() {
                return this.clone().ineg()
            }
            ,
            y.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1),
                this
            }
            ,
            y.prototype.iuor = function(gt) {
                for (; this.length < gt.length; )
                    this.words[this.length++] = 0;
                for (var vt = 0; vt < gt.length; vt++)
                    this.words[vt] = this.words[vt] | gt.words[vt];
                return this._strip()
            }
            ,
            y.prototype.ior = function(gt) {
                return m((this.negative | gt.negative) === 0),
                this.iuor(gt)
            }
            ,
            y.prototype.or = function(gt) {
                return this.length > gt.length ? this.clone().ior(gt) : gt.clone().ior(this)
            }
            ,
            y.prototype.uor = function(gt) {
                return this.length > gt.length ? this.clone().iuor(gt) : gt.clone().iuor(this)
            }
            ,
            y.prototype.iuand = function(gt) {
                var vt;
                this.length > gt.length ? vt = gt : vt = this;
                for (var Et = 0; Et < vt.length; Et++)
                    this.words[Et] = this.words[Et] & gt.words[Et];
                return this.length = vt.length,
                this._strip()
            }
            ,
            y.prototype.iand = function(gt) {
                return m((this.negative | gt.negative) === 0),
                this.iuand(gt)
            }
            ,
            y.prototype.and = function(gt) {
                return this.length > gt.length ? this.clone().iand(gt) : gt.clone().iand(this)
            }
            ,
            y.prototype.uand = function(gt) {
                return this.length > gt.length ? this.clone().iuand(gt) : gt.clone().iuand(this)
            }
            ,
            y.prototype.iuxor = function(gt) {
                var vt, Et;
                this.length > gt.length ? (vt = this,
                Et = gt) : (vt = gt,
                Et = this);
                for (var Bt = 0; Bt < Et.length; Bt++)
                    this.words[Bt] = vt.words[Bt] ^ Et.words[Bt];
                if (this !== vt)
                    for (; Bt < vt.length; Bt++)
                        this.words[Bt] = vt.words[Bt];
                return this.length = vt.length,
                this._strip()
            }
            ,
            y.prototype.ixor = function(gt) {
                return m((this.negative | gt.negative) === 0),
                this.iuxor(gt)
            }
            ,
            y.prototype.xor = function(gt) {
                return this.length > gt.length ? this.clone().ixor(gt) : gt.clone().ixor(this)
            }
            ,
            y.prototype.uxor = function(gt) {
                return this.length > gt.length ? this.clone().iuxor(gt) : gt.clone().iuxor(this)
            }
            ,
            y.prototype.inotn = function(gt) {
                m(typeof gt == "number" && gt >= 0);
                var vt = Math.ceil(gt / 26) | 0
                  , Et = gt % 26;
                this._expand(vt),
                Et > 0 && vt--;
                for (var Bt = 0; Bt < vt; Bt++)
                    this.words[Bt] = ~this.words[Bt] & 67108863;
                return Et > 0 && (this.words[Bt] = ~this.words[Bt] & 67108863 >> 26 - Et),
                this._strip()
            }
            ,
            y.prototype.notn = function(gt) {
                return this.clone().inotn(gt)
            }
            ,
            y.prototype.setn = function(gt, vt) {
                m(typeof gt == "number" && gt >= 0);
                var Et = gt / 26 | 0
                  , Bt = gt % 26;
                return this._expand(Et + 1),
                vt ? this.words[Et] = this.words[Et] | 1 << Bt : this.words[Et] = this.words[Et] & ~(1 << Bt),
                this._strip()
            }
            ,
            y.prototype.iadd = function(gt) {
                var vt;
                if (this.negative !== 0 && gt.negative === 0)
                    return this.negative = 0,
                    vt = this.isub(gt),
                    this.negative ^= 1,
                    this._normSign();
                if (this.negative === 0 && gt.negative !== 0)
                    return gt.negative = 0,
                    vt = this.isub(gt),
                    gt.negative = 1,
                    vt._normSign();
                var Et, Bt;
                this.length > gt.length ? (Et = this,
                Bt = gt) : (Et = gt,
                Bt = this);
                for (var Rt = 0, kt = 0; kt < Bt.length; kt++)
                    vt = (Et.words[kt] | 0) + (Bt.words[kt] | 0) + Rt,
                    this.words[kt] = vt & 67108863,
                    Rt = vt >>> 26;
                for (; Rt !== 0 && kt < Et.length; kt++)
                    vt = (Et.words[kt] | 0) + Rt,
                    this.words[kt] = vt & 67108863,
                    Rt = vt >>> 26;
                if (this.length = Et.length,
                Rt !== 0)
                    this.words[this.length] = Rt,
                    this.length++;
                else if (Et !== this)
                    for (; kt < Et.length; kt++)
                        this.words[kt] = Et.words[kt];
                return this
            }
            ,
            y.prototype.add = function(gt) {
                var vt;
                return gt.negative !== 0 && this.negative === 0 ? (gt.negative = 0,
                vt = this.sub(gt),
                gt.negative ^= 1,
                vt) : gt.negative === 0 && this.negative !== 0 ? (this.negative = 0,
                vt = gt.sub(this),
                this.negative = 1,
                vt) : this.length > gt.length ? this.clone().iadd(gt) : gt.clone().iadd(this)
            }
            ,
            y.prototype.isub = function(gt) {
                if (gt.negative !== 0) {
                    gt.negative = 0;
                    var vt = this.iadd(gt);
                    return gt.negative = 1,
                    vt._normSign()
                } else if (this.negative !== 0)
                    return this.negative = 0,
                    this.iadd(gt),
                    this.negative = 1,
                    this._normSign();
                var Et = this.cmp(gt);
                if (Et === 0)
                    return this.negative = 0,
                    this.length = 1,
                    this.words[0] = 0,
                    this;
                var Bt, Rt;
                Et > 0 ? (Bt = this,
                Rt = gt) : (Bt = gt,
                Rt = this);
                for (var kt = 0, Tt = 0; Tt < Rt.length; Tt++)
                    vt = (Bt.words[Tt] | 0) - (Rt.words[Tt] | 0) + kt,
                    kt = vt >> 26,
                    this.words[Tt] = vt & 67108863;
                for (; kt !== 0 && Tt < Bt.length; Tt++)
                    vt = (Bt.words[Tt] | 0) + kt,
                    kt = vt >> 26,
                    this.words[Tt] = vt & 67108863;
                if (kt === 0 && Tt < Bt.length && Bt !== this)
                    for (; Tt < Bt.length; Tt++)
                        this.words[Tt] = Bt.words[Tt];
                return this.length = Math.max(this.length, Tt),
                Bt !== this && (this.negative = 1),
                this._strip()
            }
            ,
            y.prototype.sub = function(gt) {
                return this.clone().isub(gt)
            }
            ;
            function $t(_t, gt, vt) {
                vt.negative = gt.negative ^ _t.negative;
                var Et = _t.length + gt.length | 0;
                vt.length = Et,
                Et = Et - 1 | 0;
                var Bt = _t.words[0] | 0
                  , Rt = gt.words[0] | 0
                  , kt = Bt * Rt
                  , Tt = kt & 67108863
                  , It = kt / 67108864 | 0;
                vt.words[0] = Tt;
                for (var St = 1; St < Et; St++) {
                    for (var qt = It >>> 26, ur = It & 67108863, gr = Math.min(St, gt.length - 1), lr = Math.max(0, St - _t.length + 1); lr <= gr; lr++) {
                        var Zt = St - lr | 0;
                        Bt = _t.words[Zt] | 0,
                        Rt = gt.words[lr] | 0,
                        kt = Bt * Rt + ur,
                        qt += kt / 67108864 | 0,
                        ur = kt & 67108863
                    }
                    vt.words[St] = ur | 0,
                    It = qt | 0
                }
                return It !== 0 ? vt.words[St] = It | 0 : vt.length--,
                vt._strip()
            }
            var Ot = function(gt, vt, Et) {
                var Bt = gt.words, Rt = vt.words, kt = Et.words, Tt = 0, It, St, qt, ur = Bt[0] | 0, gr = ur & 8191, lr = ur >>> 13, Zt = Bt[1] | 0, Vt = Zt & 8191, rr = Zt >>> 13, fr = Bt[2] | 0, Yt = fr & 8191, Xt = fr >>> 13, Sr = Bt[3] | 0, Rr = Sr & 8191, qr = Sr >>> 13, Nr = Bt[4] | 0, Dr = Nr & 8191, Or = Nr >>> 13, $r = Bt[5] | 0, Zr = $r & 8191, Hr = $r >>> 13, un = Bt[6] | 0, Qr = un & 8191, Gr = un >>> 13, vr = Bt[7] | 0, ar = vr & 8191, hr = vr >>> 13, _r = Bt[8] | 0, Ar = _r & 8191, Ft = _r >>> 13, Ut = Bt[9] | 0, Dt = Ut & 8191, er = Ut >>> 13, br = Rt[0] | 0, Cr = br & 8191, xr = br >>> 13, Lr = Rt[1] | 0, Ur = Lr & 8191, Ir = Lr >>> 13, Jr = Rt[2] | 0, Wr = Jr & 8191, Yr = Jr >>> 13, Sn = Rt[3] | 0, pn = Sn & 8191, tn = Sn >>> 13, Bn = Rt[4] | 0, An = Bn & 8191, dn = Bn >>> 13, Rn = Rt[5] | 0, En = Rn & 8191, an = Rn >>> 13, Un = Rt[6] | 0, Jt = Un & 8191, nr = Un >>> 13, sr = Rt[7] | 0, jt = sr & 8191, cr = sr >>> 13, Tr = Rt[8] | 0, kr = Tr & 8191, Pr = Tr >>> 13, zr = Rt[9] | 0, Vr = zr & 8191, jr = zr >>> 13;
                Et.negative = gt.negative ^ vt.negative,
                Et.length = 19,
                It = Math.imul(gr, Cr),
                St = Math.imul(gr, xr),
                St = St + Math.imul(lr, Cr) | 0,
                qt = Math.imul(lr, xr);
                var Mn = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (Mn >>> 26) | 0,
                Mn &= 67108863,
                It = Math.imul(Vt, Cr),
                St = Math.imul(Vt, xr),
                St = St + Math.imul(rr, Cr) | 0,
                qt = Math.imul(rr, xr),
                It = It + Math.imul(gr, Ur) | 0,
                St = St + Math.imul(gr, Ir) | 0,
                St = St + Math.imul(lr, Ur) | 0,
                qt = qt + Math.imul(lr, Ir) | 0;
                var nn = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (nn >>> 26) | 0,
                nn &= 67108863,
                It = Math.imul(Yt, Cr),
                St = Math.imul(Yt, xr),
                St = St + Math.imul(Xt, Cr) | 0,
                qt = Math.imul(Xt, xr),
                It = It + Math.imul(Vt, Ur) | 0,
                St = St + Math.imul(Vt, Ir) | 0,
                St = St + Math.imul(rr, Ur) | 0,
                qt = qt + Math.imul(rr, Ir) | 0,
                It = It + Math.imul(gr, Wr) | 0,
                St = St + Math.imul(gr, Yr) | 0,
                St = St + Math.imul(lr, Wr) | 0,
                qt = qt + Math.imul(lr, Yr) | 0;
                var gn = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (gn >>> 26) | 0,
                gn &= 67108863,
                It = Math.imul(Rr, Cr),
                St = Math.imul(Rr, xr),
                St = St + Math.imul(qr, Cr) | 0,
                qt = Math.imul(qr, xr),
                It = It + Math.imul(Yt, Ur) | 0,
                St = St + Math.imul(Yt, Ir) | 0,
                St = St + Math.imul(Xt, Ur) | 0,
                qt = qt + Math.imul(Xt, Ir) | 0,
                It = It + Math.imul(Vt, Wr) | 0,
                St = St + Math.imul(Vt, Yr) | 0,
                St = St + Math.imul(rr, Wr) | 0,
                qt = qt + Math.imul(rr, Yr) | 0,
                It = It + Math.imul(gr, pn) | 0,
                St = St + Math.imul(gr, tn) | 0,
                St = St + Math.imul(lr, pn) | 0,
                qt = qt + Math.imul(lr, tn) | 0;
                var mn = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (mn >>> 26) | 0,
                mn &= 67108863,
                It = Math.imul(Dr, Cr),
                St = Math.imul(Dr, xr),
                St = St + Math.imul(Or, Cr) | 0,
                qt = Math.imul(Or, xr),
                It = It + Math.imul(Rr, Ur) | 0,
                St = St + Math.imul(Rr, Ir) | 0,
                St = St + Math.imul(qr, Ur) | 0,
                qt = qt + Math.imul(qr, Ir) | 0,
                It = It + Math.imul(Yt, Wr) | 0,
                St = St + Math.imul(Yt, Yr) | 0,
                St = St + Math.imul(Xt, Wr) | 0,
                qt = qt + Math.imul(Xt, Yr) | 0,
                It = It + Math.imul(Vt, pn) | 0,
                St = St + Math.imul(Vt, tn) | 0,
                St = St + Math.imul(rr, pn) | 0,
                qt = qt + Math.imul(rr, tn) | 0,
                It = It + Math.imul(gr, An) | 0,
                St = St + Math.imul(gr, dn) | 0,
                St = St + Math.imul(lr, An) | 0,
                qt = qt + Math.imul(lr, dn) | 0;
                var xn = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (xn >>> 26) | 0,
                xn &= 67108863,
                It = Math.imul(Zr, Cr),
                St = Math.imul(Zr, xr),
                St = St + Math.imul(Hr, Cr) | 0,
                qt = Math.imul(Hr, xr),
                It = It + Math.imul(Dr, Ur) | 0,
                St = St + Math.imul(Dr, Ir) | 0,
                St = St + Math.imul(Or, Ur) | 0,
                qt = qt + Math.imul(Or, Ir) | 0,
                It = It + Math.imul(Rr, Wr) | 0,
                St = St + Math.imul(Rr, Yr) | 0,
                St = St + Math.imul(qr, Wr) | 0,
                qt = qt + Math.imul(qr, Yr) | 0,
                It = It + Math.imul(Yt, pn) | 0,
                St = St + Math.imul(Yt, tn) | 0,
                St = St + Math.imul(Xt, pn) | 0,
                qt = qt + Math.imul(Xt, tn) | 0,
                It = It + Math.imul(Vt, An) | 0,
                St = St + Math.imul(Vt, dn) | 0,
                St = St + Math.imul(rr, An) | 0,
                qt = qt + Math.imul(rr, dn) | 0,
                It = It + Math.imul(gr, En) | 0,
                St = St + Math.imul(gr, an) | 0,
                St = St + Math.imul(lr, En) | 0,
                qt = qt + Math.imul(lr, an) | 0;
                var _n = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (_n >>> 26) | 0,
                _n &= 67108863,
                It = Math.imul(Qr, Cr),
                St = Math.imul(Qr, xr),
                St = St + Math.imul(Gr, Cr) | 0,
                qt = Math.imul(Gr, xr),
                It = It + Math.imul(Zr, Ur) | 0,
                St = St + Math.imul(Zr, Ir) | 0,
                St = St + Math.imul(Hr, Ur) | 0,
                qt = qt + Math.imul(Hr, Ir) | 0,
                It = It + Math.imul(Dr, Wr) | 0,
                St = St + Math.imul(Dr, Yr) | 0,
                St = St + Math.imul(Or, Wr) | 0,
                qt = qt + Math.imul(Or, Yr) | 0,
                It = It + Math.imul(Rr, pn) | 0,
                St = St + Math.imul(Rr, tn) | 0,
                St = St + Math.imul(qr, pn) | 0,
                qt = qt + Math.imul(qr, tn) | 0,
                It = It + Math.imul(Yt, An) | 0,
                St = St + Math.imul(Yt, dn) | 0,
                St = St + Math.imul(Xt, An) | 0,
                qt = qt + Math.imul(Xt, dn) | 0,
                It = It + Math.imul(Vt, En) | 0,
                St = St + Math.imul(Vt, an) | 0,
                St = St + Math.imul(rr, En) | 0,
                qt = qt + Math.imul(rr, an) | 0,
                It = It + Math.imul(gr, Jt) | 0,
                St = St + Math.imul(gr, nr) | 0,
                St = St + Math.imul(lr, Jt) | 0,
                qt = qt + Math.imul(lr, nr) | 0;
                var yn = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (yn >>> 26) | 0,
                yn &= 67108863,
                It = Math.imul(ar, Cr),
                St = Math.imul(ar, xr),
                St = St + Math.imul(hr, Cr) | 0,
                qt = Math.imul(hr, xr),
                It = It + Math.imul(Qr, Ur) | 0,
                St = St + Math.imul(Qr, Ir) | 0,
                St = St + Math.imul(Gr, Ur) | 0,
                qt = qt + Math.imul(Gr, Ir) | 0,
                It = It + Math.imul(Zr, Wr) | 0,
                St = St + Math.imul(Zr, Yr) | 0,
                St = St + Math.imul(Hr, Wr) | 0,
                qt = qt + Math.imul(Hr, Yr) | 0,
                It = It + Math.imul(Dr, pn) | 0,
                St = St + Math.imul(Dr, tn) | 0,
                St = St + Math.imul(Or, pn) | 0,
                qt = qt + Math.imul(Or, tn) | 0,
                It = It + Math.imul(Rr, An) | 0,
                St = St + Math.imul(Rr, dn) | 0,
                St = St + Math.imul(qr, An) | 0,
                qt = qt + Math.imul(qr, dn) | 0,
                It = It + Math.imul(Yt, En) | 0,
                St = St + Math.imul(Yt, an) | 0,
                St = St + Math.imul(Xt, En) | 0,
                qt = qt + Math.imul(Xt, an) | 0,
                It = It + Math.imul(Vt, Jt) | 0,
                St = St + Math.imul(Vt, nr) | 0,
                St = St + Math.imul(rr, Jt) | 0,
                qt = qt + Math.imul(rr, nr) | 0,
                It = It + Math.imul(gr, jt) | 0,
                St = St + Math.imul(gr, cr) | 0,
                St = St + Math.imul(lr, jt) | 0,
                qt = qt + Math.imul(lr, cr) | 0;
                var wn = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (wn >>> 26) | 0,
                wn &= 67108863,
                It = Math.imul(Ar, Cr),
                St = Math.imul(Ar, xr),
                St = St + Math.imul(Ft, Cr) | 0,
                qt = Math.imul(Ft, xr),
                It = It + Math.imul(ar, Ur) | 0,
                St = St + Math.imul(ar, Ir) | 0,
                St = St + Math.imul(hr, Ur) | 0,
                qt = qt + Math.imul(hr, Ir) | 0,
                It = It + Math.imul(Qr, Wr) | 0,
                St = St + Math.imul(Qr, Yr) | 0,
                St = St + Math.imul(Gr, Wr) | 0,
                qt = qt + Math.imul(Gr, Yr) | 0,
                It = It + Math.imul(Zr, pn) | 0,
                St = St + Math.imul(Zr, tn) | 0,
                St = St + Math.imul(Hr, pn) | 0,
                qt = qt + Math.imul(Hr, tn) | 0,
                It = It + Math.imul(Dr, An) | 0,
                St = St + Math.imul(Dr, dn) | 0,
                St = St + Math.imul(Or, An) | 0,
                qt = qt + Math.imul(Or, dn) | 0,
                It = It + Math.imul(Rr, En) | 0,
                St = St + Math.imul(Rr, an) | 0,
                St = St + Math.imul(qr, En) | 0,
                qt = qt + Math.imul(qr, an) | 0,
                It = It + Math.imul(Yt, Jt) | 0,
                St = St + Math.imul(Yt, nr) | 0,
                St = St + Math.imul(Xt, Jt) | 0,
                qt = qt + Math.imul(Xt, nr) | 0,
                It = It + Math.imul(Vt, jt) | 0,
                St = St + Math.imul(Vt, cr) | 0,
                St = St + Math.imul(rr, jt) | 0,
                qt = qt + Math.imul(rr, cr) | 0,
                It = It + Math.imul(gr, kr) | 0,
                St = St + Math.imul(gr, Pr) | 0,
                St = St + Math.imul(lr, kr) | 0,
                qt = qt + Math.imul(lr, Pr) | 0;
                var vn = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (vn >>> 26) | 0,
                vn &= 67108863,
                It = Math.imul(Dt, Cr),
                St = Math.imul(Dt, xr),
                St = St + Math.imul(er, Cr) | 0,
                qt = Math.imul(er, xr),
                It = It + Math.imul(Ar, Ur) | 0,
                St = St + Math.imul(Ar, Ir) | 0,
                St = St + Math.imul(Ft, Ur) | 0,
                qt = qt + Math.imul(Ft, Ir) | 0,
                It = It + Math.imul(ar, Wr) | 0,
                St = St + Math.imul(ar, Yr) | 0,
                St = St + Math.imul(hr, Wr) | 0,
                qt = qt + Math.imul(hr, Yr) | 0,
                It = It + Math.imul(Qr, pn) | 0,
                St = St + Math.imul(Qr, tn) | 0,
                St = St + Math.imul(Gr, pn) | 0,
                qt = qt + Math.imul(Gr, tn) | 0,
                It = It + Math.imul(Zr, An) | 0,
                St = St + Math.imul(Zr, dn) | 0,
                St = St + Math.imul(Hr, An) | 0,
                qt = qt + Math.imul(Hr, dn) | 0,
                It = It + Math.imul(Dr, En) | 0,
                St = St + Math.imul(Dr, an) | 0,
                St = St + Math.imul(Or, En) | 0,
                qt = qt + Math.imul(Or, an) | 0,
                It = It + Math.imul(Rr, Jt) | 0,
                St = St + Math.imul(Rr, nr) | 0,
                St = St + Math.imul(qr, Jt) | 0,
                qt = qt + Math.imul(qr, nr) | 0,
                It = It + Math.imul(Yt, jt) | 0,
                St = St + Math.imul(Yt, cr) | 0,
                St = St + Math.imul(Xt, jt) | 0,
                qt = qt + Math.imul(Xt, cr) | 0,
                It = It + Math.imul(Vt, kr) | 0,
                St = St + Math.imul(Vt, Pr) | 0,
                St = St + Math.imul(rr, kr) | 0,
                qt = qt + Math.imul(rr, Pr) | 0,
                It = It + Math.imul(gr, Vr) | 0,
                St = St + Math.imul(gr, jr) | 0,
                St = St + Math.imul(lr, Vr) | 0,
                qt = qt + Math.imul(lr, jr) | 0;
                var sn = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (sn >>> 26) | 0,
                sn &= 67108863,
                It = Math.imul(Dt, Ur),
                St = Math.imul(Dt, Ir),
                St = St + Math.imul(er, Ur) | 0,
                qt = Math.imul(er, Ir),
                It = It + Math.imul(Ar, Wr) | 0,
                St = St + Math.imul(Ar, Yr) | 0,
                St = St + Math.imul(Ft, Wr) | 0,
                qt = qt + Math.imul(Ft, Yr) | 0,
                It = It + Math.imul(ar, pn) | 0,
                St = St + Math.imul(ar, tn) | 0,
                St = St + Math.imul(hr, pn) | 0,
                qt = qt + Math.imul(hr, tn) | 0,
                It = It + Math.imul(Qr, An) | 0,
                St = St + Math.imul(Qr, dn) | 0,
                St = St + Math.imul(Gr, An) | 0,
                qt = qt + Math.imul(Gr, dn) | 0,
                It = It + Math.imul(Zr, En) | 0,
                St = St + Math.imul(Zr, an) | 0,
                St = St + Math.imul(Hr, En) | 0,
                qt = qt + Math.imul(Hr, an) | 0,
                It = It + Math.imul(Dr, Jt) | 0,
                St = St + Math.imul(Dr, nr) | 0,
                St = St + Math.imul(Or, Jt) | 0,
                qt = qt + Math.imul(Or, nr) | 0,
                It = It + Math.imul(Rr, jt) | 0,
                St = St + Math.imul(Rr, cr) | 0,
                St = St + Math.imul(qr, jt) | 0,
                qt = qt + Math.imul(qr, cr) | 0,
                It = It + Math.imul(Yt, kr) | 0,
                St = St + Math.imul(Yt, Pr) | 0,
                St = St + Math.imul(Xt, kr) | 0,
                qt = qt + Math.imul(Xt, Pr) | 0,
                It = It + Math.imul(Vt, Vr) | 0,
                St = St + Math.imul(Vt, jr) | 0,
                St = St + Math.imul(rr, Vr) | 0,
                qt = qt + Math.imul(rr, jr) | 0;
                var hn = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (hn >>> 26) | 0,
                hn &= 67108863,
                It = Math.imul(Dt, Wr),
                St = Math.imul(Dt, Yr),
                St = St + Math.imul(er, Wr) | 0,
                qt = Math.imul(er, Yr),
                It = It + Math.imul(Ar, pn) | 0,
                St = St + Math.imul(Ar, tn) | 0,
                St = St + Math.imul(Ft, pn) | 0,
                qt = qt + Math.imul(Ft, tn) | 0,
                It = It + Math.imul(ar, An) | 0,
                St = St + Math.imul(ar, dn) | 0,
                St = St + Math.imul(hr, An) | 0,
                qt = qt + Math.imul(hr, dn) | 0,
                It = It + Math.imul(Qr, En) | 0,
                St = St + Math.imul(Qr, an) | 0,
                St = St + Math.imul(Gr, En) | 0,
                qt = qt + Math.imul(Gr, an) | 0,
                It = It + Math.imul(Zr, Jt) | 0,
                St = St + Math.imul(Zr, nr) | 0,
                St = St + Math.imul(Hr, Jt) | 0,
                qt = qt + Math.imul(Hr, nr) | 0,
                It = It + Math.imul(Dr, jt) | 0,
                St = St + Math.imul(Dr, cr) | 0,
                St = St + Math.imul(Or, jt) | 0,
                qt = qt + Math.imul(Or, cr) | 0,
                It = It + Math.imul(Rr, kr) | 0,
                St = St + Math.imul(Rr, Pr) | 0,
                St = St + Math.imul(qr, kr) | 0,
                qt = qt + Math.imul(qr, Pr) | 0,
                It = It + Math.imul(Yt, Vr) | 0,
                St = St + Math.imul(Yt, jr) | 0,
                St = St + Math.imul(Xt, Vr) | 0,
                qt = qt + Math.imul(Xt, jr) | 0;
                var rn = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (rn >>> 26) | 0,
                rn &= 67108863,
                It = Math.imul(Dt, pn),
                St = Math.imul(Dt, tn),
                St = St + Math.imul(er, pn) | 0,
                qt = Math.imul(er, tn),
                It = It + Math.imul(Ar, An) | 0,
                St = St + Math.imul(Ar, dn) | 0,
                St = St + Math.imul(Ft, An) | 0,
                qt = qt + Math.imul(Ft, dn) | 0,
                It = It + Math.imul(ar, En) | 0,
                St = St + Math.imul(ar, an) | 0,
                St = St + Math.imul(hr, En) | 0,
                qt = qt + Math.imul(hr, an) | 0,
                It = It + Math.imul(Qr, Jt) | 0,
                St = St + Math.imul(Qr, nr) | 0,
                St = St + Math.imul(Gr, Jt) | 0,
                qt = qt + Math.imul(Gr, nr) | 0,
                It = It + Math.imul(Zr, jt) | 0,
                St = St + Math.imul(Zr, cr) | 0,
                St = St + Math.imul(Hr, jt) | 0,
                qt = qt + Math.imul(Hr, cr) | 0,
                It = It + Math.imul(Dr, kr) | 0,
                St = St + Math.imul(Dr, Pr) | 0,
                St = St + Math.imul(Or, kr) | 0,
                qt = qt + Math.imul(Or, Pr) | 0,
                It = It + Math.imul(Rr, Vr) | 0,
                St = St + Math.imul(Rr, jr) | 0,
                St = St + Math.imul(qr, Vr) | 0,
                qt = qt + Math.imul(qr, jr) | 0;
                var ln = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (ln >>> 26) | 0,
                ln &= 67108863,
                It = Math.imul(Dt, An),
                St = Math.imul(Dt, dn),
                St = St + Math.imul(er, An) | 0,
                qt = Math.imul(er, dn),
                It = It + Math.imul(Ar, En) | 0,
                St = St + Math.imul(Ar, an) | 0,
                St = St + Math.imul(Ft, En) | 0,
                qt = qt + Math.imul(Ft, an) | 0,
                It = It + Math.imul(ar, Jt) | 0,
                St = St + Math.imul(ar, nr) | 0,
                St = St + Math.imul(hr, Jt) | 0,
                qt = qt + Math.imul(hr, nr) | 0,
                It = It + Math.imul(Qr, jt) | 0,
                St = St + Math.imul(Qr, cr) | 0,
                St = St + Math.imul(Gr, jt) | 0,
                qt = qt + Math.imul(Gr, cr) | 0,
                It = It + Math.imul(Zr, kr) | 0,
                St = St + Math.imul(Zr, Pr) | 0,
                St = St + Math.imul(Hr, kr) | 0,
                qt = qt + Math.imul(Hr, Pr) | 0,
                It = It + Math.imul(Dr, Vr) | 0,
                St = St + Math.imul(Dr, jr) | 0,
                St = St + Math.imul(Or, Vr) | 0,
                qt = qt + Math.imul(Or, jr) | 0;
                var yr = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (yr >>> 26) | 0,
                yr &= 67108863,
                It = Math.imul(Dt, En),
                St = Math.imul(Dt, an),
                St = St + Math.imul(er, En) | 0,
                qt = Math.imul(er, an),
                It = It + Math.imul(Ar, Jt) | 0,
                St = St + Math.imul(Ar, nr) | 0,
                St = St + Math.imul(Ft, Jt) | 0,
                qt = qt + Math.imul(Ft, nr) | 0,
                It = It + Math.imul(ar, jt) | 0,
                St = St + Math.imul(ar, cr) | 0,
                St = St + Math.imul(hr, jt) | 0,
                qt = qt + Math.imul(hr, cr) | 0,
                It = It + Math.imul(Qr, kr) | 0,
                St = St + Math.imul(Qr, Pr) | 0,
                St = St + Math.imul(Gr, kr) | 0,
                qt = qt + Math.imul(Gr, Pr) | 0,
                It = It + Math.imul(Zr, Vr) | 0,
                St = St + Math.imul(Zr, jr) | 0,
                St = St + Math.imul(Hr, Vr) | 0,
                qt = qt + Math.imul(Hr, jr) | 0;
                var Lt = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (Lt >>> 26) | 0,
                Lt &= 67108863,
                It = Math.imul(Dt, Jt),
                St = Math.imul(Dt, nr),
                St = St + Math.imul(er, Jt) | 0,
                qt = Math.imul(er, nr),
                It = It + Math.imul(Ar, jt) | 0,
                St = St + Math.imul(Ar, cr) | 0,
                St = St + Math.imul(Ft, jt) | 0,
                qt = qt + Math.imul(Ft, cr) | 0,
                It = It + Math.imul(ar, kr) | 0,
                St = St + Math.imul(ar, Pr) | 0,
                St = St + Math.imul(hr, kr) | 0,
                qt = qt + Math.imul(hr, Pr) | 0,
                It = It + Math.imul(Qr, Vr) | 0,
                St = St + Math.imul(Qr, jr) | 0,
                St = St + Math.imul(Gr, Vr) | 0,
                qt = qt + Math.imul(Gr, jr) | 0;
                var Gt = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (Gt >>> 26) | 0,
                Gt &= 67108863,
                It = Math.imul(Dt, jt),
                St = Math.imul(Dt, cr),
                St = St + Math.imul(er, jt) | 0,
                qt = Math.imul(er, cr),
                It = It + Math.imul(Ar, kr) | 0,
                St = St + Math.imul(Ar, Pr) | 0,
                St = St + Math.imul(Ft, kr) | 0,
                qt = qt + Math.imul(Ft, Pr) | 0,
                It = It + Math.imul(ar, Vr) | 0,
                St = St + Math.imul(ar, jr) | 0,
                St = St + Math.imul(hr, Vr) | 0,
                qt = qt + Math.imul(hr, jr) | 0;
                var Qt = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (Qt >>> 26) | 0,
                Qt &= 67108863,
                It = Math.imul(Dt, kr),
                St = Math.imul(Dt, Pr),
                St = St + Math.imul(er, kr) | 0,
                qt = Math.imul(er, Pr),
                It = It + Math.imul(Ar, Vr) | 0,
                St = St + Math.imul(Ar, jr) | 0,
                St = St + Math.imul(Ft, Vr) | 0,
                qt = qt + Math.imul(Ft, jr) | 0;
                var pr = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                Tt = (qt + (St >>> 13) | 0) + (pr >>> 26) | 0,
                pr &= 67108863,
                It = Math.imul(Dt, Vr),
                St = Math.imul(Dt, jr),
                St = St + Math.imul(er, Vr) | 0,
                qt = Math.imul(er, jr);
                var dr = (Tt + It | 0) + ((St & 8191) << 13) | 0;
                return Tt = (qt + (St >>> 13) | 0) + (dr >>> 26) | 0,
                dr &= 67108863,
                kt[0] = Mn,
                kt[1] = nn,
                kt[2] = gn,
                kt[3] = mn,
                kt[4] = xn,
                kt[5] = _n,
                kt[6] = yn,
                kt[7] = wn,
                kt[8] = vn,
                kt[9] = sn,
                kt[10] = hn,
                kt[11] = rn,
                kt[12] = ln,
                kt[13] = yr,
                kt[14] = Lt,
                kt[15] = Gt,
                kt[16] = Qt,
                kt[17] = pr,
                kt[18] = dr,
                Tt !== 0 && (kt[19] = Tt,
                Et.length++),
                Et
            };
            Math.imul || (Ot = $t);
            function Nt(_t, gt, vt) {
                vt.negative = gt.negative ^ _t.negative,
                vt.length = _t.length + gt.length;
                for (var Et = 0, Bt = 0, Rt = 0; Rt < vt.length - 1; Rt++) {
                    var kt = Bt;
                    Bt = 0;
                    for (var Tt = Et & 67108863, It = Math.min(Rt, gt.length - 1), St = Math.max(0, Rt - _t.length + 1); St <= It; St++) {
                        var qt = Rt - St
                          , ur = _t.words[qt] | 0
                          , gr = gt.words[St] | 0
                          , lr = ur * gr
                          , Zt = lr & 67108863;
                        kt = kt + (lr / 67108864 | 0) | 0,
                        Zt = Zt + Tt | 0,
                        Tt = Zt & 67108863,
                        kt = kt + (Zt >>> 26) | 0,
                        Bt += kt >>> 26,
                        kt &= 67108863
                    }
                    vt.words[Rt] = Tt,
                    Et = kt,
                    kt = Bt
                }
                return Et !== 0 ? vt.words[Rt] = Et : vt.length--,
                vt._strip()
            }
            function zt(_t, gt, vt) {
                return Nt(_t, gt, vt)
            }
            y.prototype.mulTo = function(gt, vt) {
                var Et, Bt = this.length + gt.length;
                return this.length === 10 && gt.length === 10 ? Et = Ot(this, gt, vt) : Bt < 63 ? Et = $t(this, gt, vt) : Bt < 1024 ? Et = Nt(this, gt, vt) : Et = zt(this, gt, vt),
                Et
            }
            ,
            y.prototype.mul = function(gt) {
                var vt = new y(null);
                return vt.words = new Array(this.length + gt.length),
                this.mulTo(gt, vt)
            }
            ,
            y.prototype.mulf = function(gt) {
                var vt = new y(null);
                return vt.words = new Array(this.length + gt.length),
                zt(this, gt, vt)
            }
            ,
            y.prototype.imul = function(gt) {
                return this.clone().mulTo(gt, this)
            }
            ,
            y.prototype.imuln = function(gt) {
                var vt = gt < 0;
                vt && (gt = -gt),
                m(typeof gt == "number"),
                m(gt < 67108864);
                for (var Et = 0, Bt = 0; Bt < this.length; Bt++) {
                    var Rt = (this.words[Bt] | 0) * gt
                      , kt = (Rt & 67108863) + (Et & 67108863);
                    Et >>= 26,
                    Et += Rt / 67108864 | 0,
                    Et += kt >>> 26,
                    this.words[Bt] = kt & 67108863
                }
                return Et !== 0 && (this.words[Bt] = Et,
                this.length++),
                vt ? this.ineg() : this
            }
            ,
            y.prototype.muln = function(gt) {
                return this.clone().imuln(gt)
            }
            ,
            y.prototype.sqr = function() {
                return this.mul(this)
            }
            ,
            y.prototype.isqr = function() {
                return this.imul(this.clone())
            }
            ,
            y.prototype.pow = function(gt) {
                var vt = Pt(gt);
                if (vt.length === 0)
                    return new y(1);
                for (var Et = this, Bt = 0; Bt < vt.length && vt[Bt] === 0; Bt++,
                Et = Et.sqr())
                    ;
                if (++Bt < vt.length)
                    for (var Rt = Et.sqr(); Bt < vt.length; Bt++,
                    Rt = Rt.sqr())
                        vt[Bt] !== 0 && (Et = Et.mul(Rt));
                return Et
            }
            ,
            y.prototype.iushln = function(gt) {
                m(typeof gt == "number" && gt >= 0);
                var vt = gt % 26, Et = (gt - vt) / 26, Bt = 67108863 >>> 26 - vt << 26 - vt, Rt;
                if (vt !== 0) {
                    var kt = 0;
                    for (Rt = 0; Rt < this.length; Rt++) {
                        var Tt = this.words[Rt] & Bt
                          , It = (this.words[Rt] | 0) - Tt << vt;
                        this.words[Rt] = It | kt,
                        kt = Tt >>> 26 - vt
                    }
                    kt && (this.words[Rt] = kt,
                    this.length++)
                }
                if (Et !== 0) {
                    for (Rt = this.length - 1; Rt >= 0; Rt--)
                        this.words[Rt + Et] = this.words[Rt];
                    for (Rt = 0; Rt < Et; Rt++)
                        this.words[Rt] = 0;
                    this.length += Et
                }
                return this._strip()
            }
            ,
            y.prototype.ishln = function(gt) {
                return m(this.negative === 0),
                this.iushln(gt)
            }
            ,
            y.prototype.iushrn = function(gt, vt, Et) {
                m(typeof gt == "number" && gt >= 0);
                var Bt;
                vt ? Bt = (vt - vt % 26) / 26 : Bt = 0;
                var Rt = gt % 26
                  , kt = Math.min((gt - Rt) / 26, this.length)
                  , Tt = 67108863 ^ 67108863 >>> Rt << Rt
                  , It = Et;
                if (Bt -= kt,
                Bt = Math.max(0, Bt),
                It) {
                    for (var St = 0; St < kt; St++)
                        It.words[St] = this.words[St];
                    It.length = kt
                }
                if (kt !== 0)
                    if (this.length > kt)
                        for (this.length -= kt,
                        St = 0; St < this.length; St++)
                            this.words[St] = this.words[St + kt];
                    else
                        this.words[0] = 0,
                        this.length = 1;
                var qt = 0;
                for (St = this.length - 1; St >= 0 && (qt !== 0 || St >= Bt); St--) {
                    var ur = this.words[St] | 0;
                    this.words[St] = qt << 26 - Rt | ur >>> Rt,
                    qt = ur & Tt
                }
                return It && qt !== 0 && (It.words[It.length++] = qt),
                this.length === 0 && (this.words[0] = 0,
                this.length = 1),
                this._strip()
            }
            ,
            y.prototype.ishrn = function(gt, vt, Et) {
                return m(this.negative === 0),
                this.iushrn(gt, vt, Et)
            }
            ,
            y.prototype.shln = function(gt) {
                return this.clone().ishln(gt)
            }
            ,
            y.prototype.ushln = function(gt) {
                return this.clone().iushln(gt)
            }
            ,
            y.prototype.shrn = function(gt) {
                return this.clone().ishrn(gt)
            }
            ,
            y.prototype.ushrn = function(gt) {
                return this.clone().iushrn(gt)
            }
            ,
            y.prototype.testn = function(gt) {
                m(typeof gt == "number" && gt >= 0);
                var vt = gt % 26
                  , Et = (gt - vt) / 26
                  , Bt = 1 << vt;
                if (this.length <= Et)
                    return !1;
                var Rt = this.words[Et];
                return !!(Rt & Bt)
            }
            ,
            y.prototype.imaskn = function(gt) {
                m(typeof gt == "number" && gt >= 0);
                var vt = gt % 26
                  , Et = (gt - vt) / 26;
                if (m(this.negative === 0, "imaskn works only with positive numbers"),
                this.length <= Et)
                    return this;
                if (vt !== 0 && Et++,
                this.length = Math.min(Et, this.length),
                vt !== 0) {
                    var Bt = 67108863 ^ 67108863 >>> vt << vt;
                    this.words[this.length - 1] &= Bt
                }
                return this._strip()
            }
            ,
            y.prototype.maskn = function(gt) {
                return this.clone().imaskn(gt)
            }
            ,
            y.prototype.iaddn = function(gt) {
                return m(typeof gt == "number"),
                m(gt < 67108864),
                gt < 0 ? this.isubn(-gt) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= gt ? (this.words[0] = gt - (this.words[0] | 0),
                this.negative = 0,
                this) : (this.negative = 0,
                this.isubn(gt),
                this.negative = 1,
                this) : this._iaddn(gt)
            }
            ,
            y.prototype._iaddn = function(gt) {
                this.words[0] += gt;
                for (var vt = 0; vt < this.length && this.words[vt] >= 67108864; vt++)
                    this.words[vt] -= 67108864,
                    vt === this.length - 1 ? this.words[vt + 1] = 1 : this.words[vt + 1]++;
                return this.length = Math.max(this.length, vt + 1),
                this
            }
            ,
            y.prototype.isubn = function(gt) {
                if (m(typeof gt == "number"),
                m(gt < 67108864),
                gt < 0)
                    return this.iaddn(-gt);
                if (this.negative !== 0)
                    return this.negative = 0,
                    this.iaddn(gt),
                    this.negative = 1,
                    this;
                if (this.words[0] -= gt,
                this.length === 1 && this.words[0] < 0)
                    this.words[0] = -this.words[0],
                    this.negative = 1;
                else
                    for (var vt = 0; vt < this.length && this.words[vt] < 0; vt++)
                        this.words[vt] += 67108864,
                        this.words[vt + 1] -= 1;
                return this._strip()
            }
            ,
            y.prototype.addn = function(gt) {
                return this.clone().iaddn(gt)
            }
            ,
            y.prototype.subn = function(gt) {
                return this.clone().isubn(gt)
            }
            ,
            y.prototype.iabs = function() {
                return this.negative = 0,
                this
            }
            ,
            y.prototype.abs = function() {
                return this.clone().iabs()
            }
            ,
            y.prototype._ishlnsubmul = function(gt, vt, Et) {
                var Bt = gt.length + Et, Rt;
                this._expand(Bt);
                var kt, Tt = 0;
                for (Rt = 0; Rt < gt.length; Rt++) {
                    kt = (this.words[Rt + Et] | 0) + Tt;
                    var It = (gt.words[Rt] | 0) * vt;
                    kt -= It & 67108863,
                    Tt = (kt >> 26) - (It / 67108864 | 0),
                    this.words[Rt + Et] = kt & 67108863
                }
                for (; Rt < this.length - Et; Rt++)
                    kt = (this.words[Rt + Et] | 0) + Tt,
                    Tt = kt >> 26,
                    this.words[Rt + Et] = kt & 67108863;
                if (Tt === 0)
                    return this._strip();
                for (m(Tt === -1),
                Tt = 0,
                Rt = 0; Rt < this.length; Rt++)
                    kt = -(this.words[Rt] | 0) + Tt,
                    Tt = kt >> 26,
                    this.words[Rt] = kt & 67108863;
                return this.negative = 1,
                this._strip()
            }
            ,
            y.prototype._wordDiv = function(gt, vt) {
                var Et = this.length - gt.length
                  , Bt = this.clone()
                  , Rt = gt
                  , kt = Rt.words[Rt.length - 1] | 0
                  , Tt = this._countBits(kt);
                Et = 26 - Tt,
                Et !== 0 && (Rt = Rt.ushln(Et),
                Bt.iushln(Et),
                kt = Rt.words[Rt.length - 1] | 0);
                var It = Bt.length - Rt.length, St;
                if (vt !== "mod") {
                    St = new y(null),
                    St.length = It + 1,
                    St.words = new Array(St.length);
                    for (var qt = 0; qt < St.length; qt++)
                        St.words[qt] = 0
                }
                var ur = Bt.clone()._ishlnsubmul(Rt, 1, It);
                ur.negative === 0 && (Bt = ur,
                St && (St.words[It] = 1));
                for (var gr = It - 1; gr >= 0; gr--) {
                    var lr = (Bt.words[Rt.length + gr] | 0) * 67108864 + (Bt.words[Rt.length + gr - 1] | 0);
                    for (lr = Math.min(lr / kt | 0, 67108863),
                    Bt._ishlnsubmul(Rt, lr, gr); Bt.negative !== 0; )
                        lr--,
                        Bt.negative = 0,
                        Bt._ishlnsubmul(Rt, 1, gr),
                        Bt.isZero() || (Bt.negative ^= 1);
                    St && (St.words[gr] = lr)
                }
                return St && St._strip(),
                Bt._strip(),
                vt !== "div" && Et !== 0 && Bt.iushrn(Et),
                {
                    div: St || null,
                    mod: Bt
                }
            }
            ,
            y.prototype.divmod = function(gt, vt, Et) {
                if (m(!gt.isZero()),
                this.isZero())
                    return {
                        div: new y(0),
                        mod: new y(0)
                    };
                var Bt, Rt, kt;
                return this.negative !== 0 && gt.negative === 0 ? (kt = this.neg().divmod(gt, vt),
                vt !== "mod" && (Bt = kt.div.neg()),
                vt !== "div" && (Rt = kt.mod.neg(),
                Et && Rt.negative !== 0 && Rt.iadd(gt)),
                {
                    div: Bt,
                    mod: Rt
                }) : this.negative === 0 && gt.negative !== 0 ? (kt = this.divmod(gt.neg(), vt),
                vt !== "mod" && (Bt = kt.div.neg()),
                {
                    div: Bt,
                    mod: kt.mod
                }) : this.negative & gt.negative ? (kt = this.neg().divmod(gt.neg(), vt),
                vt !== "div" && (Rt = kt.mod.neg(),
                Et && Rt.negative !== 0 && Rt.isub(gt)),
                {
                    div: kt.div,
                    mod: Rt
                }) : gt.length > this.length || this.cmp(gt) < 0 ? {
                    div: new y(0),
                    mod: this
                } : gt.length === 1 ? vt === "div" ? {
                    div: this.divn(gt.words[0]),
                    mod: null
                } : vt === "mod" ? {
                    div: null,
                    mod: new y(this.modrn(gt.words[0]))
                } : {
                    div: this.divn(gt.words[0]),
                    mod: new y(this.modrn(gt.words[0]))
                } : this._wordDiv(gt, vt)
            }
            ,
            y.prototype.div = function(gt) {
                return this.divmod(gt, "div", !1).div
            }
            ,
            y.prototype.mod = function(gt) {
                return this.divmod(gt, "mod", !1).mod
            }
            ,
            y.prototype.umod = function(gt) {
                return this.divmod(gt, "mod", !0).mod
            }
            ,
            y.prototype.divRound = function(gt) {
                var vt = this.divmod(gt);
                if (vt.mod.isZero())
                    return vt.div;
                var Et = vt.div.negative !== 0 ? vt.mod.isub(gt) : vt.mod
                  , Bt = gt.ushrn(1)
                  , Rt = gt.andln(1)
                  , kt = Et.cmp(Bt);
                return kt < 0 || Rt === 1 && kt === 0 ? vt.div : vt.div.negative !== 0 ? vt.div.isubn(1) : vt.div.iaddn(1)
            }
            ,
            y.prototype.modrn = function(gt) {
                var vt = gt < 0;
                vt && (gt = -gt),
                m(gt <= 67108863);
                for (var Et = (1 << 26) % gt, Bt = 0, Rt = this.length - 1; Rt >= 0; Rt--)
                    Bt = (Et * Bt + (this.words[Rt] | 0)) % gt;
                return vt ? -Bt : Bt
            }
            ,
            y.prototype.modn = function(gt) {
                return this.modrn(gt)
            }
            ,
            y.prototype.idivn = function(gt) {
                var vt = gt < 0;
                vt && (gt = -gt),
                m(gt <= 67108863);
                for (var Et = 0, Bt = this.length - 1; Bt >= 0; Bt--) {
                    var Rt = (this.words[Bt] | 0) + Et * 67108864;
                    this.words[Bt] = Rt / gt | 0,
                    Et = Rt % gt
                }
                return this._strip(),
                vt ? this.ineg() : this
            }
            ,
            y.prototype.divn = function(gt) {
                return this.clone().idivn(gt)
            }
            ,
            y.prototype.egcd = function(gt) {
                m(gt.negative === 0),
                m(!gt.isZero());
                var vt = this
                  , Et = gt.clone();
                vt.negative !== 0 ? vt = vt.umod(gt) : vt = vt.clone();
                for (var Bt = new y(1), Rt = new y(0), kt = new y(0), Tt = new y(1), It = 0; vt.isEven() && Et.isEven(); )
                    vt.iushrn(1),
                    Et.iushrn(1),
                    ++It;
                for (var St = Et.clone(), qt = vt.clone(); !vt.isZero(); ) {
                    for (var ur = 0, gr = 1; !(vt.words[0] & gr) && ur < 26; ++ur,
                    gr <<= 1)
                        ;
                    if (ur > 0)
                        for (vt.iushrn(ur); ur-- > 0; )
                            (Bt.isOdd() || Rt.isOdd()) && (Bt.iadd(St),
                            Rt.isub(qt)),
                            Bt.iushrn(1),
                            Rt.iushrn(1);
                    for (var lr = 0, Zt = 1; !(Et.words[0] & Zt) && lr < 26; ++lr,
                    Zt <<= 1)
                        ;
                    if (lr > 0)
                        for (Et.iushrn(lr); lr-- > 0; )
                            (kt.isOdd() || Tt.isOdd()) && (kt.iadd(St),
                            Tt.isub(qt)),
                            kt.iushrn(1),
                            Tt.iushrn(1);
                    vt.cmp(Et) >= 0 ? (vt.isub(Et),
                    Bt.isub(kt),
                    Rt.isub(Tt)) : (Et.isub(vt),
                    kt.isub(Bt),
                    Tt.isub(Rt))
                }
                return {
                    a: kt,
                    b: Tt,
                    gcd: Et.iushln(It)
                }
            }
            ,
            y.prototype._invmp = function(gt) {
                m(gt.negative === 0),
                m(!gt.isZero());
                var vt = this
                  , Et = gt.clone();
                vt.negative !== 0 ? vt = vt.umod(gt) : vt = vt.clone();
                for (var Bt = new y(1), Rt = new y(0), kt = Et.clone(); vt.cmpn(1) > 0 && Et.cmpn(1) > 0; ) {
                    for (var Tt = 0, It = 1; !(vt.words[0] & It) && Tt < 26; ++Tt,
                    It <<= 1)
                        ;
                    if (Tt > 0)
                        for (vt.iushrn(Tt); Tt-- > 0; )
                            Bt.isOdd() && Bt.iadd(kt),
                            Bt.iushrn(1);
                    for (var St = 0, qt = 1; !(Et.words[0] & qt) && St < 26; ++St,
                    qt <<= 1)
                        ;
                    if (St > 0)
                        for (Et.iushrn(St); St-- > 0; )
                            Rt.isOdd() && Rt.iadd(kt),
                            Rt.iushrn(1);
                    vt.cmp(Et) >= 0 ? (vt.isub(Et),
                    Bt.isub(Rt)) : (Et.isub(vt),
                    Rt.isub(Bt))
                }
                var ur;
                return vt.cmpn(1) === 0 ? ur = Bt : ur = Rt,
                ur.cmpn(0) < 0 && ur.iadd(gt),
                ur
            }
            ,
            y.prototype.gcd = function(gt) {
                if (this.isZero())
                    return gt.abs();
                if (gt.isZero())
                    return this.abs();
                var vt = this.clone()
                  , Et = gt.clone();
                vt.negative = 0,
                Et.negative = 0;
                for (var Bt = 0; vt.isEven() && Et.isEven(); Bt++)
                    vt.iushrn(1),
                    Et.iushrn(1);
                do {
                    for (; vt.isEven(); )
                        vt.iushrn(1);
                    for (; Et.isEven(); )
                        Et.iushrn(1);
                    var Rt = vt.cmp(Et);
                    if (Rt < 0) {
                        var kt = vt;
                        vt = Et,
                        Et = kt
                    } else if (Rt === 0 || Et.cmpn(1) === 0)
                        break;
                    vt.isub(Et)
                } while (!0);
                return Et.iushln(Bt)
            }
            ,
            y.prototype.invm = function(gt) {
                return this.egcd(gt).a.umod(gt)
            }
            ,
            y.prototype.isEven = function() {
                return (this.words[0] & 1) === 0
            }
            ,
            y.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1
            }
            ,
            y.prototype.andln = function(gt) {
                return this.words[0] & gt
            }
            ,
            y.prototype.bincn = function(gt) {
                m(typeof gt == "number");
                var vt = gt % 26
                  , Et = (gt - vt) / 26
                  , Bt = 1 << vt;
                if (this.length <= Et)
                    return this._expand(Et + 1),
                    this.words[Et] |= Bt,
                    this;
                for (var Rt = Bt, kt = Et; Rt !== 0 && kt < this.length; kt++) {
                    var Tt = this.words[kt] | 0;
                    Tt += Rt,
                    Rt = Tt >>> 26,
                    Tt &= 67108863,
                    this.words[kt] = Tt
                }
                return Rt !== 0 && (this.words[kt] = Rt,
                this.length++),
                this
            }
            ,
            y.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0
            }
            ,
            y.prototype.cmpn = function(gt) {
                var vt = gt < 0;
                if (this.negative !== 0 && !vt)
                    return -1;
                if (this.negative === 0 && vt)
                    return 1;
                this._strip();
                var Et;
                if (this.length > 1)
                    Et = 1;
                else {
                    vt && (gt = -gt),
                    m(gt <= 67108863, "Number is too big");
                    var Bt = this.words[0] | 0;
                    Et = Bt === gt ? 0 : Bt < gt ? -1 : 1
                }
                return this.negative !== 0 ? -Et | 0 : Et
            }
            ,
            y.prototype.cmp = function(gt) {
                if (this.negative !== 0 && gt.negative === 0)
                    return -1;
                if (this.negative === 0 && gt.negative !== 0)
                    return 1;
                var vt = this.ucmp(gt);
                return this.negative !== 0 ? -vt | 0 : vt
            }
            ,
            y.prototype.ucmp = function(gt) {
                if (this.length > gt.length)
                    return 1;
                if (this.length < gt.length)
                    return -1;
                for (var vt = 0, Et = this.length - 1; Et >= 0; Et--) {
                    var Bt = this.words[Et] | 0
                      , Rt = gt.words[Et] | 0;
                    if (Bt !== Rt) {
                        Bt < Rt ? vt = -1 : Bt > Rt && (vt = 1);
                        break
                    }
                }
                return vt
            }
            ,
            y.prototype.gtn = function(gt) {
                return this.cmpn(gt) === 1
            }
            ,
            y.prototype.gt = function(gt) {
                return this.cmp(gt) === 1
            }
            ,
            y.prototype.gten = function(gt) {
                return this.cmpn(gt) >= 0
            }
            ,
            y.prototype.gte = function(gt) {
                return this.cmp(gt) >= 0
            }
            ,
            y.prototype.ltn = function(gt) {
                return this.cmpn(gt) === -1
            }
            ,
            y.prototype.lt = function(gt) {
                return this.cmp(gt) === -1
            }
            ,
            y.prototype.lten = function(gt) {
                return this.cmpn(gt) <= 0
            }
            ,
            y.prototype.lte = function(gt) {
                return this.cmp(gt) <= 0
            }
            ,
            y.prototype.eqn = function(gt) {
                return this.cmpn(gt) === 0
            }
            ,
            y.prototype.eq = function(gt) {
                return this.cmp(gt) === 0
            }
            ,
            y.red = function(gt) {
                return new Ht(gt)
            }
            ,
            y.prototype.toRed = function(gt) {
                return m(!this.red, "Already a number in reduction context"),
                m(this.negative === 0, "red works only with positives"),
                gt.convertTo(this)._forceRed(gt)
            }
            ,
            y.prototype.fromRed = function() {
                return m(this.red, "fromRed works only with numbers in reduction context"),
                this.red.convertFrom(this)
            }
            ,
            y.prototype._forceRed = function(gt) {
                return this.red = gt,
                this
            }
            ,
            y.prototype.forceRed = function(gt) {
                return m(!this.red, "Already a number in reduction context"),
                this._forceRed(gt)
            }
            ,
            y.prototype.redAdd = function(gt) {
                return m(this.red, "redAdd works only with red numbers"),
                this.red.add(this, gt)
            }
            ,
            y.prototype.redIAdd = function(gt) {
                return m(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, gt)
            }
            ,
            y.prototype.redSub = function(gt) {
                return m(this.red, "redSub works only with red numbers"),
                this.red.sub(this, gt)
            }
            ,
            y.prototype.redISub = function(gt) {
                return m(this.red, "redISub works only with red numbers"),
                this.red.isub(this, gt)
            }
            ,
            y.prototype.redShl = function(gt) {
                return m(this.red, "redShl works only with red numbers"),
                this.red.shl(this, gt)
            }
            ,
            y.prototype.redMul = function(gt) {
                return m(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, gt),
                this.red.mul(this, gt)
            }
            ,
            y.prototype.redIMul = function(gt) {
                return m(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, gt),
                this.red.imul(this, gt)
            }
            ,
            y.prototype.redSqr = function() {
                return m(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
            }
            ,
            y.prototype.redISqr = function() {
                return m(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
            }
            ,
            y.prototype.redSqrt = function() {
                return m(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
            }
            ,
            y.prototype.redInvm = function() {
                return m(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
            }
            ,
            y.prototype.redNeg = function() {
                return m(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
            }
            ,
            y.prototype.redPow = function(gt) {
                return m(this.red && !gt.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, gt)
            }
            ;
            var Wt = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function Kt(_t, gt) {
                this.name = _t,
                this.p = new y(gt,16),
                this.n = this.p.bitLength(),
                this.k = new y(1).iushln(this.n).isub(this.p),
                this.tmp = this._tmp()
            }
            Kt.prototype._tmp = function() {
                var gt = new y(null);
                return gt.words = new Array(Math.ceil(this.n / 13)),
                gt
            }
            ,
            Kt.prototype.ireduce = function(gt) {
                var vt = gt, Et;
                do
                    this.split(vt, this.tmp),
                    vt = this.imulK(vt),
                    vt = vt.iadd(this.tmp),
                    Et = vt.bitLength();
                while (Et > this.n);
                var Bt = Et < this.n ? -1 : vt.ucmp(this.p);
                return Bt === 0 ? (vt.words[0] = 0,
                vt.length = 1) : Bt > 0 ? vt.isub(this.p) : vt.strip !== void 0 ? vt.strip() : vt._strip(),
                vt
            }
            ,
            Kt.prototype.split = function(gt, vt) {
                gt.iushrn(this.n, 0, vt)
            }
            ,
            Kt.prototype.imulK = function(gt) {
                return gt.imul(this.k)
            }
            ;
            function ir() {
                Kt.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
            }
            k(ir, Kt),
            ir.prototype.split = function(gt, vt) {
                for (var Et = 4194303, Bt = Math.min(gt.length, 9), Rt = 0; Rt < Bt; Rt++)
                    vt.words[Rt] = gt.words[Rt];
                if (vt.length = Bt,
                gt.length <= 9) {
                    gt.words[0] = 0,
                    gt.length = 1;
                    return
                }
                var kt = gt.words[9];
                for (vt.words[vt.length++] = kt & Et,
                Rt = 10; Rt < gt.length; Rt++) {
                    var Tt = gt.words[Rt] | 0;
                    gt.words[Rt - 10] = (Tt & Et) << 4 | kt >>> 22,
                    kt = Tt
                }
                kt >>>= 22,
                gt.words[Rt - 10] = kt,
                kt === 0 && gt.length > 10 ? gt.length -= 10 : gt.length -= 9
            }
            ,
            ir.prototype.imulK = function(gt) {
                gt.words[gt.length] = 0,
                gt.words[gt.length + 1] = 0,
                gt.length += 2;
                for (var vt = 0, Et = 0; Et < gt.length; Et++) {
                    var Bt = gt.words[Et] | 0;
                    vt += Bt * 977,
                    gt.words[Et] = vt & 67108863,
                    vt = Bt * 64 + (vt / 67108864 | 0)
                }
                return gt.words[gt.length - 1] === 0 && (gt.length--,
                gt.words[gt.length - 1] === 0 && gt.length--),
                gt
            }
            ;
            function or() {
                Kt.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
            }
            k(or, Kt);
            function tr() {
                Kt.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
            }
            k(tr, Kt);
            function wr() {
                Kt.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
            }
            k(wr, Kt),
            wr.prototype.imulK = function(gt) {
                for (var vt = 0, Et = 0; Et < gt.length; Et++) {
                    var Bt = (gt.words[Et] | 0) * 19 + vt
                      , Rt = Bt & 67108863;
                    Bt >>>= 26,
                    gt.words[Et] = Rt,
                    vt = Bt
                }
                return vt !== 0 && (gt.words[gt.length++] = vt),
                gt
            }
            ,
            y._prime = function(gt) {
                if (Wt[gt])
                    return Wt[gt];
                var vt;
                if (gt === "k256")
                    vt = new ir;
                else if (gt === "p224")
                    vt = new or;
                else if (gt === "p192")
                    vt = new tr;
                else if (gt === "p25519")
                    vt = new wr;
                else
                    throw new Error("Unknown prime " + gt);
                return Wt[gt] = vt,
                vt
            }
            ;
            function Ht(_t) {
                if (typeof _t == "string") {
                    var gt = y._prime(_t);
                    this.m = gt.p,
                    this.prime = gt
                } else
                    m(_t.gtn(1), "modulus must be greater than 1"),
                    this.m = _t,
                    this.prime = null
            }
            Ht.prototype._verify1 = function(gt) {
                m(gt.negative === 0, "red works only with positives"),
                m(gt.red, "red works only with red numbers")
            }
            ,
            Ht.prototype._verify2 = function(gt, vt) {
                m((gt.negative | vt.negative) === 0, "red works only with positives"),
                m(gt.red && gt.red === vt.red, "red works only with red numbers")
            }
            ,
            Ht.prototype.imod = function(gt) {
                return this.prime ? this.prime.ireduce(gt)._forceRed(this) : (pt(gt, gt.umod(this.m)._forceRed(this)),
                gt)
            }
            ,
            Ht.prototype.neg = function(gt) {
                return gt.isZero() ? gt.clone() : this.m.sub(gt)._forceRed(this)
            }
            ,
            Ht.prototype.add = function(gt, vt) {
                this._verify2(gt, vt);
                var Et = gt.add(vt);
                return Et.cmp(this.m) >= 0 && Et.isub(this.m),
                Et._forceRed(this)
            }
            ,
            Ht.prototype.iadd = function(gt, vt) {
                this._verify2(gt, vt);
                var Et = gt.iadd(vt);
                return Et.cmp(this.m) >= 0 && Et.isub(this.m),
                Et
            }
            ,
            Ht.prototype.sub = function(gt, vt) {
                this._verify2(gt, vt);
                var Et = gt.sub(vt);
                return Et.cmpn(0) < 0 && Et.iadd(this.m),
                Et._forceRed(this)
            }
            ,
            Ht.prototype.isub = function(gt, vt) {
                this._verify2(gt, vt);
                var Et = gt.isub(vt);
                return Et.cmpn(0) < 0 && Et.iadd(this.m),
                Et
            }
            ,
            Ht.prototype.shl = function(gt, vt) {
                return this._verify1(gt),
                this.imod(gt.ushln(vt))
            }
            ,
            Ht.prototype.imul = function(gt, vt) {
                return this._verify2(gt, vt),
                this.imod(gt.imul(vt))
            }
            ,
            Ht.prototype.mul = function(gt, vt) {
                return this._verify2(gt, vt),
                this.imod(gt.mul(vt))
            }
            ,
            Ht.prototype.isqr = function(gt) {
                return this.imul(gt, gt.clone())
            }
            ,
            Ht.prototype.sqr = function(gt) {
                return this.mul(gt, gt)
            }
            ,
            Ht.prototype.sqrt = function(gt) {
                if (gt.isZero())
                    return gt.clone();
                var vt = this.m.andln(3);
                if (m(vt % 2 === 1),
                vt === 3) {
                    var Et = this.m.add(new y(1)).iushrn(2);
                    return this.pow(gt, Et)
                }
                for (var Bt = this.m.subn(1), Rt = 0; !Bt.isZero() && Bt.andln(1) === 0; )
                    Rt++,
                    Bt.iushrn(1);
                m(!Bt.isZero());
                var kt = new y(1).toRed(this)
                  , Tt = kt.redNeg()
                  , It = this.m.subn(1).iushrn(1)
                  , St = this.m.bitLength();
                for (St = new y(2 * St * St).toRed(this); this.pow(St, It).cmp(Tt) !== 0; )
                    St.redIAdd(Tt);
                for (var qt = this.pow(St, Bt), ur = this.pow(gt, Bt.addn(1).iushrn(1)), gr = this.pow(gt, Bt), lr = Rt; gr.cmp(kt) !== 0; ) {
                    for (var Zt = gr, Vt = 0; Zt.cmp(kt) !== 0; Vt++)
                        Zt = Zt.redSqr();
                    m(Vt < lr);
                    var rr = this.pow(qt, new y(1).iushln(lr - Vt - 1));
                    ur = ur.redMul(rr),
                    qt = rr.redSqr(),
                    gr = gr.redMul(qt),
                    lr = Vt
                }
                return ur
            }
            ,
            Ht.prototype.invm = function(gt) {
                var vt = gt._invmp(this.m);
                return vt.negative !== 0 ? (vt.negative = 0,
                this.imod(vt).redNeg()) : this.imod(vt)
            }
            ,
            Ht.prototype.pow = function(gt, vt) {
                if (vt.isZero())
                    return new y(1).toRed(this);
                if (vt.cmpn(1) === 0)
                    return gt.clone();
                var Et = 4
                  , Bt = new Array(1 << Et);
                Bt[0] = new y(1).toRed(this),
                Bt[1] = gt;
                for (var Rt = 2; Rt < Bt.length; Rt++)
                    Bt[Rt] = this.mul(Bt[Rt - 1], gt);
                var kt = Bt[0]
                  , Tt = 0
                  , It = 0
                  , St = vt.bitLength() % 26;
                for (St === 0 && (St = 26),
                Rt = vt.length - 1; Rt >= 0; Rt--) {
                    for (var qt = vt.words[Rt], ur = St - 1; ur >= 0; ur--) {
                        var gr = qt >> ur & 1;
                        if (kt !== Bt[0] && (kt = this.sqr(kt)),
                        gr === 0 && Tt === 0) {
                            It = 0;
                            continue
                        }
                        Tt <<= 1,
                        Tt |= gr,
                        It++,
                        !(It !== Et && (Rt !== 0 || ur !== 0)) && (kt = this.mul(kt, Bt[Tt]),
                        It = 0,
                        Tt = 0)
                    }
                    St = 26
                }
                return kt
            }
            ,
            Ht.prototype.convertTo = function(gt) {
                var vt = gt.umod(this.m);
                return vt === gt ? vt.clone() : vt
            }
            ,
            Ht.prototype.convertFrom = function(gt) {
                var vt = gt.clone();
                return vt.red = null,
                vt
            }
            ,
            y.mont = function(gt) {
                return new Mt(gt)
            }
            ;
            function Mt(_t) {
                Ht.call(this, _t),
                this.shift = this.m.bitLength(),
                this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26),
                this.r = new y(1).iushln(this.shift),
                this.r2 = this.imod(this.r.sqr()),
                this.rinv = this.r._invmp(this.m),
                this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
                this.minv = this.minv.umod(this.r),
                this.minv = this.r.sub(this.minv)
            }
            k(Mt, Ht),
            Mt.prototype.convertTo = function(gt) {
                return this.imod(gt.ushln(this.shift))
            }
            ,
            Mt.prototype.convertFrom = function(gt) {
                var vt = this.imod(gt.mul(this.rinv));
                return vt.red = null,
                vt
            }
            ,
            Mt.prototype.imul = function(gt, vt) {
                if (gt.isZero() || vt.isZero())
                    return gt.words[0] = 0,
                    gt.length = 1,
                    gt;
                var Et = gt.imul(vt)
                  , Bt = Et.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , Rt = Et.isub(Bt).iushrn(this.shift)
                  , kt = Rt;
                return Rt.cmp(this.m) >= 0 ? kt = Rt.isub(this.m) : Rt.cmpn(0) < 0 && (kt = Rt.iadd(this.m)),
                kt._forceRed(this)
            }
            ,
            Mt.prototype.mul = function(gt, vt) {
                if (gt.isZero() || vt.isZero())
                    return new y(0)._forceRed(this);
                var Et = gt.mul(vt)
                  , Bt = Et.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , Rt = Et.isub(Bt).iushrn(this.shift)
                  , kt = Rt;
                return Rt.cmp(this.m) >= 0 ? kt = Rt.isub(this.m) : Rt.cmpn(0) < 0 && (kt = Rt.iadd(this.m)),
                kt._forceRed(this)
            }
            ,
            Mt.prototype.invm = function(gt) {
                var vt = this.imod(gt._invmp(this.m).mul(this.r2));
                return vt._forceRed(this)
            }
        }
        )(r, commonjsGlobal)
    }(bn)),
    bn.exports
}
var asn1$1 = {}, asn1 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
    return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1,
    function(exports) {
        var indexOf = function(r, d) {
            if (r.indexOf)
                return r.indexOf(d);
            for (var f = 0; f < r.length; f++)
                if (r[f] === d)
                    return f;
            return -1
        }
          , Object_keys = function(r) {
            if (Object.keys)
                return Object.keys(r);
            var d = [];
            for (var f in r)
                d.push(f);
            return d
        }
          , forEach = function(r, d) {
            if (r.forEach)
                return r.forEach(d);
            for (var f = 0; f < r.length; f++)
                d(r[f], f, r)
        }
          , defineProp = function() {
            try {
                return Object.defineProperty({}, "_", {}),
                function(r, d, f) {
                    Object.defineProperty(r, d, {
                        writable: !0,
                        enumerable: !1,
                        configurable: !0,
                        value: f
                    })
                }
            } catch {
                return function(d, f, m) {
                    d[f] = m
                }
            }
        }()
          , globals = ["Array", "Boolean", "Date", "Error", "EvalError", "Function", "Infinity", "JSON", "Math", "NaN", "Number", "Object", "RangeError", "ReferenceError", "RegExp", "String", "SyntaxError", "TypeError", "URIError", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "undefined", "unescape"];
        function Context() {}
        Context.prototype = {};
        var Script = exports.Script = function(d) {
            if (!(this instanceof Script))
                return new Script(d);
            this.code = d
        }
        ;
        Script.prototype.runInContext = function(r) {
            if (!(r instanceof Context))
                throw new TypeError("needs a 'context' argument.");
            var d = document.createElement("iframe");
            d.style || (d.style = {}),
            d.style.display = "none",
            document.body.appendChild(d);
            var f = d.contentWindow
              , m = f.eval
              , k = f.execScript;
            !m && k && (k.call(f, "null"),
            m = f.eval),
            forEach(Object_keys(r), function(dt) {
                f[dt] = r[dt]
            }),
            forEach(globals, function(dt) {
                r[dt] && (f[dt] = r[dt])
            });
            var y = Object_keys(f)
              , ee = m.call(f, this.code);
            return forEach(Object_keys(f), function(dt) {
                (dt in r || indexOf(y, dt) === -1) && (r[dt] = f[dt])
            }),
            forEach(globals, function(dt) {
                dt in r || defineProp(r, dt, f[dt])
            }),
            document.body.removeChild(d),
            ee
        }
        ,
        Script.prototype.runInThisContext = function() {
            return eval(this.code)
        }
        ,
        Script.prototype.runInNewContext = function(r) {
            var d = Script.createContext(r)
              , f = this.runInContext(d);
            return r && forEach(Object_keys(d), function(m) {
                r[m] = d[m]
            }),
            f
        }
        ,
        forEach(Object_keys(Script.prototype), function(r) {
            exports[r] = Script[r] = function(d) {
                var f = Script(d);
                return f[r].apply(f, [].slice.call(arguments, 1))
            }
        }),
        exports.isContext = function(r) {
            return r instanceof Context
        }
        ,
        exports.createScript = function(r) {
            return exports.Script(r)
        }
        ,
        exports.createContext = Script.createContext = function(r) {
            var d = new Context;
            return typeof r == "object" && forEach(Object_keys(r), function(f) {
                d[f] = r[f]
            }),
            d
        }
    }(vmBrowserify)),
    vmBrowserify
}
var hasRequiredApi;
function requireApi() {
    return hasRequiredApi || (hasRequiredApi = 1,
    function(r) {
        var d = requireAsn1$1()
          , f = requireInherits_browser()
          , m = r;
        m.define = function(ee, dt) {
            return new k(ee,dt)
        }
        ;
        function k(y, ee) {
            this.name = y,
            this.body = ee,
            this.decoders = {},
            this.encoders = {}
        }
        k.prototype._createNamed = function(ee) {
            var dt;
            try {
                dt = requireVmBrowserify().runInThisContext("(function " + this.name + `(entity) {
  this._initNamed(entity);
})`)
            } catch {
                dt = function(yt) {
                    this._initNamed(yt)
                }
            }
            return f(dt, ee),
            dt.prototype._initNamed = function(yt) {
                ee.call(this, yt)
            }
            ,
            new dt(this)
        }
        ,
        k.prototype._getDecoder = function(ee) {
            return ee = ee || "der",
            this.decoders.hasOwnProperty(ee) || (this.decoders[ee] = this._createNamed(d.decoders[ee])),
            this.decoders[ee]
        }
        ,
        k.prototype.decode = function(ee, dt, mt) {
            return this._getDecoder(dt).decode(ee, mt)
        }
        ,
        k.prototype._getEncoder = function(ee) {
            return ee = ee || "der",
            this.encoders.hasOwnProperty(ee) || (this.encoders[ee] = this._createNamed(d.encoders[ee])),
            this.encoders[ee]
        }
        ,
        k.prototype.encode = function(ee, dt, mt) {
            return this._getEncoder(dt).encode(ee, mt)
        }
    }(api)),
    api
}
var base = {}, reporter = {}, hasRequiredReporter;
function requireReporter() {
    if (hasRequiredReporter)
        return reporter;
    hasRequiredReporter = 1;
    var r = requireInherits_browser();
    function d(m) {
        this._reporterState = {
            obj: null,
            path: [],
            options: m || {},
            errors: []
        }
    }
    reporter.Reporter = d,
    d.prototype.isError = function(k) {
        return k instanceof f
    }
    ,
    d.prototype.save = function() {
        var k = this._reporterState;
        return {
            obj: k.obj,
            pathLen: k.path.length
        }
    }
    ,
    d.prototype.restore = function(k) {
        var y = this._reporterState;
        y.obj = k.obj,
        y.path = y.path.slice(0, k.pathLen)
    }
    ,
    d.prototype.enterKey = function(k) {
        return this._reporterState.path.push(k)
    }
    ,
    d.prototype.exitKey = function(k) {
        var y = this._reporterState;
        y.path = y.path.slice(0, k - 1)
    }
    ,
    d.prototype.leaveKey = function(k, y, ee) {
        var dt = this._reporterState;
        this.exitKey(k),
        dt.obj !== null && (dt.obj[y] = ee)
    }
    ,
    d.prototype.path = function() {
        return this._reporterState.path.join("/")
    }
    ,
    d.prototype.enterObject = function() {
        var k = this._reporterState
          , y = k.obj;
        return k.obj = {},
        y
    }
    ,
    d.prototype.leaveObject = function(k) {
        var y = this._reporterState
          , ee = y.obj;
        return y.obj = k,
        ee
    }
    ,
    d.prototype.error = function(k) {
        var y, ee = this._reporterState, dt = k instanceof f;
        if (dt ? y = k : y = new f(ee.path.map(function(mt) {
            return "[" + JSON.stringify(mt) + "]"
        }).join(""),k.message || k,k.stack),
        !ee.options.partial)
            throw y;
        return dt || ee.errors.push(y),
        y
    }
    ,
    d.prototype.wrapResult = function(k) {
        var y = this._reporterState;
        return y.options.partial ? {
            result: this.isError(k) ? null : k,
            errors: y.errors
        } : k
    }
    ;
    function f(m, k) {
        this.path = m,
        this.rethrow(k)
    }
    return r(f, Error),
    f.prototype.rethrow = function(k) {
        if (this.message = k + " at: " + (this.path || "(shallow)"),
        Error.captureStackTrace && Error.captureStackTrace(this, f),
        !this.stack)
            try {
                throw new Error(this.message)
            } catch (y) {
                this.stack = y.stack
            }
        return this
    }
    ,
    reporter
}
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
    if (hasRequiredBuffer)
        return buffer;
    hasRequiredBuffer = 1;
    var r = requireInherits_browser()
      , d = requireBase().Reporter
      , f = require$$1$2.Buffer;
    function m(y, ee) {
        if (d.call(this, ee),
        !f.isBuffer(y)) {
            this.error("Input not Buffer");
            return
        }
        this.base = y,
        this.offset = 0,
        this.length = y.length
    }
    r(m, d),
    buffer.DecoderBuffer = m,
    m.prototype.save = function() {
        return {
            offset: this.offset,
            reporter: d.prototype.save.call(this)
        }
    }
    ,
    m.prototype.restore = function(ee) {
        var dt = new m(this.base);
        return dt.offset = ee.offset,
        dt.length = this.offset,
        this.offset = ee.offset,
        d.prototype.restore.call(this, ee.reporter),
        dt
    }
    ,
    m.prototype.isEmpty = function() {
        return this.offset === this.length
    }
    ,
    m.prototype.readUInt8 = function(ee) {
        return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(ee || "DecoderBuffer overrun")
    }
    ,
    m.prototype.skip = function(ee, dt) {
        if (!(this.offset + ee <= this.length))
            return this.error(dt || "DecoderBuffer overrun");
        var mt = new m(this.base);
        return mt._reporterState = this._reporterState,
        mt.offset = this.offset,
        mt.length = this.offset + ee,
        this.offset += ee,
        mt
    }
    ,
    m.prototype.raw = function(ee) {
        return this.base.slice(ee ? ee.offset : this.offset, this.length)
    }
    ;
    function k(y, ee) {
        if (Array.isArray(y))
            this.length = 0,
            this.value = y.map(function(dt) {
                return dt instanceof k || (dt = new k(dt,ee)),
                this.length += dt.length,
                dt
            }, this);
        else if (typeof y == "number") {
            if (!(0 <= y && y <= 255))
                return ee.error("non-byte EncoderBuffer value");
            this.value = y,
            this.length = 1
        } else if (typeof y == "string")
            this.value = y,
            this.length = f.byteLength(y);
        else if (f.isBuffer(y))
            this.value = y,
            this.length = y.length;
        else
            return ee.error("Unsupported type: " + typeof y)
    }
    return buffer.EncoderBuffer = k,
    k.prototype.join = function(ee, dt) {
        return ee || (ee = new f(this.length)),
        dt || (dt = 0),
        this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(mt) {
            mt.join(ee, dt),
            dt += mt.length
        }) : (typeof this.value == "number" ? ee[dt] = this.value : typeof this.value == "string" ? ee.write(this.value, dt) : f.isBuffer(this.value) && this.value.copy(ee, dt),
        dt += this.length)),
        ee
    }
    ,
    buffer
}
var node, hasRequiredNode;
function requireNode() {
    if (hasRequiredNode)
        return node;
    hasRequiredNode = 1;
    var r = requireBase().Reporter
      , d = requireBase().EncoderBuffer
      , f = requireBase().DecoderBuffer
      , m = requireMinimalisticAssert()
      , k = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"]
      , y = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(k)
      , ee = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
    function dt(yt, pt) {
        var bt = {};
        this._baseState = bt,
        bt.enc = yt,
        bt.parent = pt || null,
        bt.children = null,
        bt.tag = null,
        bt.args = null,
        bt.reverseArgs = null,
        bt.choice = null,
        bt.optional = !1,
        bt.any = !1,
        bt.obj = !1,
        bt.use = null,
        bt.useDecoder = null,
        bt.key = null,
        bt.default = null,
        bt.explicit = null,
        bt.implicit = null,
        bt.contains = null,
        bt.parent || (bt.children = [],
        this._wrap())
    }
    node = dt;
    var mt = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
    return dt.prototype.clone = function() {
        var pt = this._baseState
          , bt = {};
        mt.forEach(function(xt) {
            bt[xt] = pt[xt]
        });
        var wt = new this.constructor(bt.parent);
        return wt._baseState = bt,
        wt
    }
    ,
    dt.prototype._wrap = function() {
        var pt = this._baseState;
        y.forEach(function(bt) {
            this[bt] = function() {
                var xt = new this.constructor(this);
                return pt.children.push(xt),
                xt[bt].apply(xt, arguments)
            }
        }, this)
    }
    ,
    dt.prototype._init = function(pt) {
        var bt = this._baseState;
        m(bt.parent === null),
        pt.call(this),
        bt.children = bt.children.filter(function(wt) {
            return wt._baseState.parent === this
        }, this),
        m.equal(bt.children.length, 1, "Root node can have only one child")
    }
    ,
    dt.prototype._useArgs = function(pt) {
        var bt = this._baseState
          , wt = pt.filter(function(xt) {
            return xt instanceof this.constructor
        }, this);
        pt = pt.filter(function(xt) {
            return !(xt instanceof this.constructor)
        }, this),
        wt.length !== 0 && (m(bt.children === null),
        bt.children = wt,
        wt.forEach(function(xt) {
            xt._baseState.parent = this
        }, this)),
        pt.length !== 0 && (m(bt.args === null),
        bt.args = pt,
        bt.reverseArgs = pt.map(function(xt) {
            if (typeof xt != "object" || xt.constructor !== Object)
                return xt;
            var At = {};
            return Object.keys(xt).forEach(function(Ct) {
                Ct == (Ct | 0) && (Ct |= 0);
                var Pt = xt[Ct];
                At[Pt] = Ct
            }),
            At
        }))
    }
    ,
    ee.forEach(function(yt) {
        dt.prototype[yt] = function() {
            var bt = this._baseState;
            throw new Error(yt + " not implemented for encoding: " + bt.enc)
        }
    }),
    k.forEach(function(yt) {
        dt.prototype[yt] = function() {
            var bt = this._baseState
              , wt = Array.prototype.slice.call(arguments);
            return m(bt.tag === null),
            bt.tag = yt,
            this._useArgs(wt),
            this
        }
    }),
    dt.prototype.use = function(pt) {
        m(pt);
        var bt = this._baseState;
        return m(bt.use === null),
        bt.use = pt,
        this
    }
    ,
    dt.prototype.optional = function() {
        var pt = this._baseState;
        return pt.optional = !0,
        this
    }
    ,
    dt.prototype.def = function(pt) {
        var bt = this._baseState;
        return m(bt.default === null),
        bt.default = pt,
        bt.optional = !0,
        this
    }
    ,
    dt.prototype.explicit = function(pt) {
        var bt = this._baseState;
        return m(bt.explicit === null && bt.implicit === null),
        bt.explicit = pt,
        this
    }
    ,
    dt.prototype.implicit = function(pt) {
        var bt = this._baseState;
        return m(bt.explicit === null && bt.implicit === null),
        bt.implicit = pt,
        this
    }
    ,
    dt.prototype.obj = function() {
        var pt = this._baseState
          , bt = Array.prototype.slice.call(arguments);
        return pt.obj = !0,
        bt.length !== 0 && this._useArgs(bt),
        this
    }
    ,
    dt.prototype.key = function(pt) {
        var bt = this._baseState;
        return m(bt.key === null),
        bt.key = pt,
        this
    }
    ,
    dt.prototype.any = function() {
        var pt = this._baseState;
        return pt.any = !0,
        this
    }
    ,
    dt.prototype.choice = function(pt) {
        var bt = this._baseState;
        return m(bt.choice === null),
        bt.choice = pt,
        this._useArgs(Object.keys(pt).map(function(wt) {
            return pt[wt]
        })),
        this
    }
    ,
    dt.prototype.contains = function(pt) {
        var bt = this._baseState;
        return m(bt.use === null),
        bt.contains = pt,
        this
    }
    ,
    dt.prototype._decode = function(pt, bt) {
        var wt = this._baseState;
        if (wt.parent === null)
            return pt.wrapResult(wt.children[0]._decode(pt, bt));
        var xt = wt.default
          , At = !0
          , Ct = null;
        if (wt.key !== null && (Ct = pt.enterKey(wt.key)),
        wt.optional) {
            var Pt = null;
            if (wt.explicit !== null ? Pt = wt.explicit : wt.implicit !== null ? Pt = wt.implicit : wt.tag !== null && (Pt = wt.tag),
            Pt === null && !wt.any) {
                var $t = pt.save();
                try {
                    wt.choice === null ? this._decodeGeneric(wt.tag, pt, bt) : this._decodeChoice(pt, bt),
                    At = !0
                } catch {
                    At = !1
                }
                pt.restore($t)
            } else if (At = this._peekTag(pt, Pt, wt.any),
            pt.isError(At))
                return At
        }
        var Ot;
        if (wt.obj && At && (Ot = pt.enterObject()),
        At) {
            if (wt.explicit !== null) {
                var Nt = this._decodeTag(pt, wt.explicit);
                if (pt.isError(Nt))
                    return Nt;
                pt = Nt
            }
            var zt = pt.offset;
            if (wt.use === null && wt.choice === null) {
                if (wt.any)
                    var $t = pt.save();
                var Wt = this._decodeTag(pt, wt.implicit !== null ? wt.implicit : wt.tag, wt.any);
                if (pt.isError(Wt))
                    return Wt;
                wt.any ? xt = pt.raw($t) : pt = Wt
            }
            if (bt && bt.track && wt.tag !== null && bt.track(pt.path(), zt, pt.length, "tagged"),
            bt && bt.track && wt.tag !== null && bt.track(pt.path(), pt.offset, pt.length, "content"),
            wt.any ? xt = xt : wt.choice === null ? xt = this._decodeGeneric(wt.tag, pt, bt) : xt = this._decodeChoice(pt, bt),
            pt.isError(xt))
                return xt;
            if (!wt.any && wt.choice === null && wt.children !== null && wt.children.forEach(function(or) {
                or._decode(pt, bt)
            }),
            wt.contains && (wt.tag === "octstr" || wt.tag === "bitstr")) {
                var Kt = new f(xt);
                xt = this._getUse(wt.contains, pt._reporterState.obj)._decode(Kt, bt)
            }
        }
        return wt.obj && At && (xt = pt.leaveObject(Ot)),
        wt.key !== null && (xt !== null || At === !0) ? pt.leaveKey(Ct, wt.key, xt) : Ct !== null && pt.exitKey(Ct),
        xt
    }
    ,
    dt.prototype._decodeGeneric = function(pt, bt, wt) {
        var xt = this._baseState;
        return pt === "seq" || pt === "set" ? null : pt === "seqof" || pt === "setof" ? this._decodeList(bt, pt, xt.args[0], wt) : /str$/.test(pt) ? this._decodeStr(bt, pt, wt) : pt === "objid" && xt.args ? this._decodeObjid(bt, xt.args[0], xt.args[1], wt) : pt === "objid" ? this._decodeObjid(bt, null, null, wt) : pt === "gentime" || pt === "utctime" ? this._decodeTime(bt, pt, wt) : pt === "null_" ? this._decodeNull(bt, wt) : pt === "bool" ? this._decodeBool(bt, wt) : pt === "objDesc" ? this._decodeStr(bt, pt, wt) : pt === "int" || pt === "enum" ? this._decodeInt(bt, xt.args && xt.args[0], wt) : xt.use !== null ? this._getUse(xt.use, bt._reporterState.obj)._decode(bt, wt) : bt.error("unknown tag: " + pt)
    }
    ,
    dt.prototype._getUse = function(pt, bt) {
        var wt = this._baseState;
        return wt.useDecoder = this._use(pt, bt),
        m(wt.useDecoder._baseState.parent === null),
        wt.useDecoder = wt.useDecoder._baseState.children[0],
        wt.implicit !== wt.useDecoder._baseState.implicit && (wt.useDecoder = wt.useDecoder.clone(),
        wt.useDecoder._baseState.implicit = wt.implicit),
        wt.useDecoder
    }
    ,
    dt.prototype._decodeChoice = function(pt, bt) {
        var wt = this._baseState
          , xt = null
          , At = !1;
        return Object.keys(wt.choice).some(function(Ct) {
            var Pt = pt.save()
              , $t = wt.choice[Ct];
            try {
                var Ot = $t._decode(pt, bt);
                if (pt.isError(Ot))
                    return !1;
                xt = {
                    type: Ct,
                    value: Ot
                },
                At = !0
            } catch {
                return pt.restore(Pt),
                !1
            }
            return !0
        }, this),
        At ? xt : pt.error("Choice not matched")
    }
    ,
    dt.prototype._createEncoderBuffer = function(pt) {
        return new d(pt,this.reporter)
    }
    ,
    dt.prototype._encode = function(pt, bt, wt) {
        var xt = this._baseState;
        if (!(xt.default !== null && xt.default === pt)) {
            var At = this._encodeValue(pt, bt, wt);
            if (At !== void 0 && !this._skipDefault(At, bt, wt))
                return At
        }
    }
    ,
    dt.prototype._encodeValue = function(pt, bt, wt) {
        var xt = this._baseState;
        if (xt.parent === null)
            return xt.children[0]._encode(pt, bt || new r);
        var $t = null;
        if (this.reporter = bt,
        xt.optional && pt === void 0)
            if (xt.default !== null)
                pt = xt.default;
            else
                return;
        var At = null
          , Ct = !1;
        if (xt.any)
            $t = this._createEncoderBuffer(pt);
        else if (xt.choice)
            $t = this._encodeChoice(pt, bt);
        else if (xt.contains)
            At = this._getUse(xt.contains, wt)._encode(pt, bt),
            Ct = !0;
        else if (xt.children)
            At = xt.children.map(function(zt) {
                if (zt._baseState.tag === "null_")
                    return zt._encode(null, bt, pt);
                if (zt._baseState.key === null)
                    return bt.error("Child should have a key");
                var Wt = bt.enterKey(zt._baseState.key);
                if (typeof pt != "object")
                    return bt.error("Child expected, but input is not object");
                var Kt = zt._encode(pt[zt._baseState.key], bt, pt);
                return bt.leaveKey(Wt),
                Kt
            }, this).filter(function(zt) {
                return zt
            }),
            At = this._createEncoderBuffer(At);
        else if (xt.tag === "seqof" || xt.tag === "setof") {
            if (!(xt.args && xt.args.length === 1))
                return bt.error("Too many args for : " + xt.tag);
            if (!Array.isArray(pt))
                return bt.error("seqof/setof, but data is not Array");
            var Pt = this.clone();
            Pt._baseState.implicit = null,
            At = this._createEncoderBuffer(pt.map(function(zt) {
                var Wt = this._baseState;
                return this._getUse(Wt.args[0], pt)._encode(zt, bt)
            }, Pt))
        } else
            xt.use !== null ? $t = this._getUse(xt.use, wt)._encode(pt, bt) : (At = this._encodePrimitive(xt.tag, pt),
            Ct = !0);
        var $t;
        if (!xt.any && xt.choice === null) {
            var Ot = xt.implicit !== null ? xt.implicit : xt.tag
              , Nt = xt.implicit === null ? "universal" : "context";
            Ot === null ? xt.use === null && bt.error("Tag could be omitted only for .use()") : xt.use === null && ($t = this._encodeComposite(Ot, Ct, Nt, At))
        }
        return xt.explicit !== null && ($t = this._encodeComposite(xt.explicit, !1, "context", $t)),
        $t
    }
    ,
    dt.prototype._encodeChoice = function(pt, bt) {
        var wt = this._baseState
          , xt = wt.choice[pt.type];
        return xt || m(!1, pt.type + " not found in " + JSON.stringify(Object.keys(wt.choice))),
        xt._encode(pt.value, bt)
    }
    ,
    dt.prototype._encodePrimitive = function(pt, bt) {
        var wt = this._baseState;
        if (/str$/.test(pt))
            return this._encodeStr(bt, pt);
        if (pt === "objid" && wt.args)
            return this._encodeObjid(bt, wt.reverseArgs[0], wt.args[1]);
        if (pt === "objid")
            return this._encodeObjid(bt, null, null);
        if (pt === "gentime" || pt === "utctime")
            return this._encodeTime(bt, pt);
        if (pt === "null_")
            return this._encodeNull();
        if (pt === "int" || pt === "enum")
            return this._encodeInt(bt, wt.args && wt.reverseArgs[0]);
        if (pt === "bool")
            return this._encodeBool(bt);
        if (pt === "objDesc")
            return this._encodeStr(bt, pt);
        throw new Error("Unsupported tag: " + pt)
    }
    ,
    dt.prototype._isNumstr = function(pt) {
        return /^[0-9 ]*$/.test(pt)
    }
    ,
    dt.prototype._isPrintstr = function(pt) {
        return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(pt)
    }
    ,
    node
}
var hasRequiredBase;
function requireBase() {
    return hasRequiredBase || (hasRequiredBase = 1,
    function(r) {
        var d = r;
        d.Reporter = requireReporter().Reporter,
        d.DecoderBuffer = requireBuffer().DecoderBuffer,
        d.EncoderBuffer = requireBuffer().EncoderBuffer,
        d.Node = requireNode()
    }(base)),
    base
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
    return hasRequiredDer$2 || (hasRequiredDer$2 = 1,
    function(r) {
        var d = requireConstants();
        r.tagClass = {
            0: "universal",
            1: "application",
            2: "context",
            3: "private"
        },
        r.tagClassByName = d._reverse(r.tagClass),
        r.tag = {
            0: "end",
            1: "bool",
            2: "int",
            3: "bitstr",
            4: "octstr",
            5: "null_",
            6: "objid",
            7: "objDesc",
            8: "external",
            9: "real",
            10: "enum",
            11: "embed",
            12: "utf8str",
            13: "relativeOid",
            16: "seq",
            17: "set",
            18: "numstr",
            19: "printstr",
            20: "t61str",
            21: "videostr",
            22: "ia5str",
            23: "utctime",
            24: "gentime",
            25: "graphstr",
            26: "iso646str",
            27: "genstr",
            28: "unistr",
            29: "charstr",
            30: "bmpstr"
        },
        r.tagByName = d._reverse(r.tag)
    }(der)),
    der
}
var hasRequiredConstants;
function requireConstants() {
    return hasRequiredConstants || (hasRequiredConstants = 1,
    function(r) {
        var d = r;
        d._reverse = function(m) {
            var k = {};
            return Object.keys(m).forEach(function(y) {
                (y | 0) == y && (y = y | 0);
                var ee = m[y];
                k[ee] = y
            }),
            k
        }
        ,
        d.der = requireDer$2()
    }(constants)),
    constants
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
    if (hasRequiredDer$1)
        return der_1$1;
    hasRequiredDer$1 = 1;
    var r = requireInherits_browser()
      , d = requireAsn1$1()
      , f = d.base
      , m = d.bignum
      , k = d.constants.der;
    function y(yt) {
        this.enc = "der",
        this.name = yt.name,
        this.entity = yt,
        this.tree = new ee,
        this.tree._init(yt.body)
    }
    der_1$1 = y,
    y.prototype.decode = function(pt, bt) {
        return pt instanceof f.DecoderBuffer || (pt = new f.DecoderBuffer(pt,bt)),
        this.tree._decode(pt, bt)
    }
    ;
    function ee(yt) {
        f.Node.call(this, "der", yt)
    }
    r(ee, f.Node),
    ee.prototype._peekTag = function(pt, bt, wt) {
        if (pt.isEmpty())
            return !1;
        var xt = pt.save()
          , At = dt(pt, 'Failed to peek tag: "' + bt + '"');
        return pt.isError(At) ? At : (pt.restore(xt),
        At.tag === bt || At.tagStr === bt || At.tagStr + "of" === bt || wt)
    }
    ,
    ee.prototype._decodeTag = function(pt, bt, wt) {
        var xt = dt(pt, 'Failed to decode tag of "' + bt + '"');
        if (pt.isError(xt))
            return xt;
        var At = mt(pt, xt.primitive, 'Failed to get length of "' + bt + '"');
        if (pt.isError(At))
            return At;
        if (!wt && xt.tag !== bt && xt.tagStr !== bt && xt.tagStr + "of" !== bt)
            return pt.error('Failed to match tag: "' + bt + '"');
        if (xt.primitive || At !== null)
            return pt.skip(At, 'Failed to match body of: "' + bt + '"');
        var Ct = pt.save()
          , Pt = this._skipUntilEnd(pt, 'Failed to skip indefinite length body: "' + this.tag + '"');
        return pt.isError(Pt) ? Pt : (At = pt.offset - Ct.offset,
        pt.restore(Ct),
        pt.skip(At, 'Failed to match body of: "' + bt + '"'))
    }
    ,
    ee.prototype._skipUntilEnd = function(pt, bt) {
        for (; ; ) {
            var wt = dt(pt, bt);
            if (pt.isError(wt))
                return wt;
            var xt = mt(pt, wt.primitive, bt);
            if (pt.isError(xt))
                return xt;
            var At;
            if (wt.primitive || xt !== null ? At = pt.skip(xt) : At = this._skipUntilEnd(pt, bt),
            pt.isError(At))
                return At;
            if (wt.tagStr === "end")
                break
        }
    }
    ,
    ee.prototype._decodeList = function(pt, bt, wt, xt) {
        for (var At = []; !pt.isEmpty(); ) {
            var Ct = this._peekTag(pt, "end");
            if (pt.isError(Ct))
                return Ct;
            var Pt = wt.decode(pt, "der", xt);
            if (pt.isError(Pt) && Ct)
                break;
            At.push(Pt)
        }
        return At
    }
    ,
    ee.prototype._decodeStr = function(pt, bt) {
        if (bt === "bitstr") {
            var wt = pt.readUInt8();
            return pt.isError(wt) ? wt : {
                unused: wt,
                data: pt.raw()
            }
        } else if (bt === "bmpstr") {
            var xt = pt.raw();
            if (xt.length % 2 === 1)
                return pt.error("Decoding of string type: bmpstr length mismatch");
            for (var At = "", Ct = 0; Ct < xt.length / 2; Ct++)
                At += String.fromCharCode(xt.readUInt16BE(Ct * 2));
            return At
        } else if (bt === "numstr") {
            var Pt = pt.raw().toString("ascii");
            return this._isNumstr(Pt) ? Pt : pt.error("Decoding of string type: numstr unsupported characters")
        } else {
            if (bt === "octstr")
                return pt.raw();
            if (bt === "objDesc")
                return pt.raw();
            if (bt === "printstr") {
                var $t = pt.raw().toString("ascii");
                return this._isPrintstr($t) ? $t : pt.error("Decoding of string type: printstr unsupported characters")
            } else
                return /str$/.test(bt) ? pt.raw().toString() : pt.error("Decoding of string type: " + bt + " unsupported")
        }
    }
    ,
    ee.prototype._decodeObjid = function(pt, bt, wt) {
        for (var xt, At = [], Ct = 0; !pt.isEmpty(); ) {
            var Pt = pt.readUInt8();
            Ct <<= 7,
            Ct |= Pt & 127,
            Pt & 128 || (At.push(Ct),
            Ct = 0)
        }
        Pt & 128 && At.push(Ct);
        var $t = At[0] / 40 | 0
          , Ot = At[0] % 40;
        if (wt ? xt = At : xt = [$t, Ot].concat(At.slice(1)),
        bt) {
            var Nt = bt[xt.join(" ")];
            Nt === void 0 && (Nt = bt[xt.join(".")]),
            Nt !== void 0 && (xt = Nt)
        }
        return xt
    }
    ,
    ee.prototype._decodeTime = function(pt, bt) {
        var wt = pt.raw().toString();
        if (bt === "gentime")
            var xt = wt.slice(0, 4) | 0
              , At = wt.slice(4, 6) | 0
              , Ct = wt.slice(6, 8) | 0
              , Pt = wt.slice(8, 10) | 0
              , $t = wt.slice(10, 12) | 0
              , Ot = wt.slice(12, 14) | 0;
        else if (bt === "utctime") {
            var xt = wt.slice(0, 2) | 0
              , At = wt.slice(2, 4) | 0
              , Ct = wt.slice(4, 6) | 0
              , Pt = wt.slice(6, 8) | 0
              , $t = wt.slice(8, 10) | 0
              , Ot = wt.slice(10, 12) | 0;
            xt < 70 ? xt = 2e3 + xt : xt = 1900 + xt
        } else
            return pt.error("Decoding " + bt + " time is not supported yet");
        return Date.UTC(xt, At - 1, Ct, Pt, $t, Ot, 0)
    }
    ,
    ee.prototype._decodeNull = function(pt) {
        return null
    }
    ,
    ee.prototype._decodeBool = function(pt) {
        var bt = pt.readUInt8();
        return pt.isError(bt) ? bt : bt !== 0
    }
    ,
    ee.prototype._decodeInt = function(pt, bt) {
        var wt = pt.raw()
          , xt = new m(wt);
        return bt && (xt = bt[xt.toString(10)] || xt),
        xt
    }
    ,
    ee.prototype._use = function(pt, bt) {
        return typeof pt == "function" && (pt = pt(bt)),
        pt._getDecoder("der").tree
    }
    ;
    function dt(yt, pt) {
        var bt = yt.readUInt8(pt);
        if (yt.isError(bt))
            return bt;
        var wt = k.tagClass[bt >> 6]
          , xt = (bt & 32) === 0;
        if ((bt & 31) === 31) {
            var At = bt;
            for (bt = 0; (At & 128) === 128; ) {
                if (At = yt.readUInt8(pt),
                yt.isError(At))
                    return At;
                bt <<= 7,
                bt |= At & 127
            }
        } else
            bt &= 31;
        var Ct = k.tag[bt];
        return {
            cls: wt,
            primitive: xt,
            tag: bt,
            tagStr: Ct
        }
    }
    function mt(yt, pt, bt) {
        var wt = yt.readUInt8(bt);
        if (yt.isError(wt))
            return wt;
        if (!pt && wt === 128)
            return null;
        if (!(wt & 128))
            return wt;
        var xt = wt & 127;
        if (xt > 4)
            return yt.error("length octect is too long");
        wt = 0;
        for (var At = 0; At < xt; At++) {
            wt <<= 8;
            var Ct = yt.readUInt8(bt);
            if (yt.isError(Ct))
                return Ct;
            wt |= Ct
        }
        return wt
    }
    return der_1$1
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
    if (hasRequiredPem$1)
        return pem$1;
    hasRequiredPem$1 = 1;
    var r = requireInherits_browser()
      , d = require$$1$2.Buffer
      , f = requireDer$1();
    function m(k) {
        f.call(this, k),
        this.enc = "pem"
    }
    return r(m, f),
    pem$1 = m,
    m.prototype.decode = function(y, ee) {
        for (var dt = y.toString().split(/[\r\n]+/g), mt = ee.label.toUpperCase(), yt = /^-----(BEGIN|END) ([^-]+)-----$/, pt = -1, bt = -1, wt = 0; wt < dt.length; wt++) {
            var xt = dt[wt].match(yt);
            if (xt !== null && xt[2] === mt)
                if (pt === -1) {
                    if (xt[1] !== "BEGIN")
                        break;
                    pt = wt
                } else {
                    if (xt[1] !== "END")
                        break;
                    bt = wt;
                    break
                }
        }
        if (pt === -1 || bt === -1)
            throw new Error("PEM section not found for: " + mt);
        var At = dt.slice(pt + 1, bt).join("");
        At.replace(/[^a-z0-9\+\/=]+/gi, "");
        var Ct = new d(At,"base64");
        return f.prototype.decode.call(this, Ct, ee)
    }
    ,
    pem$1
}
var hasRequiredDecoders;
function requireDecoders() {
    return hasRequiredDecoders || (hasRequiredDecoders = 1,
    function(r) {
        var d = r;
        d.der = requireDer$1(),
        d.pem = requirePem$1()
    }(decoders)),
    decoders
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
    if (hasRequiredDer)
        return der_1;
    hasRequiredDer = 1;
    var r = requireInherits_browser()
      , d = require$$1$2.Buffer
      , f = requireAsn1$1()
      , m = f.base
      , k = f.constants.der;
    function y(yt) {
        this.enc = "der",
        this.name = yt.name,
        this.entity = yt,
        this.tree = new ee,
        this.tree._init(yt.body)
    }
    der_1 = y,
    y.prototype.encode = function(pt, bt) {
        return this.tree._encode(pt, bt).join()
    }
    ;
    function ee(yt) {
        m.Node.call(this, "der", yt)
    }
    r(ee, m.Node),
    ee.prototype._encodeComposite = function(pt, bt, wt, xt) {
        var At = mt(pt, bt, wt, this.reporter);
        if (xt.length < 128) {
            var $t = new d(2);
            return $t[0] = At,
            $t[1] = xt.length,
            this._createEncoderBuffer([$t, xt])
        }
        for (var Ct = 1, Pt = xt.length; Pt >= 256; Pt >>= 8)
            Ct++;
        var $t = new d(2 + Ct);
        $t[0] = At,
        $t[1] = 128 | Ct;
        for (var Pt = 1 + Ct, Ot = xt.length; Ot > 0; Pt--,
        Ot >>= 8)
            $t[Pt] = Ot & 255;
        return this._createEncoderBuffer([$t, xt])
    }
    ,
    ee.prototype._encodeStr = function(pt, bt) {
        if (bt === "bitstr")
            return this._createEncoderBuffer([pt.unused | 0, pt.data]);
        if (bt === "bmpstr") {
            for (var wt = new d(pt.length * 2), xt = 0; xt < pt.length; xt++)
                wt.writeUInt16BE(pt.charCodeAt(xt), xt * 2);
            return this._createEncoderBuffer(wt)
        } else
            return bt === "numstr" ? this._isNumstr(pt) ? this._createEncoderBuffer(pt) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : bt === "printstr" ? this._isPrintstr(pt) ? this._createEncoderBuffer(pt) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(bt) ? this._createEncoderBuffer(pt) : bt === "objDesc" ? this._createEncoderBuffer(pt) : this.reporter.error("Encoding of string type: " + bt + " unsupported")
    }
    ,
    ee.prototype._encodeObjid = function(pt, bt, wt) {
        if (typeof pt == "string") {
            if (!bt)
                return this.reporter.error("string objid given, but no values map found");
            if (!bt.hasOwnProperty(pt))
                return this.reporter.error("objid not found in values map");
            pt = bt[pt].split(/[\s\.]+/g);
            for (var xt = 0; xt < pt.length; xt++)
                pt[xt] |= 0
        } else if (Array.isArray(pt)) {
            pt = pt.slice();
            for (var xt = 0; xt < pt.length; xt++)
                pt[xt] |= 0
        }
        if (!Array.isArray(pt))
            return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(pt));
        if (!wt) {
            if (pt[1] >= 40)
                return this.reporter.error("Second objid identifier OOB");
            pt.splice(0, 2, pt[0] * 40 + pt[1])
        }
        for (var At = 0, xt = 0; xt < pt.length; xt++) {
            var Ct = pt[xt];
            for (At++; Ct >= 128; Ct >>= 7)
                At++
        }
        for (var Pt = new d(At), $t = Pt.length - 1, xt = pt.length - 1; xt >= 0; xt--) {
            var Ct = pt[xt];
            for (Pt[$t--] = Ct & 127; (Ct >>= 7) > 0; )
                Pt[$t--] = 128 | Ct & 127
        }
        return this._createEncoderBuffer(Pt)
    }
    ;
    function dt(yt) {
        return yt < 10 ? "0" + yt : yt
    }
    ee.prototype._encodeTime = function(pt, bt) {
        var wt, xt = new Date(pt);
        return bt === "gentime" ? wt = [dt(xt.getFullYear()), dt(xt.getUTCMonth() + 1), dt(xt.getUTCDate()), dt(xt.getUTCHours()), dt(xt.getUTCMinutes()), dt(xt.getUTCSeconds()), "Z"].join("") : bt === "utctime" ? wt = [dt(xt.getFullYear() % 100), dt(xt.getUTCMonth() + 1), dt(xt.getUTCDate()), dt(xt.getUTCHours()), dt(xt.getUTCMinutes()), dt(xt.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + bt + " time is not supported yet"),
        this._encodeStr(wt, "octstr")
    }
    ,
    ee.prototype._encodeNull = function() {
        return this._createEncoderBuffer("")
    }
    ,
    ee.prototype._encodeInt = function(pt, bt) {
        if (typeof pt == "string") {
            if (!bt)
                return this.reporter.error("String int or enum given, but no values map");
            if (!bt.hasOwnProperty(pt))
                return this.reporter.error("Values map doesn't contain: " + JSON.stringify(pt));
            pt = bt[pt]
        }
        if (typeof pt != "number" && !d.isBuffer(pt)) {
            var wt = pt.toArray();
            !pt.sign && wt[0] & 128 && wt.unshift(0),
            pt = new d(wt)
        }
        if (d.isBuffer(pt)) {
            var xt = pt.length;
            pt.length === 0 && xt++;
            var Ct = new d(xt);
            return pt.copy(Ct),
            pt.length === 0 && (Ct[0] = 0),
            this._createEncoderBuffer(Ct)
        }
        if (pt < 128)
            return this._createEncoderBuffer(pt);
        if (pt < 256)
            return this._createEncoderBuffer([0, pt]);
        for (var xt = 1, At = pt; At >= 256; At >>= 8)
            xt++;
        for (var Ct = new Array(xt), At = Ct.length - 1; At >= 0; At--)
            Ct[At] = pt & 255,
            pt >>= 8;
        return Ct[0] & 128 && Ct.unshift(0),
        this._createEncoderBuffer(new d(Ct))
    }
    ,
    ee.prototype._encodeBool = function(pt) {
        return this._createEncoderBuffer(pt ? 255 : 0)
    }
    ,
    ee.prototype._use = function(pt, bt) {
        return typeof pt == "function" && (pt = pt(bt)),
        pt._getEncoder("der").tree
    }
    ,
    ee.prototype._skipDefault = function(pt, bt, wt) {
        var xt = this._baseState, At;
        if (xt.default === null)
            return !1;
        var Ct = pt.join();
        if (xt.defaultBuffer === void 0 && (xt.defaultBuffer = this._encodeValue(xt.default, bt, wt).join()),
        Ct.length !== xt.defaultBuffer.length)
            return !1;
        for (At = 0; At < Ct.length; At++)
            if (Ct[At] !== xt.defaultBuffer[At])
                return !1;
        return !0
    }
    ;
    function mt(yt, pt, bt, wt) {
        var xt;
        if (yt === "seqof" ? yt = "seq" : yt === "setof" && (yt = "set"),
        k.tagByName.hasOwnProperty(yt))
            xt = k.tagByName[yt];
        else if (typeof yt == "number" && (yt | 0) === yt)
            xt = yt;
        else
            return wt.error("Unknown tag: " + yt);
        return xt >= 31 ? wt.error("Multi-octet tag encoding unsupported") : (pt || (xt |= 32),
        xt |= k.tagClassByName[bt || "universal"] << 6,
        xt)
    }
    return der_1
}
var pem, hasRequiredPem;
function requirePem() {
    if (hasRequiredPem)
        return pem;
    hasRequiredPem = 1;
    var r = requireInherits_browser()
      , d = requireDer();
    function f(m) {
        d.call(this, m),
        this.enc = "pem"
    }
    return r(f, d),
    pem = f,
    f.prototype.encode = function(k, y) {
        for (var ee = d.prototype.encode.call(this, k), dt = ee.toString("base64"), mt = ["-----BEGIN " + y.label + "-----"], yt = 0; yt < dt.length; yt += 64)
            mt.push(dt.slice(yt, yt + 64));
        return mt.push("-----END " + y.label + "-----"),
        mt.join(`
`)
    }
    ,
    pem
}
var hasRequiredEncoders;
function requireEncoders() {
    return hasRequiredEncoders || (hasRequiredEncoders = 1,
    function(r) {
        var d = r;
        d.der = requireDer(),
        d.pem = requirePem()
    }(encoders)),
    encoders
}
var hasRequiredAsn1$1;
function requireAsn1$1() {
    return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1,
    function(r) {
        var d = r;
        d.bignum = requireBn$2(),
        d.define = requireApi().define,
        d.base = requireBase(),
        d.constants = requireConstants(),
        d.decoders = requireDecoders(),
        d.encoders = requireEncoders()
    }(asn1)),
    asn1
}
var certificate, hasRequiredCertificate;
function requireCertificate() {
    if (hasRequiredCertificate)
        return certificate;
    hasRequiredCertificate = 1;
    var r = requireAsn1$1()
      , d = r.define("Time", function() {
        this.choice({
            utcTime: this.utctime(),
            generalTime: this.gentime()
        })
    })
      , f = r.define("AttributeTypeValue", function() {
        this.seq().obj(this.key("type").objid(), this.key("value").any())
    })
      , m = r.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional())
    })
      , k = r.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(m), this.key("subjectPublicKey").bitstr())
    })
      , y = r.define("RelativeDistinguishedName", function() {
        this.setof(f)
    })
      , ee = r.define("RDNSequence", function() {
        this.seqof(y)
    })
      , dt = r.define("Name", function() {
        this.choice({
            rdnSequence: this.use(ee)
        })
    })
      , mt = r.define("Validity", function() {
        this.seq().obj(this.key("notBefore").use(d), this.key("notAfter").use(d))
    })
      , yt = r.define("Extension", function() {
        this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(!1), this.key("extnValue").octstr())
    })
      , pt = r.define("TBSCertificate", function() {
        this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(m), this.key("issuer").use(dt), this.key("validity").use(mt), this.key("subject").use(dt), this.key("subjectPublicKeyInfo").use(k), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(yt).optional())
    })
      , bt = r.define("X509Certificate", function() {
        this.seq().obj(this.key("tbsCertificate").use(pt), this.key("signatureAlgorithm").use(m), this.key("signatureValue").bitstr())
    });
    return certificate = bt,
    certificate
}
var hasRequiredAsn1;
function requireAsn1() {
    if (hasRequiredAsn1)
        return asn1$1;
    hasRequiredAsn1 = 1;
    var r = requireAsn1$1();
    asn1$1.certificate = requireCertificate();
    var d = r.define("RSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int())
    });
    asn1$1.RSAPrivateKey = d;
    var f = r.define("RSAPublicKey", function() {
        this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int())
    });
    asn1$1.RSAPublicKey = f;
    var m = r.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional())
    })
      , k = r.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(m), this.key("subjectPublicKey").bitstr())
    });
    asn1$1.PublicKey = k;
    var y = r.define("PrivateKeyInfo", function() {
        this.seq().obj(this.key("version").int(), this.key("algorithm").use(m), this.key("subjectPrivateKey").octstr())
    });
    asn1$1.PrivateKey = y;
    var ee = r.define("EncryptedPrivateKeyInfo", function() {
        this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr())
    });
    asn1$1.EncryptedPrivateKey = ee;
    var dt = r.define("DSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int())
    });
    asn1$1.DSAPrivateKey = dt,
    asn1$1.DSAparam = r.define("DSAparam", function() {
        this.int()
    });
    var mt = r.define("ECParameters", function() {
        this.choice({
            namedCurve: this.objid()
        })
    })
      , yt = r.define("ECPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(mt), this.key("publicKey").optional().explicit(1).bitstr())
    });
    return asn1$1.ECPrivateKey = yt,
    asn1$1.signature = r.define("signature", function() {
        this.seq().obj(this.key("r").int(), this.key("s").int())
    }),
    asn1$1
}
const require$$1 = {
    "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
    "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
    "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
    "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
    "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
    "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
    "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
    "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
    "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
    "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
    "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
    "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc, hasRequiredFixProc;
function requireFixProc() {
    if (hasRequiredFixProc)
        return fixProc;
    hasRequiredFixProc = 1;
    var r = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m
      , d = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m
      , f = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m
      , m = requireEvp_bytestokey()
      , k = requireBrowser$6()
      , y = requireSafeBuffer$1().Buffer;
    return fixProc = function(ee, dt) {
        var mt = ee.toString(), yt = mt.match(r), pt;
        if (yt) {
            var wt = "aes" + yt[1]
              , xt = y.from(yt[2], "hex")
              , At = y.from(yt[3].replace(/[\r\n]/g, ""), "base64")
              , Ct = m(dt, xt.slice(0, 8), parseInt(yt[1], 10)).key
              , Pt = []
              , $t = k.createDecipheriv(wt, Ct, xt);
            Pt.push($t.update(At)),
            Pt.push($t.final()),
            pt = y.concat(Pt)
        } else {
            var bt = mt.match(f);
            pt = y.from(bt[2].replace(/[\r\n]/g, ""), "base64")
        }
        var Ot = mt.match(d)[1];
        return {
            tag: Ot,
            data: pt
        }
    }
    ,
    fixProc
}
var parseAsn1, hasRequiredParseAsn1;
function requireParseAsn1() {
    if (hasRequiredParseAsn1)
        return parseAsn1;
    hasRequiredParseAsn1 = 1;
    var r = requireAsn1()
      , d = require$$1
      , f = requireFixProc()
      , m = requireBrowser$6()
      , k = requireBrowser$7()
      , y = requireSafeBuffer$1().Buffer;
    function ee(mt, yt) {
        var pt = mt.algorithm.decrypt.kde.kdeparams.salt
          , bt = parseInt(mt.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
          , wt = d[mt.algorithm.decrypt.cipher.algo.join(".")]
          , xt = mt.algorithm.decrypt.cipher.iv
          , At = mt.subjectPrivateKey
          , Ct = parseInt(wt.split("-")[1], 10) / 8
          , Pt = k.pbkdf2Sync(yt, pt, bt, Ct, "sha1")
          , $t = m.createDecipheriv(wt, Pt, xt)
          , Ot = [];
        return Ot.push($t.update(At)),
        Ot.push($t.final()),
        y.concat(Ot)
    }
    function dt(mt) {
        var yt;
        typeof mt == "object" && !y.isBuffer(mt) && (yt = mt.passphrase,
        mt = mt.key),
        typeof mt == "string" && (mt = y.from(mt));
        var pt = f(mt, yt), bt = pt.tag, wt = pt.data, xt, At;
        switch (bt) {
        case "CERTIFICATE":
            At = r.certificate.decode(wt, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
            switch (At || (At = r.PublicKey.decode(wt, "der")),
            xt = At.algorithm.algorithm.join("."),
            xt) {
            case "1.2.840.113549.1.1.1":
                return r.RSAPublicKey.decode(At.subjectPublicKey.data, "der");
            case "1.2.840.10045.2.1":
                return At.subjectPrivateKey = At.subjectPublicKey,
                {
                    type: "ec",
                    data: At
                };
            case "1.2.840.10040.4.1":
                return At.algorithm.params.pub_key = r.DSAparam.decode(At.subjectPublicKey.data, "der"),
                {
                    type: "dsa",
                    data: At.algorithm.params
                };
            default:
                throw new Error("unknown key id " + xt)
            }
        case "ENCRYPTED PRIVATE KEY":
            wt = r.EncryptedPrivateKey.decode(wt, "der"),
            wt = ee(wt, yt);
        case "PRIVATE KEY":
            switch (At = r.PrivateKey.decode(wt, "der"),
            xt = At.algorithm.algorithm.join("."),
            xt) {
            case "1.2.840.113549.1.1.1":
                return r.RSAPrivateKey.decode(At.subjectPrivateKey, "der");
            case "1.2.840.10045.2.1":
                return {
                    curve: At.algorithm.curve,
                    privateKey: r.ECPrivateKey.decode(At.subjectPrivateKey, "der").privateKey
                };
            case "1.2.840.10040.4.1":
                return At.algorithm.params.priv_key = r.DSAparam.decode(At.subjectPrivateKey, "der"),
                {
                    type: "dsa",
                    params: At.algorithm.params
                };
            default:
                throw new Error("unknown key id " + xt)
            }
        case "RSA PUBLIC KEY":
            return r.RSAPublicKey.decode(wt, "der");
        case "RSA PRIVATE KEY":
            return r.RSAPrivateKey.decode(wt, "der");
        case "DSA PRIVATE KEY":
            return {
                type: "dsa",
                params: r.DSAPrivateKey.decode(wt, "der")
            };
        case "EC PRIVATE KEY":
            return wt = r.ECPrivateKey.decode(wt, "der"),
            {
                curve: wt.parameters.value,
                privateKey: wt.privateKey
            };
        default:
            throw new Error("unknown key type " + bt)
        }
    }
    return dt.signature = r.signature,
    parseAsn1 = dt,
    parseAsn1
}
const require$$4$1 = {
    "1.3.132.0.10": "secp256k1",
    "1.3.132.0.33": "p224",
    "1.2.840.10045.3.1.1": "p192",
    "1.2.840.10045.3.1.7": "p256",
    "1.3.132.0.34": "p384",
    "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
    if (hasRequiredSign)
        return sign$1.exports;
    hasRequiredSign = 1;
    var r = requireSafeBuffer$1().Buffer
      , d = requireBrowser$8()
      , f = requireBrowserifyRsa()
      , m = requireElliptic().ec
      , k = requireBn()
      , y = requireParseAsn1()
      , ee = require$$4$1
      , dt = 1;
    function mt($t, Ot, Nt, zt, Wt) {
        var Kt = y(Ot);
        if (Kt.curve) {
            if (zt !== "ecdsa" && zt !== "ecdsa/rsa")
                throw new Error("wrong private key type");
            return yt($t, Kt)
        } else if (Kt.type === "dsa") {
            if (zt !== "dsa")
                throw new Error("wrong private key type");
            return pt($t, Kt, Nt)
        }
        if (zt !== "rsa" && zt !== "ecdsa/rsa")
            throw new Error("wrong private key type");
        if (Ot.padding !== void 0 && Ot.padding !== dt)
            throw new Error("illegal or unsupported padding mode");
        $t = r.concat([Wt, $t]);
        for (var ir = Kt.modulus.byteLength(), or = [0, 1]; $t.length + or.length + 1 < ir; )
            or.push(255);
        or.push(0);
        for (var tr = -1; ++tr < $t.length; )
            or.push($t[tr]);
        var wr = f(or, Kt);
        return wr
    }
    function yt($t, Ot) {
        var Nt = ee[Ot.curve.join(".")];
        if (!Nt)
            throw new Error("unknown curve " + Ot.curve.join("."));
        var zt = new m(Nt)
          , Wt = zt.keyFromPrivate(Ot.privateKey)
          , Kt = Wt.sign($t);
        return r.from(Kt.toDER())
    }
    function pt($t, Ot, Nt) {
        for (var zt = Ot.params.priv_key, Wt = Ot.params.p, Kt = Ot.params.q, ir = Ot.params.g, or = new k(0), tr, wr = xt($t, Kt).mod(Kt), Ht = !1, Mt = wt(zt, Kt, $t, Nt); Ht === !1; )
            tr = Ct(Kt, Mt, Nt),
            or = Pt(ir, tr, Wt, Kt),
            Ht = tr.invm(Kt).imul(wr.add(zt.mul(or))).mod(Kt),
            Ht.cmpn(0) === 0 && (Ht = !1,
            or = new k(0));
        return bt(or, Ht)
    }
    function bt($t, Ot) {
        $t = $t.toArray(),
        Ot = Ot.toArray(),
        $t[0] & 128 && ($t = [0].concat($t)),
        Ot[0] & 128 && (Ot = [0].concat(Ot));
        var Nt = $t.length + Ot.length + 4
          , zt = [48, Nt, 2, $t.length];
        return zt = zt.concat($t, [2, Ot.length], Ot),
        r.from(zt)
    }
    function wt($t, Ot, Nt, zt) {
        if ($t = r.from($t.toArray()),
        $t.length < Ot.byteLength()) {
            var Wt = r.alloc(Ot.byteLength() - $t.length);
            $t = r.concat([Wt, $t])
        }
        var Kt = Nt.length
          , ir = At(Nt, Ot)
          , or = r.alloc(Kt);
        or.fill(1);
        var tr = r.alloc(Kt);
        return tr = d(zt, tr).update(or).update(r.from([0])).update($t).update(ir).digest(),
        or = d(zt, tr).update(or).digest(),
        tr = d(zt, tr).update(or).update(r.from([1])).update($t).update(ir).digest(),
        or = d(zt, tr).update(or).digest(),
        {
            k: tr,
            v: or
        }
    }
    function xt($t, Ot) {
        var Nt = new k($t)
          , zt = ($t.length << 3) - Ot.bitLength();
        return zt > 0 && Nt.ishrn(zt),
        Nt
    }
    function At($t, Ot) {
        $t = xt($t, Ot),
        $t = $t.mod(Ot);
        var Nt = r.from($t.toArray());
        if (Nt.length < Ot.byteLength()) {
            var zt = r.alloc(Ot.byteLength() - Nt.length);
            Nt = r.concat([zt, Nt])
        }
        return Nt
    }
    function Ct($t, Ot, Nt) {
        var zt, Wt;
        do {
            for (zt = r.alloc(0); zt.length * 8 < $t.bitLength(); )
                Ot.v = d(Nt, Ot.k).update(Ot.v).digest(),
                zt = r.concat([zt, Ot.v]);
            Wt = xt(zt, $t),
            Ot.k = d(Nt, Ot.k).update(Ot.v).update(r.from([0])).digest(),
            Ot.v = d(Nt, Ot.k).update(Ot.v).digest()
        } while (Wt.cmp($t) !== -1);
        return Wt
    }
    function Pt($t, Ot, Nt, zt) {
        return $t.toRed(k.mont(Nt)).redPow(Ot).fromRed().mod(zt)
    }
    return sign$1.exports = mt,
    sign$1.exports.getKey = wt,
    sign$1.exports.makeKey = Ct,
    sign$1.exports
}
var verify_1, hasRequiredVerify;
function requireVerify() {
    if (hasRequiredVerify)
        return verify_1;
    hasRequiredVerify = 1;
    var r = requireSafeBuffer$1().Buffer
      , d = requireBn()
      , f = requireElliptic().ec
      , m = requireParseAsn1()
      , k = require$$4$1;
    function y(yt, pt, bt, wt, xt) {
        var At = m(bt);
        if (At.type === "ec") {
            if (wt !== "ecdsa" && wt !== "ecdsa/rsa")
                throw new Error("wrong public key type");
            return ee(yt, pt, At)
        } else if (At.type === "dsa") {
            if (wt !== "dsa")
                throw new Error("wrong public key type");
            return dt(yt, pt, At)
        }
        if (wt !== "rsa" && wt !== "ecdsa/rsa")
            throw new Error("wrong public key type");
        pt = r.concat([xt, pt]);
        for (var Ct = At.modulus.byteLength(), Pt = [1], $t = 0; pt.length + Pt.length + 2 < Ct; )
            Pt.push(255),
            $t += 1;
        Pt.push(0);
        for (var Ot = -1; ++Ot < pt.length; )
            Pt.push(pt[Ot]);
        Pt = r.from(Pt);
        var Nt = d.mont(At.modulus);
        yt = new d(yt).toRed(Nt),
        yt = yt.redPow(new d(At.publicExponent)),
        yt = r.from(yt.fromRed().toArray());
        var zt = $t < 8 ? 1 : 0;
        for (Ct = Math.min(yt.length, Pt.length),
        yt.length !== Pt.length && (zt = 1),
        Ot = -1; ++Ot < Ct; )
            zt |= yt[Ot] ^ Pt[Ot];
        return zt === 0
    }
    function ee(yt, pt, bt) {
        var wt = k[bt.data.algorithm.curve.join(".")];
        if (!wt)
            throw new Error("unknown curve " + bt.data.algorithm.curve.join("."));
        var xt = new f(wt)
          , At = bt.data.subjectPrivateKey.data;
        return xt.verify(pt, yt, At)
    }
    function dt(yt, pt, bt) {
        var wt = bt.data.p
          , xt = bt.data.q
          , At = bt.data.g
          , Ct = bt.data.pub_key
          , Pt = m.signature.decode(yt, "der")
          , $t = Pt.s
          , Ot = Pt.r;
        mt($t, xt),
        mt(Ot, xt);
        var Nt = d.mont(wt)
          , zt = $t.invm(xt)
          , Wt = At.toRed(Nt).redPow(new d(pt).mul(zt).mod(xt)).fromRed().mul(Ct.toRed(Nt).redPow(Ot.mul(zt).mod(xt)).fromRed()).mod(wt).mod(xt);
        return Wt.cmp(Ot) === 0
    }
    function mt(yt, pt) {
        if (yt.cmpn(0) <= 0)
            throw new Error("invalid sig");
        if (yt.cmp(pt) >= 0)
            throw new Error("invalid sig")
    }
    return verify_1 = y,
    verify_1
}
var browser$4, hasRequiredBrowser$3;
function requireBrowser$3() {
    if (hasRequiredBrowser$3)
        return browser$4;
    hasRequiredBrowser$3 = 1;
    var r = requireSafeBuffer$1().Buffer
      , d = requireBrowser$9()
      , f = requireReadableBrowser()
      , m = requireInherits_browser()
      , k = requireSign()
      , y = requireVerify()
      , ee = require$$6;
    Object.keys(ee).forEach(function(bt) {
        ee[bt].id = r.from(ee[bt].id, "hex"),
        ee[bt.toLowerCase()] = ee[bt]
    });
    function dt(bt) {
        f.Writable.call(this);
        var wt = ee[bt];
        if (!wt)
            throw new Error("Unknown message digest");
        this._hashType = wt.hash,
        this._hash = d(wt.hash),
        this._tag = wt.id,
        this._signType = wt.sign
    }
    m(dt, f.Writable),
    dt.prototype._write = function(wt, xt, At) {
        this._hash.update(wt),
        At()
    }
    ,
    dt.prototype.update = function(wt, xt) {
        return this._hash.update(typeof wt == "string" ? r.from(wt, xt) : wt),
        this
    }
    ,
    dt.prototype.sign = function(wt, xt) {
        this.end();
        var At = this._hash.digest()
          , Ct = k(At, wt, this._hashType, this._signType, this._tag);
        return xt ? Ct.toString(xt) : Ct
    }
    ;
    function mt(bt) {
        f.Writable.call(this);
        var wt = ee[bt];
        if (!wt)
            throw new Error("Unknown message digest");
        this._hash = d(wt.hash),
        this._tag = wt.id,
        this._signType = wt.sign
    }
    m(mt, f.Writable),
    mt.prototype._write = function(wt, xt, At) {
        this._hash.update(wt),
        At()
    }
    ,
    mt.prototype.update = function(wt, xt) {
        return this._hash.update(typeof wt == "string" ? r.from(wt, xt) : wt),
        this
    }
    ,
    mt.prototype.verify = function(wt, xt, At) {
        var Ct = typeof xt == "string" ? r.from(xt, At) : xt;
        this.end();
        var Pt = this._hash.digest();
        return y(Ct, Pt, wt, this._signType, this._tag)
    }
    ;
    function yt(bt) {
        return new dt(bt)
    }
    function pt(bt) {
        return new mt(bt)
    }
    return browser$4 = {
        Sign: yt,
        Verify: pt,
        createSign: yt,
        createVerify: pt
    },
    browser$4
}
var browser$3, hasRequiredBrowser$2;
function requireBrowser$2() {
    if (hasRequiredBrowser$2)
        return browser$3;
    hasRequiredBrowser$2 = 1;
    var r = requireElliptic()
      , d = requireBn$2();
    browser$3 = function(ee) {
        return new m(ee)
    }
    ;
    var f = {
        secp256k1: {
            name: "secp256k1",
            byteLength: 32
        },
        secp224r1: {
            name: "p224",
            byteLength: 28
        },
        prime256v1: {
            name: "p256",
            byteLength: 32
        },
        prime192v1: {
            name: "p192",
            byteLength: 24
        },
        ed25519: {
            name: "ed25519",
            byteLength: 32
        },
        secp384r1: {
            name: "p384",
            byteLength: 48
        },
        secp521r1: {
            name: "p521",
            byteLength: 66
        }
    };
    f.p224 = f.secp224r1,
    f.p256 = f.secp256r1 = f.prime256v1,
    f.p192 = f.secp192r1 = f.prime192v1,
    f.p384 = f.secp384r1,
    f.p521 = f.secp521r1;
    function m(y) {
        this.curveType = f[y],
        this.curveType || (this.curveType = {
            name: y
        }),
        this.curve = new r.ec(this.curveType.name),
        this.keys = void 0
    }
    m.prototype.generateKeys = function(y, ee) {
        return this.keys = this.curve.genKeyPair(),
        this.getPublicKey(y, ee)
    }
    ,
    m.prototype.computeSecret = function(y, ee, dt) {
        ee = ee || "utf8",
        Buffer.isBuffer(y) || (y = new Buffer(y,ee));
        var mt = this.curve.keyFromPublic(y).getPublic()
          , yt = mt.mul(this.keys.getPrivate()).getX();
        return k(yt, dt, this.curveType.byteLength)
    }
    ,
    m.prototype.getPublicKey = function(y, ee) {
        var dt = this.keys.getPublic(ee === "compressed", !0);
        return ee === "hybrid" && (dt[dt.length - 1] % 2 ? dt[0] = 7 : dt[0] = 6),
        k(dt, y)
    }
    ,
    m.prototype.getPrivateKey = function(y) {
        return k(this.keys.getPrivate(), y)
    }
    ,
    m.prototype.setPublicKey = function(y, ee) {
        return ee = ee || "utf8",
        Buffer.isBuffer(y) || (y = new Buffer(y,ee)),
        this.keys._importPublic(y),
        this
    }
    ,
    m.prototype.setPrivateKey = function(y, ee) {
        ee = ee || "utf8",
        Buffer.isBuffer(y) || (y = new Buffer(y,ee));
        var dt = new d(y);
        return dt = dt.toString(16),
        this.keys = this.curve.genKeyPair(),
        this.keys._importPrivate(dt),
        this
    }
    ;
    function k(y, ee, dt) {
        Array.isArray(y) || (y = y.toArray());
        var mt = new Buffer(y);
        if (dt && mt.length < dt) {
            var yt = new Buffer(dt - mt.length);
            yt.fill(0),
            mt = Buffer.concat([yt, mt])
        }
        return ee ? mt.toString(ee) : mt
    }
    return browser$3
}
var browser$2 = {}, mgf, hasRequiredMgf;
function requireMgf() {
    if (hasRequiredMgf)
        return mgf;
    hasRequiredMgf = 1;
    var r = requireBrowser$9()
      , d = requireSafeBuffer$1().Buffer;
    mgf = function(m, k) {
        for (var y = d.alloc(0), ee = 0, dt; y.length < k; )
            dt = f(ee++),
            y = d.concat([y, r("sha1").update(m).update(dt).digest()]);
        return y.slice(0, k)
    }
    ;
    function f(m) {
        var k = d.allocUnsafe(4);
        return k.writeUInt32BE(m, 0),
        k
    }
    return mgf
}
var xor, hasRequiredXor;
function requireXor() {
    return hasRequiredXor || (hasRequiredXor = 1,
    xor = function(d, f) {
        for (var m = d.length, k = -1; ++k < m; )
            d[k] ^= f[k];
        return d
    }
    ),
    xor
}
var withPublic_1, hasRequiredWithPublic;
function requireWithPublic() {
    if (hasRequiredWithPublic)
        return withPublic_1;
    hasRequiredWithPublic = 1;
    var r = requireBn$2()
      , d = requireSafeBuffer$1().Buffer;
    function f(m, k) {
        return d.from(m.toRed(r.mont(k.modulus)).redPow(new r(k.publicExponent)).fromRed().toArray())
    }
    return withPublic_1 = f,
    withPublic_1
}
var publicEncrypt, hasRequiredPublicEncrypt;
function requirePublicEncrypt() {
    if (hasRequiredPublicEncrypt)
        return publicEncrypt;
    hasRequiredPublicEncrypt = 1;
    var r = requireParseAsn1()
      , d = requireBrowser$b()
      , f = requireBrowser$9()
      , m = requireMgf()
      , k = requireXor()
      , y = requireBn$2()
      , ee = requireWithPublic()
      , dt = requireBrowserifyRsa()
      , mt = requireSafeBuffer$1().Buffer;
    publicEncrypt = function(xt, At, Ct) {
        var Pt;
        xt.padding ? Pt = xt.padding : Ct ? Pt = 1 : Pt = 4;
        var $t = r(xt), Ot;
        if (Pt === 4)
            Ot = yt($t, At);
        else if (Pt === 1)
            Ot = pt($t, At, Ct);
        else if (Pt === 3) {
            if (Ot = new y(At),
            Ot.cmp($t.modulus) >= 0)
                throw new Error("data too long for modulus")
        } else
            throw new Error("unknown padding");
        return Ct ? dt(Ot, $t) : ee(Ot, $t)
    }
    ;
    function yt(wt, xt) {
        var At = wt.modulus.byteLength()
          , Ct = xt.length
          , Pt = f("sha1").update(mt.alloc(0)).digest()
          , $t = Pt.length
          , Ot = 2 * $t;
        if (Ct > At - Ot - 2)
            throw new Error("message too long");
        var Nt = mt.alloc(At - Ct - Ot - 2)
          , zt = At - $t - 1
          , Wt = d($t)
          , Kt = k(mt.concat([Pt, Nt, mt.alloc(1, 1), xt], zt), m(Wt, zt))
          , ir = k(Wt, m(Kt, $t));
        return new y(mt.concat([mt.alloc(1), ir, Kt], At))
    }
    function pt(wt, xt, At) {
        var Ct = xt.length
          , Pt = wt.modulus.byteLength();
        if (Ct > Pt - 11)
            throw new Error("message too long");
        var $t;
        return At ? $t = mt.alloc(Pt - Ct - 3, 255) : $t = bt(Pt - Ct - 3),
        new y(mt.concat([mt.from([0, At ? 1 : 2]), $t, mt.alloc(1), xt], Pt))
    }
    function bt(wt) {
        for (var xt = mt.allocUnsafe(wt), At = 0, Ct = d(wt * 2), Pt = 0, $t; At < wt; )
            Pt === Ct.length && (Ct = d(wt * 2),
            Pt = 0),
            $t = Ct[Pt++],
            $t && (xt[At++] = $t);
        return xt
    }
    return publicEncrypt
}
var privateDecrypt, hasRequiredPrivateDecrypt;
function requirePrivateDecrypt() {
    if (hasRequiredPrivateDecrypt)
        return privateDecrypt;
    hasRequiredPrivateDecrypt = 1;
    var r = requireParseAsn1()
      , d = requireMgf()
      , f = requireXor()
      , m = requireBn$2()
      , k = requireBrowserifyRsa()
      , y = requireBrowser$9()
      , ee = requireWithPublic()
      , dt = requireSafeBuffer$1().Buffer;
    privateDecrypt = function(wt, xt, At) {
        var Ct;
        wt.padding ? Ct = wt.padding : At ? Ct = 1 : Ct = 4;
        var Pt = r(wt)
          , $t = Pt.modulus.byteLength();
        if (xt.length > $t || new m(xt).cmp(Pt.modulus) >= 0)
            throw new Error("decryption error");
        var Ot;
        At ? Ot = ee(new m(xt), Pt) : Ot = k(xt, Pt);
        var Nt = dt.alloc($t - Ot.length);
        if (Ot = dt.concat([Nt, Ot], $t),
        Ct === 4)
            return mt(Pt, Ot);
        if (Ct === 1)
            return yt(Pt, Ot, At);
        if (Ct === 3)
            return Ot;
        throw new Error("unknown padding")
    }
    ;
    function mt(bt, wt) {
        var xt = bt.modulus.byteLength()
          , At = y("sha1").update(dt.alloc(0)).digest()
          , Ct = At.length;
        if (wt[0] !== 0)
            throw new Error("decryption error");
        var Pt = wt.slice(1, Ct + 1)
          , $t = wt.slice(Ct + 1)
          , Ot = f(Pt, d($t, Ct))
          , Nt = f($t, d(Ot, xt - Ct - 1));
        if (pt(At, Nt.slice(0, Ct)))
            throw new Error("decryption error");
        for (var zt = Ct; Nt[zt] === 0; )
            zt++;
        if (Nt[zt++] !== 1)
            throw new Error("decryption error");
        return Nt.slice(zt)
    }
    function yt(bt, wt, xt) {
        for (var At = wt.slice(0, 2), Ct = 2, Pt = 0; wt[Ct++] !== 0; )
            if (Ct >= wt.length) {
                Pt++;
                break
            }
        var $t = wt.slice(2, Ct - 1);
        if ((At.toString("hex") !== "0002" && !xt || At.toString("hex") !== "0001" && xt) && Pt++,
        $t.length < 8 && Pt++,
        Pt)
            throw new Error("decryption error");
        return wt.slice(Ct)
    }
    function pt(bt, wt) {
        bt = dt.from(bt),
        wt = dt.from(wt);
        var xt = 0
          , At = bt.length;
        bt.length !== wt.length && (xt++,
        At = Math.min(bt.length, wt.length));
        for (var Ct = -1; ++Ct < At; )
            xt += bt[Ct] ^ wt[Ct];
        return xt
    }
    return privateDecrypt
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
    return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1,
    function(r) {
        r.publicEncrypt = requirePublicEncrypt(),
        r.privateDecrypt = requirePrivateDecrypt(),
        r.privateEncrypt = function(f, m) {
            return r.publicEncrypt(f, m, !0)
        }
        ,
        r.publicDecrypt = function(f, m) {
            return r.privateDecrypt(f, m, !0)
        }
    }(browser$2)),
    browser$2
}
var browser$1 = {}, hasRequiredBrowser;
function requireBrowser() {
    if (hasRequiredBrowser)
        return browser$1;
    hasRequiredBrowser = 1;
    function r() {
        throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`)
    }
    var d = requireSafeBuffer$1()
      , f = requireBrowser$b()
      , m = d.Buffer
      , k = d.kMaxLength
      , y = commonjsGlobal.crypto || commonjsGlobal.msCrypto
      , ee = Math.pow(2, 32) - 1;
    function dt(wt, xt) {
        if (typeof wt != "number" || wt !== wt)
            throw new TypeError("offset must be a number");
        if (wt > ee || wt < 0)
            throw new TypeError("offset must be a uint32");
        if (wt > k || wt > xt)
            throw new RangeError("offset out of range")
    }
    function mt(wt, xt, At) {
        if (typeof wt != "number" || wt !== wt)
            throw new TypeError("size must be a number");
        if (wt > ee || wt < 0)
            throw new TypeError("size must be a uint32");
        if (wt + xt > At || wt > k)
            throw new RangeError("buffer too small")
    }
    y && y.getRandomValues || !process$1.browser ? (browser$1.randomFill = yt,
    browser$1.randomFillSync = bt) : (browser$1.randomFill = r,
    browser$1.randomFillSync = r);
    function yt(wt, xt, At, Ct) {
        if (!m.isBuffer(wt) && !(wt instanceof commonjsGlobal.Uint8Array))
            throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        if (typeof xt == "function")
            Ct = xt,
            xt = 0,
            At = wt.length;
        else if (typeof At == "function")
            Ct = At,
            At = wt.length - xt;
        else if (typeof Ct != "function")
            throw new TypeError('"cb" argument must be a function');
        return dt(xt, wt.length),
        mt(At, xt, wt.length),
        pt(wt, xt, At, Ct)
    }
    function pt(wt, xt, At, Ct) {
        if (process$1.browser) {
            var Pt = wt.buffer
              , $t = new Uint8Array(Pt,xt,At);
            if (y.getRandomValues($t),
            Ct) {
                process$1.nextTick(function() {
                    Ct(null, wt)
                });
                return
            }
            return wt
        }
        if (Ct) {
            f(At, function(Nt, zt) {
                if (Nt)
                    return Ct(Nt);
                zt.copy(wt, xt),
                Ct(null, wt)
            });
            return
        }
        var Ot = f(At);
        return Ot.copy(wt, xt),
        wt
    }
    function bt(wt, xt, At) {
        if (typeof xt > "u" && (xt = 0),
        !m.isBuffer(wt) && !(wt instanceof commonjsGlobal.Uint8Array))
            throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        return dt(xt, wt.length),
        At === void 0 && (At = wt.length - xt),
        mt(At, xt, wt.length),
        pt(wt, xt, At)
    }
    return browser$1
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
    if (hasRequiredCryptoBrowserify)
        return cryptoBrowserify;
    hasRequiredCryptoBrowserify = 1,
    cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$b(),
    cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$9(),
    cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8();
    var r = requireAlgos()
      , d = Object.keys(r)
      , f = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(d);
    cryptoBrowserify.getHashes = function() {
        return f
    }
    ;
    var m = requireBrowser$7();
    cryptoBrowserify.pbkdf2 = m.pbkdf2,
    cryptoBrowserify.pbkdf2Sync = m.pbkdf2Sync;
    var k = requireBrowser$5();
    cryptoBrowserify.Cipher = k.Cipher,
    cryptoBrowserify.createCipher = k.createCipher,
    cryptoBrowserify.Cipheriv = k.Cipheriv,
    cryptoBrowserify.createCipheriv = k.createCipheriv,
    cryptoBrowserify.Decipher = k.Decipher,
    cryptoBrowserify.createDecipher = k.createDecipher,
    cryptoBrowserify.Decipheriv = k.Decipheriv,
    cryptoBrowserify.createDecipheriv = k.createDecipheriv,
    cryptoBrowserify.getCiphers = k.getCiphers,
    cryptoBrowserify.listCiphers = k.listCiphers;
    var y = requireBrowser$4();
    cryptoBrowserify.DiffieHellmanGroup = y.DiffieHellmanGroup,
    cryptoBrowserify.createDiffieHellmanGroup = y.createDiffieHellmanGroup,
    cryptoBrowserify.getDiffieHellman = y.getDiffieHellman,
    cryptoBrowserify.createDiffieHellman = y.createDiffieHellman,
    cryptoBrowserify.DiffieHellman = y.DiffieHellman;
    var ee = requireBrowser$3();
    cryptoBrowserify.createSign = ee.createSign,
    cryptoBrowserify.Sign = ee.Sign,
    cryptoBrowserify.createVerify = ee.createVerify,
    cryptoBrowserify.Verify = ee.Verify,
    cryptoBrowserify.createECDH = requireBrowser$2();
    var dt = requireBrowser$1();
    cryptoBrowserify.publicEncrypt = dt.publicEncrypt,
    cryptoBrowserify.privateEncrypt = dt.privateEncrypt,
    cryptoBrowserify.publicDecrypt = dt.publicDecrypt,
    cryptoBrowserify.privateDecrypt = dt.privateDecrypt;
    var mt = requireBrowser();
    return cryptoBrowserify.randomFill = mt.randomFill,
    cryptoBrowserify.randomFillSync = mt.randomFillSync,
    cryptoBrowserify.createCredentials = function() {
        throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`))
    }
    ,
    cryptoBrowserify.constants = {
        DH_CHECK_P_NOT_SAFE_PRIME: 2,
        DH_CHECK_P_NOT_PRIME: 1,
        DH_UNABLE_TO_CHECK_GENERATOR: 4,
        DH_NOT_SUITABLE_GENERATOR: 8,
        NPN_ENABLED: 1,
        ALPN_ENABLED: 1,
        RSA_PKCS1_PADDING: 1,
        RSA_SSLV23_PADDING: 2,
        RSA_NO_PADDING: 3,
        RSA_PKCS1_OAEP_PADDING: 4,
        RSA_X931_PADDING: 5,
        RSA_PKCS1_PSS_PADDING: 6,
        POINT_CONVERSION_COMPRESSED: 2,
        POINT_CONVERSION_UNCOMPRESSED: 4,
        POINT_CONVERSION_HYBRID: 6
    },
    cryptoBrowserify
}
(function(r) {
    (function(d) {
        var f = function(Jt) {
            var nr, sr = new Float64Array(16);
            if (Jt)
                for (nr = 0; nr < Jt.length; nr++)
                    sr[nr] = Jt[nr];
            return sr
        }
          , m = function() {
            throw new Error("no PRNG")
        }
          , k = new Uint8Array(16)
          , y = new Uint8Array(32);
        y[0] = 9;
        var ee = f()
          , dt = f([1])
          , mt = f([56129, 1])
          , yt = f([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995])
          , pt = f([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222])
          , bt = f([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553])
          , wt = f([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214])
          , xt = f([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
        function At(Jt, nr, sr, jt) {
            Jt[nr] = sr >> 24 & 255,
            Jt[nr + 1] = sr >> 16 & 255,
            Jt[nr + 2] = sr >> 8 & 255,
            Jt[nr + 3] = sr & 255,
            Jt[nr + 4] = jt >> 24 & 255,
            Jt[nr + 5] = jt >> 16 & 255,
            Jt[nr + 6] = jt >> 8 & 255,
            Jt[nr + 7] = jt & 255
        }
        function Ct(Jt, nr, sr, jt, cr) {
            var Tr, kr = 0;
            for (Tr = 0; Tr < cr; Tr++)
                kr |= Jt[nr + Tr] ^ sr[jt + Tr];
            return (1 & kr - 1 >>> 8) - 1
        }
        function Pt(Jt, nr, sr, jt) {
            return Ct(Jt, nr, sr, jt, 16)
        }
        function $t(Jt, nr, sr, jt) {
            return Ct(Jt, nr, sr, jt, 32)
        }
        function Ot(Jt, nr, sr, jt) {
            for (var cr = jt[0] & 255 | (jt[1] & 255) << 8 | (jt[2] & 255) << 16 | (jt[3] & 255) << 24, Tr = sr[0] & 255 | (sr[1] & 255) << 8 | (sr[2] & 255) << 16 | (sr[3] & 255) << 24, kr = sr[4] & 255 | (sr[5] & 255) << 8 | (sr[6] & 255) << 16 | (sr[7] & 255) << 24, Pr = sr[8] & 255 | (sr[9] & 255) << 8 | (sr[10] & 255) << 16 | (sr[11] & 255) << 24, zr = sr[12] & 255 | (sr[13] & 255) << 8 | (sr[14] & 255) << 16 | (sr[15] & 255) << 24, Vr = jt[4] & 255 | (jt[5] & 255) << 8 | (jt[6] & 255) << 16 | (jt[7] & 255) << 24, jr = nr[0] & 255 | (nr[1] & 255) << 8 | (nr[2] & 255) << 16 | (nr[3] & 255) << 24, Mn = nr[4] & 255 | (nr[5] & 255) << 8 | (nr[6] & 255) << 16 | (nr[7] & 255) << 24, nn = nr[8] & 255 | (nr[9] & 255) << 8 | (nr[10] & 255) << 16 | (nr[11] & 255) << 24, gn = nr[12] & 255 | (nr[13] & 255) << 8 | (nr[14] & 255) << 16 | (nr[15] & 255) << 24, mn = jt[8] & 255 | (jt[9] & 255) << 8 | (jt[10] & 255) << 16 | (jt[11] & 255) << 24, xn = sr[16] & 255 | (sr[17] & 255) << 8 | (sr[18] & 255) << 16 | (sr[19] & 255) << 24, _n = sr[20] & 255 | (sr[21] & 255) << 8 | (sr[22] & 255) << 16 | (sr[23] & 255) << 24, yn = sr[24] & 255 | (sr[25] & 255) << 8 | (sr[26] & 255) << 16 | (sr[27] & 255) << 24, wn = sr[28] & 255 | (sr[29] & 255) << 8 | (sr[30] & 255) << 16 | (sr[31] & 255) << 24, vn = jt[12] & 255 | (jt[13] & 255) << 8 | (jt[14] & 255) << 16 | (jt[15] & 255) << 24, sn = cr, hn = Tr, rn = kr, ln = Pr, yr = zr, Lt = Vr, Gt = jr, Qt = Mn, pr = nn, dr = gn, Mr = mn, Br = xn, Fr = _n, Kr = yn, Xr = wn, Cn = vn, Er, kn = 0; kn < 20; kn += 2)
                Er = sn + Fr | 0,
                yr ^= Er << 7 | Er >>> 25,
                Er = yr + sn | 0,
                pr ^= Er << 9 | Er >>> 23,
                Er = pr + yr | 0,
                Fr ^= Er << 13 | Er >>> 19,
                Er = Fr + pr | 0,
                sn ^= Er << 18 | Er >>> 14,
                Er = Lt + hn | 0,
                dr ^= Er << 7 | Er >>> 25,
                Er = dr + Lt | 0,
                Kr ^= Er << 9 | Er >>> 23,
                Er = Kr + dr | 0,
                hn ^= Er << 13 | Er >>> 19,
                Er = hn + Kr | 0,
                Lt ^= Er << 18 | Er >>> 14,
                Er = Mr + Gt | 0,
                Xr ^= Er << 7 | Er >>> 25,
                Er = Xr + Mr | 0,
                rn ^= Er << 9 | Er >>> 23,
                Er = rn + Xr | 0,
                Gt ^= Er << 13 | Er >>> 19,
                Er = Gt + rn | 0,
                Mr ^= Er << 18 | Er >>> 14,
                Er = Cn + Br | 0,
                ln ^= Er << 7 | Er >>> 25,
                Er = ln + Cn | 0,
                Qt ^= Er << 9 | Er >>> 23,
                Er = Qt + ln | 0,
                Br ^= Er << 13 | Er >>> 19,
                Er = Br + Qt | 0,
                Cn ^= Er << 18 | Er >>> 14,
                Er = sn + ln | 0,
                hn ^= Er << 7 | Er >>> 25,
                Er = hn + sn | 0,
                rn ^= Er << 9 | Er >>> 23,
                Er = rn + hn | 0,
                ln ^= Er << 13 | Er >>> 19,
                Er = ln + rn | 0,
                sn ^= Er << 18 | Er >>> 14,
                Er = Lt + yr | 0,
                Gt ^= Er << 7 | Er >>> 25,
                Er = Gt + Lt | 0,
                Qt ^= Er << 9 | Er >>> 23,
                Er = Qt + Gt | 0,
                yr ^= Er << 13 | Er >>> 19,
                Er = yr + Qt | 0,
                Lt ^= Er << 18 | Er >>> 14,
                Er = Mr + dr | 0,
                Br ^= Er << 7 | Er >>> 25,
                Er = Br + Mr | 0,
                pr ^= Er << 9 | Er >>> 23,
                Er = pr + Br | 0,
                dr ^= Er << 13 | Er >>> 19,
                Er = dr + pr | 0,
                Mr ^= Er << 18 | Er >>> 14,
                Er = Cn + Xr | 0,
                Fr ^= Er << 7 | Er >>> 25,
                Er = Fr + Cn | 0,
                Kr ^= Er << 9 | Er >>> 23,
                Er = Kr + Fr | 0,
                Xr ^= Er << 13 | Er >>> 19,
                Er = Xr + Kr | 0,
                Cn ^= Er << 18 | Er >>> 14;
            sn = sn + cr | 0,
            hn = hn + Tr | 0,
            rn = rn + kr | 0,
            ln = ln + Pr | 0,
            yr = yr + zr | 0,
            Lt = Lt + Vr | 0,
            Gt = Gt + jr | 0,
            Qt = Qt + Mn | 0,
            pr = pr + nn | 0,
            dr = dr + gn | 0,
            Mr = Mr + mn | 0,
            Br = Br + xn | 0,
            Fr = Fr + _n | 0,
            Kr = Kr + yn | 0,
            Xr = Xr + wn | 0,
            Cn = Cn + vn | 0,
            Jt[0] = sn >>> 0 & 255,
            Jt[1] = sn >>> 8 & 255,
            Jt[2] = sn >>> 16 & 255,
            Jt[3] = sn >>> 24 & 255,
            Jt[4] = hn >>> 0 & 255,
            Jt[5] = hn >>> 8 & 255,
            Jt[6] = hn >>> 16 & 255,
            Jt[7] = hn >>> 24 & 255,
            Jt[8] = rn >>> 0 & 255,
            Jt[9] = rn >>> 8 & 255,
            Jt[10] = rn >>> 16 & 255,
            Jt[11] = rn >>> 24 & 255,
            Jt[12] = ln >>> 0 & 255,
            Jt[13] = ln >>> 8 & 255,
            Jt[14] = ln >>> 16 & 255,
            Jt[15] = ln >>> 24 & 255,
            Jt[16] = yr >>> 0 & 255,
            Jt[17] = yr >>> 8 & 255,
            Jt[18] = yr >>> 16 & 255,
            Jt[19] = yr >>> 24 & 255,
            Jt[20] = Lt >>> 0 & 255,
            Jt[21] = Lt >>> 8 & 255,
            Jt[22] = Lt >>> 16 & 255,
            Jt[23] = Lt >>> 24 & 255,
            Jt[24] = Gt >>> 0 & 255,
            Jt[25] = Gt >>> 8 & 255,
            Jt[26] = Gt >>> 16 & 255,
            Jt[27] = Gt >>> 24 & 255,
            Jt[28] = Qt >>> 0 & 255,
            Jt[29] = Qt >>> 8 & 255,
            Jt[30] = Qt >>> 16 & 255,
            Jt[31] = Qt >>> 24 & 255,
            Jt[32] = pr >>> 0 & 255,
            Jt[33] = pr >>> 8 & 255,
            Jt[34] = pr >>> 16 & 255,
            Jt[35] = pr >>> 24 & 255,
            Jt[36] = dr >>> 0 & 255,
            Jt[37] = dr >>> 8 & 255,
            Jt[38] = dr >>> 16 & 255,
            Jt[39] = dr >>> 24 & 255,
            Jt[40] = Mr >>> 0 & 255,
            Jt[41] = Mr >>> 8 & 255,
            Jt[42] = Mr >>> 16 & 255,
            Jt[43] = Mr >>> 24 & 255,
            Jt[44] = Br >>> 0 & 255,
            Jt[45] = Br >>> 8 & 255,
            Jt[46] = Br >>> 16 & 255,
            Jt[47] = Br >>> 24 & 255,
            Jt[48] = Fr >>> 0 & 255,
            Jt[49] = Fr >>> 8 & 255,
            Jt[50] = Fr >>> 16 & 255,
            Jt[51] = Fr >>> 24 & 255,
            Jt[52] = Kr >>> 0 & 255,
            Jt[53] = Kr >>> 8 & 255,
            Jt[54] = Kr >>> 16 & 255,
            Jt[55] = Kr >>> 24 & 255,
            Jt[56] = Xr >>> 0 & 255,
            Jt[57] = Xr >>> 8 & 255,
            Jt[58] = Xr >>> 16 & 255,
            Jt[59] = Xr >>> 24 & 255,
            Jt[60] = Cn >>> 0 & 255,
            Jt[61] = Cn >>> 8 & 255,
            Jt[62] = Cn >>> 16 & 255,
            Jt[63] = Cn >>> 24 & 255
        }
        function Nt(Jt, nr, sr, jt) {
            for (var cr = jt[0] & 255 | (jt[1] & 255) << 8 | (jt[2] & 255) << 16 | (jt[3] & 255) << 24, Tr = sr[0] & 255 | (sr[1] & 255) << 8 | (sr[2] & 255) << 16 | (sr[3] & 255) << 24, kr = sr[4] & 255 | (sr[5] & 255) << 8 | (sr[6] & 255) << 16 | (sr[7] & 255) << 24, Pr = sr[8] & 255 | (sr[9] & 255) << 8 | (sr[10] & 255) << 16 | (sr[11] & 255) << 24, zr = sr[12] & 255 | (sr[13] & 255) << 8 | (sr[14] & 255) << 16 | (sr[15] & 255) << 24, Vr = jt[4] & 255 | (jt[5] & 255) << 8 | (jt[6] & 255) << 16 | (jt[7] & 255) << 24, jr = nr[0] & 255 | (nr[1] & 255) << 8 | (nr[2] & 255) << 16 | (nr[3] & 255) << 24, Mn = nr[4] & 255 | (nr[5] & 255) << 8 | (nr[6] & 255) << 16 | (nr[7] & 255) << 24, nn = nr[8] & 255 | (nr[9] & 255) << 8 | (nr[10] & 255) << 16 | (nr[11] & 255) << 24, gn = nr[12] & 255 | (nr[13] & 255) << 8 | (nr[14] & 255) << 16 | (nr[15] & 255) << 24, mn = jt[8] & 255 | (jt[9] & 255) << 8 | (jt[10] & 255) << 16 | (jt[11] & 255) << 24, xn = sr[16] & 255 | (sr[17] & 255) << 8 | (sr[18] & 255) << 16 | (sr[19] & 255) << 24, _n = sr[20] & 255 | (sr[21] & 255) << 8 | (sr[22] & 255) << 16 | (sr[23] & 255) << 24, yn = sr[24] & 255 | (sr[25] & 255) << 8 | (sr[26] & 255) << 16 | (sr[27] & 255) << 24, wn = sr[28] & 255 | (sr[29] & 255) << 8 | (sr[30] & 255) << 16 | (sr[31] & 255) << 24, vn = jt[12] & 255 | (jt[13] & 255) << 8 | (jt[14] & 255) << 16 | (jt[15] & 255) << 24, sn = cr, hn = Tr, rn = kr, ln = Pr, yr = zr, Lt = Vr, Gt = jr, Qt = Mn, pr = nn, dr = gn, Mr = mn, Br = xn, Fr = _n, Kr = yn, Xr = wn, Cn = vn, Er, kn = 0; kn < 20; kn += 2)
                Er = sn + Fr | 0,
                yr ^= Er << 7 | Er >>> 25,
                Er = yr + sn | 0,
                pr ^= Er << 9 | Er >>> 23,
                Er = pr + yr | 0,
                Fr ^= Er << 13 | Er >>> 19,
                Er = Fr + pr | 0,
                sn ^= Er << 18 | Er >>> 14,
                Er = Lt + hn | 0,
                dr ^= Er << 7 | Er >>> 25,
                Er = dr + Lt | 0,
                Kr ^= Er << 9 | Er >>> 23,
                Er = Kr + dr | 0,
                hn ^= Er << 13 | Er >>> 19,
                Er = hn + Kr | 0,
                Lt ^= Er << 18 | Er >>> 14,
                Er = Mr + Gt | 0,
                Xr ^= Er << 7 | Er >>> 25,
                Er = Xr + Mr | 0,
                rn ^= Er << 9 | Er >>> 23,
                Er = rn + Xr | 0,
                Gt ^= Er << 13 | Er >>> 19,
                Er = Gt + rn | 0,
                Mr ^= Er << 18 | Er >>> 14,
                Er = Cn + Br | 0,
                ln ^= Er << 7 | Er >>> 25,
                Er = ln + Cn | 0,
                Qt ^= Er << 9 | Er >>> 23,
                Er = Qt + ln | 0,
                Br ^= Er << 13 | Er >>> 19,
                Er = Br + Qt | 0,
                Cn ^= Er << 18 | Er >>> 14,
                Er = sn + ln | 0,
                hn ^= Er << 7 | Er >>> 25,
                Er = hn + sn | 0,
                rn ^= Er << 9 | Er >>> 23,
                Er = rn + hn | 0,
                ln ^= Er << 13 | Er >>> 19,
                Er = ln + rn | 0,
                sn ^= Er << 18 | Er >>> 14,
                Er = Lt + yr | 0,
                Gt ^= Er << 7 | Er >>> 25,
                Er = Gt + Lt | 0,
                Qt ^= Er << 9 | Er >>> 23,
                Er = Qt + Gt | 0,
                yr ^= Er << 13 | Er >>> 19,
                Er = yr + Qt | 0,
                Lt ^= Er << 18 | Er >>> 14,
                Er = Mr + dr | 0,
                Br ^= Er << 7 | Er >>> 25,
                Er = Br + Mr | 0,
                pr ^= Er << 9 | Er >>> 23,
                Er = pr + Br | 0,
                dr ^= Er << 13 | Er >>> 19,
                Er = dr + pr | 0,
                Mr ^= Er << 18 | Er >>> 14,
                Er = Cn + Xr | 0,
                Fr ^= Er << 7 | Er >>> 25,
                Er = Fr + Cn | 0,
                Kr ^= Er << 9 | Er >>> 23,
                Er = Kr + Fr | 0,
                Xr ^= Er << 13 | Er >>> 19,
                Er = Xr + Kr | 0,
                Cn ^= Er << 18 | Er >>> 14;
            Jt[0] = sn >>> 0 & 255,
            Jt[1] = sn >>> 8 & 255,
            Jt[2] = sn >>> 16 & 255,
            Jt[3] = sn >>> 24 & 255,
            Jt[4] = Lt >>> 0 & 255,
            Jt[5] = Lt >>> 8 & 255,
            Jt[6] = Lt >>> 16 & 255,
            Jt[7] = Lt >>> 24 & 255,
            Jt[8] = Mr >>> 0 & 255,
            Jt[9] = Mr >>> 8 & 255,
            Jt[10] = Mr >>> 16 & 255,
            Jt[11] = Mr >>> 24 & 255,
            Jt[12] = Cn >>> 0 & 255,
            Jt[13] = Cn >>> 8 & 255,
            Jt[14] = Cn >>> 16 & 255,
            Jt[15] = Cn >>> 24 & 255,
            Jt[16] = Gt >>> 0 & 255,
            Jt[17] = Gt >>> 8 & 255,
            Jt[18] = Gt >>> 16 & 255,
            Jt[19] = Gt >>> 24 & 255,
            Jt[20] = Qt >>> 0 & 255,
            Jt[21] = Qt >>> 8 & 255,
            Jt[22] = Qt >>> 16 & 255,
            Jt[23] = Qt >>> 24 & 255,
            Jt[24] = pr >>> 0 & 255,
            Jt[25] = pr >>> 8 & 255,
            Jt[26] = pr >>> 16 & 255,
            Jt[27] = pr >>> 24 & 255,
            Jt[28] = dr >>> 0 & 255,
            Jt[29] = dr >>> 8 & 255,
            Jt[30] = dr >>> 16 & 255,
            Jt[31] = dr >>> 24 & 255
        }
        function zt(Jt, nr, sr, jt) {
            Ot(Jt, nr, sr, jt)
        }
        function Wt(Jt, nr, sr, jt) {
            Nt(Jt, nr, sr, jt)
        }
        var Kt = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
        function ir(Jt, nr, sr, jt, cr, Tr, kr) {
            var Pr = new Uint8Array(16), zr = new Uint8Array(64), Vr, jr;
            for (jr = 0; jr < 16; jr++)
                Pr[jr] = 0;
            for (jr = 0; jr < 8; jr++)
                Pr[jr] = Tr[jr];
            for (; cr >= 64; ) {
                for (zt(zr, Pr, kr, Kt),
                jr = 0; jr < 64; jr++)
                    Jt[nr + jr] = sr[jt + jr] ^ zr[jr];
                for (Vr = 1,
                jr = 8; jr < 16; jr++)
                    Vr = Vr + (Pr[jr] & 255) | 0,
                    Pr[jr] = Vr & 255,
                    Vr >>>= 8;
                cr -= 64,
                nr += 64,
                jt += 64
            }
            if (cr > 0)
                for (zt(zr, Pr, kr, Kt),
                jr = 0; jr < cr; jr++)
                    Jt[nr + jr] = sr[jt + jr] ^ zr[jr];
            return 0
        }
        function or(Jt, nr, sr, jt, cr) {
            var Tr = new Uint8Array(16), kr = new Uint8Array(64), Pr, zr;
            for (zr = 0; zr < 16; zr++)
                Tr[zr] = 0;
            for (zr = 0; zr < 8; zr++)
                Tr[zr] = jt[zr];
            for (; sr >= 64; ) {
                for (zt(kr, Tr, cr, Kt),
                zr = 0; zr < 64; zr++)
                    Jt[nr + zr] = kr[zr];
                for (Pr = 1,
                zr = 8; zr < 16; zr++)
                    Pr = Pr + (Tr[zr] & 255) | 0,
                    Tr[zr] = Pr & 255,
                    Pr >>>= 8;
                sr -= 64,
                nr += 64
            }
            if (sr > 0)
                for (zt(kr, Tr, cr, Kt),
                zr = 0; zr < sr; zr++)
                    Jt[nr + zr] = kr[zr];
            return 0
        }
        function tr(Jt, nr, sr, jt, cr) {
            var Tr = new Uint8Array(32);
            Wt(Tr, jt, cr, Kt);
            for (var kr = new Uint8Array(8), Pr = 0; Pr < 8; Pr++)
                kr[Pr] = jt[Pr + 16];
            return or(Jt, nr, sr, kr, Tr)
        }
        function wr(Jt, nr, sr, jt, cr, Tr, kr) {
            var Pr = new Uint8Array(32);
            Wt(Pr, Tr, kr, Kt);
            for (var zr = new Uint8Array(8), Vr = 0; Vr < 8; Vr++)
                zr[Vr] = Tr[Vr + 16];
            return ir(Jt, nr, sr, jt, cr, zr, Pr)
        }
        var Ht = function(Jt) {
            this.buffer = new Uint8Array(16),
            this.r = new Uint16Array(10),
            this.h = new Uint16Array(10),
            this.pad = new Uint16Array(8),
            this.leftover = 0,
            this.fin = 0;
            var nr, sr, jt, cr, Tr, kr, Pr, zr;
            nr = Jt[0] & 255 | (Jt[1] & 255) << 8,
            this.r[0] = nr & 8191,
            sr = Jt[2] & 255 | (Jt[3] & 255) << 8,
            this.r[1] = (nr >>> 13 | sr << 3) & 8191,
            jt = Jt[4] & 255 | (Jt[5] & 255) << 8,
            this.r[2] = (sr >>> 10 | jt << 6) & 7939,
            cr = Jt[6] & 255 | (Jt[7] & 255) << 8,
            this.r[3] = (jt >>> 7 | cr << 9) & 8191,
            Tr = Jt[8] & 255 | (Jt[9] & 255) << 8,
            this.r[4] = (cr >>> 4 | Tr << 12) & 255,
            this.r[5] = Tr >>> 1 & 8190,
            kr = Jt[10] & 255 | (Jt[11] & 255) << 8,
            this.r[6] = (Tr >>> 14 | kr << 2) & 8191,
            Pr = Jt[12] & 255 | (Jt[13] & 255) << 8,
            this.r[7] = (kr >>> 11 | Pr << 5) & 8065,
            zr = Jt[14] & 255 | (Jt[15] & 255) << 8,
            this.r[8] = (Pr >>> 8 | zr << 8) & 8191,
            this.r[9] = zr >>> 5 & 127,
            this.pad[0] = Jt[16] & 255 | (Jt[17] & 255) << 8,
            this.pad[1] = Jt[18] & 255 | (Jt[19] & 255) << 8,
            this.pad[2] = Jt[20] & 255 | (Jt[21] & 255) << 8,
            this.pad[3] = Jt[22] & 255 | (Jt[23] & 255) << 8,
            this.pad[4] = Jt[24] & 255 | (Jt[25] & 255) << 8,
            this.pad[5] = Jt[26] & 255 | (Jt[27] & 255) << 8,
            this.pad[6] = Jt[28] & 255 | (Jt[29] & 255) << 8,
            this.pad[7] = Jt[30] & 255 | (Jt[31] & 255) << 8
        };
        Ht.prototype.blocks = function(Jt, nr, sr) {
            for (var jt = this.fin ? 0 : 2048, cr, Tr, kr, Pr, zr, Vr, jr, Mn, nn, gn, mn, xn, _n, yn, wn, vn, sn, hn, rn, ln = this.h[0], yr = this.h[1], Lt = this.h[2], Gt = this.h[3], Qt = this.h[4], pr = this.h[5], dr = this.h[6], Mr = this.h[7], Br = this.h[8], Fr = this.h[9], Kr = this.r[0], Xr = this.r[1], Cn = this.r[2], Er = this.r[3], kn = this.r[4], $n = this.r[5], qn = this.r[6], Tn = this.r[7], In = this.r[8], Pn = this.r[9]; sr >= 16; )
                cr = Jt[nr + 0] & 255 | (Jt[nr + 1] & 255) << 8,
                ln += cr & 8191,
                Tr = Jt[nr + 2] & 255 | (Jt[nr + 3] & 255) << 8,
                yr += (cr >>> 13 | Tr << 3) & 8191,
                kr = Jt[nr + 4] & 255 | (Jt[nr + 5] & 255) << 8,
                Lt += (Tr >>> 10 | kr << 6) & 8191,
                Pr = Jt[nr + 6] & 255 | (Jt[nr + 7] & 255) << 8,
                Gt += (kr >>> 7 | Pr << 9) & 8191,
                zr = Jt[nr + 8] & 255 | (Jt[nr + 9] & 255) << 8,
                Qt += (Pr >>> 4 | zr << 12) & 8191,
                pr += zr >>> 1 & 8191,
                Vr = Jt[nr + 10] & 255 | (Jt[nr + 11] & 255) << 8,
                dr += (zr >>> 14 | Vr << 2) & 8191,
                jr = Jt[nr + 12] & 255 | (Jt[nr + 13] & 255) << 8,
                Mr += (Vr >>> 11 | jr << 5) & 8191,
                Mn = Jt[nr + 14] & 255 | (Jt[nr + 15] & 255) << 8,
                Br += (jr >>> 8 | Mn << 8) & 8191,
                Fr += Mn >>> 5 | jt,
                nn = 0,
                gn = nn,
                gn += ln * Kr,
                gn += yr * (5 * Pn),
                gn += Lt * (5 * In),
                gn += Gt * (5 * Tn),
                gn += Qt * (5 * qn),
                nn = gn >>> 13,
                gn &= 8191,
                gn += pr * (5 * $n),
                gn += dr * (5 * kn),
                gn += Mr * (5 * Er),
                gn += Br * (5 * Cn),
                gn += Fr * (5 * Xr),
                nn += gn >>> 13,
                gn &= 8191,
                mn = nn,
                mn += ln * Xr,
                mn += yr * Kr,
                mn += Lt * (5 * Pn),
                mn += Gt * (5 * In),
                mn += Qt * (5 * Tn),
                nn = mn >>> 13,
                mn &= 8191,
                mn += pr * (5 * qn),
                mn += dr * (5 * $n),
                mn += Mr * (5 * kn),
                mn += Br * (5 * Er),
                mn += Fr * (5 * Cn),
                nn += mn >>> 13,
                mn &= 8191,
                xn = nn,
                xn += ln * Cn,
                xn += yr * Xr,
                xn += Lt * Kr,
                xn += Gt * (5 * Pn),
                xn += Qt * (5 * In),
                nn = xn >>> 13,
                xn &= 8191,
                xn += pr * (5 * Tn),
                xn += dr * (5 * qn),
                xn += Mr * (5 * $n),
                xn += Br * (5 * kn),
                xn += Fr * (5 * Er),
                nn += xn >>> 13,
                xn &= 8191,
                _n = nn,
                _n += ln * Er,
                _n += yr * Cn,
                _n += Lt * Xr,
                _n += Gt * Kr,
                _n += Qt * (5 * Pn),
                nn = _n >>> 13,
                _n &= 8191,
                _n += pr * (5 * In),
                _n += dr * (5 * Tn),
                _n += Mr * (5 * qn),
                _n += Br * (5 * $n),
                _n += Fr * (5 * kn),
                nn += _n >>> 13,
                _n &= 8191,
                yn = nn,
                yn += ln * kn,
                yn += yr * Er,
                yn += Lt * Cn,
                yn += Gt * Xr,
                yn += Qt * Kr,
                nn = yn >>> 13,
                yn &= 8191,
                yn += pr * (5 * Pn),
                yn += dr * (5 * In),
                yn += Mr * (5 * Tn),
                yn += Br * (5 * qn),
                yn += Fr * (5 * $n),
                nn += yn >>> 13,
                yn &= 8191,
                wn = nn,
                wn += ln * $n,
                wn += yr * kn,
                wn += Lt * Er,
                wn += Gt * Cn,
                wn += Qt * Xr,
                nn = wn >>> 13,
                wn &= 8191,
                wn += pr * Kr,
                wn += dr * (5 * Pn),
                wn += Mr * (5 * In),
                wn += Br * (5 * Tn),
                wn += Fr * (5 * qn),
                nn += wn >>> 13,
                wn &= 8191,
                vn = nn,
                vn += ln * qn,
                vn += yr * $n,
                vn += Lt * kn,
                vn += Gt * Er,
                vn += Qt * Cn,
                nn = vn >>> 13,
                vn &= 8191,
                vn += pr * Xr,
                vn += dr * Kr,
                vn += Mr * (5 * Pn),
                vn += Br * (5 * In),
                vn += Fr * (5 * Tn),
                nn += vn >>> 13,
                vn &= 8191,
                sn = nn,
                sn += ln * Tn,
                sn += yr * qn,
                sn += Lt * $n,
                sn += Gt * kn,
                sn += Qt * Er,
                nn = sn >>> 13,
                sn &= 8191,
                sn += pr * Cn,
                sn += dr * Xr,
                sn += Mr * Kr,
                sn += Br * (5 * Pn),
                sn += Fr * (5 * In),
                nn += sn >>> 13,
                sn &= 8191,
                hn = nn,
                hn += ln * In,
                hn += yr * Tn,
                hn += Lt * qn,
                hn += Gt * $n,
                hn += Qt * kn,
                nn = hn >>> 13,
                hn &= 8191,
                hn += pr * Er,
                hn += dr * Cn,
                hn += Mr * Xr,
                hn += Br * Kr,
                hn += Fr * (5 * Pn),
                nn += hn >>> 13,
                hn &= 8191,
                rn = nn,
                rn += ln * Pn,
                rn += yr * In,
                rn += Lt * Tn,
                rn += Gt * qn,
                rn += Qt * $n,
                nn = rn >>> 13,
                rn &= 8191,
                rn += pr * kn,
                rn += dr * Er,
                rn += Mr * Cn,
                rn += Br * Xr,
                rn += Fr * Kr,
                nn += rn >>> 13,
                rn &= 8191,
                nn = (nn << 2) + nn | 0,
                nn = nn + gn | 0,
                gn = nn & 8191,
                nn = nn >>> 13,
                mn += nn,
                ln = gn,
                yr = mn,
                Lt = xn,
                Gt = _n,
                Qt = yn,
                pr = wn,
                dr = vn,
                Mr = sn,
                Br = hn,
                Fr = rn,
                nr += 16,
                sr -= 16;
            this.h[0] = ln,
            this.h[1] = yr,
            this.h[2] = Lt,
            this.h[3] = Gt,
            this.h[4] = Qt,
            this.h[5] = pr,
            this.h[6] = dr,
            this.h[7] = Mr,
            this.h[8] = Br,
            this.h[9] = Fr
        }
        ,
        Ht.prototype.finish = function(Jt, nr) {
            var sr = new Uint16Array(10), jt, cr, Tr, kr;
            if (this.leftover) {
                for (kr = this.leftover,
                this.buffer[kr++] = 1; kr < 16; kr++)
                    this.buffer[kr] = 0;
                this.fin = 1,
                this.blocks(this.buffer, 0, 16)
            }
            for (jt = this.h[1] >>> 13,
            this.h[1] &= 8191,
            kr = 2; kr < 10; kr++)
                this.h[kr] += jt,
                jt = this.h[kr] >>> 13,
                this.h[kr] &= 8191;
            for (this.h[0] += jt * 5,
            jt = this.h[0] >>> 13,
            this.h[0] &= 8191,
            this.h[1] += jt,
            jt = this.h[1] >>> 13,
            this.h[1] &= 8191,
            this.h[2] += jt,
            sr[0] = this.h[0] + 5,
            jt = sr[0] >>> 13,
            sr[0] &= 8191,
            kr = 1; kr < 10; kr++)
                sr[kr] = this.h[kr] + jt,
                jt = sr[kr] >>> 13,
                sr[kr] &= 8191;
            for (sr[9] -= 8192,
            cr = (jt ^ 1) - 1,
            kr = 0; kr < 10; kr++)
                sr[kr] &= cr;
            for (cr = ~cr,
            kr = 0; kr < 10; kr++)
                this.h[kr] = this.h[kr] & cr | sr[kr];
            for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535,
            this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535,
            this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535,
            this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535,
            this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535,
            this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535,
            this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535,
            this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535,
            Tr = this.h[0] + this.pad[0],
            this.h[0] = Tr & 65535,
            kr = 1; kr < 8; kr++)
                Tr = (this.h[kr] + this.pad[kr] | 0) + (Tr >>> 16) | 0,
                this.h[kr] = Tr & 65535;
            Jt[nr + 0] = this.h[0] >>> 0 & 255,
            Jt[nr + 1] = this.h[0] >>> 8 & 255,
            Jt[nr + 2] = this.h[1] >>> 0 & 255,
            Jt[nr + 3] = this.h[1] >>> 8 & 255,
            Jt[nr + 4] = this.h[2] >>> 0 & 255,
            Jt[nr + 5] = this.h[2] >>> 8 & 255,
            Jt[nr + 6] = this.h[3] >>> 0 & 255,
            Jt[nr + 7] = this.h[3] >>> 8 & 255,
            Jt[nr + 8] = this.h[4] >>> 0 & 255,
            Jt[nr + 9] = this.h[4] >>> 8 & 255,
            Jt[nr + 10] = this.h[5] >>> 0 & 255,
            Jt[nr + 11] = this.h[5] >>> 8 & 255,
            Jt[nr + 12] = this.h[6] >>> 0 & 255,
            Jt[nr + 13] = this.h[6] >>> 8 & 255,
            Jt[nr + 14] = this.h[7] >>> 0 & 255,
            Jt[nr + 15] = this.h[7] >>> 8 & 255
        }
        ,
        Ht.prototype.update = function(Jt, nr, sr) {
            var jt, cr;
            if (this.leftover) {
                for (cr = 16 - this.leftover,
                cr > sr && (cr = sr),
                jt = 0; jt < cr; jt++)
                    this.buffer[this.leftover + jt] = Jt[nr + jt];
                if (sr -= cr,
                nr += cr,
                this.leftover += cr,
                this.leftover < 16)
                    return;
                this.blocks(this.buffer, 0, 16),
                this.leftover = 0
            }
            if (sr >= 16 && (cr = sr - sr % 16,
            this.blocks(Jt, nr, cr),
            nr += cr,
            sr -= cr),
            sr) {
                for (jt = 0; jt < sr; jt++)
                    this.buffer[this.leftover + jt] = Jt[nr + jt];
                this.leftover += sr
            }
        }
        ;
        function Mt(Jt, nr, sr, jt, cr, Tr) {
            var kr = new Ht(Tr);
            return kr.update(sr, jt, cr),
            kr.finish(Jt, nr),
            0
        }
        function _t(Jt, nr, sr, jt, cr, Tr) {
            var kr = new Uint8Array(16);
            return Mt(kr, 0, sr, jt, cr, Tr),
            Pt(Jt, nr, kr, 0)
        }
        function gt(Jt, nr, sr, jt, cr) {
            var Tr;
            if (sr < 32)
                return -1;
            for (wr(Jt, 0, nr, 0, sr, jt, cr),
            Mt(Jt, 16, Jt, 32, sr - 32, Jt),
            Tr = 0; Tr < 16; Tr++)
                Jt[Tr] = 0;
            return 0
        }
        function vt(Jt, nr, sr, jt, cr) {
            var Tr, kr = new Uint8Array(32);
            if (sr < 32 || (tr(kr, 0, 32, jt, cr),
            _t(nr, 16, nr, 32, sr - 32, kr) !== 0))
                return -1;
            for (wr(Jt, 0, nr, 0, sr, jt, cr),
            Tr = 0; Tr < 32; Tr++)
                Jt[Tr] = 0;
            return 0
        }
        function Et(Jt, nr) {
            var sr;
            for (sr = 0; sr < 16; sr++)
                Jt[sr] = nr[sr] | 0
        }
        function Bt(Jt) {
            var nr, sr, jt = 1;
            for (nr = 0; nr < 16; nr++)
                sr = Jt[nr] + jt + 65535,
                jt = Math.floor(sr / 65536),
                Jt[nr] = sr - jt * 65536;
            Jt[0] += jt - 1 + 37 * (jt - 1)
        }
        function Rt(Jt, nr, sr) {
            for (var jt, cr = ~(sr - 1), Tr = 0; Tr < 16; Tr++)
                jt = cr & (Jt[Tr] ^ nr[Tr]),
                Jt[Tr] ^= jt,
                nr[Tr] ^= jt
        }
        function kt(Jt, nr) {
            var sr, jt, cr, Tr = f(), kr = f();
            for (sr = 0; sr < 16; sr++)
                kr[sr] = nr[sr];
            for (Bt(kr),
            Bt(kr),
            Bt(kr),
            jt = 0; jt < 2; jt++) {
                for (Tr[0] = kr[0] - 65517,
                sr = 1; sr < 15; sr++)
                    Tr[sr] = kr[sr] - 65535 - (Tr[sr - 1] >> 16 & 1),
                    Tr[sr - 1] &= 65535;
                Tr[15] = kr[15] - 32767 - (Tr[14] >> 16 & 1),
                cr = Tr[15] >> 16 & 1,
                Tr[14] &= 65535,
                Rt(kr, Tr, 1 - cr)
            }
            for (sr = 0; sr < 16; sr++)
                Jt[2 * sr] = kr[sr] & 255,
                Jt[2 * sr + 1] = kr[sr] >> 8
        }
        function Tt(Jt, nr) {
            var sr = new Uint8Array(32)
              , jt = new Uint8Array(32);
            return kt(sr, Jt),
            kt(jt, nr),
            $t(sr, 0, jt, 0)
        }
        function It(Jt) {
            var nr = new Uint8Array(32);
            return kt(nr, Jt),
            nr[0] & 1
        }
        function St(Jt, nr) {
            var sr;
            for (sr = 0; sr < 16; sr++)
                Jt[sr] = nr[2 * sr] + (nr[2 * sr + 1] << 8);
            Jt[15] &= 32767
        }
        function qt(Jt, nr, sr) {
            for (var jt = 0; jt < 16; jt++)
                Jt[jt] = nr[jt] + sr[jt]
        }
        function ur(Jt, nr, sr) {
            for (var jt = 0; jt < 16; jt++)
                Jt[jt] = nr[jt] - sr[jt]
        }
        function gr(Jt, nr, sr) {
            var jt, cr, Tr = 0, kr = 0, Pr = 0, zr = 0, Vr = 0, jr = 0, Mn = 0, nn = 0, gn = 0, mn = 0, xn = 0, _n = 0, yn = 0, wn = 0, vn = 0, sn = 0, hn = 0, rn = 0, ln = 0, yr = 0, Lt = 0, Gt = 0, Qt = 0, pr = 0, dr = 0, Mr = 0, Br = 0, Fr = 0, Kr = 0, Xr = 0, Cn = 0, Er = sr[0], kn = sr[1], $n = sr[2], qn = sr[3], Tn = sr[4], In = sr[5], Pn = sr[6], jn = sr[7], On = sr[8], Ln = sr[9], Dn = sr[10], Nn = sr[11], zn = sr[12], Fn = sr[13], Wn = sr[14], Vn = sr[15];
            jt = nr[0],
            Tr += jt * Er,
            kr += jt * kn,
            Pr += jt * $n,
            zr += jt * qn,
            Vr += jt * Tn,
            jr += jt * In,
            Mn += jt * Pn,
            nn += jt * jn,
            gn += jt * On,
            mn += jt * Ln,
            xn += jt * Dn,
            _n += jt * Nn,
            yn += jt * zn,
            wn += jt * Fn,
            vn += jt * Wn,
            sn += jt * Vn,
            jt = nr[1],
            kr += jt * Er,
            Pr += jt * kn,
            zr += jt * $n,
            Vr += jt * qn,
            jr += jt * Tn,
            Mn += jt * In,
            nn += jt * Pn,
            gn += jt * jn,
            mn += jt * On,
            xn += jt * Ln,
            _n += jt * Dn,
            yn += jt * Nn,
            wn += jt * zn,
            vn += jt * Fn,
            sn += jt * Wn,
            hn += jt * Vn,
            jt = nr[2],
            Pr += jt * Er,
            zr += jt * kn,
            Vr += jt * $n,
            jr += jt * qn,
            Mn += jt * Tn,
            nn += jt * In,
            gn += jt * Pn,
            mn += jt * jn,
            xn += jt * On,
            _n += jt * Ln,
            yn += jt * Dn,
            wn += jt * Nn,
            vn += jt * zn,
            sn += jt * Fn,
            hn += jt * Wn,
            rn += jt * Vn,
            jt = nr[3],
            zr += jt * Er,
            Vr += jt * kn,
            jr += jt * $n,
            Mn += jt * qn,
            nn += jt * Tn,
            gn += jt * In,
            mn += jt * Pn,
            xn += jt * jn,
            _n += jt * On,
            yn += jt * Ln,
            wn += jt * Dn,
            vn += jt * Nn,
            sn += jt * zn,
            hn += jt * Fn,
            rn += jt * Wn,
            ln += jt * Vn,
            jt = nr[4],
            Vr += jt * Er,
            jr += jt * kn,
            Mn += jt * $n,
            nn += jt * qn,
            gn += jt * Tn,
            mn += jt * In,
            xn += jt * Pn,
            _n += jt * jn,
            yn += jt * On,
            wn += jt * Ln,
            vn += jt * Dn,
            sn += jt * Nn,
            hn += jt * zn,
            rn += jt * Fn,
            ln += jt * Wn,
            yr += jt * Vn,
            jt = nr[5],
            jr += jt * Er,
            Mn += jt * kn,
            nn += jt * $n,
            gn += jt * qn,
            mn += jt * Tn,
            xn += jt * In,
            _n += jt * Pn,
            yn += jt * jn,
            wn += jt * On,
            vn += jt * Ln,
            sn += jt * Dn,
            hn += jt * Nn,
            rn += jt * zn,
            ln += jt * Fn,
            yr += jt * Wn,
            Lt += jt * Vn,
            jt = nr[6],
            Mn += jt * Er,
            nn += jt * kn,
            gn += jt * $n,
            mn += jt * qn,
            xn += jt * Tn,
            _n += jt * In,
            yn += jt * Pn,
            wn += jt * jn,
            vn += jt * On,
            sn += jt * Ln,
            hn += jt * Dn,
            rn += jt * Nn,
            ln += jt * zn,
            yr += jt * Fn,
            Lt += jt * Wn,
            Gt += jt * Vn,
            jt = nr[7],
            nn += jt * Er,
            gn += jt * kn,
            mn += jt * $n,
            xn += jt * qn,
            _n += jt * Tn,
            yn += jt * In,
            wn += jt * Pn,
            vn += jt * jn,
            sn += jt * On,
            hn += jt * Ln,
            rn += jt * Dn,
            ln += jt * Nn,
            yr += jt * zn,
            Lt += jt * Fn,
            Gt += jt * Wn,
            Qt += jt * Vn,
            jt = nr[8],
            gn += jt * Er,
            mn += jt * kn,
            xn += jt * $n,
            _n += jt * qn,
            yn += jt * Tn,
            wn += jt * In,
            vn += jt * Pn,
            sn += jt * jn,
            hn += jt * On,
            rn += jt * Ln,
            ln += jt * Dn,
            yr += jt * Nn,
            Lt += jt * zn,
            Gt += jt * Fn,
            Qt += jt * Wn,
            pr += jt * Vn,
            jt = nr[9],
            mn += jt * Er,
            xn += jt * kn,
            _n += jt * $n,
            yn += jt * qn,
            wn += jt * Tn,
            vn += jt * In,
            sn += jt * Pn,
            hn += jt * jn,
            rn += jt * On,
            ln += jt * Ln,
            yr += jt * Dn,
            Lt += jt * Nn,
            Gt += jt * zn,
            Qt += jt * Fn,
            pr += jt * Wn,
            dr += jt * Vn,
            jt = nr[10],
            xn += jt * Er,
            _n += jt * kn,
            yn += jt * $n,
            wn += jt * qn,
            vn += jt * Tn,
            sn += jt * In,
            hn += jt * Pn,
            rn += jt * jn,
            ln += jt * On,
            yr += jt * Ln,
            Lt += jt * Dn,
            Gt += jt * Nn,
            Qt += jt * zn,
            pr += jt * Fn,
            dr += jt * Wn,
            Mr += jt * Vn,
            jt = nr[11],
            _n += jt * Er,
            yn += jt * kn,
            wn += jt * $n,
            vn += jt * qn,
            sn += jt * Tn,
            hn += jt * In,
            rn += jt * Pn,
            ln += jt * jn,
            yr += jt * On,
            Lt += jt * Ln,
            Gt += jt * Dn,
            Qt += jt * Nn,
            pr += jt * zn,
            dr += jt * Fn,
            Mr += jt * Wn,
            Br += jt * Vn,
            jt = nr[12],
            yn += jt * Er,
            wn += jt * kn,
            vn += jt * $n,
            sn += jt * qn,
            hn += jt * Tn,
            rn += jt * In,
            ln += jt * Pn,
            yr += jt * jn,
            Lt += jt * On,
            Gt += jt * Ln,
            Qt += jt * Dn,
            pr += jt * Nn,
            dr += jt * zn,
            Mr += jt * Fn,
            Br += jt * Wn,
            Fr += jt * Vn,
            jt = nr[13],
            wn += jt * Er,
            vn += jt * kn,
            sn += jt * $n,
            hn += jt * qn,
            rn += jt * Tn,
            ln += jt * In,
            yr += jt * Pn,
            Lt += jt * jn,
            Gt += jt * On,
            Qt += jt * Ln,
            pr += jt * Dn,
            dr += jt * Nn,
            Mr += jt * zn,
            Br += jt * Fn,
            Fr += jt * Wn,
            Kr += jt * Vn,
            jt = nr[14],
            vn += jt * Er,
            sn += jt * kn,
            hn += jt * $n,
            rn += jt * qn,
            ln += jt * Tn,
            yr += jt * In,
            Lt += jt * Pn,
            Gt += jt * jn,
            Qt += jt * On,
            pr += jt * Ln,
            dr += jt * Dn,
            Mr += jt * Nn,
            Br += jt * zn,
            Fr += jt * Fn,
            Kr += jt * Wn,
            Xr += jt * Vn,
            jt = nr[15],
            sn += jt * Er,
            hn += jt * kn,
            rn += jt * $n,
            ln += jt * qn,
            yr += jt * Tn,
            Lt += jt * In,
            Gt += jt * Pn,
            Qt += jt * jn,
            pr += jt * On,
            dr += jt * Ln,
            Mr += jt * Dn,
            Br += jt * Nn,
            Fr += jt * zn,
            Kr += jt * Fn,
            Xr += jt * Wn,
            Cn += jt * Vn,
            Tr += 38 * hn,
            kr += 38 * rn,
            Pr += 38 * ln,
            zr += 38 * yr,
            Vr += 38 * Lt,
            jr += 38 * Gt,
            Mn += 38 * Qt,
            nn += 38 * pr,
            gn += 38 * dr,
            mn += 38 * Mr,
            xn += 38 * Br,
            _n += 38 * Fr,
            yn += 38 * Kr,
            wn += 38 * Xr,
            vn += 38 * Cn,
            cr = 1,
            jt = Tr + cr + 65535,
            cr = Math.floor(jt / 65536),
            Tr = jt - cr * 65536,
            jt = kr + cr + 65535,
            cr = Math.floor(jt / 65536),
            kr = jt - cr * 65536,
            jt = Pr + cr + 65535,
            cr = Math.floor(jt / 65536),
            Pr = jt - cr * 65536,
            jt = zr + cr + 65535,
            cr = Math.floor(jt / 65536),
            zr = jt - cr * 65536,
            jt = Vr + cr + 65535,
            cr = Math.floor(jt / 65536),
            Vr = jt - cr * 65536,
            jt = jr + cr + 65535,
            cr = Math.floor(jt / 65536),
            jr = jt - cr * 65536,
            jt = Mn + cr + 65535,
            cr = Math.floor(jt / 65536),
            Mn = jt - cr * 65536,
            jt = nn + cr + 65535,
            cr = Math.floor(jt / 65536),
            nn = jt - cr * 65536,
            jt = gn + cr + 65535,
            cr = Math.floor(jt / 65536),
            gn = jt - cr * 65536,
            jt = mn + cr + 65535,
            cr = Math.floor(jt / 65536),
            mn = jt - cr * 65536,
            jt = xn + cr + 65535,
            cr = Math.floor(jt / 65536),
            xn = jt - cr * 65536,
            jt = _n + cr + 65535,
            cr = Math.floor(jt / 65536),
            _n = jt - cr * 65536,
            jt = yn + cr + 65535,
            cr = Math.floor(jt / 65536),
            yn = jt - cr * 65536,
            jt = wn + cr + 65535,
            cr = Math.floor(jt / 65536),
            wn = jt - cr * 65536,
            jt = vn + cr + 65535,
            cr = Math.floor(jt / 65536),
            vn = jt - cr * 65536,
            jt = sn + cr + 65535,
            cr = Math.floor(jt / 65536),
            sn = jt - cr * 65536,
            Tr += cr - 1 + 37 * (cr - 1),
            cr = 1,
            jt = Tr + cr + 65535,
            cr = Math.floor(jt / 65536),
            Tr = jt - cr * 65536,
            jt = kr + cr + 65535,
            cr = Math.floor(jt / 65536),
            kr = jt - cr * 65536,
            jt = Pr + cr + 65535,
            cr = Math.floor(jt / 65536),
            Pr = jt - cr * 65536,
            jt = zr + cr + 65535,
            cr = Math.floor(jt / 65536),
            zr = jt - cr * 65536,
            jt = Vr + cr + 65535,
            cr = Math.floor(jt / 65536),
            Vr = jt - cr * 65536,
            jt = jr + cr + 65535,
            cr = Math.floor(jt / 65536),
            jr = jt - cr * 65536,
            jt = Mn + cr + 65535,
            cr = Math.floor(jt / 65536),
            Mn = jt - cr * 65536,
            jt = nn + cr + 65535,
            cr = Math.floor(jt / 65536),
            nn = jt - cr * 65536,
            jt = gn + cr + 65535,
            cr = Math.floor(jt / 65536),
            gn = jt - cr * 65536,
            jt = mn + cr + 65535,
            cr = Math.floor(jt / 65536),
            mn = jt - cr * 65536,
            jt = xn + cr + 65535,
            cr = Math.floor(jt / 65536),
            xn = jt - cr * 65536,
            jt = _n + cr + 65535,
            cr = Math.floor(jt / 65536),
            _n = jt - cr * 65536,
            jt = yn + cr + 65535,
            cr = Math.floor(jt / 65536),
            yn = jt - cr * 65536,
            jt = wn + cr + 65535,
            cr = Math.floor(jt / 65536),
            wn = jt - cr * 65536,
            jt = vn + cr + 65535,
            cr = Math.floor(jt / 65536),
            vn = jt - cr * 65536,
            jt = sn + cr + 65535,
            cr = Math.floor(jt / 65536),
            sn = jt - cr * 65536,
            Tr += cr - 1 + 37 * (cr - 1),
            Jt[0] = Tr,
            Jt[1] = kr,
            Jt[2] = Pr,
            Jt[3] = zr,
            Jt[4] = Vr,
            Jt[5] = jr,
            Jt[6] = Mn,
            Jt[7] = nn,
            Jt[8] = gn,
            Jt[9] = mn,
            Jt[10] = xn,
            Jt[11] = _n,
            Jt[12] = yn,
            Jt[13] = wn,
            Jt[14] = vn,
            Jt[15] = sn
        }
        function lr(Jt, nr) {
            gr(Jt, nr, nr)
        }
        function Zt(Jt, nr) {
            var sr = f(), jt;
            for (jt = 0; jt < 16; jt++)
                sr[jt] = nr[jt];
            for (jt = 253; jt >= 0; jt--)
                lr(sr, sr),
                jt !== 2 && jt !== 4 && gr(sr, sr, nr);
            for (jt = 0; jt < 16; jt++)
                Jt[jt] = sr[jt]
        }
        function Vt(Jt, nr) {
            var sr = f(), jt;
            for (jt = 0; jt < 16; jt++)
                sr[jt] = nr[jt];
            for (jt = 250; jt >= 0; jt--)
                lr(sr, sr),
                jt !== 1 && gr(sr, sr, nr);
            for (jt = 0; jt < 16; jt++)
                Jt[jt] = sr[jt]
        }
        function rr(Jt, nr, sr) {
            var jt = new Uint8Array(32), cr = new Float64Array(80), Tr, kr, Pr = f(), zr = f(), Vr = f(), jr = f(), Mn = f(), nn = f();
            for (kr = 0; kr < 31; kr++)
                jt[kr] = nr[kr];
            for (jt[31] = nr[31] & 127 | 64,
            jt[0] &= 248,
            St(cr, sr),
            kr = 0; kr < 16; kr++)
                zr[kr] = cr[kr],
                jr[kr] = Pr[kr] = Vr[kr] = 0;
            for (Pr[0] = jr[0] = 1,
            kr = 254; kr >= 0; --kr)
                Tr = jt[kr >>> 3] >>> (kr & 7) & 1,
                Rt(Pr, zr, Tr),
                Rt(Vr, jr, Tr),
                qt(Mn, Pr, Vr),
                ur(Pr, Pr, Vr),
                qt(Vr, zr, jr),
                ur(zr, zr, jr),
                lr(jr, Mn),
                lr(nn, Pr),
                gr(Pr, Vr, Pr),
                gr(Vr, zr, Mn),
                qt(Mn, Pr, Vr),
                ur(Pr, Pr, Vr),
                lr(zr, Pr),
                ur(Vr, jr, nn),
                gr(Pr, Vr, mt),
                qt(Pr, Pr, jr),
                gr(Vr, Vr, Pr),
                gr(Pr, jr, nn),
                gr(jr, zr, cr),
                lr(zr, Mn),
                Rt(Pr, zr, Tr),
                Rt(Vr, jr, Tr);
            for (kr = 0; kr < 16; kr++)
                cr[kr + 16] = Pr[kr],
                cr[kr + 32] = Vr[kr],
                cr[kr + 48] = zr[kr],
                cr[kr + 64] = jr[kr];
            var gn = cr.subarray(32)
              , mn = cr.subarray(16);
            return Zt(gn, gn),
            gr(mn, mn, gn),
            kt(Jt, mn),
            0
        }
        function fr(Jt, nr) {
            return rr(Jt, nr, y)
        }
        function Yt(Jt, nr) {
            return m(nr, 32),
            fr(Jt, nr)
        }
        function Xt(Jt, nr, sr) {
            var jt = new Uint8Array(32);
            return rr(jt, sr, nr),
            Wt(Jt, k, jt, Kt)
        }
        var Sr = gt
          , Rr = vt;
        function qr(Jt, nr, sr, jt, cr, Tr) {
            var kr = new Uint8Array(32);
            return Xt(kr, cr, Tr),
            Sr(Jt, nr, sr, jt, kr)
        }
        function Nr(Jt, nr, sr, jt, cr, Tr) {
            var kr = new Uint8Array(32);
            return Xt(kr, cr, Tr),
            Rr(Jt, nr, sr, jt, kr)
        }
        var Dr = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
        function Or(Jt, nr, sr, jt) {
            for (var cr = new Int32Array(16), Tr = new Int32Array(16), kr, Pr, zr, Vr, jr, Mn, nn, gn, mn, xn, _n, yn, wn, vn, sn, hn, rn, ln, yr, Lt, Gt, Qt, pr, dr, Mr, Br, Fr = Jt[0], Kr = Jt[1], Xr = Jt[2], Cn = Jt[3], Er = Jt[4], kn = Jt[5], $n = Jt[6], qn = Jt[7], Tn = nr[0], In = nr[1], Pn = nr[2], jn = nr[3], On = nr[4], Ln = nr[5], Dn = nr[6], Nn = nr[7], zn = 0; jt >= 128; ) {
                for (yr = 0; yr < 16; yr++)
                    Lt = 8 * yr + zn,
                    cr[yr] = sr[Lt + 0] << 24 | sr[Lt + 1] << 16 | sr[Lt + 2] << 8 | sr[Lt + 3],
                    Tr[yr] = sr[Lt + 4] << 24 | sr[Lt + 5] << 16 | sr[Lt + 6] << 8 | sr[Lt + 7];
                for (yr = 0; yr < 80; yr++)
                    if (kr = Fr,
                    Pr = Kr,
                    zr = Xr,
                    Vr = Cn,
                    jr = Er,
                    Mn = kn,
                    nn = $n,
                    gn = qn,
                    mn = Tn,
                    xn = In,
                    _n = Pn,
                    yn = jn,
                    wn = On,
                    vn = Ln,
                    sn = Dn,
                    hn = Nn,
                    Gt = qn,
                    Qt = Nn,
                    pr = Qt & 65535,
                    dr = Qt >>> 16,
                    Mr = Gt & 65535,
                    Br = Gt >>> 16,
                    Gt = (Er >>> 14 | On << 18) ^ (Er >>> 18 | On << 14) ^ (On >>> 9 | Er << 23),
                    Qt = (On >>> 14 | Er << 18) ^ (On >>> 18 | Er << 14) ^ (Er >>> 9 | On << 23),
                    pr += Qt & 65535,
                    dr += Qt >>> 16,
                    Mr += Gt & 65535,
                    Br += Gt >>> 16,
                    Gt = Er & kn ^ ~Er & $n,
                    Qt = On & Ln ^ ~On & Dn,
                    pr += Qt & 65535,
                    dr += Qt >>> 16,
                    Mr += Gt & 65535,
                    Br += Gt >>> 16,
                    Gt = Dr[yr * 2],
                    Qt = Dr[yr * 2 + 1],
                    pr += Qt & 65535,
                    dr += Qt >>> 16,
                    Mr += Gt & 65535,
                    Br += Gt >>> 16,
                    Gt = cr[yr % 16],
                    Qt = Tr[yr % 16],
                    pr += Qt & 65535,
                    dr += Qt >>> 16,
                    Mr += Gt & 65535,
                    Br += Gt >>> 16,
                    dr += pr >>> 16,
                    Mr += dr >>> 16,
                    Br += Mr >>> 16,
                    rn = Mr & 65535 | Br << 16,
                    ln = pr & 65535 | dr << 16,
                    Gt = rn,
                    Qt = ln,
                    pr = Qt & 65535,
                    dr = Qt >>> 16,
                    Mr = Gt & 65535,
                    Br = Gt >>> 16,
                    Gt = (Fr >>> 28 | Tn << 4) ^ (Tn >>> 2 | Fr << 30) ^ (Tn >>> 7 | Fr << 25),
                    Qt = (Tn >>> 28 | Fr << 4) ^ (Fr >>> 2 | Tn << 30) ^ (Fr >>> 7 | Tn << 25),
                    pr += Qt & 65535,
                    dr += Qt >>> 16,
                    Mr += Gt & 65535,
                    Br += Gt >>> 16,
                    Gt = Fr & Kr ^ Fr & Xr ^ Kr & Xr,
                    Qt = Tn & In ^ Tn & Pn ^ In & Pn,
                    pr += Qt & 65535,
                    dr += Qt >>> 16,
                    Mr += Gt & 65535,
                    Br += Gt >>> 16,
                    dr += pr >>> 16,
                    Mr += dr >>> 16,
                    Br += Mr >>> 16,
                    gn = Mr & 65535 | Br << 16,
                    hn = pr & 65535 | dr << 16,
                    Gt = Vr,
                    Qt = yn,
                    pr = Qt & 65535,
                    dr = Qt >>> 16,
                    Mr = Gt & 65535,
                    Br = Gt >>> 16,
                    Gt = rn,
                    Qt = ln,
                    pr += Qt & 65535,
                    dr += Qt >>> 16,
                    Mr += Gt & 65535,
                    Br += Gt >>> 16,
                    dr += pr >>> 16,
                    Mr += dr >>> 16,
                    Br += Mr >>> 16,
                    Vr = Mr & 65535 | Br << 16,
                    yn = pr & 65535 | dr << 16,
                    Kr = kr,
                    Xr = Pr,
                    Cn = zr,
                    Er = Vr,
                    kn = jr,
                    $n = Mn,
                    qn = nn,
                    Fr = gn,
                    In = mn,
                    Pn = xn,
                    jn = _n,
                    On = yn,
                    Ln = wn,
                    Dn = vn,
                    Nn = sn,
                    Tn = hn,
                    yr % 16 === 15)
                        for (Lt = 0; Lt < 16; Lt++)
                            Gt = cr[Lt],
                            Qt = Tr[Lt],
                            pr = Qt & 65535,
                            dr = Qt >>> 16,
                            Mr = Gt & 65535,
                            Br = Gt >>> 16,
                            Gt = cr[(Lt + 9) % 16],
                            Qt = Tr[(Lt + 9) % 16],
                            pr += Qt & 65535,
                            dr += Qt >>> 16,
                            Mr += Gt & 65535,
                            Br += Gt >>> 16,
                            rn = cr[(Lt + 1) % 16],
                            ln = Tr[(Lt + 1) % 16],
                            Gt = (rn >>> 1 | ln << 31) ^ (rn >>> 8 | ln << 24) ^ rn >>> 7,
                            Qt = (ln >>> 1 | rn << 31) ^ (ln >>> 8 | rn << 24) ^ (ln >>> 7 | rn << 25),
                            pr += Qt & 65535,
                            dr += Qt >>> 16,
                            Mr += Gt & 65535,
                            Br += Gt >>> 16,
                            rn = cr[(Lt + 14) % 16],
                            ln = Tr[(Lt + 14) % 16],
                            Gt = (rn >>> 19 | ln << 13) ^ (ln >>> 29 | rn << 3) ^ rn >>> 6,
                            Qt = (ln >>> 19 | rn << 13) ^ (rn >>> 29 | ln << 3) ^ (ln >>> 6 | rn << 26),
                            pr += Qt & 65535,
                            dr += Qt >>> 16,
                            Mr += Gt & 65535,
                            Br += Gt >>> 16,
                            dr += pr >>> 16,
                            Mr += dr >>> 16,
                            Br += Mr >>> 16,
                            cr[Lt] = Mr & 65535 | Br << 16,
                            Tr[Lt] = pr & 65535 | dr << 16;
                Gt = Fr,
                Qt = Tn,
                pr = Qt & 65535,
                dr = Qt >>> 16,
                Mr = Gt & 65535,
                Br = Gt >>> 16,
                Gt = Jt[0],
                Qt = nr[0],
                pr += Qt & 65535,
                dr += Qt >>> 16,
                Mr += Gt & 65535,
                Br += Gt >>> 16,
                dr += pr >>> 16,
                Mr += dr >>> 16,
                Br += Mr >>> 16,
                Jt[0] = Fr = Mr & 65535 | Br << 16,
                nr[0] = Tn = pr & 65535 | dr << 16,
                Gt = Kr,
                Qt = In,
                pr = Qt & 65535,
                dr = Qt >>> 16,
                Mr = Gt & 65535,
                Br = Gt >>> 16,
                Gt = Jt[1],
                Qt = nr[1],
                pr += Qt & 65535,
                dr += Qt >>> 16,
                Mr += Gt & 65535,
                Br += Gt >>> 16,
                dr += pr >>> 16,
                Mr += dr >>> 16,
                Br += Mr >>> 16,
                Jt[1] = Kr = Mr & 65535 | Br << 16,
                nr[1] = In = pr & 65535 | dr << 16,
                Gt = Xr,
                Qt = Pn,
                pr = Qt & 65535,
                dr = Qt >>> 16,
                Mr = Gt & 65535,
                Br = Gt >>> 16,
                Gt = Jt[2],
                Qt = nr[2],
                pr += Qt & 65535,
                dr += Qt >>> 16,
                Mr += Gt & 65535,
                Br += Gt >>> 16,
                dr += pr >>> 16,
                Mr += dr >>> 16,
                Br += Mr >>> 16,
                Jt[2] = Xr = Mr & 65535 | Br << 16,
                nr[2] = Pn = pr & 65535 | dr << 16,
                Gt = Cn,
                Qt = jn,
                pr = Qt & 65535,
                dr = Qt >>> 16,
                Mr = Gt & 65535,
                Br = Gt >>> 16,
                Gt = Jt[3],
                Qt = nr[3],
                pr += Qt & 65535,
                dr += Qt >>> 16,
                Mr += Gt & 65535,
                Br += Gt >>> 16,
                dr += pr >>> 16,
                Mr += dr >>> 16,
                Br += Mr >>> 16,
                Jt[3] = Cn = Mr & 65535 | Br << 16,
                nr[3] = jn = pr & 65535 | dr << 16,
                Gt = Er,
                Qt = On,
                pr = Qt & 65535,
                dr = Qt >>> 16,
                Mr = Gt & 65535,
                Br = Gt >>> 16,
                Gt = Jt[4],
                Qt = nr[4],
                pr += Qt & 65535,
                dr += Qt >>> 16,
                Mr += Gt & 65535,
                Br += Gt >>> 16,
                dr += pr >>> 16,
                Mr += dr >>> 16,
                Br += Mr >>> 16,
                Jt[4] = Er = Mr & 65535 | Br << 16,
                nr[4] = On = pr & 65535 | dr << 16,
                Gt = kn,
                Qt = Ln,
                pr = Qt & 65535,
                dr = Qt >>> 16,
                Mr = Gt & 65535,
                Br = Gt >>> 16,
                Gt = Jt[5],
                Qt = nr[5],
                pr += Qt & 65535,
                dr += Qt >>> 16,
                Mr += Gt & 65535,
                Br += Gt >>> 16,
                dr += pr >>> 16,
                Mr += dr >>> 16,
                Br += Mr >>> 16,
                Jt[5] = kn = Mr & 65535 | Br << 16,
                nr[5] = Ln = pr & 65535 | dr << 16,
                Gt = $n,
                Qt = Dn,
                pr = Qt & 65535,
                dr = Qt >>> 16,
                Mr = Gt & 65535,
                Br = Gt >>> 16,
                Gt = Jt[6],
                Qt = nr[6],
                pr += Qt & 65535,
                dr += Qt >>> 16,
                Mr += Gt & 65535,
                Br += Gt >>> 16,
                dr += pr >>> 16,
                Mr += dr >>> 16,
                Br += Mr >>> 16,
                Jt[6] = $n = Mr & 65535 | Br << 16,
                nr[6] = Dn = pr & 65535 | dr << 16,
                Gt = qn,
                Qt = Nn,
                pr = Qt & 65535,
                dr = Qt >>> 16,
                Mr = Gt & 65535,
                Br = Gt >>> 16,
                Gt = Jt[7],
                Qt = nr[7],
                pr += Qt & 65535,
                dr += Qt >>> 16,
                Mr += Gt & 65535,
                Br += Gt >>> 16,
                dr += pr >>> 16,
                Mr += dr >>> 16,
                Br += Mr >>> 16,
                Jt[7] = qn = Mr & 65535 | Br << 16,
                nr[7] = Nn = pr & 65535 | dr << 16,
                zn += 128,
                jt -= 128
            }
            return jt
        }
        function $r(Jt, nr, sr) {
            var jt = new Int32Array(8), cr = new Int32Array(8), Tr = new Uint8Array(256), kr, Pr = sr;
            for (jt[0] = 1779033703,
            jt[1] = 3144134277,
            jt[2] = 1013904242,
            jt[3] = 2773480762,
            jt[4] = 1359893119,
            jt[5] = 2600822924,
            jt[6] = 528734635,
            jt[7] = 1541459225,
            cr[0] = 4089235720,
            cr[1] = 2227873595,
            cr[2] = 4271175723,
            cr[3] = 1595750129,
            cr[4] = 2917565137,
            cr[5] = 725511199,
            cr[6] = 4215389547,
            cr[7] = 327033209,
            Or(jt, cr, nr, sr),
            sr %= 128,
            kr = 0; kr < sr; kr++)
                Tr[kr] = nr[Pr - sr + kr];
            for (Tr[sr] = 128,
            sr = 256 - 128 * (sr < 112 ? 1 : 0),
            Tr[sr - 9] = 0,
            At(Tr, sr - 8, Pr / 536870912 | 0, Pr << 3),
            Or(jt, cr, Tr, sr),
            kr = 0; kr < 8; kr++)
                At(Jt, 8 * kr, jt[kr], cr[kr]);
            return 0
        }
        function Zr(Jt, nr) {
            var sr = f()
              , jt = f()
              , cr = f()
              , Tr = f()
              , kr = f()
              , Pr = f()
              , zr = f()
              , Vr = f()
              , jr = f();
            ur(sr, Jt[1], Jt[0]),
            ur(jr, nr[1], nr[0]),
            gr(sr, sr, jr),
            qt(jt, Jt[0], Jt[1]),
            qt(jr, nr[0], nr[1]),
            gr(jt, jt, jr),
            gr(cr, Jt[3], nr[3]),
            gr(cr, cr, pt),
            gr(Tr, Jt[2], nr[2]),
            qt(Tr, Tr, Tr),
            ur(kr, jt, sr),
            ur(Pr, Tr, cr),
            qt(zr, Tr, cr),
            qt(Vr, jt, sr),
            gr(Jt[0], kr, Pr),
            gr(Jt[1], Vr, zr),
            gr(Jt[2], zr, Pr),
            gr(Jt[3], kr, Vr)
        }
        function Hr(Jt, nr, sr) {
            var jt;
            for (jt = 0; jt < 4; jt++)
                Rt(Jt[jt], nr[jt], sr)
        }
        function un(Jt, nr) {
            var sr = f()
              , jt = f()
              , cr = f();
            Zt(cr, nr[2]),
            gr(sr, nr[0], cr),
            gr(jt, nr[1], cr),
            kt(Jt, jt),
            Jt[31] ^= It(sr) << 7
        }
        function Qr(Jt, nr, sr) {
            var jt, cr;
            for (Et(Jt[0], ee),
            Et(Jt[1], dt),
            Et(Jt[2], dt),
            Et(Jt[3], ee),
            cr = 255; cr >= 0; --cr)
                jt = sr[cr / 8 | 0] >> (cr & 7) & 1,
                Hr(Jt, nr, jt),
                Zr(nr, Jt),
                Zr(Jt, Jt),
                Hr(Jt, nr, jt)
        }
        function Gr(Jt, nr) {
            var sr = [f(), f(), f(), f()];
            Et(sr[0], bt),
            Et(sr[1], wt),
            Et(sr[2], dt),
            gr(sr[3], bt, wt),
            Qr(Jt, sr, nr)
        }
        function vr(Jt, nr, sr) {
            var jt = new Uint8Array(64), cr = [f(), f(), f(), f()], Tr;
            for (sr || m(nr, 32),
            $r(jt, nr, 32),
            jt[0] &= 248,
            jt[31] &= 127,
            jt[31] |= 64,
            Gr(cr, jt),
            un(Jt, cr),
            Tr = 0; Tr < 32; Tr++)
                nr[Tr + 32] = Jt[Tr];
            return 0
        }
        var ar = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
        function hr(Jt, nr) {
            var sr, jt, cr, Tr;
            for (jt = 63; jt >= 32; --jt) {
                for (sr = 0,
                cr = jt - 32,
                Tr = jt - 12; cr < Tr; ++cr)
                    nr[cr] += sr - 16 * nr[jt] * ar[cr - (jt - 32)],
                    sr = Math.floor((nr[cr] + 128) / 256),
                    nr[cr] -= sr * 256;
                nr[cr] += sr,
                nr[jt] = 0
            }
            for (sr = 0,
            cr = 0; cr < 32; cr++)
                nr[cr] += sr - (nr[31] >> 4) * ar[cr],
                sr = nr[cr] >> 8,
                nr[cr] &= 255;
            for (cr = 0; cr < 32; cr++)
                nr[cr] -= sr * ar[cr];
            for (jt = 0; jt < 32; jt++)
                nr[jt + 1] += nr[jt] >> 8,
                Jt[jt] = nr[jt] & 255
        }
        function _r(Jt) {
            var nr = new Float64Array(64), sr;
            for (sr = 0; sr < 64; sr++)
                nr[sr] = Jt[sr];
            for (sr = 0; sr < 64; sr++)
                Jt[sr] = 0;
            hr(Jt, nr)
        }
        function Ar(Jt, nr, sr, jt) {
            var cr = new Uint8Array(64), Tr = new Uint8Array(64), kr = new Uint8Array(64), Pr, zr, Vr = new Float64Array(64), jr = [f(), f(), f(), f()];
            $r(cr, jt, 32),
            cr[0] &= 248,
            cr[31] &= 127,
            cr[31] |= 64;
            var Mn = sr + 64;
            for (Pr = 0; Pr < sr; Pr++)
                Jt[64 + Pr] = nr[Pr];
            for (Pr = 0; Pr < 32; Pr++)
                Jt[32 + Pr] = cr[32 + Pr];
            for ($r(kr, Jt.subarray(32), sr + 32),
            _r(kr),
            Gr(jr, kr),
            un(Jt, jr),
            Pr = 32; Pr < 64; Pr++)
                Jt[Pr] = jt[Pr];
            for ($r(Tr, Jt, sr + 64),
            _r(Tr),
            Pr = 0; Pr < 64; Pr++)
                Vr[Pr] = 0;
            for (Pr = 0; Pr < 32; Pr++)
                Vr[Pr] = kr[Pr];
            for (Pr = 0; Pr < 32; Pr++)
                for (zr = 0; zr < 32; zr++)
                    Vr[Pr + zr] += Tr[Pr] * cr[zr];
            return hr(Jt.subarray(32), Vr),
            Mn
        }
        function Ft(Jt, nr) {
            var sr = f()
              , jt = f()
              , cr = f()
              , Tr = f()
              , kr = f()
              , Pr = f()
              , zr = f();
            return Et(Jt[2], dt),
            St(Jt[1], nr),
            lr(cr, Jt[1]),
            gr(Tr, cr, yt),
            ur(cr, cr, Jt[2]),
            qt(Tr, Jt[2], Tr),
            lr(kr, Tr),
            lr(Pr, kr),
            gr(zr, Pr, kr),
            gr(sr, zr, cr),
            gr(sr, sr, Tr),
            Vt(sr, sr),
            gr(sr, sr, cr),
            gr(sr, sr, Tr),
            gr(sr, sr, Tr),
            gr(Jt[0], sr, Tr),
            lr(jt, Jt[0]),
            gr(jt, jt, Tr),
            Tt(jt, cr) && gr(Jt[0], Jt[0], xt),
            lr(jt, Jt[0]),
            gr(jt, jt, Tr),
            Tt(jt, cr) ? -1 : (It(Jt[0]) === nr[31] >> 7 && ur(Jt[0], ee, Jt[0]),
            gr(Jt[3], Jt[0], Jt[1]),
            0)
        }
        function Ut(Jt, nr, sr, jt) {
            var cr, Tr = new Uint8Array(32), kr = new Uint8Array(64), Pr = [f(), f(), f(), f()], zr = [f(), f(), f(), f()];
            if (sr < 64 || Ft(zr, jt))
                return -1;
            for (cr = 0; cr < sr; cr++)
                Jt[cr] = nr[cr];
            for (cr = 0; cr < 32; cr++)
                Jt[cr + 32] = jt[cr];
            if ($r(kr, Jt, sr),
            _r(kr),
            Qr(Pr, zr, kr),
            Gr(zr, nr.subarray(32)),
            Zr(Pr, zr),
            un(Tr, Pr),
            sr -= 64,
            $t(nr, 0, Tr, 0)) {
                for (cr = 0; cr < sr; cr++)
                    Jt[cr] = 0;
                return -1
            }
            for (cr = 0; cr < sr; cr++)
                Jt[cr] = nr[cr + 64];
            return sr
        }
        var Dt = 32
          , er = 24
          , br = 32
          , Cr = 16
          , xr = 32
          , Lr = 32
          , Ur = 32
          , Ir = 32
          , Jr = 32
          , Wr = er
          , Yr = br
          , Sn = Cr
          , pn = 64
          , tn = 32
          , Bn = 64
          , An = 32
          , dn = 64;
        d.lowlevel = {
            crypto_core_hsalsa20: Wt,
            crypto_stream_xor: wr,
            crypto_stream: tr,
            crypto_stream_salsa20_xor: ir,
            crypto_stream_salsa20: or,
            crypto_onetimeauth: Mt,
            crypto_onetimeauth_verify: _t,
            crypto_verify_16: Pt,
            crypto_verify_32: $t,
            crypto_secretbox: gt,
            crypto_secretbox_open: vt,
            crypto_scalarmult: rr,
            crypto_scalarmult_base: fr,
            crypto_box_beforenm: Xt,
            crypto_box_afternm: Sr,
            crypto_box: qr,
            crypto_box_open: Nr,
            crypto_box_keypair: Yt,
            crypto_hash: $r,
            crypto_sign: Ar,
            crypto_sign_keypair: vr,
            crypto_sign_open: Ut,
            crypto_secretbox_KEYBYTES: Dt,
            crypto_secretbox_NONCEBYTES: er,
            crypto_secretbox_ZEROBYTES: br,
            crypto_secretbox_BOXZEROBYTES: Cr,
            crypto_scalarmult_BYTES: xr,
            crypto_scalarmult_SCALARBYTES: Lr,
            crypto_box_PUBLICKEYBYTES: Ur,
            crypto_box_SECRETKEYBYTES: Ir,
            crypto_box_BEFORENMBYTES: Jr,
            crypto_box_NONCEBYTES: Wr,
            crypto_box_ZEROBYTES: Yr,
            crypto_box_BOXZEROBYTES: Sn,
            crypto_sign_BYTES: pn,
            crypto_sign_PUBLICKEYBYTES: tn,
            crypto_sign_SECRETKEYBYTES: Bn,
            crypto_sign_SEEDBYTES: An,
            crypto_hash_BYTES: dn,
            gf: f,
            D: yt,
            L: ar,
            pack25519: kt,
            unpack25519: St,
            M: gr,
            A: qt,
            S: lr,
            Z: ur,
            pow2523: Vt,
            add: Zr,
            set25519: Et,
            modL: hr,
            scalarmult: Qr,
            scalarbase: Gr
        };
        function Rn(Jt, nr) {
            if (Jt.length !== Dt)
                throw new Error("bad key size");
            if (nr.length !== er)
                throw new Error("bad nonce size")
        }
        function En(Jt, nr) {
            if (Jt.length !== Ur)
                throw new Error("bad public key size");
            if (nr.length !== Ir)
                throw new Error("bad secret key size")
        }
        function an() {
            for (var Jt = 0; Jt < arguments.length; Jt++)
                if (!(arguments[Jt]instanceof Uint8Array))
                    throw new TypeError("unexpected type, use Uint8Array")
        }
        function Un(Jt) {
            for (var nr = 0; nr < Jt.length; nr++)
                Jt[nr] = 0
        }
        d.randomBytes = function(Jt) {
            var nr = new Uint8Array(Jt);
            return m(nr, Jt),
            nr
        }
        ,
        d.secretbox = function(Jt, nr, sr) {
            an(Jt, nr, sr),
            Rn(sr, nr);
            for (var jt = new Uint8Array(br + Jt.length), cr = new Uint8Array(jt.length), Tr = 0; Tr < Jt.length; Tr++)
                jt[Tr + br] = Jt[Tr];
            return gt(cr, jt, jt.length, nr, sr),
            cr.subarray(Cr)
        }
        ,
        d.secretbox.open = function(Jt, nr, sr) {
            an(Jt, nr, sr),
            Rn(sr, nr);
            for (var jt = new Uint8Array(Cr + Jt.length), cr = new Uint8Array(jt.length), Tr = 0; Tr < Jt.length; Tr++)
                jt[Tr + Cr] = Jt[Tr];
            return jt.length < 32 || vt(cr, jt, jt.length, nr, sr) !== 0 ? null : cr.subarray(br)
        }
        ,
        d.secretbox.keyLength = Dt,
        d.secretbox.nonceLength = er,
        d.secretbox.overheadLength = Cr,
        d.scalarMult = function(Jt, nr) {
            if (an(Jt, nr),
            Jt.length !== Lr)
                throw new Error("bad n size");
            if (nr.length !== xr)
                throw new Error("bad p size");
            var sr = new Uint8Array(xr);
            return rr(sr, Jt, nr),
            sr
        }
        ,
        d.scalarMult.base = function(Jt) {
            if (an(Jt),
            Jt.length !== Lr)
                throw new Error("bad n size");
            var nr = new Uint8Array(xr);
            return fr(nr, Jt),
            nr
        }
        ,
        d.scalarMult.scalarLength = Lr,
        d.scalarMult.groupElementLength = xr,
        d.box = function(Jt, nr, sr, jt) {
            var cr = d.box.before(sr, jt);
            return d.secretbox(Jt, nr, cr)
        }
        ,
        d.box.before = function(Jt, nr) {
            an(Jt, nr),
            En(Jt, nr);
            var sr = new Uint8Array(Jr);
            return Xt(sr, Jt, nr),
            sr
        }
        ,
        d.box.after = d.secretbox,
        d.box.open = function(Jt, nr, sr, jt) {
            var cr = d.box.before(sr, jt);
            return d.secretbox.open(Jt, nr, cr)
        }
        ,
        d.box.open.after = d.secretbox.open,
        d.box.keyPair = function() {
            var Jt = new Uint8Array(Ur)
              , nr = new Uint8Array(Ir);
            return Yt(Jt, nr),
            {
                publicKey: Jt,
                secretKey: nr
            }
        }
        ,
        d.box.keyPair.fromSecretKey = function(Jt) {
            if (an(Jt),
            Jt.length !== Ir)
                throw new Error("bad secret key size");
            var nr = new Uint8Array(Ur);
            return fr(nr, Jt),
            {
                publicKey: nr,
                secretKey: new Uint8Array(Jt)
            }
        }
        ,
        d.box.publicKeyLength = Ur,
        d.box.secretKeyLength = Ir,
        d.box.sharedKeyLength = Jr,
        d.box.nonceLength = Wr,
        d.box.overheadLength = d.secretbox.overheadLength,
        d.sign = function(Jt, nr) {
            if (an(Jt, nr),
            nr.length !== Bn)
                throw new Error("bad secret key size");
            var sr = new Uint8Array(pn + Jt.length);
            return Ar(sr, Jt, Jt.length, nr),
            sr
        }
        ,
        d.sign.open = function(Jt, nr) {
            if (an(Jt, nr),
            nr.length !== tn)
                throw new Error("bad public key size");
            var sr = new Uint8Array(Jt.length)
              , jt = Ut(sr, Jt, Jt.length, nr);
            if (jt < 0)
                return null;
            for (var cr = new Uint8Array(jt), Tr = 0; Tr < cr.length; Tr++)
                cr[Tr] = sr[Tr];
            return cr
        }
        ,
        d.sign.detached = function(Jt, nr) {
            for (var sr = d.sign(Jt, nr), jt = new Uint8Array(pn), cr = 0; cr < jt.length; cr++)
                jt[cr] = sr[cr];
            return jt
        }
        ,
        d.sign.detached.verify = function(Jt, nr, sr) {
            if (an(Jt, nr, sr),
            nr.length !== pn)
                throw new Error("bad signature size");
            if (sr.length !== tn)
                throw new Error("bad public key size");
            var jt = new Uint8Array(pn + Jt.length), cr = new Uint8Array(pn + Jt.length), Tr;
            for (Tr = 0; Tr < pn; Tr++)
                jt[Tr] = nr[Tr];
            for (Tr = 0; Tr < Jt.length; Tr++)
                jt[Tr + pn] = Jt[Tr];
            return Ut(cr, jt, jt.length, sr) >= 0
        }
        ,
        d.sign.keyPair = function() {
            var Jt = new Uint8Array(tn)
              , nr = new Uint8Array(Bn);
            return vr(Jt, nr),
            {
                publicKey: Jt,
                secretKey: nr
            }
        }
        ,
        d.sign.keyPair.fromSecretKey = function(Jt) {
            if (an(Jt),
            Jt.length !== Bn)
                throw new Error("bad secret key size");
            for (var nr = new Uint8Array(tn), sr = 0; sr < nr.length; sr++)
                nr[sr] = Jt[32 + sr];
            return {
                publicKey: nr,
                secretKey: new Uint8Array(Jt)
            }
        }
        ,
        d.sign.keyPair.fromSeed = function(Jt) {
            if (an(Jt),
            Jt.length !== An)
                throw new Error("bad seed size");
            for (var nr = new Uint8Array(tn), sr = new Uint8Array(Bn), jt = 0; jt < 32; jt++)
                sr[jt] = Jt[jt];
            return vr(nr, sr, !0),
            {
                publicKey: nr,
                secretKey: sr
            }
        }
        ,
        d.sign.publicKeyLength = tn,
        d.sign.secretKeyLength = Bn,
        d.sign.seedLength = An,
        d.sign.signatureLength = pn,
        d.hash = function(Jt) {
            an(Jt);
            var nr = new Uint8Array(dn);
            return $r(nr, Jt, Jt.length),
            nr
        }
        ,
        d.hash.hashLength = dn,
        d.verify = function(Jt, nr) {
            return an(Jt, nr),
            Jt.length === 0 || nr.length === 0 || Jt.length !== nr.length ? !1 : Ct(Jt, 0, nr, 0, Jt.length) === 0
        }
        ,
        d.setPRNG = function(Jt) {
            m = Jt
        }
        ,
        function() {
            var Jt = typeof self < "u" ? self.crypto || self.msCrypto : null;
            if (Jt && Jt.getRandomValues) {
                var nr = 65536;
                d.setPRNG(function(sr, jt) {
                    var cr, Tr = new Uint8Array(jt);
                    for (cr = 0; cr < jt; cr += nr)
                        Jt.getRandomValues(Tr.subarray(cr, cr + Math.min(jt - cr, nr)));
                    for (cr = 0; cr < jt; cr++)
                        sr[cr] = Tr[cr];
                    Un(Tr)
                })
            } else
                typeof commonjsRequire < "u" && (Jt = requireCryptoBrowserify(),
                Jt && Jt.randomBytes && d.setPRNG(function(sr, jt) {
                    var cr, Tr = Jt.randomBytes(jt);
                    for (cr = 0; cr < jt; cr++)
                        sr[cr] = Tr[cr];
                    Un(Tr)
                }))
        }()
    }
    )(r.exports ? r.exports : self.nacl = self.nacl || {})
}
)(naclFast);
var naclFastExports = naclFast.exports;
const nacl$1 = getDefaultExportFromCjs(naclFastExports);
var CONNECT_EVENT_ERROR_CODES;
(function(r) {
    r[r.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR",
    r[r.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR",
    r[r.MANIFEST_NOT_FOUND_ERROR = 2] = "MANIFEST_NOT_FOUND_ERROR",
    r[r.MANIFEST_CONTENT_ERROR = 3] = "MANIFEST_CONTENT_ERROR",
    r[r.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR",
    r[r.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR",
    r[r.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED"
}
)(CONNECT_EVENT_ERROR_CODES || (CONNECT_EVENT_ERROR_CODES = {}));
var CONNECT_ITEM_ERROR_CODES;
(function(r) {
    r[r.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR",
    r[r.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED"
}
)(CONNECT_ITEM_ERROR_CODES || (CONNECT_ITEM_ERROR_CODES = {}));
var SEND_TRANSACTION_ERROR_CODES;
(function(r) {
    r[r.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR",
    r[r.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR",
    r[r.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR",
    r[r.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR",
    r[r.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED"
}
)(SEND_TRANSACTION_ERROR_CODES || (SEND_TRANSACTION_ERROR_CODES = {}));
var SIGN_DATA_ERROR_CODES;
(function(r) {
    r[r.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR",
    r[r.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR",
    r[r.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR",
    r[r.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR",
    r[r.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED"
}
)(SIGN_DATA_ERROR_CODES || (SIGN_DATA_ERROR_CODES = {}));
var DISCONNECT_ERROR_CODES;
(function(r) {
    r[r.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR",
    r[r.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR",
    r[r.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR",
    r[r.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED"
}
)(DISCONNECT_ERROR_CODES || (DISCONNECT_ERROR_CODES = {}));
var CHAIN;
(function(r) {
    r.MAINNET = "-239",
    r.TESTNET = "-3"
}
)(CHAIN || (CHAIN = {}));
function encodeUint8Array(r, d) {
    const f = nacl$2.encodeBase64(r);
    return d ? encodeURIComponent(f) : f
}
function decodeToUint8Array(r, d) {
    return d && (r = decodeURIComponent(r)),
    nacl$2.decodeBase64(r)
}
function encode$2(r, d=!1) {
    let f;
    return r instanceof Uint8Array ? f = r : (typeof r != "string" && (r = JSON.stringify(r)),
    f = nacl$2.decodeUTF8(r)),
    encodeUint8Array(f, d)
}
function decode(r, d=!1) {
    const f = decodeToUint8Array(r, d);
    return {
        toString() {
            return nacl$2.encodeUTF8(f)
        },
        toObject() {
            try {
                return JSON.parse(nacl$2.encodeUTF8(f))
            } catch {
                return null
            }
        },
        toUint8Array() {
            return f
        }
    }
}
const Base64 = {
    encode: encode$2,
    decode
};
function concatUint8Arrays(r, d) {
    const f = new Uint8Array(r.length + d.length);
    return f.set(r),
    f.set(d, r.length),
    f
}
function splitToUint8Arrays(r, d) {
    if (d >= r.length)
        throw new Error("Index is out of buffer");
    const f = r.slice(0, d)
      , m = r.slice(d);
    return [f, m]
}
function toHexString(r) {
    let d = "";
    return r.forEach(f=>{
        d += ("0" + (f & 255).toString(16)).slice(-2)
    }
    ),
    d
}
function hexToByteArray(r) {
    if (r.length % 2 !== 0)
        throw new Error(`Cannot convert ${r} to bytesArray`);
    const d = new Uint8Array(r.length / 2);
    for (let f = 0; f < r.length; f += 2)
        d[f / 2] = parseInt(r.slice(f, f + 2), 16);
    return d
}
class SessionCrypto {
    constructor(d) {
        this.nonceLength = 24,
        this.keyPair = d ? this.createKeypairFromString(d) : this.createKeypair(),
        this.sessionId = toHexString(this.keyPair.publicKey)
    }
    createKeypair() {
        return nacl$1.box.keyPair()
    }
    createKeypairFromString(d) {
        return {
            publicKey: hexToByteArray(d.publicKey),
            secretKey: hexToByteArray(d.secretKey)
        }
    }
    createNonce() {
        return nacl$1.randomBytes(this.nonceLength)
    }
    encrypt(d, f) {
        const m = new TextEncoder().encode(d)
          , k = this.createNonce()
          , y = nacl$1.box(m, k, f, this.keyPair.secretKey);
        return concatUint8Arrays(k, y)
    }
    decrypt(d, f) {
        const [m,k] = splitToUint8Arrays(d, this.nonceLength)
          , y = nacl$1.box.open(k, m, f, this.keyPair.secretKey);
        if (!y)
            throw new Error(`Decryption error: 
 message: ${d.toString()} 
 sender pubkey: ${f.toString()} 
 keypair pubkey: ${this.keyPair.publicKey.toString()} 
 keypair secretkey: ${this.keyPair.secretKey.toString()}`);
        return new TextDecoder().decode(y)
    }
    stringifyKeypair() {
        return {
            publicKey: toHexString(this.keyPair.publicKey),
            secretKey: toHexString(this.keyPair.secretKey)
        }
    }
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __rest(r, d) {
    var f = {};
    for (var m in r)
        Object.prototype.hasOwnProperty.call(r, m) && d.indexOf(m) < 0 && (f[m] = r[m]);
    if (r != null && typeof Object.getOwnPropertySymbols == "function")
        for (var k = 0, m = Object.getOwnPropertySymbols(r); k < m.length; k++)
            d.indexOf(m[k]) < 0 && Object.prototype.propertyIsEnumerable.call(r, m[k]) && (f[m[k]] = r[m[k]]);
    return f
}
function __awaiter(r, d, f, m) {
    function k(y) {
        return y instanceof f ? y : new f(function(ee) {
            ee(y)
        }
        )
    }
    return new (f || (f = Promise))(function(y, ee) {
        function dt(pt) {
            try {
                yt(m.next(pt))
            } catch (bt) {
                ee(bt)
            }
        }
        function mt(pt) {
            try {
                yt(m.throw(pt))
            } catch (bt) {
                ee(bt)
            }
        }
        function yt(pt) {
            pt.done ? y(pt.value) : k(pt.value).then(dt, mt)
        }
        yt((m = m.apply(r, d || [])).next())
    }
    )
}
class TonConnectError extends Error {
    constructor(d, f) {
        super(d, f),
        this.message = `${TonConnectError.prefix} ${this.constructor.name}${this.info ? ": " + this.info : ""}${d ? `
` + d : ""}`,
        Object.setPrototypeOf(this, TonConnectError.prototype)
    }
    get info() {
        return ""
    }
}
TonConnectError.prefix = "[TON_CONNECT_SDK_ERROR]";
class DappMetadataError extends TonConnectError {
    get info() {
        return "Passed DappMetadata is in incorrect format."
    }
    constructor(...d) {
        super(...d),
        Object.setPrototypeOf(this, DappMetadataError.prototype)
    }
}
class ManifestContentErrorError extends TonConnectError {
    get info() {
        return "Passed `tonconnect-manifest.json` contains errors. Check format of your manifest. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest"
    }
    constructor(...d) {
        super(...d),
        Object.setPrototypeOf(this, ManifestContentErrorError.prototype)
    }
}
class ManifestNotFoundError extends TonConnectError {
    get info() {
        return "Manifest not found. Make sure you added `tonconnect-manifest.json` to the root of your app or passed correct manifestUrl. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest"
    }
    constructor(...d) {
        super(...d),
        Object.setPrototypeOf(this, ManifestNotFoundError.prototype)
    }
}
class WalletAlreadyConnectedError extends TonConnectError {
    get info() {
        return "Wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection."
    }
    constructor(...d) {
        super(...d),
        Object.setPrototypeOf(this, WalletAlreadyConnectedError.prototype)
    }
}
class WalletNotConnectedError extends TonConnectError {
    get info() {
        return "Send transaction or other protocol methods called while wallet is not connected."
    }
    constructor(...d) {
        super(...d),
        Object.setPrototypeOf(this, WalletNotConnectedError.prototype)
    }
}
function isWalletConnectionSourceJS(r) {
    return "jsBridgeKey"in r
}
class UserRejectsError extends TonConnectError {
    get info() {
        return "User rejects the action in the wallet."
    }
    constructor(...d) {
        super(...d),
        Object.setPrototypeOf(this, UserRejectsError.prototype)
    }
}
class BadRequestError extends TonConnectError {
    get info() {
        return "Request to the wallet contains errors."
    }
    constructor(...d) {
        super(...d),
        Object.setPrototypeOf(this, BadRequestError.prototype)
    }
}
class UnknownAppError extends TonConnectError {
    get info() {
        return "App tries to send rpc request to the injected wallet while not connected."
    }
    constructor(...d) {
        super(...d),
        Object.setPrototypeOf(this, UnknownAppError.prototype)
    }
}
class WalletNotInjectedError extends TonConnectError {
    get info() {
        return "There is an attempt to connect to the injected wallet while it is not exists in the webpage."
    }
    constructor(...d) {
        super(...d),
        Object.setPrototypeOf(this, WalletNotInjectedError.prototype)
    }
}
class FetchWalletsError extends TonConnectError {
    get info() {
        return "An error occurred while fetching the wallets list."
    }
    constructor(...d) {
        super(...d),
        Object.setPrototypeOf(this, FetchWalletsError.prototype)
    }
}
class WrongAddressError extends TonConnectError {
    get info() {
        return "Passed address is in incorrect format."
    }
    constructor(...d) {
        super(...d),
        Object.setPrototypeOf(this, WrongAddressError.prototype)
    }
}
class ParseHexError extends TonConnectError {
    get info() {
        return "Passed hex is in incorrect format."
    }
    constructor(...d) {
        super(...d),
        Object.setPrototypeOf(this, ParseHexError.prototype)
    }
}
class UnknownError extends TonConnectError {
    constructor(...d) {
        super(...d),
        Object.setPrototypeOf(this, UnknownError.prototype)
    }
}
const connectEventErrorsCodes = {
    [CONNECT_EVENT_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,
    [CONNECT_EVENT_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,
    [CONNECT_EVENT_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,
    [CONNECT_EVENT_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError,
    [CONNECT_EVENT_ERROR_CODES.MANIFEST_NOT_FOUND_ERROR]: ManifestNotFoundError,
    [CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR]: ManifestContentErrorError
};
class ConnectErrorsParser {
    parseError(d) {
        let f = UnknownError;
        return d.code in connectEventErrorsCodes && (f = connectEventErrorsCodes[d.code] || UnknownError),
        new f(d.message)
    }
}
const connectErrorsParser = new ConnectErrorsParser;
class RpcParser {
    isError(d) {
        return "error"in d
    }
}
const sendTransactionErrors = {
    [SEND_TRANSACTION_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,
    [SEND_TRANSACTION_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,
    [SEND_TRANSACTION_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,
    [SEND_TRANSACTION_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError
};
class SendTransactionParser extends RpcParser {
    convertToRpcRequest(d) {
        return {
            method: "sendTransaction",
            params: [JSON.stringify(d)]
        }
    }
    parseAndThrowError(d) {
        let f = UnknownError;
        throw d.error.code in sendTransactionErrors && (f = sendTransactionErrors[d.error.code] || UnknownError),
        new f(d.error.message)
    }
    convertFromRpcResponse(d) {
        return {
            boc: d.result
        }
    }
}
const sendTransactionParser = new SendTransactionParser;
class HttpBridgeGatewayStorage {
    constructor(d, f) {
        this.storage = d,
        this.storeKey = "ton-connect-storage_http-bridge-gateway::" + f
    }
    storeLastEventId(d) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.storage.setItem(this.storeKey, d)
        })
    }
    removeLastEventId() {
        return __awaiter(this, void 0, void 0, function*() {
            return this.storage.removeItem(this.storeKey)
        })
    }
    getLastEventId() {
        return __awaiter(this, void 0, void 0, function*() {
            const d = yield this.storage.getItem(this.storeKey);
            return d || null
        })
    }
}
function removeUrlLastSlash(r) {
    return r.slice(-1) === "/" ? r.slice(0, -1) : r
}
function addPathToUrl(r, d) {
    return removeUrlLastSlash(r) + "/" + d
}
function isTelegramUrl(r) {
    if (!r)
        return !1;
    const d = new URL(r);
    return d.protocol === "tg:" || d.hostname === "t.me"
}
function encodeTelegramUrlParameters(r) {
    return r.replaceAll(".", "%2E").replaceAll("-", "%2D").replaceAll("_", "%5F").replaceAll("&", "-").replaceAll("=", "__").replaceAll("%", "--")
}
function delay(r, d) {
    return __awaiter(this, void 0, void 0, function*() {
        return new Promise((f,m)=>{
            var k, y;
            if (!((k = d == null ? void 0 : d.signal) === null || k === void 0) && k.aborted) {
                m(new TonConnectError("Delay aborted"));
                return
            }
            const ee = setTimeout(()=>f(), r);
            (y = d == null ? void 0 : d.signal) === null || y === void 0 || y.addEventListener("abort", ()=>{
                clearTimeout(ee),
                m(new TonConnectError("Delay aborted"))
            }
            )
        }
        )
    })
}
function createAbortController(r) {
    const d = new AbortController;
    return r != null && r.aborted ? d.abort() : r == null || r.addEventListener("abort", ()=>d.abort(), {
        once: !0
    }),
    d
}
function callForSuccess(r, d) {
    var f, m;
    return __awaiter(this, void 0, void 0, function*() {
        const k = (f = d == null ? void 0 : d.attempts) !== null && f !== void 0 ? f : 10
          , y = (m = d == null ? void 0 : d.delayMs) !== null && m !== void 0 ? m : 200
          , ee = createAbortController(d == null ? void 0 : d.signal);
        if (typeof r != "function")
            throw new TonConnectError(`Expected a function, got ${typeof r}`);
        let dt = 0, mt;
        for (; dt < k; ) {
            if (ee.signal.aborted)
                throw new TonConnectError(`Aborted after attempts ${dt}`);
            try {
                return yield r({
                    signal: ee.signal
                })
            } catch (yt) {
                mt = yt,
                dt++,
                dt < k && (yield delay(y))
            }
        }
        throw mt
    })
}
function logDebug$1(...r) {
    try {
        console.debug("[TON_CONNECT_SDK]", ...r)
    } catch {}
}
function logError$1(...r) {
    try {
        console.error("[TON_CONNECT_SDK]", ...r)
    } catch {}
}
function logWarning$1(...r) {
    try {
        console.warn("[TON_CONNECT_SDK]", ...r)
    } catch {}
}
function createResource$1(r, d) {
    let f = null
      , m = null
      , k = null
      , y = null
      , ee = null;
    const dt = (bt,...wt)=>__awaiter(this, void 0, void 0, function*() {
        if (y = bt ?? null,
        ee == null || ee.abort(),
        ee = createAbortController(bt),
        ee.signal.aborted)
            throw new TonConnectError("Resource creation was aborted");
        m = wt ?? null;
        const xt = r(ee.signal, ...wt);
        k = xt;
        const At = yield xt;
        if (k !== xt && At !== f)
            throw yield d(At),
            new TonConnectError("Resource creation was aborted by a new resource creation");
        return f = At,
        f
    });
    return {
        create: dt,
        current: ()=>f ?? null,
        dispose: ()=>__awaiter(this, void 0, void 0, function*() {
            try {
                const bt = f;
                f = null;
                const wt = k;
                k = null;
                try {
                    ee == null || ee.abort()
                } catch {}
                yield Promise.allSettled([bt ? d(bt) : Promise.resolve(), wt ? d(yield wt) : Promise.resolve()])
            } catch {}
        }),
        recreate: bt=>__awaiter(this, void 0, void 0, function*() {
            const wt = f
              , xt = k
              , At = m
              , Ct = y;
            if (yield delay(bt),
            wt === f && xt === k && At === m && Ct === y)
                return yield dt(y, ...At ?? []);
            throw new TonConnectError("Resource recreation was aborted by a new resource creation")
        })
    }
}
function timeout(r, d) {
    const f = d == null ? void 0 : d.timeout
      , m = d == null ? void 0 : d.signal
      , k = createAbortController(m);
    return new Promise((y,ee)=>{
        if (k.signal.aborted) {
            ee(new TonConnectError("Operation aborted"));
            return
        }
        let dt;
        typeof f < "u" && (dt = setTimeout(()=>{
            k.abort(),
            ee(new TonConnectError(`Timeout after ${f}ms`))
        }
        , f)),
        k.signal.addEventListener("abort", ()=>{
            clearTimeout(dt),
            ee(new TonConnectError("Operation aborted"))
        }
        , {
            once: !0
        });
        const mt = {
            timeout: f,
            abort: k.signal
        };
        r(y, ee, mt).finally(()=>clearTimeout(dt))
    }
    )
}
class BridgeGateway {
    constructor(d, f, m, k, y) {
        this.bridgeUrl = f,
        this.sessionId = m,
        this.listener = k,
        this.errorsListener = y,
        this.ssePath = "events",
        this.postPath = "message",
        this.heartbeatMessage = "heartbeat",
        this.defaultTtl = 300,
        this.defaultReconnectDelay = 5e3,
        this.eventSource = createResource$1((ee,dt)=>__awaiter(this, void 0, void 0, function*() {
            const mt = {
                bridgeUrl: this.bridgeUrl,
                ssePath: this.ssePath,
                sessionId: this.sessionId,
                bridgeGatewayStorage: this.bridgeGatewayStorage,
                errorHandler: this.errorsHandler.bind(this),
                messageHandler: this.messagesHandler.bind(this),
                signal: ee,
                openingDeadlineMS: dt
            };
            return yield createEventSource(mt)
        }), ee=>__awaiter(this, void 0, void 0, function*() {
            ee.close()
        })),
        this.bridgeGatewayStorage = new HttpBridgeGatewayStorage(d,f)
    }
    get isReady() {
        const d = this.eventSource.current();
        return (d == null ? void 0 : d.readyState) === EventSource.OPEN
    }
    get isClosed() {
        const d = this.eventSource.current();
        return (d == null ? void 0 : d.readyState) !== EventSource.OPEN
    }
    get isConnecting() {
        const d = this.eventSource.current();
        return (d == null ? void 0 : d.readyState) === EventSource.CONNECTING
    }
    registerSession(d) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.eventSource.create(d == null ? void 0 : d.signal, d == null ? void 0 : d.openingDeadlineMS)
        })
    }
    send(d, f, m, k) {
        var y;
        return __awaiter(this, void 0, void 0, function*() {
            const ee = {};
            typeof k == "number" ? ee.ttl = k : (ee.ttl = k == null ? void 0 : k.ttl,
            ee.signal = k == null ? void 0 : k.signal,
            ee.attempts = k == null ? void 0 : k.attempts);
            const dt = new URL(addPathToUrl(this.bridgeUrl, this.postPath));
            dt.searchParams.append("client_id", this.sessionId),
            dt.searchParams.append("to", f),
            dt.searchParams.append("ttl", ((ee == null ? void 0 : ee.ttl) || this.defaultTtl).toString()),
            dt.searchParams.append("topic", m);
            const mt = Base64.encode(d);
            yield callForSuccess(yt=>__awaiter(this, void 0, void 0, function*() {
                const pt = yield this.post(dt, mt, yt.signal);
                if (!pt.ok)
                    throw new TonConnectError(`Bridge send failed, status ${pt.status}`)
            }), {
                attempts: (y = ee == null ? void 0 : ee.attempts) !== null && y !== void 0 ? y : Number.MAX_SAFE_INTEGER,
                delayMs: 5e3,
                signal: ee == null ? void 0 : ee.signal
            })
        })
    }
    pause() {
        this.eventSource.dispose().catch(d=>logError$1(`Bridge pause failed, ${d}`))
    }
    unPause() {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.eventSource.recreate(0)
        })
    }
    close() {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.eventSource.dispose().catch(d=>logError$1(`Bridge close failed, ${d}`))
        })
    }
    setListener(d) {
        this.listener = d
    }
    setErrorsListener(d) {
        this.errorsListener = d
    }
    post(d, f, m) {
        return __awaiter(this, void 0, void 0, function*() {
            const k = yield fetch(d, {
                method: "post",
                body: f,
                signal: m
            });
            if (!k.ok)
                throw new TonConnectError(`Bridge send failed, status ${k.status}`);
            return k
        })
    }
    errorsHandler(d, f) {
        return __awaiter(this, void 0, void 0, function*() {
            if (this.isConnecting) {
                logError$1("Bridge error", JSON.stringify(f));
                return
            }
            if (this.isReady) {
                try {
                    this.errorsListener(f)
                } catch {}
                return
            }
            if (this.isClosed)
                return d.close(),
                logDebug$1(`Bridge reconnecting, ${this.defaultReconnectDelay}ms delay`),
                yield this.eventSource.recreate(this.defaultReconnectDelay);
            throw new TonConnectError("Bridge error, unknown state")
        })
    }
    messagesHandler(d) {
        return __awaiter(this, void 0, void 0, function*() {
            if (d.data === this.heartbeatMessage || (yield this.bridgeGatewayStorage.storeLastEventId(d.lastEventId),
            this.isClosed))
                return;
            let f;
            try {
                f = JSON.parse(d.data)
            } catch (m) {
                throw new TonConnectError(`Bridge message parse failed, message ${m.data}`)
            }
            this.listener(f)
        })
    }
}
function createEventSource(r) {
    return __awaiter(this, void 0, void 0, function*() {
        return yield timeout((d,f,m)=>__awaiter(this, void 0, void 0, function*() {
            var k;
            const ee = createAbortController(m.signal).signal;
            if (ee.aborted) {
                f(new TonConnectError("Bridge connection aborted"));
                return
            }
            const dt = new URL(addPathToUrl(r.bridgeUrl, r.ssePath));
            dt.searchParams.append("client_id", r.sessionId);
            const mt = yield r.bridgeGatewayStorage.getLastEventId();
            if (mt && dt.searchParams.append("last_event_id", mt),
            ee.aborted) {
                f(new TonConnectError("Bridge connection aborted"));
                return
            }
            const yt = new EventSource(dt.toString());
            yt.onerror = pt=>__awaiter(this, void 0, void 0, function*() {
                if (ee.aborted) {
                    yt.close(),
                    f(new TonConnectError("Bridge connection aborted"));
                    return
                }
                try {
                    const bt = yield r.errorHandler(yt, pt);
                    bt !== yt && yt.close(),
                    bt && bt !== yt && d(bt)
                } catch (bt) {
                    yt.close(),
                    f(bt)
                }
            }),
            yt.onopen = ()=>{
                if (ee.aborted) {
                    yt.close(),
                    f(new TonConnectError("Bridge connection aborted"));
                    return
                }
                d(yt)
            }
            ,
            yt.onmessage = pt=>{
                if (ee.aborted) {
                    yt.close(),
                    f(new TonConnectError("Bridge connection aborted"));
                    return
                }
                r.messageHandler(pt)
            }
            ,
            (k = r.signal) === null || k === void 0 || k.addEventListener("abort", ()=>{
                yt.close(),
                f(new TonConnectError("Bridge connection aborted"))
            }
            )
        }), {
            timeout: r.openingDeadlineMS,
            signal: r.signal
        })
    })
}
function isPendingConnectionHttp(r) {
    return !("connectEvent"in r)
}
class BridgeConnectionStorage {
    constructor(d) {
        this.storage = d,
        this.storeKey = "ton-connect-storage_bridge-connection"
    }
    storeConnection(d) {
        return __awaiter(this, void 0, void 0, function*() {
            if (d.type === "injected")
                return this.storage.setItem(this.storeKey, JSON.stringify(d));
            if (!isPendingConnectionHttp(d)) {
                const m = {
                    sessionKeyPair: d.session.sessionCrypto.stringifyKeypair(),
                    walletPublicKey: d.session.walletPublicKey,
                    bridgeUrl: d.session.bridgeUrl
                }
                  , k = {
                    type: "http",
                    connectEvent: d.connectEvent,
                    session: m,
                    lastWalletEventId: d.lastWalletEventId,
                    nextRpcRequestId: d.nextRpcRequestId
                };
                return this.storage.setItem(this.storeKey, JSON.stringify(k))
            }
            const f = {
                type: "http",
                connectionSource: d.connectionSource,
                sessionCrypto: d.sessionCrypto.stringifyKeypair()
            };
            return this.storage.setItem(this.storeKey, JSON.stringify(f))
        })
    }
    removeConnection() {
        return __awaiter(this, void 0, void 0, function*() {
            return this.storage.removeItem(this.storeKey)
        })
    }
    getConnection() {
        return __awaiter(this, void 0, void 0, function*() {
            const d = yield this.storage.getItem(this.storeKey);
            if (!d)
                return null;
            const f = JSON.parse(d);
            if (f.type === "injected")
                return f;
            if ("connectEvent"in f) {
                const m = new SessionCrypto(f.session.sessionKeyPair);
                return {
                    type: "http",
                    connectEvent: f.connectEvent,
                    lastWalletEventId: f.lastWalletEventId,
                    nextRpcRequestId: f.nextRpcRequestId,
                    session: {
                        sessionCrypto: m,
                        bridgeUrl: f.session.bridgeUrl,
                        walletPublicKey: f.session.walletPublicKey
                    }
                }
            }
            return {
                type: "http",
                sessionCrypto: new SessionCrypto(f.sessionCrypto),
                connectionSource: f.connectionSource
            }
        })
    }
    getHttpConnection() {
        return __awaiter(this, void 0, void 0, function*() {
            const d = yield this.getConnection();
            if (!d)
                throw new TonConnectError("Trying to read HTTP connection source while nothing is stored");
            if (d.type === "injected")
                throw new TonConnectError("Trying to read HTTP connection source while injected connection is stored");
            return d
        })
    }
    getHttpPendingConnection() {
        return __awaiter(this, void 0, void 0, function*() {
            const d = yield this.getConnection();
            if (!d)
                throw new TonConnectError("Trying to read HTTP connection source while nothing is stored");
            if (d.type === "injected")
                throw new TonConnectError("Trying to read HTTP connection source while injected connection is stored");
            if (!isPendingConnectionHttp(d))
                throw new TonConnectError("Trying to read HTTP-pending connection while http connection is stored");
            return d
        })
    }
    getInjectedConnection() {
        return __awaiter(this, void 0, void 0, function*() {
            const d = yield this.getConnection();
            if (!d)
                throw new TonConnectError("Trying to read Injected bridge connection source while nothing is stored");
            if ((d == null ? void 0 : d.type) === "http")
                throw new TonConnectError("Trying to read Injected bridge connection source while HTTP connection is stored");
            return d
        })
    }
    storedConnectionType() {
        return __awaiter(this, void 0, void 0, function*() {
            const d = yield this.storage.getItem(this.storeKey);
            return d ? JSON.parse(d).type : null
        })
    }
    storeLastWalletEventId(d) {
        return __awaiter(this, void 0, void 0, function*() {
            const f = yield this.getConnection();
            if (f && f.type === "http" && !isPendingConnectionHttp(f))
                return f.lastWalletEventId = d,
                this.storeConnection(f)
        })
    }
    getLastWalletEventId() {
        return __awaiter(this, void 0, void 0, function*() {
            const d = yield this.getConnection();
            if (d && "lastWalletEventId"in d)
                return d.lastWalletEventId
        })
    }
    increaseNextRpcRequestId() {
        return __awaiter(this, void 0, void 0, function*() {
            const d = yield this.getConnection();
            if (d && "nextRpcRequestId"in d) {
                const f = d.nextRpcRequestId || 0;
                return d.nextRpcRequestId = f + 1,
                this.storeConnection(d)
            }
        })
    }
    getNextRpcRequestId() {
        return __awaiter(this, void 0, void 0, function*() {
            const d = yield this.getConnection();
            return d && "nextRpcRequestId"in d && d.nextRpcRequestId || 0
        })
    }
}
const PROTOCOL_VERSION = 2;
class BridgeProvider {
    constructor(d, f) {
        this.storage = d,
        this.walletConnectionSource = f,
        this.type = "http",
        this.standardUniversalLink = "tc://",
        this.pendingRequests = new Map,
        this.session = null,
        this.gateway = null,
        this.pendingGateways = [],
        this.listeners = [],
        this.defaultOpeningDeadlineMS = 5e3,
        this.connectionStorage = new BridgeConnectionStorage(d)
    }
    static fromStorage(d) {
        return __awaiter(this, void 0, void 0, function*() {
            const m = yield new BridgeConnectionStorage(d).getHttpConnection();
            return isPendingConnectionHttp(m) ? new BridgeProvider(d,m.connectionSource) : new BridgeProvider(d,{
                bridgeUrl: m.session.bridgeUrl
            })
        })
    }
    connect(d, f) {
        var m;
        const k = createAbortController(f == null ? void 0 : f.signal);
        (m = this.abortController) === null || m === void 0 || m.abort(),
        this.abortController = k,
        this.closeGateways();
        const y = new SessionCrypto;
        this.session = {
            sessionCrypto: y,
            bridgeUrl: "bridgeUrl"in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ""
        },
        this.connectionStorage.storeConnection({
            type: "http",
            connectionSource: this.walletConnectionSource,
            sessionCrypto: y
        }).then(()=>__awaiter(this, void 0, void 0, function*() {
            k.signal.aborted || (yield callForSuccess(dt=>this.openGateways(y, {
                openingDeadlineMS: f == null ? void 0 : f.openingDeadlineMS,
                signal: dt == null ? void 0 : dt.signal
            }), {
                attempts: Number.MAX_SAFE_INTEGER,
                delayMs: 5e3,
                signal: k.signal
            }))
        }));
        const ee = "universalLink"in this.walletConnectionSource && this.walletConnectionSource.universalLink ? this.walletConnectionSource.universalLink : this.standardUniversalLink;
        return this.generateUniversalLink(ee, d)
    }
    restoreConnection(d) {
        var f, m;
        return __awaiter(this, void 0, void 0, function*() {
            const k = createAbortController(d == null ? void 0 : d.signal);
            if ((f = this.abortController) === null || f === void 0 || f.abort(),
            this.abortController = k,
            k.signal.aborted)
                return;
            this.closeGateways();
            const y = yield this.connectionStorage.getHttpConnection();
            if (!y || k.signal.aborted)
                return;
            const ee = (m = d == null ? void 0 : d.openingDeadlineMS) !== null && m !== void 0 ? m : this.defaultOpeningDeadlineMS;
            if (isPendingConnectionHttp(y))
                return this.session = {
                    sessionCrypto: y.sessionCrypto,
                    bridgeUrl: "bridgeUrl"in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ""
                },
                yield this.openGateways(y.sessionCrypto, {
                    openingDeadlineMS: ee,
                    signal: k == null ? void 0 : k.signal
                });
            if (Array.isArray(this.walletConnectionSource))
                throw new TonConnectError("Internal error. Connection source is array while WalletConnectionSourceHTTP was expected.");
            if (this.session = y.session,
            this.gateway && (logDebug$1("Gateway is already opened, closing previous gateway"),
            yield this.gateway.close()),
            this.gateway = new BridgeGateway(this.storage,this.walletConnectionSource.bridgeUrl,y.session.sessionCrypto.sessionId,this.gatewayListener.bind(this),this.gatewayErrorsListener.bind(this)),
            !k.signal.aborted) {
                this.listeners.forEach(dt=>dt(y.connectEvent));
                try {
                    yield callForSuccess(dt=>this.gateway.registerSession({
                        openingDeadlineMS: ee,
                        signal: dt.signal
                    }), {
                        attempts: Number.MAX_SAFE_INTEGER,
                        delayMs: 5e3,
                        signal: k.signal
                    })
                } catch {
                    yield this.disconnect({
                        signal: k.signal
                    });
                    return
                }
            }
        })
    }
    sendRequest(d, f) {
        const m = {};
        return typeof f == "function" ? m.onRequestSent = f : (m.onRequestSent = f == null ? void 0 : f.onRequestSent,
        m.signal = f == null ? void 0 : f.signal,
        m.attempts = f == null ? void 0 : f.attempts),
        new Promise((k,y)=>__awaiter(this, void 0, void 0, function*() {
            var ee;
            if (!this.gateway || !this.session || !("walletPublicKey"in this.session))
                throw new TonConnectError("Trying to send bridge request without session");
            const dt = (yield this.connectionStorage.getNextRpcRequestId()).toString();
            yield this.connectionStorage.increaseNextRpcRequestId(),
            logDebug$1("Send http-bridge request:", Object.assign(Object.assign({}, d), {
                id: dt
            }));
            const mt = this.session.sessionCrypto.encrypt(JSON.stringify(Object.assign(Object.assign({}, d), {
                id: dt
            })), hexToByteArray(this.session.walletPublicKey));
            try {
                yield this.gateway.send(mt, this.session.walletPublicKey, d.method, {
                    attempts: m == null ? void 0 : m.attempts,
                    signal: m == null ? void 0 : m.signal
                }),
                (ee = m == null ? void 0 : m.onRequestSent) === null || ee === void 0 || ee.call(m),
                this.pendingRequests.set(dt.toString(), k)
            } catch (yt) {
                y(yt)
            }
        }))
    }
    closeConnection() {
        this.closeGateways(),
        this.listeners = [],
        this.session = null,
        this.gateway = null
    }
    disconnect(d) {
        return __awaiter(this, void 0, void 0, function*() {
            return new Promise(f=>__awaiter(this, void 0, void 0, function*() {
                let m = !1
                  , k = null;
                const y = ()=>{
                    m || (m = !0,
                    this.removeBridgeAndSession().then(f))
                }
                ;
                try {
                    this.closeGateways();
                    const ee = createAbortController(d == null ? void 0 : d.signal);
                    k = setTimeout(()=>{
                        ee.abort()
                    }
                    , this.defaultOpeningDeadlineMS),
                    yield this.sendRequest({
                        method: "disconnect",
                        params: []
                    }, {
                        onRequestSent: y,
                        signal: ee.signal,
                        attempts: 1
                    })
                } catch (ee) {
                    logDebug$1("Disconnect error:", ee),
                    m || this.removeBridgeAndSession().then(f)
                } finally {
                    k && clearTimeout(k),
                    y()
                }
            }))
        })
    }
    listen(d) {
        return this.listeners.push(d),
        ()=>this.listeners = this.listeners.filter(f=>f !== d)
    }
    pause() {
        var d;
        (d = this.gateway) === null || d === void 0 || d.pause(),
        this.pendingGateways.forEach(f=>f.pause())
    }
    unPause() {
        return __awaiter(this, void 0, void 0, function*() {
            const d = this.pendingGateways.map(f=>f.unPause());
            this.gateway && d.push(this.gateway.unPause()),
            yield Promise.all(d)
        })
    }
    pendingGatewaysListener(d, f, m) {
        return __awaiter(this, void 0, void 0, function*() {
            if (!this.pendingGateways.includes(d)) {
                yield d.close();
                return
            }
            return this.closeGateways({
                except: d
            }),
            this.gateway && (logDebug$1("Gateway is already opened, closing previous gateway"),
            yield this.gateway.close()),
            this.session.bridgeUrl = f,
            this.gateway = d,
            this.gateway.setErrorsListener(this.gatewayErrorsListener.bind(this)),
            this.gateway.setListener(this.gatewayListener.bind(this)),
            this.gatewayListener(m)
        })
    }
    gatewayListener(d) {
        return __awaiter(this, void 0, void 0, function*() {
            const f = JSON.parse(this.session.sessionCrypto.decrypt(Base64.decode(d.message).toUint8Array(), hexToByteArray(d.from)));
            if (logDebug$1("Wallet message received:", f),
            !("event"in f)) {
                const k = f.id.toString()
                  , y = this.pendingRequests.get(k);
                if (!y) {
                    logDebug$1(`Response id ${k} doesn't match any request's id`);
                    return
                }
                y(f),
                this.pendingRequests.delete(k);
                return
            }
            if (f.id !== void 0) {
                const k = yield this.connectionStorage.getLastWalletEventId();
                if (k !== void 0 && f.id <= k) {
                    logError$1(`Received event id (=${f.id}) must be greater than stored last wallet event id (=${k}) `);
                    return
                }
                f.event !== "connect" && (yield this.connectionStorage.storeLastWalletEventId(f.id))
            }
            const m = this.listeners;
            f.event === "connect" && (yield this.updateSession(f, d.from)),
            f.event === "disconnect" && (logDebug$1("Removing bridge and session: received disconnect event"),
            yield this.removeBridgeAndSession()),
            m.forEach(k=>k(f))
        })
    }
    gatewayErrorsListener(d) {
        return __awaiter(this, void 0, void 0, function*() {
            throw new TonConnectError(`Bridge error ${JSON.stringify(d)}`)
        })
    }
    updateSession(d, f) {
        return __awaiter(this, void 0, void 0, function*() {
            this.session = Object.assign(Object.assign({}, this.session), {
                walletPublicKey: f
            });
            const m = d.payload.items.find(y=>y.name === "ton_addr")
              , k = Object.assign(Object.assign({}, d), {
                payload: Object.assign(Object.assign({}, d.payload), {
                    items: [m]
                })
            });
            yield this.connectionStorage.storeConnection({
                type: "http",
                session: this.session,
                lastWalletEventId: d.id,
                connectEvent: k,
                nextRpcRequestId: 0
            })
        })
    }
    removeBridgeAndSession() {
        return __awaiter(this, void 0, void 0, function*() {
            this.closeConnection(),
            yield this.connectionStorage.removeConnection()
        })
    }
    generateUniversalLink(d, f) {
        return isTelegramUrl(d) ? this.generateTGUniversalLink(d, f) : this.generateRegularUniversalLink(d, f)
    }
    generateRegularUniversalLink(d, f) {
        const m = new URL(d);
        return m.searchParams.append("v", PROTOCOL_VERSION.toString()),
        m.searchParams.append("id", this.session.sessionCrypto.sessionId),
        m.searchParams.append("r", JSON.stringify(f)),
        m.toString()
    }
    generateTGUniversalLink(d, f) {
        const k = this.generateRegularUniversalLink("about:blank", f).split("?")[1]
          , y = "tonconnect-" + encodeTelegramUrlParameters(k)
          , ee = this.convertToDirectLink(d)
          , dt = new URL(ee);
        return dt.searchParams.append("startapp", y),
        dt.toString()
    }
    convertToDirectLink(d) {
        const f = new URL(d);
        return f.searchParams.has("attach") && (f.searchParams.delete("attach"),
        f.pathname += "/start"),
        f.toString()
    }
    openGateways(d, f) {
        return __awaiter(this, void 0, void 0, function*() {
            if (Array.isArray(this.walletConnectionSource)) {
                this.pendingGateways.map(m=>m.close().catch()),
                this.pendingGateways = this.walletConnectionSource.map(m=>{
                    const k = new BridgeGateway(this.storage,m.bridgeUrl,d.sessionId,()=>{}
                    ,()=>{}
                    );
                    return k.setListener(y=>this.pendingGatewaysListener(k, m.bridgeUrl, y)),
                    k
                }
                ),
                yield Promise.allSettled(this.pendingGateways.map(m=>callForSuccess(k=>this.pendingGateways.some(y=>y === m) ? m.registerSession({
                    openingDeadlineMS: f == null ? void 0 : f.openingDeadlineMS,
                    signal: k.signal
                }) : m.close(), {
                    attempts: Number.MAX_SAFE_INTEGER,
                    delayMs: 5e3,
                    signal: f == null ? void 0 : f.signal
                })));
                return
            } else
                return this.gateway && (logDebug$1("Gateway is already opened, closing previous gateway"),
                yield this.gateway.close()),
                this.gateway = new BridgeGateway(this.storage,this.walletConnectionSource.bridgeUrl,d.sessionId,this.gatewayListener.bind(this),this.gatewayErrorsListener.bind(this)),
                yield this.gateway.registerSession({
                    openingDeadlineMS: f == null ? void 0 : f.openingDeadlineMS,
                    signal: f == null ? void 0 : f.signal
                })
        })
    }
    closeGateways(d) {
        var f;
        (f = this.gateway) === null || f === void 0 || f.close(),
        this.pendingGateways.filter(m=>m !== (d == null ? void 0 : d.except)).forEach(m=>m.close()),
        this.pendingGateways = []
    }
}
function hasProperty(r, d) {
    return hasProperties(r, [d])
}
function hasProperties(r, d) {
    return !r || typeof r != "object" ? !1 : d.every(f=>f in r)
}
function isJSBridgeWithMetadata(r) {
    try {
        return !hasProperty(r, "tonconnect") || !hasProperty(r.tonconnect, "walletInfo") ? !1 : hasProperties(r.tonconnect.walletInfo, ["name", "app_name", "image", "about_url", "platforms"])
    } catch {
        return !1
    }
}
let InMemoryStorage$1 = class Kn {
    constructor() {
        this.storage = {}
    }
    static getInstance() {
        return Kn.instance || (Kn.instance = new Kn),
        Kn.instance
    }
    get length() {
        return Object.keys(this.storage).length
    }
    clear() {
        this.storage = {}
    }
    getItem(d) {
        var f;
        return (f = this.storage[d]) !== null && f !== void 0 ? f : null
    }
    key(d) {
        var f;
        const m = Object.keys(this.storage);
        return d < 0 || d >= m.length ? null : (f = m[d]) !== null && f !== void 0 ? f : null
    }
    removeItem(d) {
        delete this.storage[d]
    }
    setItem(d, f) {
        this.storage[d] = f
    }
}
;
function getWindow$2() {
    if (!(typeof window > "u"))
        return window
}
function tryGetWindowKeys() {
    const r = getWindow$2();
    if (!r)
        return [];
    try {
        return Object.keys(r)
    } catch {
        return []
    }
}
function getDocument() {
    if (!(typeof document > "u"))
        return document
}
function getWebPageManifest() {
    var r;
    const d = (r = getWindow$2()) === null || r === void 0 ? void 0 : r.location.origin;
    return d ? d + "/tonconnect-manifest.json" : ""
}
function tryGetLocalStorage$1() {
    if (isLocalStorageAvailable$1())
        return localStorage;
    if (isNodeJs$1())
        throw new TonConnectError("`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector");
    return InMemoryStorage$1.getInstance()
}
function isLocalStorageAvailable$1() {
    try {
        return typeof localStorage < "u"
    } catch {
        return !1
    }
}
function isNodeJs$1() {
    return typeof process$1 < "u" && process$1.versions != null && process$1.versions.node != null
}
class InjectedProvider {
    constructor(d, f) {
        this.injectedWalletKey = f,
        this.type = "injected",
        this.unsubscribeCallback = null,
        this.listenSubscriptions = !1,
        this.listeners = [];
        const m = InjectedProvider.window;
        if (!InjectedProvider.isWindowContainsWallet(m, f))
            throw new WalletNotInjectedError;
        this.connectionStorage = new BridgeConnectionStorage(d),
        this.injectedWallet = m[f].tonconnect
    }
    static fromStorage(d) {
        return __awaiter(this, void 0, void 0, function*() {
            const m = yield new BridgeConnectionStorage(d).getInjectedConnection();
            return new InjectedProvider(d,m.jsBridgeKey)
        })
    }
    static isWalletInjected(d) {
        return InjectedProvider.isWindowContainsWallet(this.window, d)
    }
    static isInsideWalletBrowser(d) {
        return InjectedProvider.isWindowContainsWallet(this.window, d) ? this.window[d].tonconnect.isWalletBrowser : !1
    }
    static getCurrentlyInjectedWallets() {
        return this.window ? tryGetWindowKeys().filter(([m,k])=>isJSBridgeWithMetadata(k)).map(([m,k])=>({
            name: k.tonconnect.walletInfo.name,
            appName: k.tonconnect.walletInfo.app_name,
            aboutUrl: k.tonconnect.walletInfo.about_url,
            imageUrl: k.tonconnect.walletInfo.image,
            tondns: k.tonconnect.walletInfo.tondns,
            jsBridgeKey: m,
            injected: !0,
            embedded: k.tonconnect.isWalletBrowser,
            platforms: k.tonconnect.walletInfo.platforms
        })) : []
    }
    static isWindowContainsWallet(d, f) {
        return !!d && f in d && typeof d[f] == "object" && "tonconnect"in d[f]
    }
    connect(d) {
        this._connect(PROTOCOL_VERSION, d)
    }
    restoreConnection() {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                logDebug$1("Injected Provider restoring connection...");
                const d = yield this.injectedWallet.restoreConnection();
                logDebug$1("Injected Provider restoring connection response", d),
                d.event === "connect" ? (this.makeSubscriptions(),
                this.listeners.forEach(f=>f(d))) : yield this.connectionStorage.removeConnection()
            } catch (d) {
                yield this.connectionStorage.removeConnection(),
                console.error(d)
            }
        })
    }
    closeConnection() {
        this.listenSubscriptions && this.injectedWallet.disconnect(),
        this.closeAllListeners()
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function*() {
            return new Promise(d=>{
                const f = ()=>{
                    this.closeAllListeners(),
                    this.connectionStorage.removeConnection().then(d)
                }
                ;
                try {
                    this.injectedWallet.disconnect(),
                    f()
                } catch (m) {
                    logDebug$1(m),
                    this.sendRequest({
                        method: "disconnect",
                        params: []
                    }, f)
                }
            }
            )
        })
    }
    closeAllListeners() {
        var d;
        this.listenSubscriptions = !1,
        this.listeners = [],
        (d = this.unsubscribeCallback) === null || d === void 0 || d.call(this)
    }
    listen(d) {
        return this.listeners.push(d),
        ()=>this.listeners = this.listeners.filter(f=>f !== d)
    }
    sendRequest(d, f) {
        var m;
        return __awaiter(this, void 0, void 0, function*() {
            const k = {};
            typeof f == "function" ? k.onRequestSent = f : (k.onRequestSent = f == null ? void 0 : f.onRequestSent,
            k.signal = f == null ? void 0 : f.signal);
            const y = (yield this.connectionStorage.getNextRpcRequestId()).toString();
            yield this.connectionStorage.increaseNextRpcRequestId(),
            logDebug$1("Send injected-bridge request:", Object.assign(Object.assign({}, d), {
                id: y
            }));
            const ee = this.injectedWallet.send(Object.assign(Object.assign({}, d), {
                id: y
            }));
            return ee.then(dt=>logDebug$1("Wallet message received:", dt)),
            (m = k == null ? void 0 : k.onRequestSent) === null || m === void 0 || m.call(k),
            ee
        })
    }
    _connect(d, f) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                logDebug$1(`Injected Provider connect request: protocolVersion: ${d}, message:`, f);
                const m = yield this.injectedWallet.connect(d, f);
                logDebug$1("Injected Provider connect response:", m),
                m.event === "connect" && (yield this.updateSession(),
                this.makeSubscriptions()),
                this.listeners.forEach(k=>k(m))
            } catch (m) {
                logDebug$1("Injected Provider connect error:", m);
                const k = {
                    event: "connect_error",
                    payload: {
                        code: 0,
                        message: m == null ? void 0 : m.toString()
                    }
                };
                this.listeners.forEach(y=>y(k))
            }
        })
    }
    makeSubscriptions() {
        this.listenSubscriptions = !0,
        this.unsubscribeCallback = this.injectedWallet.listen(d=>{
            logDebug$1("Wallet message received:", d),
            this.listenSubscriptions && this.listeners.forEach(f=>f(d)),
            d.event === "disconnect" && this.disconnect()
        }
        )
    }
    updateSession() {
        return this.connectionStorage.storeConnection({
            type: "injected",
            jsBridgeKey: this.injectedWalletKey,
            nextRpcRequestId: 0
        })
    }
}
InjectedProvider.window = getWindow$2();
class DefaultStorage {
    constructor() {
        this.localStorage = tryGetLocalStorage$1()
    }
    getItem(d) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.localStorage.getItem(d)
        })
    }
    removeItem(d) {
        return __awaiter(this, void 0, void 0, function*() {
            this.localStorage.removeItem(d)
        })
    }
    setItem(d, f) {
        return __awaiter(this, void 0, void 0, function*() {
            this.localStorage.setItem(d, f)
        })
    }
}
function isWalletInfoCurrentlyInjected(r) {
    return isWalletInfoInjectable(r) && r.injected
}
function isWalletInfoCurrentlyEmbedded(r) {
    return isWalletInfoCurrentlyInjected(r) && r.embedded
}
function isWalletInfoInjectable(r) {
    return "jsBridgeKey"in r
}
function isWalletInfoRemote(r) {
    return "bridgeUrl"in r
}
const FALLBACK_WALLETS_LIST = [{
    app_name: "telegram-wallet",
    name: "Wallet",
    image: "https://wallet.tg/images/logo-288.png",
    about_url: "https://wallet.tg/",
    universal_url: "https://t.me/wallet?attach=wallet",
    bridge: [{
        type: "sse",
        url: "https://bridge.tonapi.io/bridge"
    }],
    platforms: ["ios", "android", "macos", "windows", "linux"]
}, {
    app_name: "tonkeeper",
    name: "Tonkeeper",
    image: "https://tonkeeper.com/assets/tonconnect-icon.png",
    tondns: "tonkeeper.ton",
    about_url: "https://tonkeeper.com",
    universal_url: "https://app.tonkeeper.com/ton-connect",
    deepLink: "tonkeeper-tc://",
    bridge: [{
        type: "sse",
        url: "https://bridge.tonapi.io/bridge"
    }, {
        type: "js",
        key: "tonkeeper"
    }],
    platforms: ["ios", "android", "chrome", "firefox", "macos"]
}, {
    app_name: "mytonwallet",
    name: "MyTonWallet",
    image: "https://mytonwallet.io/icon-256.png",
    about_url: "https://mytonwallet.io",
    universal_url: "https://connect.mytonwallet.org",
    bridge: [{
        type: "js",
        key: "mytonwallet"
    }, {
        type: "sse",
        url: "https://tonconnectbridge.mytonwallet.org/bridge/"
    }],
    platforms: ["chrome", "windows", "macos", "linux", "ios", "android", "firefox"]
}, {
    app_name: "openmask",
    name: "OpenMask",
    image: "https://raw.githubusercontent.com/OpenProduct/openmask-extension/main/public/openmask-logo-288.png",
    about_url: "https://www.openmask.app/",
    bridge: [{
        type: "js",
        key: "openmask"
    }],
    platforms: ["chrome"]
}, {
    app_name: "tonhub",
    name: "Tonhub",
    image: "https://tonhub.com/tonconnect_logo.png",
    about_url: "https://tonhub.com",
    universal_url: "https://tonhub.com/ton-connect",
    bridge: [{
        type: "js",
        key: "tonhub"
    }, {
        type: "sse",
        url: "https://connect.tonhubapi.com/tonconnect"
    }],
    platforms: ["ios", "android"]
}, {
    app_name: "dewallet",
    name: "DeWallet",
    image: "https://app.delabwallet.com/logo_black.png",
    about_url: "https://delabwallet.com",
    bridge: [{
        type: "js",
        key: "dewallet"
    }],
    platforms: ["chrome"]
}, {
    app_name: "xtonwallet",
    name: "XTONWallet",
    image: "https://xtonwallet.com/assets/img/icon-256-back.png",
    about_url: "https://xtonwallet.com",
    bridge: [{
        type: "js",
        key: "xtonwallet"
    }],
    platforms: ["chrome", "firefox"]
}, {
    app_name: "tonwallet",
    name: "TON Wallet",
    image: "https://wallet.ton.org/assets/ui/qr-logo.png",
    about_url: "https://chrome.google.com/webstore/detail/ton-wallet/nphplpgoakhhjchkkhmiggakijnkhfnd",
    bridge: [{
        type: "js",
        key: "tonwallet"
    }],
    platforms: ["chrome"]
}];
class WalletsListManager {
    constructor(d) {
        this.walletsListCache = null,
        this.walletsListCacheCreationTimestamp = null,
        this.walletsListSource = "https://raw.githubusercontent.com/ton-blockchain/wallets-list/main/wallets-v2.json",
        d != null && d.walletsListSource && (this.walletsListSource = d.walletsListSource),
        d != null && d.cacheTTLMs && (this.cacheTTLMs = d.cacheTTLMs)
    }
    getWallets() {
        return __awaiter(this, void 0, void 0, function*() {
            return this.cacheTTLMs && this.walletsListCacheCreationTimestamp && Date.now() > this.walletsListCacheCreationTimestamp + this.cacheTTLMs && (this.walletsListCache = null),
            this.walletsListCache || (this.walletsListCache = this.fetchWalletsList(),
            this.walletsListCache.then(()=>{
                this.walletsListCacheCreationTimestamp = Date.now()
            }
            ).catch(()=>{
                this.walletsListCache = null,
                this.walletsListCacheCreationTimestamp = null
            }
            )),
            this.walletsListCache
        })
    }
    getEmbeddedWallet() {
        return __awaiter(this, void 0, void 0, function*() {
            const f = (yield this.getWallets()).filter(isWalletInfoCurrentlyEmbedded);
            return f.length !== 1 ? null : f[0]
        })
    }
    fetchWalletsList() {
        return __awaiter(this, void 0, void 0, function*() {
            let d = [];
            try {
                if (d = yield(yield fetch(this.walletsListSource)).json(),
                !Array.isArray(d))
                    throw new FetchWalletsError("Wrong wallets list format, wallets list must be an array.");
                const k = d.filter(y=>!this.isCorrectWalletConfigDTO(y));
                k.length && (logError$1(`Wallet(s) ${k.map(y=>y.name).join(", ")} config format is wrong. They were removed from the wallets list.`),
                d = d.filter(y=>this.isCorrectWalletConfigDTO(y)))
            } catch (m) {
                logError$1(m),
                d = FALLBACK_WALLETS_LIST
            }
            let f = [];
            try {
                f = InjectedProvider.getCurrentlyInjectedWallets()
            } catch (m) {
                logError$1(m)
            }
            return this.mergeWalletsLists(this.walletConfigDTOListToWalletConfigList(d), f)
        })
    }
    walletConfigDTOListToWalletConfigList(d) {
        return d.map(f=>{
            const k = {
                name: f.name,
                appName: f.app_name,
                imageUrl: f.image,
                aboutUrl: f.about_url,
                tondns: f.tondns,
                platforms: f.platforms
            };
            return f.bridge.forEach(y=>{
                if (y.type === "sse" && (k.bridgeUrl = y.url,
                k.universalLink = f.universal_url,
                k.deepLink = f.deepLink),
                y.type === "js") {
                    const ee = y.key;
                    k.jsBridgeKey = ee,
                    k.injected = InjectedProvider.isWalletInjected(ee),
                    k.embedded = InjectedProvider.isInsideWalletBrowser(ee)
                }
            }
            ),
            k
        }
        )
    }
    mergeWalletsLists(d, f) {
        return [...new Set(d.concat(f).map(k=>k.name)).values()].map(k=>{
            const y = d.find(dt=>dt.name === k)
              , ee = f.find(dt=>dt.name === k);
            return Object.assign(Object.assign({}, y && Object.assign({}, y)), ee && Object.assign({}, ee))
        }
        )
    }
    isCorrectWalletConfigDTO(d) {
        if (!d || typeof d != "object")
            return !1;
        const f = "name"in d
          , m = "app_name"in d
          , k = "image"in d
          , y = "about_url"in d
          , ee = "platforms"in d;
        if (!f || !k || !y || !ee || !m || !d.platforms || !Array.isArray(d.platforms) || !d.platforms.length || !("bridge"in d) || !Array.isArray(d.bridge) || !d.bridge.length)
            return !1;
        const dt = d.bridge;
        if (dt.some(pt=>!pt || typeof pt != "object" || !("type"in pt)))
            return !1;
        const mt = dt.find(pt=>pt.type === "sse");
        if (mt && (!("url"in mt) || !mt.url || !d.universal_url))
            return !1;
        const yt = dt.find(pt=>pt.type === "js");
        return !(yt && (!("key"in yt) || !yt.key))
    }
}
class WalletNotSupportFeatureError extends TonConnectError {
    get info() {
        return "Wallet doesn't support requested feature method."
    }
    constructor(...d) {
        super(...d),
        Object.setPrototypeOf(this, WalletNotSupportFeatureError.prototype)
    }
}
function checkSendTransactionSupport(r, d) {
    const f = r.includes("SendTransaction")
      , m = r.find(k=>k && typeof k == "object" && k.name === "SendTransaction");
    if (!f && !m)
        throw new WalletNotSupportFeatureError("Wallet doesn't support SendTransaction feature.");
    if (m && m.maxMessages !== void 0) {
        if (m.maxMessages < d.requiredMessagesNumber)
            throw new WalletNotSupportFeatureError(`Wallet is not able to handle such SendTransaction request. Max support messages number is ${m.maxMessages}, but ${d.requiredMessagesNumber} is required.`);
        return
    }
    logWarning$1("Connected wallet didn't provide information about max allowed messages in the SendTransaction request. Request may be rejected by the wallet.")
}
function createRequestVersionEvent() {
    return {
        type: "request-version"
    }
}
function createResponseVersionEvent(r) {
    return {
        type: "response-version",
        version: r
    }
}
function createVersionInfo(r) {
    return {
        ton_connect_sdk_lib: r.ton_connect_sdk_lib,
        ton_connect_ui_lib: r.ton_connect_ui_lib
    }
}
function createConnectionInfo(r, d) {
    var f, m, k, y, ee, dt, mt, yt;
    const bt = ((f = d == null ? void 0 : d.connectItems) === null || f === void 0 ? void 0 : f.tonProof) && "proof"in d.connectItems.tonProof ? "ton_proof" : "ton_addr";
    return {
        wallet_address: (k = (m = d == null ? void 0 : d.account) === null || m === void 0 ? void 0 : m.address) !== null && k !== void 0 ? k : null,
        wallet_type: (y = d == null ? void 0 : d.device.appName) !== null && y !== void 0 ? y : null,
        wallet_version: (ee = d == null ? void 0 : d.device.appVersion) !== null && ee !== void 0 ? ee : null,
        auth_type: bt,
        custom_data: Object.assign({
            chain_id: (mt = (dt = d == null ? void 0 : d.account) === null || dt === void 0 ? void 0 : dt.chain) !== null && mt !== void 0 ? mt : null,
            provider: (yt = d == null ? void 0 : d.provider) !== null && yt !== void 0 ? yt : null
        }, createVersionInfo(r))
    }
}
function createConnectionStartedEvent(r) {
    return {
        type: "connection-started",
        custom_data: createVersionInfo(r)
    }
}
function createConnectionCompletedEvent(r, d) {
    return Object.assign({
        type: "connection-completed",
        is_success: !0
    }, createConnectionInfo(r, d))
}
function createConnectionErrorEvent(r, d, f) {
    return {
        type: "connection-error",
        is_success: !1,
        error_message: d,
        error_code: f ?? null,
        custom_data: createVersionInfo(r)
    }
}
function createConnectionRestoringStartedEvent(r) {
    return {
        type: "connection-restoring-started",
        custom_data: createVersionInfo(r)
    }
}
function createConnectionRestoringCompletedEvent(r, d) {
    return Object.assign({
        type: "connection-restoring-completed",
        is_success: !0
    }, createConnectionInfo(r, d))
}
function createConnectionRestoringErrorEvent(r, d) {
    return {
        type: "connection-restoring-error",
        is_success: !1,
        error_message: d,
        custom_data: createVersionInfo(r)
    }
}
function createTransactionInfo(r, d) {
    var f, m, k, y;
    return {
        valid_until: (f = String(d.validUntil)) !== null && f !== void 0 ? f : null,
        from: (y = (m = d.from) !== null && m !== void 0 ? m : (k = r == null ? void 0 : r.account) === null || k === void 0 ? void 0 : k.address) !== null && y !== void 0 ? y : null,
        messages: d.messages.map(ee=>{
            var dt, mt;
            return {
                address: (dt = ee.address) !== null && dt !== void 0 ? dt : null,
                amount: (mt = ee.amount) !== null && mt !== void 0 ? mt : null
            }
        }
        )
    }
}
function createTransactionSentForSignatureEvent(r, d, f) {
    return Object.assign(Object.assign({
        type: "transaction-sent-for-signature"
    }, createConnectionInfo(r, d)), createTransactionInfo(d, f))
}
function createTransactionSignedEvent(r, d, f, m) {
    return Object.assign(Object.assign({
        type: "transaction-signed",
        is_success: !0,
        signed_transaction: m.boc
    }, createConnectionInfo(r, d)), createTransactionInfo(d, f))
}
function createTransactionSigningFailedEvent(r, d, f, m, k) {
    return Object.assign(Object.assign({
        type: "transaction-signing-failed",
        is_success: !1,
        error_message: m,
        error_code: k ?? null
    }, createConnectionInfo(r, d)), createTransactionInfo(d, f))
}
function createDisconnectionEvent(r, d, f) {
    return Object.assign({
        type: "disconnection",
        scope: f
    }, createConnectionInfo(r, d))
}
class BrowserEventDispatcher {
    constructor() {
        this.window = getWindow$2()
    }
    dispatchEvent(d, f) {
        var m;
        return __awaiter(this, void 0, void 0, function*() {
            const k = new CustomEvent(d,{
                detail: f
            });
            (m = this.window) === null || m === void 0 || m.dispatchEvent(k)
        })
    }
    addEventListener(d, f, m) {
        var k;
        return __awaiter(this, void 0, void 0, function*() {
            return (k = this.window) === null || k === void 0 || k.addEventListener(d, f, m),
            ()=>{
                var y;
                return (y = this.window) === null || y === void 0 ? void 0 : y.removeEventListener(d, f)
            }
        })
    }
}
class TonConnectTracker {
    constructor(d) {
        var f;
        this.eventPrefix = "ton-connect-",
        this.tonConnectUiVersion = null,
        this.eventDispatcher = (f = d == null ? void 0 : d.eventDispatcher) !== null && f !== void 0 ? f : new BrowserEventDispatcher,
        this.tonConnectSdkVersion = d.tonConnectSdkVersion,
        this.init().catch()
    }
    get version() {
        return createVersionInfo({
            ton_connect_sdk_lib: this.tonConnectSdkVersion,
            ton_connect_ui_lib: this.tonConnectUiVersion
        })
    }
    init() {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                yield this.setRequestVersionHandler(),
                this.tonConnectUiVersion = yield this.requestTonConnectUiVersion()
            } catch {}
        })
    }
    setRequestVersionHandler() {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.eventDispatcher.addEventListener("ton-connect-request-version", ()=>__awaiter(this, void 0, void 0, function*() {
                yield this.eventDispatcher.dispatchEvent("ton-connect-response-version", createResponseVersionEvent(this.tonConnectSdkVersion))
            }))
        })
    }
    requestTonConnectUiVersion() {
        return __awaiter(this, void 0, void 0, function*() {
            return new Promise((d,f)=>__awaiter(this, void 0, void 0, function*() {
                try {
                    yield this.eventDispatcher.addEventListener("ton-connect-ui-response-version", m=>{
                        d(m.detail.version)
                    }
                    , {
                        once: !0
                    }),
                    yield this.eventDispatcher.dispatchEvent("ton-connect-ui-request-version", createRequestVersionEvent())
                } catch (m) {
                    f(m)
                }
            }))
        })
    }
    dispatchUserActionEvent(d) {
        try {
            this.eventDispatcher.dispatchEvent(`${this.eventPrefix}${d.type}`, d).catch()
        } catch {}
    }
    trackConnectionStarted(...d) {
        try {
            const f = createConnectionStartedEvent(this.version, ...d);
            this.dispatchUserActionEvent(f)
        } catch {}
    }
    trackConnectionCompleted(...d) {
        try {
            const f = createConnectionCompletedEvent(this.version, ...d);
            this.dispatchUserActionEvent(f)
        } catch {}
    }
    trackConnectionError(...d) {
        try {
            const f = createConnectionErrorEvent(this.version, ...d);
            this.dispatchUserActionEvent(f)
        } catch {}
    }
    trackConnectionRestoringStarted(...d) {
        try {
            const f = createConnectionRestoringStartedEvent(this.version, ...d);
            this.dispatchUserActionEvent(f)
        } catch {}
    }
    trackConnectionRestoringCompleted(...d) {
        try {
            const f = createConnectionRestoringCompletedEvent(this.version, ...d);
            this.dispatchUserActionEvent(f)
        } catch {}
    }
    trackConnectionRestoringError(...d) {
        try {
            const f = createConnectionRestoringErrorEvent(this.version, ...d);
            this.dispatchUserActionEvent(f)
        } catch {}
    }
    trackDisconnection(...d) {
        try {
            const f = createDisconnectionEvent(this.version, ...d);
            this.dispatchUserActionEvent(f)
        } catch {}
    }
    trackTransactionSentForSignature(...d) {
        try {
            const f = createTransactionSentForSignatureEvent(this.version, ...d);
            this.dispatchUserActionEvent(f)
        } catch {}
    }
    trackTransactionSigned(...d) {
        try {
            const f = createTransactionSignedEvent(this.version, ...d);
            this.dispatchUserActionEvent(f)
        } catch {}
    }
    trackTransactionSigningFailed(...d) {
        try {
            const f = createTransactionSigningFailedEvent(this.version, ...d);
            this.dispatchUserActionEvent(f)
        } catch {}
    }
}
const tonConnectSdkVersion = "3.0.3";
class TonConnect {
    constructor(d) {
        if (this.walletsList = new WalletsListManager,
        this._wallet = null,
        this.provider = null,
        this.statusChangeSubscriptions = [],
        this.statusChangeErrorSubscriptions = [],
        this.dappSettings = {
            manifestUrl: (d == null ? void 0 : d.manifestUrl) || getWebPageManifest(),
            storage: (d == null ? void 0 : d.storage) || new DefaultStorage
        },
        this.walletsList = new WalletsListManager({
            walletsListSource: d == null ? void 0 : d.walletsListSource,
            cacheTTLMs: d == null ? void 0 : d.walletsListCacheTTLMs
        }),
        this.tracker = new TonConnectTracker({
            eventDispatcher: d == null ? void 0 : d.eventDispatcher,
            tonConnectSdkVersion
        }),
        !this.dappSettings.manifestUrl)
            throw new DappMetadataError("Dapp tonconnect-manifest.json must be specified if window.location.origin is undefined. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest");
        this.bridgeConnectionStorage = new BridgeConnectionStorage(this.dappSettings.storage),
        d != null && d.disableAutoPauseConnection || this.addWindowFocusAndBlurSubscriptions()
    }
    static getWallets() {
        return this.walletsList.getWallets()
    }
    get connected() {
        return this._wallet !== null
    }
    get account() {
        var d;
        return ((d = this._wallet) === null || d === void 0 ? void 0 : d.account) || null
    }
    get wallet() {
        return this._wallet
    }
    set wallet(d) {
        this._wallet = d,
        this.statusChangeSubscriptions.forEach(f=>f(this._wallet))
    }
    getWallets() {
        return this.walletsList.getWallets()
    }
    onStatusChange(d, f) {
        return this.statusChangeSubscriptions.push(d),
        f && this.statusChangeErrorSubscriptions.push(f),
        ()=>{
            this.statusChangeSubscriptions = this.statusChangeSubscriptions.filter(m=>m !== d),
            f && (this.statusChangeErrorSubscriptions = this.statusChangeErrorSubscriptions.filter(m=>m !== f))
        }
    }
    connect(d, f) {
        var m, k;
        const y = {};
        if (typeof f == "object" && "tonProof"in f && (y.request = f),
        typeof f == "object" && ("openingDeadlineMS"in f || "signal"in f || "request"in f) && (y.request = f == null ? void 0 : f.request,
        y.openingDeadlineMS = f == null ? void 0 : f.openingDeadlineMS,
        y.signal = f == null ? void 0 : f.signal),
        this.connected)
            throw new WalletAlreadyConnectedError;
        const ee = createAbortController(y == null ? void 0 : y.signal);
        if ((m = this.abortController) === null || m === void 0 || m.abort(),
        this.abortController = ee,
        ee.signal.aborted)
            throw new TonConnectError("Connection was aborted");
        return (k = this.provider) === null || k === void 0 || k.closeConnection(),
        this.provider = this.createProvider(d),
        ee.signal.addEventListener("abort", ()=>{
            var dt;
            (dt = this.provider) === null || dt === void 0 || dt.closeConnection(),
            this.provider = null
        }
        ),
        this.tracker.trackConnectionStarted(),
        this.provider.connect(this.createConnectRequest(y == null ? void 0 : y.request), {
            openingDeadlineMS: y == null ? void 0 : y.openingDeadlineMS,
            signal: ee.signal
        })
    }
    restoreConnection(d) {
        var f, m;
        return __awaiter(this, void 0, void 0, function*() {
            this.tracker.trackConnectionRestoringStarted();
            const k = createAbortController(d == null ? void 0 : d.signal);
            if ((f = this.abortController) === null || f === void 0 || f.abort(),
            this.abortController = k,
            k.signal.aborted) {
                this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
                return
            }
            const [y,ee] = yield Promise.all([this.bridgeConnectionStorage.storedConnectionType(), this.walletsList.getEmbeddedWallet()]);
            if (k.signal.aborted) {
                this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
                return
            }
            let dt = null;
            try {
                switch (y) {
                case "http":
                    dt = yield BridgeProvider.fromStorage(this.dappSettings.storage);
                    break;
                case "injected":
                    dt = yield InjectedProvider.fromStorage(this.dappSettings.storage);
                    break;
                default:
                    if (ee)
                        dt = this.createProvider(ee);
                    else
                        return
                }
            } catch {
                this.tracker.trackConnectionRestoringError("Provider is not restored"),
                yield this.bridgeConnectionStorage.removeConnection(),
                dt == null || dt.closeConnection(),
                dt = null;
                return
            }
            if (k.signal.aborted) {
                dt == null || dt.closeConnection(),
                this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
                return
            }
            if (!dt) {
                logError$1("Provider is not restored"),
                this.tracker.trackConnectionRestoringError("Provider is not restored");
                return
            }
            (m = this.provider) === null || m === void 0 || m.closeConnection(),
            this.provider = dt,
            dt.listen(this.walletEventsListener.bind(this));
            const mt = ()=>{
                this.tracker.trackConnectionRestoringError("Connection restoring was aborted"),
                dt == null || dt.closeConnection(),
                dt = null
            }
            ;
            return k.signal.addEventListener("abort", mt),
            yield callForSuccess(yt=>__awaiter(this, void 0, void 0, function*() {
                yield dt == null ? void 0 : dt.restoreConnection({
                    openingDeadlineMS: d == null ? void 0 : d.openingDeadlineMS,
                    signal: yt.signal
                }),
                k.signal.removeEventListener("abort", mt),
                this.connected ? this.tracker.trackConnectionRestoringCompleted(this.wallet) : this.tracker.trackConnectionRestoringError("Connection restoring failed")
            }), {
                attempts: Number.MAX_SAFE_INTEGER,
                delayMs: 5e3,
                signal: d == null ? void 0 : d.signal
            })
        })
    }
    sendTransaction(d, f) {
        return __awaiter(this, void 0, void 0, function*() {
            const m = {};
            typeof f == "function" ? m.onRequestSent = f : (m.onRequestSent = f == null ? void 0 : f.onRequestSent,
            m.signal = f == null ? void 0 : f.signal);
            const k = createAbortController(m == null ? void 0 : m.signal);
            if (k.signal.aborted)
                throw new TonConnectError("Transaction sending was aborted");
            this.checkConnection(),
            checkSendTransactionSupport(this.wallet.device.features, {
                requiredMessagesNumber: d.messages.length
            }),
            this.tracker.trackTransactionSentForSignature(this.wallet, d);
            const {validUntil: y} = d
              , ee = __rest(d, ["validUntil"])
              , dt = d.from || this.account.address
              , mt = d.network || this.account.chain
              , yt = yield this.provider.sendRequest(sendTransactionParser.convertToRpcRequest(Object.assign(Object.assign({}, ee), {
                valid_until: y,
                from: dt,
                network: mt
            })), {
                onRequestSent: m.onRequestSent,
                signal: k.signal
            });
            if (sendTransactionParser.isError(yt))
                return this.tracker.trackTransactionSigningFailed(this.wallet, d, yt.error.message, yt.error.code),
                sendTransactionParser.parseAndThrowError(yt);
            const pt = sendTransactionParser.convertFromRpcResponse(yt);
            return this.tracker.trackTransactionSigned(this.wallet, d, pt),
            pt
        })
    }
    disconnect(d) {
        var f;
        return __awaiter(this, void 0, void 0, function*() {
            if (!this.connected)
                throw new WalletNotConnectedError;
            const m = createAbortController(d == null ? void 0 : d.signal)
              , k = this.abortController;
            if (this.abortController = m,
            m.signal.aborted)
                throw new TonConnectError("Disconnect was aborted");
            this.onWalletDisconnected("dapp"),
            yield(f = this.provider) === null || f === void 0 ? void 0 : f.disconnect({
                signal: m.signal
            }),
            k == null || k.abort()
        })
    }
    pauseConnection() {
        var d;
        ((d = this.provider) === null || d === void 0 ? void 0 : d.type) === "http" && this.provider.pause()
    }
    unPauseConnection() {
        var d;
        return ((d = this.provider) === null || d === void 0 ? void 0 : d.type) !== "http" ? Promise.resolve() : this.provider.unPause()
    }
    addWindowFocusAndBlurSubscriptions() {
        const d = getDocument();
        if (d)
            try {
                d.addEventListener("visibilitychange", ()=>{
                    d.hidden ? this.pauseConnection() : this.unPauseConnection().catch()
                }
                )
            } catch (f) {
                logError$1("Cannot subscribe to the document.visibilitychange: ", f)
            }
    }
    createProvider(d) {
        let f;
        return !Array.isArray(d) && isWalletConnectionSourceJS(d) ? f = new InjectedProvider(this.dappSettings.storage,d.jsBridgeKey) : f = new BridgeProvider(this.dappSettings.storage,d),
        f.listen(this.walletEventsListener.bind(this)),
        f
    }
    walletEventsListener(d) {
        switch (d.event) {
        case "connect":
            this.onWalletConnected(d.payload);
            break;
        case "connect_error":
            this.onWalletConnectError(d.payload);
            break;
        case "disconnect":
            this.onWalletDisconnected("wallet")
        }
    }
    onWalletConnected(d) {
        const f = d.items.find(y=>y.name === "ton_addr")
          , m = d.items.find(y=>y.name === "ton_proof");
        if (!f)
            throw new TonConnectError("ton_addr connection item was not found");
        const k = {
            device: d.device,
            provider: this.provider.type,
            account: {
                address: f.address,
                chain: f.network,
                walletStateInit: f.walletStateInit,
                publicKey: f.publicKey
            }
        };
        m && (k.connectItems = {
            tonProof: m
        }),
        this.wallet = k,
        this.tracker.trackConnectionCompleted(k)
    }
    onWalletConnectError(d) {
        const f = connectErrorsParser.parseError(d);
        if (this.statusChangeErrorSubscriptions.forEach(m=>m(f)),
        logDebug$1(f),
        this.tracker.trackConnectionError(d.message, d.code),
        f instanceof ManifestNotFoundError || f instanceof ManifestContentErrorError)
            throw logError$1(f),
            f
    }
    onWalletDisconnected(d) {
        this.tracker.trackDisconnection(this.wallet, d),
        this.wallet = null
    }
    checkConnection() {
        if (!this.connected)
            throw new WalletNotConnectedError
    }
    createConnectRequest(d) {
        const f = [{
            name: "ton_addr"
        }];
        return d != null && d.tonProof && f.push({
            name: "ton_proof",
            payload: d.tonProof
        }),
        {
            manifestUrl: this.dappSettings.manifestUrl,
            items: f
        }
    }
}
TonConnect.walletsList = new WalletsListManager;
TonConnect.isWalletInjected = r=>InjectedProvider.isWalletInjected(r);
TonConnect.isInsideWalletBrowser = r=>InjectedProvider.isInsideWalletBrowser(r);
const noBounceableTag = 81
  , testOnlyTag = 128;
function toUserFriendlyAddress(r, d=!1) {
    const {wc: f, hex: m} = parseHexAddress(r);
    let k = noBounceableTag;
    d && (k |= testOnlyTag);
    const y = new Int8Array(34);
    y[0] = k,
    y[1] = f,
    y.set(m, 2);
    const ee = new Uint8Array(36);
    return ee.set(y),
    ee.set(crc16$3(y), 34),
    Base64.encode(ee).replace(/\+/g, "-").replace(/\//g, "_")
}
function parseHexAddress(r) {
    if (!r.includes(":"))
        throw new WrongAddressError(`Wrong address ${r}. Address must include ":".`);
    const d = r.split(":");
    if (d.length !== 2)
        throw new WrongAddressError(`Wrong address ${r}. Address must include ":" only once.`);
    const f = parseInt(d[0]);
    if (f !== 0 && f !== -1)
        throw new WrongAddressError(`Wrong address ${r}. WC must be eq 0 or -1, but ${f} received.`);
    const m = d[1];
    if ((m == null ? void 0 : m.length) !== 64)
        throw new WrongAddressError(`Wrong address ${r}. Hex part must be 64bytes length, but ${m == null ? void 0 : m.length} received.`);
    return {
        wc: f,
        hex: hexToBytes(m)
    }
}
function crc16$3(r) {
    let f = 0;
    const m = new Uint8Array(r.length + 2);
    m.set(r);
    for (let k of m) {
        let y = 128;
        for (; y > 0; )
            f <<= 1,
            k & y && (f += 1),
            y >>= 1,
            f > 65535 && (f &= 65535,
            f ^= 4129)
    }
    return new Uint8Array([Math.floor(f / 256), f % 256])
}
const toByteMap = {};
for (let r = 0; r <= 255; r++) {
    let d = r.toString(16);
    d.length < 2 && (d = "0" + d),
    toByteMap[d] = r
}
function hexToBytes(r) {
    r = r.toLowerCase();
    const d = r.length;
    if (d % 2 !== 0)
        throw new ParseHexError("Hex string must have length a multiple of 2: " + r);
    const f = d / 2
      , m = new Uint8Array(f);
    for (let k = 0; k < f; k++) {
        const y = k * 2
          , ee = r.substring(y, y + 2);
        if (!toByteMap.hasOwnProperty(ee))
            throw new ParseHexError("Invalid hex character: " + ee);
        m[k] = toByteMap[ee]
    }
    return m
}
var uaParser = {
    exports: {}
};
(function(r, d) {
    (function(f, m) {
        var k = "1.0.38"
          , y = ""
          , ee = "?"
          , dt = "function"
          , mt = "undefined"
          , yt = "object"
          , pt = "string"
          , bt = "major"
          , wt = "model"
          , xt = "name"
          , At = "type"
          , Ct = "vendor"
          , Pt = "version"
          , $t = "architecture"
          , Ot = "console"
          , Nt = "mobile"
          , zt = "tablet"
          , Wt = "smarttv"
          , Kt = "wearable"
          , ir = "embedded"
          , or = 500
          , tr = "Amazon"
          , wr = "Apple"
          , Ht = "ASUS"
          , Mt = "BlackBerry"
          , _t = "Browser"
          , gt = "Chrome"
          , vt = "Edge"
          , Et = "Firefox"
          , Bt = "Google"
          , Rt = "Huawei"
          , kt = "LG"
          , Tt = "Microsoft"
          , It = "Motorola"
          , St = "Opera"
          , qt = "Samsung"
          , ur = "Sharp"
          , gr = "Sony"
          , lr = "Xiaomi"
          , Zt = "Zebra"
          , Vt = "Facebook"
          , rr = "Chromium OS"
          , fr = "Mac OS"
          , Yt = function(vr, ar) {
            var hr = {};
            for (var _r in vr)
                ar[_r] && ar[_r].length % 2 === 0 ? hr[_r] = ar[_r].concat(vr[_r]) : hr[_r] = vr[_r];
            return hr
        }
          , Xt = function(vr) {
            for (var ar = {}, hr = 0; hr < vr.length; hr++)
                ar[vr[hr].toUpperCase()] = vr[hr];
            return ar
        }
          , Sr = function(vr, ar) {
            return typeof vr === pt ? Rr(ar).indexOf(Rr(vr)) !== -1 : !1
        }
          , Rr = function(vr) {
            return vr.toLowerCase()
        }
          , qr = function(vr) {
            return typeof vr === pt ? vr.replace(/[^\d\.]/g, y).split(".")[0] : m
        }
          , Nr = function(vr, ar) {
            if (typeof vr === pt)
                return vr = vr.replace(/^\s\s*/, y),
                typeof ar === mt ? vr : vr.substring(0, or)
        }
          , Dr = function(vr, ar) {
            for (var hr = 0, _r, Ar, Ft, Ut, Dt, er; hr < ar.length && !Dt; ) {
                var br = ar[hr]
                  , Cr = ar[hr + 1];
                for (_r = Ar = 0; _r < br.length && !Dt && br[_r]; )
                    if (Dt = br[_r++].exec(vr),
                    Dt)
                        for (Ft = 0; Ft < Cr.length; Ft++)
                            er = Dt[++Ar],
                            Ut = Cr[Ft],
                            typeof Ut === yt && Ut.length > 0 ? Ut.length === 2 ? typeof Ut[1] == dt ? this[Ut[0]] = Ut[1].call(this, er) : this[Ut[0]] = Ut[1] : Ut.length === 3 ? typeof Ut[1] === dt && !(Ut[1].exec && Ut[1].test) ? this[Ut[0]] = er ? Ut[1].call(this, er, Ut[2]) : m : this[Ut[0]] = er ? er.replace(Ut[1], Ut[2]) : m : Ut.length === 4 && (this[Ut[0]] = er ? Ut[3].call(this, er.replace(Ut[1], Ut[2])) : m) : this[Ut] = er || m;
                hr += 2
            }
        }
          , Or = function(vr, ar) {
            for (var hr in ar)
                if (typeof ar[hr] === yt && ar[hr].length > 0) {
                    for (var _r = 0; _r < ar[hr].length; _r++)
                        if (Sr(ar[hr][_r], vr))
                            return hr === ee ? m : hr
                } else if (Sr(ar[hr], vr))
                    return hr === ee ? m : hr;
            return vr
        }
          , $r = {
            "1.0": "/8",
            "1.2": "/1",
            "1.3": "/3",
            "2.0": "/412",
            "2.0.2": "/416",
            "2.0.3": "/417",
            "2.0.4": "/419",
            "?": "/"
        }
          , Zr = {
            ME: "4.90",
            "NT 3.11": "NT3.51",
            "NT 4.0": "NT4.0",
            2e3: "NT 5.0",
            XP: ["NT 5.1", "NT 5.2"],
            Vista: "NT 6.0",
            7: "NT 6.1",
            8: "NT 6.2",
            "8.1": "NT 6.3",
            10: ["NT 6.4", "NT 10.0"],
            RT: "ARM"
        }
          , Hr = {
            browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [Pt, [xt, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [Pt, [xt, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [xt, Pt], [/opios[\/ ]+([\w\.]+)/i], [Pt, [xt, St + " Mini"]], [/\bop(?:rg)?x\/([\w\.]+)/i], [Pt, [xt, St + " GX"]], [/\bopr\/([\w\.]+)/i], [Pt, [xt, St]], [/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i], [Pt, [xt, "Baidu"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant|iemobile|slim)\s?(?:browser)?[\/ ]?([\w\.]*)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(heytap|ovi)browser\/([\d\.]+)/i, /(weibo)__([\d\.]+)/i], [xt, Pt], [/\bddg\/([\w\.]+)/i], [Pt, [xt, "DuckDuckGo"]], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [Pt, [xt, "UC" + _t]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i, /micromessenger\/([\w\.]+)/i], [Pt, [xt, "WeChat"]], [/konqueror\/([\w\.]+)/i], [Pt, [xt, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [Pt, [xt, "IE"]], [/ya(?:search)?browser\/([\w\.]+)/i], [Pt, [xt, "Yandex"]], [/slbrowser\/([\w\.]+)/i], [Pt, [xt, "Smart Lenovo " + _t]], [/(avast|avg)\/([\w\.]+)/i], [[xt, /(.+)/, "$1 Secure " + _t], Pt], [/\bfocus\/([\w\.]+)/i], [Pt, [xt, Et + " Focus"]], [/\bopt\/([\w\.]+)/i], [Pt, [xt, St + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [Pt, [xt, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [Pt, [xt, "Dolphin"]], [/coast\/([\w\.]+)/i], [Pt, [xt, St + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [Pt, [xt, "MIUI " + _t]], [/fxios\/([-\w\.]+)/i], [Pt, [xt, Et]], [/\bqihu|(qi?ho?o?|360)browser/i], [[xt, "360 " + _t]], [/(oculus|sailfish|huawei|vivo)browser\/([\w\.]+)/i], [[xt, /(.+)/, "$1 " + _t], Pt], [/samsungbrowser\/([\w\.]+)/i], [Pt, [xt, qt + " Internet"]], [/(comodo_dragon)\/([\w\.]+)/i], [[xt, /_/g, " "], Pt], [/metasr[\/ ]?([\d\.]+)/i], [Pt, [xt, "Sogou Explorer"]], [/(sogou)mo\w+\/([\d\.]+)/i], [[xt, "Sogou Mobile"], Pt], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|2345Explorer)[\/ ]?([\w\.]+)/i], [xt, Pt], [/(lbbrowser)/i, /\[(linkedin)app\]/i], [xt], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[xt, Vt], Pt], [/(Klarna)\/([\w\.]+)/i, /(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(alipay)client\/([\w\.]+)/i, /(twitter)(?:and| f.+e\/([\w\.]+))/i, /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i], [xt, Pt], [/\bgsa\/([\w\.]+) .*safari\//i], [Pt, [xt, "GSA"]], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i], [Pt, [xt, "TikTok"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [Pt, [xt, gt + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[xt, gt + " WebView"], Pt], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [Pt, [xt, "Android " + _t]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [xt, Pt], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [Pt, [xt, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [Pt, xt], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [xt, [Pt, Or, $r]], [/(webkit|khtml)\/([\w\.]+)/i], [xt, Pt], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[xt, "Netscape"], Pt], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [Pt, [xt, Et + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i], [xt, Pt], [/(cobalt)\/([\w\.]+)/i], [xt, [Pt, /master.|lts./, ""]]],
            cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[$t, "amd64"]], [/(ia32(?=;))/i], [[$t, Rr]], [/((?:i[346]|x)86)[;\)]/i], [[$t, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[$t, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[$t, "armhf"]], [/windows (ce|mobile); ppc;/i], [[$t, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[$t, /ower/, y, Rr]], [/(sun4\w)[;\)]/i], [[$t, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[$t, Rr]]],
            device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [wt, [Ct, qt], [At, zt]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [wt, [Ct, qt], [At, Nt]], [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i], [wt, [Ct, wr], [At, Nt]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [wt, [Ct, wr], [At, zt]], [/(macintosh);/i], [wt, [Ct, wr]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [wt, [Ct, ur], [At, Nt]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [wt, [Ct, Rt], [At, zt]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [wt, [Ct, Rt], [At, Nt]], [/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[wt, /_/g, " "], [Ct, lr], [At, Nt]], [/oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i, /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[wt, /_/g, " "], [Ct, lr], [At, zt]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [wt, [Ct, "OPPO"], [At, Nt]], [/\b(opd2\d{3}a?) bui/i], [wt, [Ct, "OPPO"], [At, zt]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [wt, [Ct, "Vivo"], [At, Nt]], [/\b(rmx[1-3]\d{3})(?: bui|;|\))/i], [wt, [Ct, "Realme"], [At, Nt]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [wt, [Ct, It], [At, Nt]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [wt, [Ct, It], [At, zt]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [wt, [Ct, kt], [At, zt]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [wt, [Ct, kt], [At, Nt]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [wt, [Ct, "Lenovo"], [At, zt]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[wt, /_/g, " "], [Ct, "Nokia"], [At, Nt]], [/(pixel c)\b/i], [wt, [Ct, Bt], [At, zt]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [wt, [Ct, Bt], [At, Nt]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [wt, [Ct, gr], [At, Nt]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[wt, "Xperia Tablet"], [Ct, gr], [At, zt]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [wt, [Ct, "OnePlus"], [At, Nt]], [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [wt, [Ct, tr], [At, zt]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[wt, /(.+)/g, "Fire Phone $1"], [Ct, tr], [At, Nt]], [/(playbook);[-\w\),; ]+(rim)/i], [wt, Ct, [At, zt]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [wt, [Ct, Mt], [At, Nt]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [wt, [Ct, Ht], [At, zt]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [wt, [Ct, Ht], [At, Nt]], [/(nexus 9)/i], [wt, [Ct, "HTC"], [At, zt]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [Ct, [wt, /_/g, " "], [At, Nt]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [wt, [Ct, "Acer"], [At, zt]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [wt, [Ct, "Meizu"], [At, Nt]], [/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i], [wt, [Ct, "Ulefone"], [At, Nt]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [Ct, wt, [At, Nt]], [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [Ct, wt, [At, zt]], [/(surface duo)/i], [wt, [Ct, Tt], [At, zt]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [wt, [Ct, "Fairphone"], [At, Nt]], [/(u304aa)/i], [wt, [Ct, "AT&T"], [At, Nt]], [/\bsie-(\w*)/i], [wt, [Ct, "Siemens"], [At, Nt]], [/\b(rct\w+) b/i], [wt, [Ct, "RCA"], [At, zt]], [/\b(venue[\d ]{2,7}) b/i], [wt, [Ct, "Dell"], [At, zt]], [/\b(q(?:mv|ta)\w+) b/i], [wt, [Ct, "Verizon"], [At, zt]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [wt, [Ct, "Barnes & Noble"], [At, zt]], [/\b(tm\d{3}\w+) b/i], [wt, [Ct, "NuVision"], [At, zt]], [/\b(k88) b/i], [wt, [Ct, "ZTE"], [At, zt]], [/\b(nx\d{3}j) b/i], [wt, [Ct, "ZTE"], [At, Nt]], [/\b(gen\d{3}) b.+49h/i], [wt, [Ct, "Swiss"], [At, Nt]], [/\b(zur\d{3}) b/i], [wt, [Ct, "Swiss"], [At, zt]], [/\b((zeki)?tb.*\b) b/i], [wt, [Ct, "Zeki"], [At, zt]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[Ct, "Dragon Touch"], wt, [At, zt]], [/\b(ns-?\w{0,9}) b/i], [wt, [Ct, "Insignia"], [At, zt]], [/\b((nxa|next)-?\w{0,9}) b/i], [wt, [Ct, "NextBook"], [At, zt]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[Ct, "Voice"], wt, [At, Nt]], [/\b(lvtel\-)?(v1[12]) b/i], [[Ct, "LvTel"], wt, [At, Nt]], [/\b(ph-1) /i], [wt, [Ct, "Essential"], [At, Nt]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [wt, [Ct, "Envizen"], [At, zt]], [/\b(trio[-\w\. ]+) b/i], [wt, [Ct, "MachSpeed"], [At, zt]], [/\btu_(1491) b/i], [wt, [Ct, "Rotor"], [At, zt]], [/(shield[\w ]+) b/i], [wt, [Ct, "Nvidia"], [At, zt]], [/(sprint) (\w+)/i], [Ct, wt, [At, Nt]], [/(kin\.[onetw]{3})/i], [[wt, /\./g, " "], [Ct, Tt], [At, Nt]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [wt, [Ct, Zt], [At, zt]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [wt, [Ct, Zt], [At, Nt]], [/smart-tv.+(samsung)/i], [Ct, [At, Wt]], [/hbbtv.+maple;(\d+)/i], [[wt, /^/, "SmartTV"], [Ct, qt], [At, Wt]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[Ct, kt], [At, Wt]], [/(apple) ?tv/i], [Ct, [wt, wr + " TV"], [At, Wt]], [/crkey/i], [[wt, gt + "cast"], [Ct, Bt], [At, Wt]], [/droid.+aft(\w+)( bui|\))/i], [wt, [Ct, tr], [At, Wt]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [wt, [Ct, ur], [At, Wt]], [/(bravia[\w ]+)( bui|\))/i], [wt, [Ct, gr], [At, Wt]], [/(mitv-\w{5}) bui/i], [wt, [Ct, lr], [At, Wt]], [/Hbbtv.*(technisat) (.*);/i], [Ct, wt, [At, Wt]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[Ct, Nr], [wt, Nr], [At, Wt]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[At, Wt]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [Ct, wt, [At, Ot]], [/droid.+; (shield) bui/i], [wt, [Ct, "Nvidia"], [At, Ot]], [/(playstation [345portablevi]+)/i], [wt, [Ct, gr], [At, Ot]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [wt, [Ct, Tt], [At, Ot]], [/((pebble))app/i], [Ct, wt, [At, Kt]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [wt, [Ct, wr], [At, Kt]], [/droid.+; (glass) \d/i], [wt, [Ct, Bt], [At, Kt]], [/droid.+; (wt63?0{2,3})\)/i], [wt, [Ct, Zt], [At, Kt]], [/(quest( \d| pro)?)/i], [wt, [Ct, Vt], [At, Kt]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [Ct, [At, ir]], [/(aeobc)\b/i], [wt, [Ct, tr], [At, ir]], [/droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i], [wt, [At, Nt]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [wt, [At, zt]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[At, zt]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[At, Nt]], [/(android[-\w\. ]{0,9});.+buil/i], [wt, [Ct, "Generic"]]],
            engine: [[/windows.+ edge\/([\w\.]+)/i], [Pt, [xt, vt + "HTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [Pt, [xt, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i], [xt, Pt], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [Pt, xt]],
            os: [[/microsoft (windows) (vista|xp)/i], [xt, Pt], [/(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i], [xt, [Pt, Or, Zr]], [/windows nt 6\.2; (arm)/i, /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i, /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[Pt, Or, Zr], [xt, "Windows"]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[Pt, /_/g, "."], [xt, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[xt, fr], [Pt, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [Pt, xt], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [xt, Pt], [/\(bb(10);/i], [Pt, [xt, Mt]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [Pt, [xt, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [Pt, [xt, Et + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [Pt, [xt, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [Pt, [xt, "watchOS"]], [/crkey\/([\d\.]+)/i], [Pt, [xt, gt + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[xt, rr], Pt], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [xt, Pt], [/(sunos) ?([\w\.\d]*)/i], [[xt, "Solaris"], Pt], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i], [xt, Pt]]
        }
          , un = function(vr, ar) {
            if (typeof vr === yt && (ar = vr,
            vr = m),
            !(this instanceof un))
                return new un(vr,ar).getResult();
            var hr = typeof f !== mt && f.navigator ? f.navigator : m
              , _r = vr || (hr && hr.userAgent ? hr.userAgent : y)
              , Ar = hr && hr.userAgentData ? hr.userAgentData : m
              , Ft = ar ? Yt(Hr, ar) : Hr
              , Ut = hr && hr.userAgent == _r;
            return this.getBrowser = function() {
                var Dt = {};
                return Dt[xt] = m,
                Dt[Pt] = m,
                Dr.call(Dt, _r, Ft.browser),
                Dt[bt] = qr(Dt[Pt]),
                Ut && hr && hr.brave && typeof hr.brave.isBrave == dt && (Dt[xt] = "Brave"),
                Dt
            }
            ,
            this.getCPU = function() {
                var Dt = {};
                return Dt[$t] = m,
                Dr.call(Dt, _r, Ft.cpu),
                Dt
            }
            ,
            this.getDevice = function() {
                var Dt = {};
                return Dt[Ct] = m,
                Dt[wt] = m,
                Dt[At] = m,
                Dr.call(Dt, _r, Ft.device),
                Ut && !Dt[At] && Ar && Ar.mobile && (Dt[At] = Nt),
                Ut && Dt[wt] == "Macintosh" && hr && typeof hr.standalone !== mt && hr.maxTouchPoints && hr.maxTouchPoints > 2 && (Dt[wt] = "iPad",
                Dt[At] = zt),
                Dt
            }
            ,
            this.getEngine = function() {
                var Dt = {};
                return Dt[xt] = m,
                Dt[Pt] = m,
                Dr.call(Dt, _r, Ft.engine),
                Dt
            }
            ,
            this.getOS = function() {
                var Dt = {};
                return Dt[xt] = m,
                Dt[Pt] = m,
                Dr.call(Dt, _r, Ft.os),
                Ut && !Dt[xt] && Ar && Ar.platform && Ar.platform != "Unknown" && (Dt[xt] = Ar.platform.replace(/chrome os/i, rr).replace(/macos/i, fr)),
                Dt
            }
            ,
            this.getResult = function() {
                return {
                    ua: this.getUA(),
                    browser: this.getBrowser(),
                    engine: this.getEngine(),
                    os: this.getOS(),
                    device: this.getDevice(),
                    cpu: this.getCPU()
                }
            }
            ,
            this.getUA = function() {
                return _r
            }
            ,
            this.setUA = function(Dt) {
                return _r = typeof Dt === pt && Dt.length > or ? Nr(Dt, or) : Dt,
                this
            }
            ,
            this.setUA(_r),
            this
        };
        un.VERSION = k,
        un.BROWSER = Xt([xt, Pt, bt]),
        un.CPU = Xt([$t]),
        un.DEVICE = Xt([wt, Ct, At, Ot, Nt, Wt, zt, Kt, ir]),
        un.ENGINE = un.OS = Xt([xt, Pt]),
        r.exports && (d = r.exports = un),
        d.UAParser = un;
        var Qr = typeof f !== mt && (f.jQuery || f.Zepto);
        if (Qr && !Qr.ua) {
            var Gr = new un;
            Qr.ua = Gr.getResult(),
            Qr.ua.get = function() {
                return Gr.getUA()
            }
            ,
            Qr.ua.set = function(vr) {
                Gr.setUA(vr);
                var ar = Gr.getResult();
                for (var hr in ar)
                    Qr.ua[hr] = ar[hr]
            }
        }
    }
    )(typeof window == "object" ? window : commonjsGlobal)
}
)(uaParser, uaParser.exports);
var uaParserExports = uaParser.exports;
const UAParser = getDefaultExportFromCjs(uaParserExports);
var isMergeableObject = function r(d) {
    return isNonNullObject(d) && !isSpecial(d)
};
function isNonNullObject(r) {
    return !!r && typeof r == "object"
}
function isSpecial(r) {
    var d = Object.prototype.toString.call(r);
    return d === "[object RegExp]" || d === "[object Date]" || isReactElement(r)
}
var canUseSymbol = typeof Symbol == "function" && Symbol.for
  , REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(r) {
    return r.$$typeof === REACT_ELEMENT_TYPE
}
function emptyTarget(r) {
    return Array.isArray(r) ? [] : {}
}
function cloneUnlessOtherwiseSpecified(r, d) {
    return d.clone !== !1 && d.isMergeableObject(r) ? deepmerge(emptyTarget(r), r, d) : r
}
function defaultArrayMerge(r, d, f) {
    return r.concat(d).map(function(m) {
        return cloneUnlessOtherwiseSpecified(m, f)
    })
}
function getMergeFunction(r, d) {
    if (!d.customMerge)
        return deepmerge;
    var f = d.customMerge(r);
    return typeof f == "function" ? f : deepmerge
}
function getEnumerableOwnPropertySymbols(r) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(r).filter(function(d) {
        return Object.propertyIsEnumerable.call(r, d)
    }) : []
}
function getKeys(r) {
    return Object.keys(r).concat(getEnumerableOwnPropertySymbols(r))
}
function propertyIsOnObject(r, d) {
    try {
        return d in r
    } catch {
        return !1
    }
}
function propertyIsUnsafe(r, d) {
    return propertyIsOnObject(r, d) && !(Object.hasOwnProperty.call(r, d) && Object.propertyIsEnumerable.call(r, d))
}
function mergeObject(r, d, f) {
    var m = {};
    return f.isMergeableObject(r) && getKeys(r).forEach(function(k) {
        m[k] = cloneUnlessOtherwiseSpecified(r[k], f)
    }),
    getKeys(d).forEach(function(k) {
        propertyIsUnsafe(r, k) || (propertyIsOnObject(r, k) && f.isMergeableObject(d[k]) ? m[k] = getMergeFunction(k, f)(r[k], d[k], f) : m[k] = cloneUnlessOtherwiseSpecified(d[k], f))
    }),
    m
}
function deepmerge(r, d, f) {
    f = f || {},
    f.arrayMerge = f.arrayMerge || defaultArrayMerge,
    f.isMergeableObject = f.isMergeableObject || isMergeableObject,
    f.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var m = Array.isArray(d)
      , k = Array.isArray(r)
      , y = m === k;
    return y ? m ? f.arrayMerge(r, d, f) : mergeObject(r, d, f) : cloneUnlessOtherwiseSpecified(d, f)
}
deepmerge.all = function r(d, f) {
    if (!Array.isArray(d))
        throw new Error("first argument should be an array");
    return d.reduce(function(m, k) {
        return deepmerge(m, k, f)
    }, {})
}
;
var deepmerge_1 = deepmerge
  , cjs = deepmerge_1;
const deepmerge$1 = getDefaultExportFromCjs(cjs);
var classnames = {
    exports: {}
};
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(r) {
    (function() {
        var d = {}.hasOwnProperty;
        function f() {
            for (var y = "", ee = 0; ee < arguments.length; ee++) {
                var dt = arguments[ee];
                dt && (y = k(y, m(dt)))
            }
            return y
        }
        function m(y) {
            if (typeof y == "string" || typeof y == "number")
                return y;
            if (typeof y != "object")
                return "";
            if (Array.isArray(y))
                return f.apply(null, y);
            if (y.toString !== Object.prototype.toString && !y.toString.toString().includes("[native code]"))
                return y.toString();
            var ee = "";
            for (var dt in y)
                d.call(y, dt) && y[dt] && (ee = k(ee, dt));
            return ee
        }
        function k(y, ee) {
            return ee ? y ? y + " " + ee : y + ee : y
        }
        r.exports ? (f.default = f,
        r.exports = f) : window.classNames = f
    }
    )()
}
)(classnames);
var classnamesExports = classnames.exports;
const cn = getDefaultExportFromCjs(classnamesExports);
var __defProp = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (r,d,f)=>d in r ? __defProp(r, d, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: f
}) : r[d] = f, __spreadValues = (r,d)=>{
    for (var f in d || (d = {}))
        __hasOwnProp.call(d, f) && __defNormalProp(r, f, d[f]);
    if (__getOwnPropSymbols)
        for (var f of __getOwnPropSymbols(d))
            __propIsEnum.call(d, f) && __defNormalProp(r, f, d[f]);
    return r
}
, __spreadProps = (r,d)=>__defProps(r, __getOwnPropDescs(d)), __publicField = (r,d,f)=>(__defNormalProp(r, typeof d != "symbol" ? d + "" : d, f),
f), __async = (r,d,f)=>new Promise((m,k)=>{
    var y = mt=>{
        try {
            dt(f.next(mt))
        } catch (yt) {
            k(yt)
        }
    }
      , ee = mt=>{
        try {
            dt(f.throw(mt))
        } catch (yt) {
            k(yt)
        }
    }
      , dt = mt=>mt.done ? m(mt.value) : Promise.resolve(mt.value).then(y, ee);
    dt((f = f.apply(r, d)).next())
}
), _a$3, _b, _c, _d, _e$1, _f, _g, _h;
const sharedConfig = {};
function setHydrateContext(r) {
    sharedConfig.context = r
}
const equalFn = (r,d)=>r === d
  , $PROXY = Symbol("solid-proxy")
  , $TRACK = Symbol("solid-track")
  , signalOptions = {
    equals: equalFn
};
let runEffects = runQueue;
const STALE = 1
  , PENDING = 2
  , UNOWNED = {
    owned: null,
    cleanups: null,
    context: null,
    owner: null
}
  , NO_INIT = {};
var Owner = null;
let Transition$1 = null
  , Listener = null
  , Updates = null
  , Effects = null
  , ExecCount = 0;
function createRoot(r, d) {
    const f = Listener
      , m = Owner
      , k = r.length === 0
      , y = k ? UNOWNED : {
        owned: null,
        cleanups: null,
        context: null,
        owner: d === void 0 ? m : d
    }
      , ee = k ? r : ()=>r(()=>untrack(()=>cleanNode(y)));
    Owner = y,
    Listener = null;
    try {
        return runUpdates(ee, !0)
    } finally {
        Listener = f,
        Owner = m
    }
}
function createSignal(r, d) {
    d = d ? Object.assign({}, signalOptions, d) : signalOptions;
    const f = {
        value: r,
        observers: null,
        observerSlots: null,
        comparator: d.equals || void 0
    }
      , m = k=>(typeof k == "function" && (k = k(f.value)),
    writeSignal(f, k));
    return [readSignal.bind(f), m]
}
function createComputed(r, d, f) {
    const m = createComputation(r, d, !0, STALE);
    updateComputation(m)
}
function createRenderEffect(r, d, f) {
    const m = createComputation(r, d, !1, STALE);
    updateComputation(m)
}
function createEffect(r, d, f) {
    runEffects = runUserEffects;
    const m = createComputation(r, d, !1, STALE);
    m.user = !0,
    Effects ? Effects.push(m) : updateComputation(m)
}
function createMemo(r, d, f) {
    f = f ? Object.assign({}, signalOptions, f) : signalOptions;
    const m = createComputation(r, d, !0, 0);
    return m.observers = null,
    m.observerSlots = null,
    m.comparator = f.equals || void 0,
    updateComputation(m),
    readSignal.bind(m)
}
function createResource(r, d, f) {
    let m, k, y;
    arguments.length === 2 && typeof d == "object" || arguments.length === 1 ? (m = !0,
    k = r,
    y = d || {}) : (m = r,
    k = d,
    y = f || {});
    let ee = null
      , dt = NO_INIT
      , mt = null
      , yt = !1
      , pt = "initialValue"in y
      , bt = typeof m == "function" && createMemo(m);
    const wt = new Set
      , [xt,At] = (y.storage || createSignal)(y.initialValue)
      , [Ct,Pt] = createSignal(void 0)
      , [$t,Ot] = createSignal(void 0, {
        equals: !1
    })
      , [Nt,zt] = createSignal(pt ? "ready" : "unresolved");
    if (sharedConfig.context) {
        mt = `${sharedConfig.context.id}${sharedConfig.context.count++}`;
        let tr;
        y.ssrLoadFrom === "initial" ? dt = y.initialValue : sharedConfig.load && (tr = sharedConfig.load(mt)) && (dt = tr[0])
    }
    function Wt(tr, wr, Ht, Mt) {
        return ee === tr && (ee = null,
        pt = !0,
        (tr === dt || wr === dt) && y.onHydrated && queueMicrotask(()=>y.onHydrated(Mt, {
            value: wr
        })),
        dt = NO_INIT,
        Kt(wr, Ht)),
        wr
    }
    function Kt(tr, wr) {
        runUpdates(()=>{
            wr === void 0 && At(()=>tr),
            zt(wr !== void 0 ? "errored" : "ready"),
            Pt(wr);
            for (const Ht of wt.keys())
                Ht.decrement();
            wt.clear()
        }
        , !1)
    }
    function ir() {
        const tr = SuspenseContext
          , wr = xt()
          , Ht = Ct();
        if (Ht !== void 0 && !ee)
            throw Ht;
        return Listener && !Listener.user && tr && createComputed(()=>{
            $t(),
            ee && (tr.resolved || wt.has(tr) || (tr.increment(),
            wt.add(tr)))
        }
        ),
        wr
    }
    function or(tr=!0) {
        if (tr !== !1 && yt)
            return;
        yt = !1;
        const wr = bt ? bt() : m;
        if (wr == null || wr === !1) {
            Wt(ee, untrack(xt));
            return
        }
        const Ht = dt !== NO_INIT ? dt : untrack(()=>k(wr, {
            value: xt(),
            refetching: tr
        }));
        return typeof Ht != "object" || !(Ht && "then"in Ht) ? (Wt(ee, Ht, void 0, wr),
        Ht) : (ee = Ht,
        yt = !0,
        queueMicrotask(()=>yt = !1),
        runUpdates(()=>{
            zt(pt ? "refreshing" : "pending"),
            Ot()
        }
        , !1),
        Ht.then(Mt=>Wt(Ht, Mt, void 0, wr), Mt=>Wt(Ht, void 0, castError(Mt), wr)))
    }
    return Object.defineProperties(ir, {
        state: {
            get: ()=>Nt()
        },
        error: {
            get: ()=>Ct()
        },
        loading: {
            get() {
                const tr = Nt();
                return tr === "pending" || tr === "refreshing"
            }
        },
        latest: {
            get() {
                if (!pt)
                    return ir();
                const tr = Ct();
                if (tr && !ee)
                    throw tr;
                return xt()
            }
        }
    }),
    bt ? createComputed(()=>or(!1)) : or(!1),
    [ir, {
        refetch: or,
        mutate: At
    }]
}
function batch(r) {
    return runUpdates(r, !1)
}
function untrack(r) {
    if (Listener === null)
        return r();
    const d = Listener;
    Listener = null;
    try {
        return r()
    } finally {
        Listener = d
    }
}
function on(r, d, f) {
    const m = Array.isArray(r);
    let k, y = f && f.defer;
    return ee=>{
        let dt;
        if (m) {
            dt = Array(r.length);
            for (let yt = 0; yt < r.length; yt++)
                dt[yt] = r[yt]()
        } else
            dt = r();
        if (y) {
            y = !1;
            return
        }
        const mt = untrack(()=>d(dt, k, ee));
        return k = dt,
        mt
    }
}
function onMount(r) {
    createEffect(()=>untrack(r))
}
function onCleanup(r) {
    return Owner === null || (Owner.cleanups === null ? Owner.cleanups = [r] : Owner.cleanups.push(r)),
    r
}
function getListener() {
    return Listener
}
function getOwner() {
    return Owner
}
function createContext(r, d) {
    const f = Symbol("context");
    return {
        id: f,
        Provider: createProvider$2(f),
        defaultValue: r
    }
}
function useContext(r) {
    let d;
    return (d = lookup(Owner, r.id)) !== void 0 ? d : r.defaultValue
}
function children(r) {
    const d = createMemo(r)
      , f = createMemo(()=>resolveChildren(d()));
    return f.toArray = ()=>{
        const m = f();
        return Array.isArray(m) ? m : m != null ? [m] : []
    }
    ,
    f
}
let SuspenseContext;
function readSignal() {
    const r = Transition$1;
    if (this.sources && (this.state || r))
        if (this.state === STALE || r)
            updateComputation(this);
        else {
            const d = Updates;
            Updates = null,
            runUpdates(()=>lookUpstream(this), !1),
            Updates = d
        }
    if (Listener) {
        const d = this.observers ? this.observers.length : 0;
        Listener.sources ? (Listener.sources.push(this),
        Listener.sourceSlots.push(d)) : (Listener.sources = [this],
        Listener.sourceSlots = [d]),
        this.observers ? (this.observers.push(Listener),
        this.observerSlots.push(Listener.sources.length - 1)) : (this.observers = [Listener],
        this.observerSlots = [Listener.sources.length - 1])
    }
    return this.value
}
function writeSignal(r, d, f) {
    let m = r.value;
    return (!r.comparator || !r.comparator(m, d)) && (r.value = d,
    r.observers && r.observers.length && runUpdates(()=>{
        for (let k = 0; k < r.observers.length; k += 1) {
            const y = r.observers[k]
              , ee = Transition$1 && Transition$1.running;
            ee && Transition$1.disposed.has(y),
            (ee && !y.tState || !ee && !y.state) && (y.pure ? Updates.push(y) : Effects.push(y),
            y.observers && markDownstream(y)),
            ee || (y.state = STALE)
        }
        if (Updates.length > 1e6)
            throw Updates = [],
            new Error
    }
    , !1)),
    d
}
function updateComputation(r) {
    if (!r.fn)
        return;
    cleanNode(r);
    const d = Owner
      , f = Listener
      , m = ExecCount;
    Listener = Owner = r,
    runComputation(r, r.value, m),
    Listener = f,
    Owner = d
}
function runComputation(r, d, f) {
    let m;
    try {
        m = r.fn(d)
    } catch (k) {
        r.pure && (r.state = STALE,
        r.owned && r.owned.forEach(cleanNode),
        r.owned = null),
        handleError(k)
    }
    (!r.updatedAt || r.updatedAt <= f) && (r.updatedAt != null && "observers"in r ? writeSignal(r, m) : r.value = m,
    r.updatedAt = f)
}
function createComputation(r, d, f, m=STALE, k) {
    const y = {
        fn: r,
        state: m,
        updatedAt: null,
        owned: null,
        sources: null,
        sourceSlots: null,
        cleanups: null,
        value: d,
        owner: Owner,
        context: null,
        pure: f
    };
    return Owner === null || Owner !== UNOWNED && (Owner.owned ? Owner.owned.push(y) : Owner.owned = [y]),
    y
}
function runTop(r) {
    const d = Transition$1;
    if (r.state === 0 || d)
        return;
    if (r.state === PENDING || d)
        return lookUpstream(r);
    if (r.suspense && untrack(r.suspense.inFallback))
        return r.suspense.effects.push(r);
    const f = [r];
    for (; (r = r.owner) && (!r.updatedAt || r.updatedAt < ExecCount); )
        (r.state || d) && f.push(r);
    for (let m = f.length - 1; m >= 0; m--)
        if (r = f[m],
        r.state === STALE || d)
            updateComputation(r);
        else if (r.state === PENDING || d) {
            const k = Updates;
            Updates = null,
            runUpdates(()=>lookUpstream(r, f[0]), !1),
            Updates = k
        }
}
function runUpdates(r, d) {
    if (Updates)
        return r();
    let f = !1;
    d || (Updates = []),
    Effects ? f = !0 : Effects = [],
    ExecCount++;
    try {
        const m = r();
        return completeUpdates(f),
        m
    } catch (m) {
        f || (Effects = null),
        Updates = null,
        handleError(m)
    }
}
function completeUpdates(r) {
    if (Updates && (runQueue(Updates),
    Updates = null),
    r)
        return;
    const d = Effects;
    Effects = null,
    d.length && runUpdates(()=>runEffects(d), !1)
}
function runQueue(r) {
    for (let d = 0; d < r.length; d++)
        runTop(r[d])
}
function runUserEffects(r) {
    let d, f = 0;
    for (d = 0; d < r.length; d++) {
        const m = r[d];
        m.user ? r[f++] = m : runTop(m)
    }
    for (sharedConfig.context && setHydrateContext(),
    d = 0; d < f; d++)
        runTop(r[d])
}
function lookUpstream(r, d) {
    const f = Transition$1;
    r.state = 0;
    for (let m = 0; m < r.sources.length; m += 1) {
        const k = r.sources[m];
        k.sources && (k.state === STALE || f ? k !== d && runTop(k) : (k.state === PENDING || f) && lookUpstream(k, d))
    }
}
function markDownstream(r) {
    const d = Transition$1;
    for (let f = 0; f < r.observers.length; f += 1) {
        const m = r.observers[f];
        (!m.state || d) && (m.state = PENDING,
        m.pure ? Updates.push(m) : Effects.push(m),
        m.observers && markDownstream(m))
    }
}
function cleanNode(r) {
    let d;
    if (r.sources)
        for (; r.sources.length; ) {
            const f = r.sources.pop()
              , m = r.sourceSlots.pop()
              , k = f.observers;
            if (k && k.length) {
                const y = k.pop()
                  , ee = f.observerSlots.pop();
                m < k.length && (y.sourceSlots[ee] = m,
                k[m] = y,
                f.observerSlots[m] = ee)
            }
        }
    if (r.owned) {
        for (d = 0; d < r.owned.length; d++)
            cleanNode(r.owned[d]);
        r.owned = null
    }
    if (r.cleanups) {
        for (d = 0; d < r.cleanups.length; d++)
            r.cleanups[d]();
        r.cleanups = null
    }
    r.state = 0,
    r.context = null
}
function castError(r) {
    return r instanceof Error || typeof r == "string" ? r : new Error("Unknown error")
}
function handleError(r) {
    throw r = castError(r),
    r
}
function lookup(r, d) {
    return r ? r.context && r.context[d] !== void 0 ? r.context[d] : lookup(r.owner, d) : void 0
}
function resolveChildren(r) {
    if (typeof r == "function" && !r.length)
        return resolveChildren(r());
    if (Array.isArray(r)) {
        const d = [];
        for (let f = 0; f < r.length; f++) {
            const m = resolveChildren(r[f]);
            Array.isArray(m) ? d.push.apply(d, m) : d.push(m)
        }
        return d
    }
    return r
}
function createProvider$2(r, d) {
    return function(m) {
        let k;
        return createRenderEffect(()=>k = untrack(()=>(Owner.context = {
            [r]: m.value
        },
        children(()=>m.children))), void 0),
        k
    }
}
const FALLBACK = Symbol("fallback");
function dispose(r) {
    for (let d = 0; d < r.length; d++)
        r[d]()
}
function mapArray(r, d, f={}) {
    let m = []
      , k = []
      , y = []
      , ee = 0
      , dt = d.length > 1 ? [] : null;
    return onCleanup(()=>dispose(y)),
    ()=>{
        let mt = r() || [], yt, pt;
        return mt[$TRACK],
        untrack(()=>{
            let wt = mt.length, xt, At, Ct, Pt, $t, Ot, Nt, zt, Wt;
            if (wt === 0)
                ee !== 0 && (dispose(y),
                y = [],
                m = [],
                k = [],
                ee = 0,
                dt && (dt = [])),
                f.fallback && (m = [FALLBACK],
                k[0] = createRoot(Kt=>(y[0] = Kt,
                f.fallback())),
                ee = 1);
            else if (ee === 0) {
                for (k = new Array(wt),
                pt = 0; pt < wt; pt++)
                    m[pt] = mt[pt],
                    k[pt] = createRoot(bt);
                ee = wt
            } else {
                for (Ct = new Array(wt),
                Pt = new Array(wt),
                dt && ($t = new Array(wt)),
                Ot = 0,
                Nt = Math.min(ee, wt); Ot < Nt && m[Ot] === mt[Ot]; Ot++)
                    ;
                for (Nt = ee - 1,
                zt = wt - 1; Nt >= Ot && zt >= Ot && m[Nt] === mt[zt]; Nt--,
                zt--)
                    Ct[zt] = k[Nt],
                    Pt[zt] = y[Nt],
                    dt && ($t[zt] = dt[Nt]);
                for (xt = new Map,
                At = new Array(zt + 1),
                pt = zt; pt >= Ot; pt--)
                    Wt = mt[pt],
                    yt = xt.get(Wt),
                    At[pt] = yt === void 0 ? -1 : yt,
                    xt.set(Wt, pt);
                for (yt = Ot; yt <= Nt; yt++)
                    Wt = m[yt],
                    pt = xt.get(Wt),
                    pt !== void 0 && pt !== -1 ? (Ct[pt] = k[yt],
                    Pt[pt] = y[yt],
                    dt && ($t[pt] = dt[yt]),
                    pt = At[pt],
                    xt.set(Wt, pt)) : y[yt]();
                for (pt = Ot; pt < wt; pt++)
                    pt in Ct ? (k[pt] = Ct[pt],
                    y[pt] = Pt[pt],
                    dt && (dt[pt] = $t[pt],
                    dt[pt](pt))) : k[pt] = createRoot(bt);
                k = k.slice(0, ee = wt),
                m = mt.slice(0)
            }
            return k
        }
        );
        function bt(wt) {
            if (y[pt] = wt,
            dt) {
                const [xt,At] = createSignal(pt);
                return dt[pt] = At,
                d(mt[pt], xt)
            }
            return d(mt[pt])
        }
    }
}
function createComponent(r, d) {
    return untrack(()=>r(d || {}))
}
function trueFn() {
    return !0
}
const propTraps = {
    get(r, d, f) {
        return d === $PROXY ? f : r.get(d)
    },
    has(r, d) {
        return d === $PROXY ? !0 : r.has(d)
    },
    set: trueFn,
    deleteProperty: trueFn,
    getOwnPropertyDescriptor(r, d) {
        return {
            configurable: !0,
            enumerable: !0,
            get() {
                return r.get(d)
            },
            set: trueFn,
            deleteProperty: trueFn
        }
    },
    ownKeys(r) {
        return r.keys()
    }
};
function resolveSource(r) {
    return (r = typeof r == "function" ? r() : r) ? r : {}
}
function mergeProps(...r) {
    let d = !1;
    for (let m = 0; m < r.length; m++) {
        const k = r[m];
        d = d || !!k && $PROXY in k,
        r[m] = typeof k == "function" ? (d = !0,
        createMemo(k)) : k
    }
    if (d)
        return new Proxy({
            get(m) {
                for (let k = r.length - 1; k >= 0; k--) {
                    const y = resolveSource(r[k])[m];
                    if (y !== void 0)
                        return y
                }
            },
            has(m) {
                for (let k = r.length - 1; k >= 0; k--)
                    if (m in resolveSource(r[k]))
                        return !0;
                return !1
            },
            keys() {
                const m = [];
                for (let k = 0; k < r.length; k++)
                    m.push(...Object.keys(resolveSource(r[k])));
                return [...new Set(m)]
            }
        },propTraps);
    const f = {};
    for (let m = r.length - 1; m >= 0; m--)
        if (r[m]) {
            const k = Object.getOwnPropertyDescriptors(r[m]);
            for (const y in k)
                y in f || Object.defineProperty(f, y, {
                    enumerable: !0,
                    get() {
                        for (let ee = r.length - 1; ee >= 0; ee--) {
                            const dt = (r[ee] || {})[y];
                            if (dt !== void 0)
                                return dt
                        }
                    }
                })
        }
    return f
}
function splitProps(r, ...d) {
    const f = new Set(d.flat());
    if ($PROXY in r) {
        const k = d.map(y=>new Proxy({
            get(ee) {
                return y.includes(ee) ? r[ee] : void 0
            },
            has(ee) {
                return y.includes(ee) && ee in r
            },
            keys() {
                return y.filter(ee=>ee in r)
            }
        },propTraps));
        return k.push(new Proxy({
            get(y) {
                return f.has(y) ? void 0 : r[y]
            },
            has(y) {
                return f.has(y) ? !1 : y in r
            },
            keys() {
                return Object.keys(r).filter(y=>!f.has(y))
            }
        },propTraps)),
        k
    }
    const m = Object.getOwnPropertyDescriptors(r);
    return d.push(Object.keys(m).filter(k=>!f.has(k))),
    d.map(k=>{
        const y = {};
        for (let ee = 0; ee < k.length; ee++) {
            const dt = k[ee];
            dt in r && Object.defineProperty(y, dt, m[dt] ? m[dt] : {
                get() {
                    return r[dt]
                },
                set() {
                    return !0
                },
                enumerable: !0
            })
        }
        return y
    }
    )
}
function For(r) {
    const d = "fallback"in r && {
        fallback: ()=>r.fallback
    };
    return createMemo(mapArray(()=>r.each, r.children, d || void 0))
}
function Show(r) {
    let d = !1;
    const f = r.keyed
      , m = createMemo(()=>r.when, void 0, {
        equals: (k,y)=>d ? k === y : !k == !y
    });
    return createMemo(()=>{
        const k = m();
        if (k) {
            const y = r.children
              , ee = typeof y == "function" && y.length > 0;
            return d = f || ee,
            ee ? untrack(()=>y(k)) : y
        }
        return r.fallback
    }
    , void 0, void 0)
}
function Switch(r) {
    let d = !1
      , f = !1;
    const m = (ee,dt)=>ee[0] === dt[0] && (d ? ee[1] === dt[1] : !ee[1] == !dt[1]) && ee[2] === dt[2]
      , k = children(()=>r.children)
      , y = createMemo(()=>{
        let ee = k();
        Array.isArray(ee) || (ee = [ee]);
        for (let dt = 0; dt < ee.length; dt++) {
            const mt = ee[dt].when;
            if (mt)
                return f = !!ee[dt].keyed,
                [dt, mt, ee[dt]]
        }
        return [-1]
    }
    , void 0, {
        equals: m
    });
    return createMemo(()=>{
        const [ee,dt,mt] = y();
        if (ee < 0)
            return r.fallback;
        const yt = mt.children
          , pt = typeof yt == "function" && yt.length > 0;
        return d = f || pt,
        pt ? untrack(()=>yt(dt)) : yt
    }
    , void 0, void 0)
}
function Match(r) {
    return r
}
const booleans = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "disabled", "formnovalidate", "hidden", "indeterminate", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "seamless", "selected"]
  , Properties = new Set(["className", "value", "readOnly", "formNoValidate", "isMap", "noModule", "playsInline", ...booleans])
  , ChildProperties = new Set(["innerHTML", "textContent", "innerText", "children"])
  , Aliases = Object.assign(Object.create(null), {
    className: "class",
    htmlFor: "for"
})
  , PropAliases = Object.assign(Object.create(null), {
    class: "className",
    formnovalidate: "formNoValidate",
    ismap: "isMap",
    nomodule: "noModule",
    playsinline: "playsInline",
    readonly: "readOnly"
})
  , DelegatedEvents = new Set(["beforeinput", "click", "dblclick", "contextmenu", "focusin", "focusout", "input", "keydown", "keyup", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "pointerdown", "pointermove", "pointerout", "pointerover", "pointerup", "touchend", "touchmove", "touchstart"])
  , SVGElements = new Set(["altGlyph", "altGlyphDef", "altGlyphItem", "animate", "animateColor", "animateMotion", "animateTransform", "circle", "clipPath", "color-profile", "cursor", "defs", "desc", "ellipse", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "font", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignObject", "g", "glyph", "glyphRef", "hkern", "image", "line", "linearGradient", "marker", "mask", "metadata", "missing-glyph", "mpath", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "set", "stop", "svg", "switch", "symbol", "text", "textPath", "tref", "tspan", "use", "view", "vkern"])
  , SVGNamespace = {
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace"
};
function reconcileArrays(r, d, f) {
    let m = f.length
      , k = d.length
      , y = m
      , ee = 0
      , dt = 0
      , mt = d[k - 1].nextSibling
      , yt = null;
    for (; ee < k || dt < y; ) {
        if (d[ee] === f[dt]) {
            ee++,
            dt++;
            continue
        }
        for (; d[k - 1] === f[y - 1]; )
            k--,
            y--;
        if (k === ee) {
            const pt = y < m ? dt ? f[dt - 1].nextSibling : f[y - dt] : mt;
            for (; dt < y; )
                r.insertBefore(f[dt++], pt)
        } else if (y === dt)
            for (; ee < k; )
                (!yt || !yt.has(d[ee])) && d[ee].remove(),
                ee++;
        else if (d[ee] === f[y - 1] && f[dt] === d[k - 1]) {
            const pt = d[--k].nextSibling;
            r.insertBefore(f[dt++], d[ee++].nextSibling),
            r.insertBefore(f[--y], pt),
            d[k] = f[y]
        } else {
            if (!yt) {
                yt = new Map;
                let bt = dt;
                for (; bt < y; )
                    yt.set(f[bt], bt++)
            }
            const pt = yt.get(d[ee]);
            if (pt != null)
                if (dt < pt && pt < y) {
                    let bt = ee, wt = 1, xt;
                    for (; ++bt < k && bt < y && !((xt = yt.get(d[bt])) == null || xt !== pt + wt); )
                        wt++;
                    if (wt > pt - dt) {
                        const At = d[ee];
                        for (; dt < pt; )
                            r.insertBefore(f[dt++], At)
                    } else
                        r.replaceChild(f[dt++], d[ee++])
                } else
                    ee++;
            else
                d[ee++].remove()
        }
    }
}
const $$EVENTS = "_$DX_DELEGATE";
function render(r, d, f, m={}) {
    let k;
    return createRoot(y=>{
        k = y,
        d === document ? r() : insert(d, r(), d.firstChild ? null : void 0, f)
    }
    , m.owner),
    ()=>{
        k(),
        d.textContent = ""
    }
}
function template$1(r, d, f) {
    if (typeof window > "u")
        return null;
    const m = document.createElement("template");
    m.innerHTML = r;
    let k = m.content.firstChild;
    return f && (k = k.firstChild),
    k
}
function delegateEvents(r, d=window.document) {
    const f = d[$$EVENTS] || (d[$$EVENTS] = new Set);
    for (let m = 0, k = r.length; m < k; m++) {
        const y = r[m];
        f.has(y) || (f.add(y),
        d.addEventListener(y, eventHandler))
    }
}
function setAttribute(r, d, f) {
    f == null ? r.removeAttribute(d) : r.setAttribute(d, f)
}
function setAttributeNS(r, d, f, m) {
    m == null ? r.removeAttributeNS(d, f) : r.setAttributeNS(d, f, m)
}
function className(r, d) {
    d == null ? r.removeAttribute("class") : r.className = d
}
function addEventListener(r, d, f, m) {
    if (m)
        Array.isArray(f) ? (r[`$$${d}`] = f[0],
        r[`$$${d}Data`] = f[1]) : r[`$$${d}`] = f;
    else if (Array.isArray(f)) {
        const k = f[0];
        r.addEventListener(d, f[0] = y=>k.call(r, f[1], y))
    } else
        r.addEventListener(d, f)
}
function classList(r, d, f={}) {
    const m = Object.keys(d || {})
      , k = Object.keys(f);
    let y, ee;
    for (y = 0,
    ee = k.length; y < ee; y++) {
        const dt = k[y];
        !dt || dt === "undefined" || d[dt] || (toggleClassKey(r, dt, !1),
        delete f[dt])
    }
    for (y = 0,
    ee = m.length; y < ee; y++) {
        const dt = m[y]
          , mt = !!d[dt];
        !dt || dt === "undefined" || f[dt] === mt || !mt || (toggleClassKey(r, dt, !0),
        f[dt] = mt)
    }
    return f
}
function style(r, d, f) {
    if (!d)
        return f ? setAttribute(r, "style") : d;
    const m = r.style;
    if (typeof d == "string")
        return m.cssText = d;
    typeof f == "string" && (m.cssText = f = void 0),
    f || (f = {}),
    d || (d = {});
    let k, y;
    for (y in f)
        d[y] == null && m.removeProperty(y),
        delete f[y];
    for (y in d)
        k = d[y],
        k !== f[y] && (m.setProperty(y, k),
        f[y] = k);
    return f
}
function spread$1(r, d={}, f, m) {
    const k = {};
    return m || createRenderEffect(()=>k.children = insertExpression(r, d.children, k.children)),
    createRenderEffect(()=>d.ref && d.ref(r)),
    createRenderEffect(()=>assign(r, d, f, !0, k, !0)),
    k
}
function use(r, d, f) {
    return untrack(()=>r(d, f))
}
function insert(r, d, f, m) {
    if (f !== void 0 && !m && (m = []),
    typeof d != "function")
        return insertExpression(r, d, m, f);
    createRenderEffect(k=>insertExpression(r, d(), k, f), m)
}
function assign(r, d, f, m, k={}, y=!1) {
    d || (d = {});
    for (const ee in k)
        if (!(ee in d)) {
            if (ee === "children")
                continue;
            k[ee] = assignProp(r, ee, null, k[ee], f, y)
        }
    for (const ee in d) {
        if (ee === "children") {
            m || insertExpression(r, d.children);
            continue
        }
        const dt = d[ee];
        k[ee] = assignProp(r, ee, dt, k[ee], f, y)
    }
}
function getNextElement(r) {
    let d, f;
    return !sharedConfig.context || !(d = sharedConfig.registry.get(f = getHydrationKey())) ? r.cloneNode(!0) : (sharedConfig.completed && sharedConfig.completed.add(d),
    sharedConfig.registry.delete(f),
    d)
}
function toPropertyName(r) {
    return r.toLowerCase().replace(/-([a-z])/g, (d,f)=>f.toUpperCase())
}
function toggleClassKey(r, d, f) {
    const m = d.trim().split(/\s+/);
    for (let k = 0, y = m.length; k < y; k++)
        r.classList.toggle(m[k], f)
}
function assignProp(r, d, f, m, k, y) {
    let ee, dt, mt;
    if (d === "style")
        return style(r, f, m);
    if (d === "classList")
        return classList(r, f, m);
    if (f === m)
        return m;
    if (d === "ref")
        y || f(r);
    else if (d.slice(0, 3) === "on:") {
        const yt = d.slice(3);
        m && r.removeEventListener(yt, m),
        f && r.addEventListener(yt, f)
    } else if (d.slice(0, 10) === "oncapture:") {
        const yt = d.slice(10);
        m && r.removeEventListener(yt, m, !0),
        f && r.addEventListener(yt, f, !0)
    } else if (d.slice(0, 2) === "on") {
        const yt = d.slice(2).toLowerCase()
          , pt = DelegatedEvents.has(yt);
        if (!pt && m) {
            const bt = Array.isArray(m) ? m[0] : m;
            r.removeEventListener(yt, bt)
        }
        (pt || f) && (addEventListener(r, yt, f, pt),
        pt && delegateEvents([yt]))
    } else if ((mt = ChildProperties.has(d)) || !k && (PropAliases[d] || (dt = Properties.has(d))) || (ee = r.nodeName.includes("-")))
        d === "class" || d === "className" ? className(r, f) : ee && !dt && !mt ? r[toPropertyName(d)] = f : r[PropAliases[d] || d] = f;
    else {
        const yt = k && d.indexOf(":") > -1 && SVGNamespace[d.split(":")[0]];
        yt ? setAttributeNS(r, yt, d, f) : setAttribute(r, Aliases[d] || d, f)
    }
    return f
}
function eventHandler(r) {
    const d = `$$${r.type}`;
    let f = r.composedPath && r.composedPath()[0] || r.target;
    for (r.target !== f && Object.defineProperty(r, "target", {
        configurable: !0,
        value: f
    }),
    Object.defineProperty(r, "currentTarget", {
        configurable: !0,
        get() {
            return f || document
        }
    }),
    sharedConfig.registry && !sharedConfig.done && (sharedConfig.done = !0,
    document.querySelectorAll("[id^=pl-]").forEach(m=>{
        for (; m && m.nodeType !== 8 && m.nodeValue !== "pl-" + r; ) {
            let k = m.nextSibling;
            m.remove(),
            m = k
        }
        m && m.remove()
    }
    )); f; ) {
        const m = f[d];
        if (m && !f.disabled) {
            const k = f[`${d}Data`];
            if (k !== void 0 ? m.call(f, k, r) : m.call(f, r),
            r.cancelBubble)
                return
        }
        f = f._$host || f.parentNode || f.host
    }
}
function insertExpression(r, d, f, m, k) {
    for (sharedConfig.context && !f && (f = [...r.childNodes]); typeof f == "function"; )
        f = f();
    if (d === f)
        return f;
    const y = typeof d
      , ee = m !== void 0;
    if (r = ee && f[0] && f[0].parentNode || r,
    y === "string" || y === "number") {
        if (sharedConfig.context)
            return f;
        if (y === "number" && (d = d.toString()),
        ee) {
            let dt = f[0];
            dt && dt.nodeType === 3 ? dt.data = d : dt = document.createTextNode(d),
            f = cleanChildren(r, f, m, dt)
        } else
            f !== "" && typeof f == "string" ? f = r.firstChild.data = d : f = r.textContent = d
    } else if (d == null || y === "boolean") {
        if (sharedConfig.context)
            return f;
        f = cleanChildren(r, f, m)
    } else {
        if (y === "function")
            return createRenderEffect(()=>{
                let dt = d();
                for (; typeof dt == "function"; )
                    dt = dt();
                f = insertExpression(r, dt, f, m)
            }
            ),
            ()=>f;
        if (Array.isArray(d)) {
            const dt = []
              , mt = f && Array.isArray(f);
            if (normalizeIncomingArray(dt, d, f, k))
                return createRenderEffect(()=>f = insertExpression(r, dt, f, m, !0)),
                ()=>f;
            if (sharedConfig.context) {
                if (!dt.length)
                    return f;
                for (let yt = 0; yt < dt.length; yt++)
                    if (dt[yt].parentNode)
                        return f = dt
            }
            if (dt.length === 0) {
                if (f = cleanChildren(r, f, m),
                ee)
                    return f
            } else
                mt ? f.length === 0 ? appendNodes(r, dt, m) : reconcileArrays(r, f, dt) : (f && cleanChildren(r),
                appendNodes(r, dt));
            f = dt
        } else if (d instanceof Node) {
            if (sharedConfig.context && d.parentNode)
                return f = ee ? [d] : d;
            if (Array.isArray(f)) {
                if (ee)
                    return f = cleanChildren(r, f, m, d);
                cleanChildren(r, f, null, d)
            } else
                f == null || f === "" || !r.firstChild ? r.appendChild(d) : r.replaceChild(d, r.firstChild);
            f = d
        }
    }
    return f
}
function normalizeIncomingArray(r, d, f, m) {
    let k = !1;
    for (let y = 0, ee = d.length; y < ee; y++) {
        let dt = d[y]
          , mt = f && f[y];
        if (dt instanceof Node)
            r.push(dt);
        else if (!(dt == null || dt === !0 || dt === !1))
            if (Array.isArray(dt))
                k = normalizeIncomingArray(r, dt, mt) || k;
            else if (typeof dt == "function")
                if (m) {
                    for (; typeof dt == "function"; )
                        dt = dt();
                    k = normalizeIncomingArray(r, Array.isArray(dt) ? dt : [dt], Array.isArray(mt) ? mt : [mt]) || k
                } else
                    r.push(dt),
                    k = !0;
            else {
                const yt = String(dt);
                mt && mt.nodeType === 3 && mt.data === yt ? r.push(mt) : r.push(document.createTextNode(yt))
            }
    }
    return k
}
function appendNodes(r, d, f=null) {
    for (let m = 0, k = d.length; m < k; m++)
        r.insertBefore(d[m], f)
}
function cleanChildren(r, d, f, m) {
    if (f === void 0)
        return r.textContent = "";
    const k = m || document.createTextNode("");
    if (d.length) {
        let y = !1;
        for (let ee = d.length - 1; ee >= 0; ee--) {
            const dt = d[ee];
            if (k !== dt) {
                const mt = dt.parentNode === r;
                !y && !ee ? mt ? r.replaceChild(k, dt) : r.insertBefore(k, f) : mt && dt.remove()
            } else
                y = !0
        }
    } else
        r.insertBefore(k, f);
    return [k]
}
function getHydrationKey() {
    const r = sharedConfig.context;
    return `${r.id}${r.count++}`
}
const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
function createElement(r, d=!1) {
    return d ? document.createElementNS(SVG_NAMESPACE, r) : document.createElement(r)
}
function Portal(r) {
    const {useShadow: d} = r
      , f = document.createTextNode("")
      , m = r.mount || document.body;
    function k() {
        if (sharedConfig.context) {
            const [y,ee] = createSignal(!1);
            return queueMicrotask(()=>ee(!0)),
            ()=>y() && r.children
        } else
            return ()=>r.children
    }
    if (m instanceof HTMLHeadElement) {
        const [y,ee] = createSignal(!1)
          , dt = ()=>ee(!0);
        createRoot(mt=>insert(m, ()=>y() ? mt() : k()(), null)),
        onCleanup(()=>{
            sharedConfig.context ? queueMicrotask(dt) : dt()
        }
        )
    } else {
        const y = createElement(r.isSVG ? "g" : "div", r.isSVG)
          , ee = d && y.attachShadow ? y.attachShadow({
            mode: "open"
        }) : y;
        Object.defineProperty(y, "_$host", {
            get() {
                return f.parentNode
            },
            configurable: !0
        }),
        insert(ee, k()),
        m.appendChild(y),
        r.ref && r.ref(y),
        onCleanup(()=>m.removeChild(y))
    }
    return f
}
function Dynamic(r) {
    const [d,f] = splitProps(r, ["component"])
      , m = createMemo(()=>d.component);
    return createMemo(()=>{
        const k = m();
        switch (typeof k) {
        case "function":
            return untrack(()=>k(f));
        case "string":
            const y = SVGElements.has(k)
              , ee = sharedConfig.context ? getNextElement() : createElement(k, y);
            return spread$1(ee, f, y),
            ee
        }
    }
    )
}
var THEME = (r=>(r.DARK = "DARK",
r.LIGHT = "LIGHT",
r))(THEME || {});
let e = {
    data: ""
}
  , t = r=>typeof window == "object" ? ((r ? r.querySelector("#_goober") : window._goober) || Object.assign((r || document.head).appendChild(document.createElement("style")), {
    innerHTML: " ",
    id: "_goober"
})).firstChild : r || e
  , l = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g
  , a = /\/\*[^]*?\*\/|  +/g
  , n = /\n+/g
  , o = (r,d)=>{
    let f = ""
      , m = ""
      , k = "";
    for (let y in r) {
        let ee = r[y];
        y[0] == "@" ? y[1] == "i" ? f = y + " " + ee + ";" : m += y[1] == "f" ? o(ee, y) : y + "{" + o(ee, y[1] == "k" ? "" : d) + "}" : typeof ee == "object" ? m += o(ee, d ? d.replace(/([^,])+/g, dt=>y.replace(/(^:.*)|([^,])+/g, mt=>/&/.test(mt) ? mt.replace(/&/g, dt) : dt ? dt + " " + mt : mt)) : y) : ee != null && (y = /^--/.test(y) ? y : y.replace(/[A-Z]/g, "-$&").toLowerCase(),
        k += o.p ? o.p(y, ee) : y + ":" + ee + ";")
    }
    return f + (d && k ? d + "{" + k + "}" : k) + m
}
  , c = {}
  , s = r=>{
    if (typeof r == "object") {
        let d = "";
        for (let f in r)
            d += f + s(r[f]);
        return d
    }
    return r
}
  , i = (r,d,f,m,k)=>{
    let y = s(r)
      , ee = c[y] || (c[y] = (mt=>{
        let yt = 0
          , pt = 11;
        for (; yt < mt.length; )
            pt = 101 * pt + mt.charCodeAt(yt++) >>> 0;
        return "go" + pt
    }
    )(y));
    if (!c[ee]) {
        let mt = y !== r ? r : (yt=>{
            let pt, bt, wt = [{}];
            for (; pt = l.exec(yt.replace(a, "")); )
                pt[4] ? wt.shift() : pt[3] ? (bt = pt[3].replace(n, " ").trim(),
                wt.unshift(wt[0][bt] = wt[0][bt] || {})) : wt[0][pt[1]] = pt[2].replace(n, " ").trim();
            return wt[0]
        }
        )(r);
        c[ee] = o(k ? {
            ["@keyframes " + ee]: mt
        } : mt, f ? "" : "." + ee)
    }
    let dt = f && c.g ? c.g : null;
    return f && (c.g = c[ee]),
    ((mt,yt,pt,bt)=>{
        bt ? yt.data = yt.data.replace(bt, mt) : yt.data.indexOf(mt) === -1 && (yt.data = pt ? mt + yt.data : yt.data + mt)
    }
    )(c[ee], d, m, dt),
    ee
}
  , p$1 = (r,d,f)=>r.reduce((m,k,y)=>{
    let ee = d[y];
    if (ee && ee.call) {
        let dt = ee(f)
          , mt = dt && dt.props && dt.props.className || /^go/.test(dt) && dt;
        ee = mt ? "." + mt : dt && typeof dt == "object" ? dt.props ? "" : o(dt, "") : dt === !1 ? "" : dt
    }
    return m + k + (ee ?? "")
}
, "");
function u$1(r) {
    let d = this || {}
      , f = r.call ? r(d.p) : r;
    return i(f.unshift ? f.raw ? p$1(f, [].slice.call(arguments, 1), d.p) : f.reduce((m,k)=>Object.assign(m, k && k.call ? k(d.p) : k), {}) : f, t(d.target), d.g, d.o, d.k)
}
u$1.bind({
    g: 1
});
let h = u$1.bind({
    k: 1
});
const ThemeContext = createContext();
function ThemeProvider(r) {
    return createComponent(ThemeContext.Provider, {
        value: r.theme,
        get children() {
            return r.children
        }
    })
}
function useTheme() {
    return useContext(ThemeContext)
}
function makeStyled(r) {
    let d = this || {};
    return (...f)=>{
        const m = k=>{
            const y = useContext(ThemeContext)
              , ee = mergeProps(k, {
                theme: y
            })
              , dt = mergeProps(ee, {
                get class() {
                    const xt = ee.class
                      , At = "class"in ee && /^go[0-9]+/.test(xt);
                    let Ct = u$1.apply({
                        target: d.target,
                        o: At,
                        p: ee,
                        g: d.g
                    }, f);
                    return [xt, Ct].filter(Boolean).join(" ")
                }
            })
              , [mt,yt] = splitProps(dt, ["as", "theme"])
              , pt = yt
              , bt = mt.as || r;
            let wt;
            return typeof bt == "function" ? wt = bt(pt) : d.g == 1 ? (wt = document.createElement(bt),
            spread$1(wt, pt)) : wt = Dynamic(mergeProps({
                component: bt
            }, pt)),
            wt
        }
        ;
        return m.class = k=>untrack(()=>u$1.apply({
            target: d.target,
            p: k,
            g: d.g
        }, f)),
        m
    }
}
const styled = new Proxy(makeStyled,{
    get(r, d) {
        return r(d)
    }
});
function createGlobalStyles() {
    const r = makeStyled.call({
        g: 1
    }, "div").apply(null, arguments);
    return function(f) {
        return r(f),
        null
    }
}
const globalStylesTag = "tc-root"
  , disableScrollClass = "tc-disable-scroll"
  , usingMouseClass = "tc-using-mouse"
  , GlobalStyles = ()=>{
    document.body.addEventListener("mousedown", ()=>document.body.classList.add(usingMouseClass)),
    document.body.addEventListener("keydown", d=>{
        d.key === "Tab" && document.body.classList.remove(usingMouseClass)
    }
    );
    const r = createGlobalStyles`
    ${globalStylesTag} * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        
        font-family: -apple-system, BlinkMacSystemFont, 'Roboto', 'Helvetica Neue', Arial, Tahoma, Verdana, sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;        
        -webkit-tap-highlight-color: transparent;
    }
    
    ${globalStylesTag} img {
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }   
 
    ${globalStylesTag} *:focus {
        outline: #08f auto 2px;
    }
    
    ${globalStylesTag} li {
        list-style: none;
    }
    
    ${globalStylesTag} button {
        outline: none;
    }
    
    body.${disableScrollClass} {
        position: fixed; 
        overflow-y: scroll;
        right: 0;
        left: 0;
    }
    
    body.${usingMouseClass} ${globalStylesTag} *:focus {
        outline: none;
    }
`;
    return createComponent(r, {})
}
;
function hexToRgb(r) {
    r[0] === "#" && (r = r.slice(1));
    const d = parseInt(r, 16)
      , f = d >> 16 & 255
      , m = d >> 8 & 255
      , k = d & 255;
    return [f, m, k].join(",")
}
function rgba(r, d) {
    return r[0] === "#" && (r = hexToRgb(r)),
    `rgba(${r}, ${d})`
}
function toPx(r) {
    return r.toString() + "px"
}
const _InMemoryStorage = class {
    constructor() {
        __publicField(this, "storage", {})
    }
    static getInstance() {
        return _InMemoryStorage.instance || (_InMemoryStorage.instance = new _InMemoryStorage),
        _InMemoryStorage.instance
    }
    get length() {
        return Object.keys(this.storage).length
    }
    clear() {
        this.storage = {}
    }
    getItem(r) {
        var d;
        return (d = this.storage[r]) != null ? d : null
    }
    key(r) {
        var d;
        const f = Object.keys(this.storage);
        return r < 0 || r >= f.length ? null : (d = f[r]) != null ? d : null
    }
    removeItem(r) {
        delete this.storage[r]
    }
    setItem(r, d) {
        this.storage[r] = d
    }
}
;
let InMemoryStorage = _InMemoryStorage;
__publicField(InMemoryStorage, "instance");
class TonConnectUIError extends TonConnectError {
    constructor(...d) {
        super(...d),
        Object.setPrototypeOf(this, TonConnectUIError.prototype)
    }
}
function logDebug(...r) {
    try {
        console.debug("[TON_CONNECT_UI]", ...r)
    } catch {}
}
function logError(...r) {
    try {
        console.error("[TON_CONNECT_UI]", ...r)
    } catch {}
}
function logWarning(...r) {
    try {
        console.warn("[TON_CONNECT_UI]", ...r)
    } catch {}
}
function openLink(r, d="_self") {
    logDebug("openLink", r, d),
    window.open(r, d, "noopener noreferrer")
}
function openLinkBlank(r) {
    openLink(r, "_blank")
}
function openDeeplinkWithFallback(r, d) {
    const f = ()=>{
        isBrowser("safari") || isOS("android") && isBrowser("firefox") || d()
    }
      , m = setTimeout(()=>f(), 200);
    window.addEventListener("blur", ()=>clearTimeout(m), {
        once: !0
    }),
    openLink(r, "_self")
}
function getSystemTheme() {
    return window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches ? THEME.LIGHT : THEME.DARK
}
function subscribeToThemeChange(r) {
    const d = f=>r(f.matches ? THEME.DARK : THEME.LIGHT);
    return window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", d),
    ()=>window.matchMedia("(prefers-color-scheme: dark)").removeEventListener("change", d)
}
function disableScroll() {
    document.documentElement.scrollHeight !== document.documentElement.clientHeight && (document.body.style.top = toPx(-document.documentElement.scrollTop),
    document.body.classList.add(disableScrollClass))
}
function enableScroll() {
    document.body.classList.remove(disableScrollClass),
    document.documentElement.scrollTo({
        top: -parseFloat(getComputedStyle(document.body).top)
    }),
    document.body.style.top = "auto"
}
function fixMobileSafariActiveTransition() {
    document.body.hasAttribute("ontouchstart") || document.body.setAttribute("ontouchstart", "")
}
function defineStylesRoot() {
    customElements.define(globalStylesTag, class extends HTMLElement {
    }
    )
}
function createMacrotask(r) {
    return __async(this, null, function*() {
        yield new Promise(d=>requestAnimationFrame(d)),
        r()
    })
}
function createMacrotaskAsync(r) {
    return __async(this, null, function*() {
        return yield new Promise(d=>requestAnimationFrame(d)),
        r()
    })
}
function preloadImages(r) {
    document.readyState !== "complete" ? window.addEventListener("load", ()=>createMacrotask(()=>preloadImages(r)), {
        once: !0
    }) : r.forEach(d=>{
        const f = new window.Image;
        f.src = d
    }
    )
}
function getWindow$1() {
    if (typeof window < "u")
        return window
}
function tryGetLocalStorage() {
    if (isLocalStorageAvailable())
        return localStorage;
    if (isNodeJs())
        throw new TonConnectUIError("`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector");
    return InMemoryStorage.getInstance()
}
function isLocalStorageAvailable() {
    try {
        return typeof localStorage < "u"
    } catch {
        return !1
    }
}
function isNodeJs() {
    return typeof process$1 < "u" && process$1.versions != null && process$1.versions.node != null
}
function getUserAgent() {
    var r, d, f;
    const m = new UAParser().getResult()
      , k = (r = m.os.name) == null ? void 0 : r.toLowerCase()
      , y = (d = m.device.model) == null ? void 0 : d.toLowerCase();
    let ee;
    switch (!0) {
    case y === "ipad":
        ee = "ipad";
        break;
    case k === "ios":
        ee = "ios";
        break;
    case k === "android":
        ee = "android";
        break;
    case k === "mac os":
        ee = "macos";
        break;
    case k === "linux":
        ee = "linux";
        break;
    case (k == null ? void 0 : k.includes("windows")):
        ee = "windows";
        break
    }
    const dt = (f = m.browser.name) == null ? void 0 : f.toLowerCase();
    let mt;
    switch (!0) {
    case dt === "chrome":
        mt = "chrome";
        break;
    case dt === "firefox":
        mt = "firefox";
        break;
    case (dt == null ? void 0 : dt.includes("safari")):
        mt = "safari";
        break;
    case (dt == null ? void 0 : dt.includes("opera")):
        mt = "opera";
        break
    }
    return {
        os: ee,
        browser: mt
    }
}
function isOS(...r) {
    return r.includes(getUserAgent().os)
}
function isBrowser(...r) {
    return r.includes(getUserAgent().browser)
}
function toDeeplink(r, d) {
    const f = new URL(r);
    return d + f.search
}
class WalletInfoStorage {
    constructor() {
        __publicField(this, "localStorage"),
        __publicField(this, "storageKey", "ton-connect-ui_wallet-info"),
        this.localStorage = tryGetLocalStorage()
    }
    setWalletInfo(d) {
        this.localStorage.setItem(this.storageKey, JSON.stringify(d))
    }
    getWalletInfo() {
        const d = this.localStorage.getItem(this.storageKey);
        return d ? JSON.parse(d) : null
    }
    removeWalletInfo() {
        this.localStorage.removeItem(this.storageKey)
    }
}
class PreferredWalletStorage {
    constructor() {
        __publicField(this, "localStorage"),
        __publicField(this, "storageKey", "ton-connect-ui_preferred-wallet"),
        this.localStorage = tryGetLocalStorage()
    }
    setPreferredWalletAppName(d) {
        this.localStorage.setItem(this.storageKey, d)
    }
    getPreferredWalletAppName() {
        return this.localStorage.getItem(this.storageKey) || void 0
    }
}
class LastSelectedWalletInfoStorage {
    constructor() {
        __publicField(this, "localStorage"),
        __publicField(this, "storageKey", "ton-connect-ui_last-selected-wallet-info"),
        this.localStorage = tryGetLocalStorage()
    }
    setLastSelectedWalletInfo(d) {
        this.localStorage.setItem(this.storageKey, JSON.stringify(d))
    }
    getLastSelectedWalletInfo() {
        const d = this.localStorage.getItem(this.storageKey);
        return d ? JSON.parse(d) : null
    }
    removeLastSelectedWalletInfo() {
        this.localStorage.removeItem(this.storageKey)
    }
}
const [walletsModalState,setWalletsModalState] = createSignal({
    status: "closed",
    closeReason: null
})
  , getWalletsModalIsOpened = createMemo(()=>walletsModalState().status === "opened")
  , [singleWalletModalState,setSingleWalletModalState] = createSignal({
    status: "closed",
    closeReason: null
})
  , getSingleWalletModalIsOpened = createMemo(()=>singleWalletModalState().status === "opened")
  , getSingleWalletModalWalletInfo = createMemo(()=>{
    const r = singleWalletModalState();
    return r.status === "opened" ? r.walletInfo : null
}
);
let lastSelectedWalletInfoStorage = typeof window < "u" ? new LastSelectedWalletInfoStorage : void 0;
const [lastSelectedWalletInfo,_setLastSelectedWalletInfo] = createSignal((lastSelectedWalletInfoStorage == null ? void 0 : lastSelectedWalletInfoStorage.getLastSelectedWalletInfo()) || null)
  , setLastSelectedWalletInfo = r=>{
    lastSelectedWalletInfoStorage || (lastSelectedWalletInfoStorage = new LastSelectedWalletInfoStorage),
    r ? lastSelectedWalletInfoStorage.setLastSelectedWalletInfo(r) : lastSelectedWalletInfoStorage.removeLastSelectedWalletInfo(),
    _setLastSelectedWalletInfo(r)
}
  , [action,setAction] = createSignal(null)
  , common$1 = {
    close: "Close",
    openWallet: "Open wallet",
    copyLink: "Copy Link",
    linkCopied: "Link Copied",
    copied: "Copied",
    yourWallet: "Your Wallet",
    retry: "Retry",
    get: "GET",
    mobile: "Mobile",
    browserExtension: "Browser Extension",
    desktop: "Desktop"
}
  , button$1 = {
    connectWallet: "Connect Wallet",
    dropdown: {
        copy: "Copy address",
        copied: "Address copied!",
        disconnect: "Disconnect"
    }
}
  , notifications$1 = {
    confirm: {
        header: "Open {{ name }} to confirm the transaction."
    },
    transactionSent: {
        header: "Transaction sent",
        text: "Your transaction will be processed in a few seconds."
    },
    transactionCanceled: {
        header: "Transaction canceled",
        text: "There will be no changes to your account."
    }
}
  , walletItem$1 = {
    walletOn: "Wallet On",
    recent: "Recent",
    installed: "Installed",
    popular: "Popular"
}
  , walletModal$1 = {
    loading: "Loading wallets",
    wallets: "Wallets",
    mobileUniversalModal: {
        connectYourWallet: "Connect your wallet",
        openWalletOnTelegramOrSelect: "Open Wallet in Telegram or select your wallet to connect",
        openWalletOnTelegram: "Open Wallet in Telegram",
        openLink: "Open Link",
        scan: "Scan with your mobile wallet"
    },
    desktopUniversalModal: {
        connectYourWallet: "Connect your wallet",
        scan: "Scan with your mobile wallet",
        availableWallets: "Available wallets"
    },
    mobileConnectionModal: {
        showQR: "Show QR Code",
        scanQR: "Scan the QR code below with your phone’s or {{ name }}’s camera",
        continueIn: "Continue in {{ name }}…",
        connectionDeclined: "Connection declined"
    },
    desktopConnectionModal: {
        scanQR: "Scan the QR code below with your phone’s or {{ name }}’s camera",
        continueInExtension: "Continue in {{ name }} browser extension…",
        dontHaveExtension: "Seems you don't have installed {{ name }} browser extension",
        getWallet: "Get {{ name }}",
        continueOnDesktop: "Continue in {{ name }} on desktop…",
        openWalletOnTelegram: "Open Wallet in Telegram on desktop",
        connectionDeclined: "Connection declined"
    },
    infoModal: {
        whatIsAWallet: "What is a wallet",
        secureDigitalAssets: "Secure digital assets storage",
        walletProtects: "A wallet protects and manages your digital assets including TON, tokens and collectables.",
        controlIdentity: "Control your Web3 identity",
        manageIdentity: "Manage your digital identity and access decentralized applications with ease. Maintain control over your data and engage securely in the blockchain ecosystem.",
        effortlessCryptoTransactions: "Effortless crypto transactions",
        easilySend: "Easily send, receive, monitor your cryptocurrencies. Streamline your operations with decentralized applications.",
        getAWallet: "Get a Wallet"
    }
}
  , actionModal$1 = {
    confirmTransaction: {
        header: "Confirm the transaction in {{ name }}",
        text: "It will only take a moment."
    },
    transactionSent: "$notifications.transactionSent",
    transactionCanceled: "$notifications.transactionCanceled"
}
  , en$1 = {
    common: common$1,
    button: button$1,
    notifications: notifications$1,
    walletItem: walletItem$1,
    walletModal: walletModal$1,
    actionModal: actionModal$1
}
  , common = {
    close: "Закрыть",
    openWallet: "Открыть кошелёк",
    copyLink: "Копировать ссылку",
    linkCopied: "Ссылка скопирована",
    copied: "Ссылка скопирована",
    yourWallet: "Ваш кошелёк",
    retry: "Повторить",
    get: "Скачать",
    mobile: "Мобильный",
    browserExtension: "Расширение",
    desktop: "Десктоп"
}
  , button$2 = {
    connectWallet: "Подключить кошелёк",
    dropdown: {
        copy: "Скопировать адрес",
        copied: "Адрес скопирован!",
        disconnect: "Отключить кошелёк"
    }
}
  , notifications = {
    confirm: {
        header: "Откройте {{ name }}, чтобы подтвердить транзакцию."
    },
    transactionSent: {
        header: "Транзакция отправлена",
        text: "Ваша транзакция будет обработана через несколько секунд."
    },
    transactionCanceled: {
        header: "Транзакция отменена",
        text: "Состояние вашего счёта не изменится."
    }
}
  , walletItem = {
    walletOn: "Wallet в",
    recent: "Недавний",
    installed: "Установлен",
    popular: "Популярен"
}
  , walletModal = {
    loading: "Кошельки загружаются",
    wallets: "Кошельки",
    mobileUniversalModal: {
        connectYourWallet: "Подключите кошелёк",
        openWalletOnTelegramOrSelect: "Подключите Wallet в Telegram или выберете кошелёк для подключения",
        openWalletOnTelegram: "Открыть Wallet в Telegram",
        openLink: "Открыть ссылку",
        scan: "Отсканируйте камерой вашего телефона"
    },
    desktopUniversalModal: {
        connectYourWallet: "Подключите кошелёк",
        scan: "Отсканируйте QR-код камерой вашего телефона",
        availableWallets: "Доступные кошельки"
    },
    mobileConnectionModal: {
        showQR: "Показать QR-код",
        scanQR: "Отсканируйте QR-код ниже камерой в приложении {{ name }}, или камерой телефона",
        continueIn: "Продолжите в {{ name }}…",
        connectionDeclined: "Подключение отклонено"
    },
    desktopConnectionModal: {
        scanQR: "Отсканируйте QR-код ниже камерой в приложении {{ name }}, или камерой телефона",
        continueInExtension: "Откройте браузерное расширение {{ name }}",
        dontHaveExtension: "Похоже, у вас не установлено браузерное расширение {{ name }}",
        getWallet: "Скачать {{ name }}",
        continueOnDesktop: "Откройте {{ name }} на компьютере…",
        openWalletOnTelegram: "Открыть Wallet в Telegram",
        connectionDeclined: "Подключение отклонено"
    },
    infoModal: {
        whatIsAWallet: "Что такое кошелёк?",
        secureDigitalAssets: "Надежное хранилище цифровых активов",
        walletProtects: "Кошелёк защищает ваши цифровые активы, включая TON, токены и предметы коллекционирования, и управляет ими.",
        controlIdentity: "Контроль своей личности Web3",
        manageIdentity: "Управляйте своей цифровой идентификацией и с легкостью получайте доступ к децентрализованным приложениям. Сохраняйте контроль над своими данными и безопасно участвуйте в экосистеме блокчейна.",
        effortlessCryptoTransactions: "Простые криптотранзакции",
        easilySend: "Легко отправляйте, получайте и отслеживайте свои криптовалюты. Оптимизируйте свои операции с помощью децентрализованных приложений.",
        getAWallet: "Скачать кошелёк"
    }
}
  , actionModal = {
    confirmTransaction: {
        header: "Подтвердите действие в {{ name }}",
        text: "Это займет пару секунд."
    },
    transactionSent: "$notifications.transactionSent",
    transactionCanceled: "$notifications.transactionCanceled"
}
  , ru = {
    common,
    button: button$2,
    notifications,
    walletItem,
    walletModal,
    actionModal
}
  , i18nDictionary = {
    en: parseDictionary(en$1),
    ru: parseDictionary(ru)
};
function parseDictionary(r) {
    const d = "$"
      , f = m=>{
        Object.entries(m).forEach(([k,y])=>{
            if (typeof y == "object" && y)
                return f(y);
            if (typeof y == "string") {
                if (y[0] === d) {
                    const ee = y.slice(1).split(".");
                    let dt = r;
                    ee.forEach(mt=>{
                        if (mt in dt)
                            dt = dt[mt];
                        else
                            throw new Error(`Cannot parse translations: there is no property ${mt} in translation`)
                    }
                    ),
                    m[k] = dt
                }
                y.slice(0, 2) === `\\${d}` && (m[k] = y.slice(1))
            }
        }
        )
    }
    ;
    return f(r),
    r
}
const ConnectorContext = createContext()
  , $RAW = Symbol("store-raw")
  , $NODE = Symbol("store-node")
  , $NAME = Symbol("store-name");
function wrap$1(r, d) {
    let f = r[$PROXY];
    if (!f && (Object.defineProperty(r, $PROXY, {
        value: f = new Proxy(r,proxyTraps$1)
    }),
    !Array.isArray(r))) {
        const m = Object.keys(r)
          , k = Object.getOwnPropertyDescriptors(r);
        for (let y = 0, ee = m.length; y < ee; y++) {
            const dt = m[y];
            k[dt].get && Object.defineProperty(r, dt, {
                enumerable: k[dt].enumerable,
                get: k[dt].get.bind(f)
            })
        }
    }
    return f
}
function isWrappable(r) {
    let d;
    return r != null && typeof r == "object" && (r[$PROXY] || !(d = Object.getPrototypeOf(r)) || d === Object.prototype || Array.isArray(r))
}
function unwrap(r, d=new Set) {
    let f, m, k, y;
    if (f = r != null && r[$RAW])
        return f;
    if (!isWrappable(r) || d.has(r))
        return r;
    if (Array.isArray(r)) {
        Object.isFrozen(r) ? r = r.slice(0) : d.add(r);
        for (let ee = 0, dt = r.length; ee < dt; ee++)
            k = r[ee],
            (m = unwrap(k, d)) !== k && (r[ee] = m)
    } else {
        Object.isFrozen(r) ? r = Object.assign({}, r) : d.add(r);
        const ee = Object.keys(r)
          , dt = Object.getOwnPropertyDescriptors(r);
        for (let mt = 0, yt = ee.length; mt < yt; mt++)
            y = ee[mt],
            !dt[y].get && (k = r[y],
            (m = unwrap(k, d)) !== k && (r[y] = m))
    }
    return r
}
function getDataNodes(r) {
    let d = r[$NODE];
    return d || Object.defineProperty(r, $NODE, {
        value: d = {}
    }),
    d
}
function getDataNode(r, d, f) {
    return r[d] || (r[d] = createDataNode(f))
}
function proxyDescriptor$1(r, d) {
    const f = Reflect.getOwnPropertyDescriptor(r, d);
    return !f || f.get || !f.configurable || d === $PROXY || d === $NODE || d === $NAME || (delete f.value,
    delete f.writable,
    f.get = ()=>r[$PROXY][d]),
    f
}
function trackSelf(r) {
    if (getListener()) {
        const d = getDataNodes(r);
        (d._ || (d._ = createDataNode()))()
    }
}
function ownKeys(r) {
    return trackSelf(r),
    Reflect.ownKeys(r)
}
function createDataNode(r) {
    const [d,f] = createSignal(r, {
        equals: !1,
        internal: !0
    });
    return d.$ = f,
    d
}
const proxyTraps$1 = {
    get(r, d, f) {
        if (d === $RAW)
            return r;
        if (d === $PROXY)
            return f;
        if (d === $TRACK)
            return trackSelf(r),
            f;
        const m = getDataNodes(r)
          , k = m.hasOwnProperty(d);
        let y = k ? m[d]() : r[d];
        if (d === $NODE || d === "__proto__")
            return y;
        if (!k) {
            const ee = Object.getOwnPropertyDescriptor(r, d);
            getListener() && (typeof y != "function" || r.hasOwnProperty(d)) && !(ee && ee.get) && (y = getDataNode(m, d, y)())
        }
        return isWrappable(y) ? wrap$1(y) : y
    },
    has(r, d) {
        return d === $RAW || d === $PROXY || d === $TRACK || d === $NODE || d === "__proto__" ? !0 : (this.get(r, d, r),
        d in r)
    },
    set() {
        return !0
    },
    deleteProperty() {
        return !0
    },
    ownKeys,
    getOwnPropertyDescriptor: proxyDescriptor$1
};
function setProperty(r, d, f, m=!1) {
    if (!m && r[d] === f)
        return;
    const k = r[d]
      , y = r.length;
    f === void 0 ? delete r[d] : r[d] = f;
    let ee = getDataNodes(r), dt;
    (dt = getDataNode(ee, d, k)) && dt.$(()=>f),
    Array.isArray(r) && r.length !== y && (dt = getDataNode(ee, "length", y)) && dt.$(r.length),
    (dt = ee._) && dt.$()
}
function mergeStoreNode(r, d) {
    const f = Object.keys(d);
    for (let m = 0; m < f.length; m += 1) {
        const k = f[m];
        setProperty(r, k, d[k])
    }
}
function updateArray(r, d) {
    if (typeof d == "function" && (d = d(r)),
    d = unwrap(d),
    Array.isArray(d)) {
        if (r === d)
            return;
        let f = 0
          , m = d.length;
        for (; f < m; f++) {
            const k = d[f];
            r[f] !== k && setProperty(r, f, k)
        }
        setProperty(r, "length", m)
    } else
        mergeStoreNode(r, d)
}
function updatePath(r, d, f=[]) {
    let m, k = r;
    if (d.length > 1) {
        m = d.shift();
        const ee = typeof m
          , dt = Array.isArray(r);
        if (Array.isArray(m)) {
            for (let mt = 0; mt < m.length; mt++)
                updatePath(r, [m[mt]].concat(d), f);
            return
        } else if (dt && ee === "function") {
            for (let mt = 0; mt < r.length; mt++)
                m(r[mt], mt) && updatePath(r, [mt].concat(d), f);
            return
        } else if (dt && ee === "object") {
            const {from: mt=0, to: yt=r.length - 1, by: pt=1} = m;
            for (let bt = mt; bt <= yt; bt += pt)
                updatePath(r, [bt].concat(d), f);
            return
        } else if (d.length > 1) {
            updatePath(r[m], d, [m].concat(f));
            return
        }
        k = r[m],
        f = [m].concat(f)
    }
    let y = d[0];
    typeof y == "function" && (y = y(k, f),
    y === k) || m === void 0 && y == null || (y = unwrap(y),
    m === void 0 || isWrappable(k) && isWrappable(y) && !Array.isArray(y) ? mergeStoreNode(k, y) : setProperty(r, m, y))
}
function createStore(...[r,d]) {
    const f = unwrap(r || {})
      , m = Array.isArray(f)
      , k = wrap$1(f);
    function y(...ee) {
        batch(()=>{
            m && ee.length === 1 ? updateArray(f, ee[0]) : updatePath(f, ee)
        }
        )
    }
    return [k, y]
}
const defaultLightColorsSet = {
    constant: {
        black: "#000000",
        white: "#FFFFFF"
    },
    connectButton: {
        background: "#0098EA",
        foreground: "#FFFFFF"
    },
    accent: "#0098EA",
    telegramButton: "#0098EA",
    icon: {
        primary: "#0F0F0F",
        secondary: "#7A8999",
        tertiary: "#C1CAD2",
        success: "#29CC6A",
        error: "#F5A73B"
    },
    background: {
        primary: "#FFFFFF",
        secondary: "#F1F3F5",
        segment: "#FFFFFF",
        tint: "#F1F3F5",
        qr: "#F1F3F5"
    },
    text: {
        primary: "#0F0F0F",
        secondary: "#6A7785"
    }
}
  , defaultDarkColorsSet = {
    constant: {
        black: "#000000",
        white: "#FFFFFF"
    },
    connectButton: {
        background: "#0098EA",
        foreground: "#FFFFFF"
    },
    accent: "#E5E5EA",
    telegramButton: "#31A6F5",
    icon: {
        primary: "#E5E5EA",
        secondary: "#909099",
        tertiary: "#434347",
        success: "#29CC6A",
        error: "#F5A73B"
    },
    background: {
        primary: "#121214",
        secondary: "#18181A",
        segment: "#262629",
        tint: "#222224",
        qr: "#FFFFFF"
    },
    text: {
        primary: "#E5E5EA",
        secondary: "#7D7D85"
    }
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function isObject$1(r) {
    return Object.prototype.toString.call(r) === "[object Object]"
}
function isPlainObject$1(r) {
    var d, f;
    return isObject$1(r) === !1 ? !1 : (d = r.constructor,
    d === void 0 ? !0 : (f = d.prototype,
    !(isObject$1(f) === !1 || f.hasOwnProperty("isPrototypeOf") === !1)))
}
function mergeOptions(r, d) {
    return r ? deepmerge$1(d, r, {
        arrayMerge: (m,k,y)=>k,
        isMergeableObject: isPlainObject$1
    }) : d
}
const [themeState,setThemeState] = createStore({
    theme: THEME.LIGHT,
    colors: defaultLightColorsSet,
    borderRadius: "m"
})
  , themeColorsMappingDefault = {
    [THEME.LIGHT]: defaultLightColorsSet,
    [THEME.DARK]: defaultDarkColorsSet
}
  , themeCustomColors = {
    [THEME.LIGHT]: void 0,
    [THEME.DARK]: void 0
};
function setTheme(r, d) {
    d && (themeCustomColors[THEME.DARK] = mergeOptions(d[THEME.DARK], themeCustomColors[THEME.DARK]),
    themeCustomColors[THEME.LIGHT] = mergeOptions(d[THEME.LIGHT], themeCustomColors[THEME.LIGHT])),
    setThemeState({
        theme: r,
        colors: mergeOptions(themeCustomColors[r], themeColorsMappingDefault[r])
    })
}
function setBorderRadius(r) {
    setThemeState({
        borderRadius: r
    })
}
function setColors(r) {
    themeCustomColors[THEME.DARK] = mergeOptions(r[THEME.DARK], themeCustomColors[THEME.DARK]),
    themeCustomColors[THEME.LIGHT] = mergeOptions(r[THEME.LIGHT], themeCustomColors[THEME.LIGHT]),
    setThemeState(d=>({
        colors: mergeOptions(themeCustomColors[d.theme], themeColorsMappingDefault[d.theme])
    }))
}
const ImagePlaceholder = styled.div`
    background-color: ${r=>r.theme.colors.background.secondary};
`
  , Image = r=>{
    let d;
    const [f,m] = createSignal(null);
    return createEffect(()=>{
        const k = new window.Image;
        return k.src = r.src,
        k.alt = r.alt || "",
        k.setAttribute("draggable", "false"),
        r.class && k.classList.add(r.class),
        k.complete ? m(k) : (k.addEventListener("load", ()=>m(k)),
        ()=>k.removeEventListener("load", ()=>m(k)))
    }
    ),
    [createComponent(Show, {
        get when() {
            return f()
        },
        get children() {
            return f()
        }
    }), createComponent(Show, {
        get when() {
            return !f()
        },
        get children() {
            return createComponent(ImagePlaceholder, {
                get class() {
                    return r.class
                },
                ref(k) {
                    const y = d;
                    typeof y == "function" ? y(k) : d = k
                }
            })
        }
    })]
}
;
let initParams = {};
try {
    let r = location.hash.toString();
    initParams = urlParseHashParams(r)
} catch (r) {}
let tmaPlatform = "unknown";
initParams != null && initParams.tgWebAppPlatform && (tmaPlatform = (_a$3 = initParams.tgWebAppPlatform) != null ? _a$3 : "unknown");
if (tmaPlatform === "unknown") {
    const r = getWindow$1();
    tmaPlatform = (_d = (_c = (_b = r == null ? void 0 : r.Telegram) == null ? void 0 : _b.WebApp) == null ? void 0 : _c.platform) != null ? _d : "unknown"
}
let webAppVersion = "6.0";
initParams != null && initParams.tgWebAppVersion && (webAppVersion = initParams.tgWebAppVersion);
if (!webAppVersion) {
    const r = getWindow$1();
    webAppVersion = (_g = (_f = (_e$1 = r == null ? void 0 : r.Telegram) == null ? void 0 : _e$1.WebApp) == null ? void 0 : _f.version) != null ? _g : "6.0"
}
function isTmaPlatform(...r) {
    return r.includes(tmaPlatform)
}
function isInTMA() {
    var r;
    return tmaPlatform !== "unknown" || !!((r = getWindow$1()) != null && r.TelegramWebviewProxy)
}
function sendExpand() {
    postEvent("web_app_expand", {})
}
function sendOpenTelegramLink(r, d) {
    const f = new URL(r);
    if (f.protocol !== "http:" && f.protocol !== "https:") {
        if (d)
            return d();
        throw new TonConnectUIError(`Url protocol is not supported: ${f}`)
    }
    if (f.hostname !== "t.me") {
        if (d)
            return d();
        throw new TonConnectUIError(`Url host is not supported: ${f}`)
    }
    const m = f.pathname + f.search;
    isIframe() || versionAtLeast("6.1") ? postEvent("web_app_open_tg_link", {
        path_full: m
    }) : openLinkBlank("https://t.me" + m)
}
function isIframe() {
    try {
        const r = getWindow$1();
        return r ? r.parent != null && r !== r.parent : !1
    } catch {
        return !1
    }
}
function postEvent(r, d) {
    try {
        const f = getWindow$1();
        if (!f)
            throw new TonConnectUIError("Can't post event to parent window: window is not defined");
        if (f.TelegramWebviewProxy !== void 0)
            logDebug("postEvent", r, d),
            f.TelegramWebviewProxy.postEvent(r, JSON.stringify(d));
        else if (f.external && "notify"in f.external)
            logDebug("postEvent", r, d),
            f.external.notify(JSON.stringify({
                eventType: r,
                eventData: d
            }));
        else if (isIframe()) {
            const m = "*"
              , k = JSON.stringify({
                eventType: r,
                eventData: d
            });
            logDebug("postEvent", r, d),
            f.parent.postMessage(k, m)
        } else
            throw new TonConnectUIError("Can't post event to TMA")
    } catch (f) {
        logError(`Can't post event to parent window: ${f}`)
    }
}
function urlParseHashParams(r) {
    r = r.replace(/^#/, "");
    let d = {};
    if (!r.length)
        return d;
    if (r.indexOf("=") < 0 && r.indexOf("?") < 0)
        return d._path = urlSafeDecode(r),
        d;
    let f = r.indexOf("?");
    if (f >= 0) {
        let k = r.substr(0, f);
        d._path = urlSafeDecode(k),
        r = r.substr(f + 1)
    }
    let m = urlParseQueryString(r);
    for (let k in m)
        d[k] = m[k];
    return d
}
function urlSafeDecode(r) {
    try {
        return r = r.replace(/\+/g, "%20"),
        decodeURIComponent(r)
    } catch {
        return r
    }
}
function urlParseQueryString(r) {
    let d = {};
    if (!r.length)
        return d;
    let f = r.split("&"), m, k, y, ee;
    for (m = 0; m < f.length; m++)
        k = f[m].split("="),
        y = urlSafeDecode(k[0]),
        ee = k[1] == null ? null : urlSafeDecode(k[1]),
        d[y] = ee;
    return d
}
function versionCompare(r, d) {
    typeof r != "string" && (r = ""),
    typeof d != "string" && (d = "");
    let f = r.replace(/^\s+|\s+$/g, "").split("."), m = d.replace(/^\s+|\s+$/g, "").split("."), k, y, ee, dt;
    for (k = Math.max(f.length, m.length),
    y = 0; y < k; y++)
        if (ee = parseInt(f[y]) || 0,
        dt = parseInt(m[y]) || 0,
        ee !== dt)
            return ee > dt ? 1 : -1;
    return 0
}
function versionAtLeast(r) {
    return versionCompare(webAppVersion, r) >= 0
}
const maxWidth = {
    mobile: 440,
    tablet: 1020
};
function isDevice(r) {
    const d = getWindow$1();
    if (!d)
        return r === "desktop";
    if (isTmaPlatform("weba"))
        return !0;
    const f = d.innerWidth;
    switch (r) {
    case "desktop":
        return f > maxWidth.tablet;
    case "tablet":
        return f > maxWidth.mobile;
    default:
    case "mobile":
        return f <= maxWidth.mobile || isOS("ios", "android", "ipad")
    }
}
function media(r) {
    switch (r) {
    case "mobile":
        return `@media (max-width: ${maxWidth.mobile}px)`;
    case "tablet":
        return `@media (max-width: ${maxWidth.tablet}px) (min-width: ${maxWidth.mobile}px)`;
    default:
    case "desktop":
        return `@media (min-width: ${maxWidth.tablet}px)`
    }
}
const mediaTouch = "@media (hover: none)"
  , mediaNotTouch = "@media not all and (hover: none)"
  , borders$5 = {
    m: "100vh",
    s: "8px",
    none: "0"
}
  , scaleValues = {
    s: .02,
    m: .04
}
  , ButtonStyled$1 = styled.button`
    display: ${r=>r.leftIcon || r.rightIcon ? "flex" : "inline-block"};
    gap: ${r=>r.leftIcon || r.rightIcon ? "6px" : "unset"};
    align-items: ${r=>r.leftIcon || r.rightIcon ? "center" : "unset"};
    justify-content: ${r=>r.leftIcon || r.rightIcon ? "space-between" : "unset"};
    background-color: ${r=>r.appearance === "flat" ? "transparent" : r.appearance === "secondary" ? r.theme.colors.background.tint : rgba(r.theme.colors.accent, .12)};
    color: ${r=>r.appearance === "secondary" ? r.theme.colors.text.primary : r.theme.colors.accent};

    padding: ${r=>r.appearance === "flat" ? "0" : "9px 16px"};
    padding-left: ${r=>r.leftIcon && r.appearance !== "flat" ? "12px" : "16px"};
    padding-right: ${r=>r.rightIcon && r.appearance !== "flat" ? "12px" : "16px"};
    border: none;
    border-radius: ${r=>borders$5[r.theme.borderRadius]};
    cursor: ${r=>r.disabled ? "not-allowed" : "pointer"};

    font-size: 14px;
    font-weight: 590;
    line-height: 18px;

    transition: transform 0.125s ease-in-out;

    ${mediaNotTouch} {
        &:hover {
            transform: ${r=>r.disabled ? "unset" : `scale(${1 + scaleValues[r.scale]})`};
        }
    }

    &:active {
        transform: ${r=>r.disabled ? "unset" : `scale(${1 - scaleValues[r.scale]})`};
    }

    ${mediaTouch} {
        &:active {
            transform: ${r=>r.disabled ? "unset" : `scale(${1 - scaleValues[r.scale] * 2})`};
        }
    }
`;
function useDataAttributes(r) {
    const d = untrack(()=>Object.keys(r).filter(m=>m.startsWith("data-")))
      , [f] = splitProps(r, d);
    return f
}
const Button = r=>{
    const d = useDataAttributes(r);
    return createComponent(ButtonStyled$1, mergeProps({
        get appearance() {
            return r.appearance || "primary"
        },
        get class() {
            return r.class
        },
        onClick: f=>{
            var m;
            return (m = r.onClick) == null ? void 0 : m.call(r, f)
        }
        ,
        onMouseEnter: f=>{
            var m;
            return (m = r.onMouseEnter) == null ? void 0 : m.call(r, f)
        }
        ,
        onMouseLeave: f=>{
            var m;
            return (m = r.onMouseLeave) == null ? void 0 : m.call(r, f)
        }
        ,
        ref(f) {
            const m = r.ref;
            typeof m == "function" ? m(f) : r.ref = f
        },
        get disabled() {
            return r.disabled
        },
        get scale() {
            return r.scale || "m"
        },
        get leftIcon() {
            return !!r.leftIcon
        },
        get rightIcon() {
            return !!r.rightIcon
        },
        "data-tc-button": "true"
    }, d, {
        get children() {
            return [createMemo(()=>r.leftIcon), createMemo(()=>r.children), createMemo(()=>r.rightIcon)]
        }
    }))
}
;
function nextFrame(r) {
    requestAnimationFrame(()=>{
        requestAnimationFrame(r)
    }
    )
}
const Transition = r=>{
    let d, f = !0;
    const [m,k] = createSignal()
      , [y,ee] = createSignal()
      , dt = children(()=>r.children)
      , {onBeforeEnter: mt, onEnter: yt, onAfterEnter: pt, onBeforeExit: bt, onExit: wt, onAfterExit: xt} = r
      , At = createMemo(()=>{
        const $t = r.name || "s";
        return {
            enterActiveClass: r.enterActiveClass || $t + "-enter-active",
            enterClass: r.enterClass || $t + "-enter",
            enterToClass: r.enterToClass || $t + "-enter-to",
            exitActiveClass: r.exitActiveClass || $t + "-exit-active",
            exitClass: r.exitClass || $t + "-exit",
            exitToClass: r.exitToClass || $t + "-exit-to"
        }
    }
    );
    function Ct($t, Ot) {
        if (!f || r.appear) {
            let Nt = function(ir) {
                $t && (!ir || ir.target === $t) && ($t.removeEventListener("transitionend", Nt),
                $t.removeEventListener("animationend", Nt),
                $t.classList.remove(...Wt),
                $t.classList.remove(...Kt),
                batch(()=>{
                    m() !== $t && k($t),
                    y() === $t && ee(void 0)
                }
                ),
                pt && pt($t),
                r.mode === "inout" && Pt($t, Ot))
            };
            const zt = At().enterClass.split(" ")
              , Wt = At().enterActiveClass.split(" ")
              , Kt = At().enterToClass.split(" ");
            mt && mt($t),
            $t.classList.add(...zt),
            $t.classList.add(...Wt),
            nextFrame(()=>{
                $t.classList.remove(...zt),
                $t.classList.add(...Kt),
                yt && yt($t, ()=>Nt()),
                (!yt || yt.length < 2) && ($t.addEventListener("transitionend", Nt),
                $t.addEventListener("animationend", Nt))
            }
            )
        }
        Ot && !r.mode ? ee($t) : k($t)
    }
    function Pt($t, Ot) {
        const Nt = At().exitClass.split(" ")
          , zt = At().exitActiveClass.split(" ")
          , Wt = At().exitToClass.split(" ");
        if (!Ot.parentNode)
            return Kt();
        bt && bt(Ot),
        Ot.classList.add(...Nt),
        Ot.classList.add(...zt),
        nextFrame(()=>{
            Ot.classList.remove(...Nt),
            Ot.classList.add(...Wt)
        }
        ),
        wt && wt(Ot, ()=>Kt()),
        (!wt || wt.length < 2) && (Ot.addEventListener("transitionend", Kt),
        Ot.addEventListener("animationend", Kt));
        function Kt(ir) {
            (!ir || ir.target === Ot) && (Ot.removeEventListener("transitionend", Kt),
            Ot.removeEventListener("animationend", Kt),
            Ot.classList.remove(...zt),
            Ot.classList.remove(...Wt),
            m() === Ot && k(void 0),
            xt && xt(Ot),
            r.mode === "outin" && Ct($t, Ot))
        }
    }
    return createComputed($t=>{
        for (d = dt(); typeof d == "function"; )
            d = d();
        return untrack(()=>(d && d !== $t && (r.mode !== "outin" ? Ct(d, $t) : f && k(d)),
        $t && $t !== d && r.mode !== "inout" && Pt(d, $t),
        f = !1,
        d))
    }
    ),
    [m, y]
}
;
function getRect(r) {
    const {top: d, bottom: f, left: m, right: k, width: y, height: ee} = r.getBoundingClientRect()
      , dt = r.parentNode.getBoundingClientRect();
    return {
        top: d - dt.top,
        bottom: f,
        left: m - dt.left,
        right: k,
        width: y,
        height: ee
    }
}
const TransitionGroup = r=>{
    const d = children(()=>r.children)
      , f = createMemo(()=>{
        const xt = r.name || "s";
        return {
            enterActiveClass: r.enterActiveClass || xt + "-enter-active",
            enterClass: r.enterClass || xt + "-enter",
            enterToClass: r.enterToClass || xt + "-enter-to",
            exitActiveClass: r.exitActiveClass || xt + "-exit-active",
            exitClass: r.exitClass || xt + "-exit",
            exitToClass: r.exitToClass || xt + "-exit-to",
            moveClass: r.moveClass || xt + "-move"
        }
    }
    )
      , {onBeforeEnter: m, onEnter: k, onAfterEnter: y, onBeforeExit: ee, onExit: dt, onAfterExit: mt} = r
      , [yt,pt] = createSignal();
    let bt = []
      , wt = !0;
    return createComputed(()=>{
        const xt = d()
          , At = [...xt]
          , Ct = new Set(xt)
          , Pt = new Set(bt)
          , $t = f().enterClass.split(" ")
          , Ot = f().enterActiveClass.split(" ")
          , Nt = f().enterToClass.split(" ")
          , zt = f().exitClass.split(" ")
          , Wt = f().exitActiveClass.split(" ")
          , Kt = f().exitToClass.split(" ");
        for (let ir = 0; ir < xt.length; ir++) {
            const or = xt[ir];
            if (!wt && !Pt.has(or)) {
                let tr = function(wr) {
                    or && (!wr || wr.target === or) && (or.removeEventListener("transitionend", tr),
                    or.removeEventListener("animationend", tr),
                    or.classList.remove(...Ot),
                    or.classList.remove(...Nt),
                    y && y(or))
                };
                m && m(or),
                or.classList.add(...$t),
                or.classList.add(...Ot),
                nextFrame(()=>{
                    or.classList.remove(...$t),
                    or.classList.add(...Nt),
                    k && k(or, ()=>tr()),
                    (!k || k.length < 2) && (or.addEventListener("transitionend", tr),
                    or.addEventListener("animationend", tr))
                }
                )
            }
        }
        for (let ir = 0; ir < bt.length; ir++) {
            const or = bt[ir];
            if (!Ct.has(or) && or.parentNode) {
                let tr = function(wr) {
                    (!wr || wr.target === or) && (or.removeEventListener("transitionend", tr),
                    or.removeEventListener("animationend", tr),
                    or.classList.remove(...Wt),
                    or.classList.remove(...Kt),
                    mt && mt(or),
                    bt = bt.filter(Ht=>Ht !== or),
                    pt(bt))
                };
                At.splice(ir, 0, or),
                ee && ee(or),
                or.classList.add(...zt),
                or.classList.add(...Wt),
                nextFrame(()=>{
                    or.classList.remove(...zt),
                    or.classList.add(...Kt)
                }
                ),
                dt && dt(or, ()=>tr()),
                (!dt || dt.length < 2) && (or.addEventListener("transitionend", tr),
                or.addEventListener("animationend", tr))
            }
        }
        bt = At,
        pt(At)
    }
    ),
    createEffect(xt=>{
        const At = yt();
        return At.forEach(Ct=>{
            let Pt;
            (Pt = xt.get(Ct)) ? Pt.new && (Pt.new = !1,
            Pt.newPos = getRect(Ct)) : xt.set(Ct, Pt = {
                pos: getRect(Ct),
                new: !wt
            }),
            Pt.new && Ct.addEventListener("transitionend", ()=>{
                Pt.new = !1,
                Ct.parentNode && (Pt.newPos = getRect(Ct))
            }
            , {
                once: !0
            }),
            Pt.newPos && (Pt.pos = Pt.newPos),
            Pt.newPos = getRect(Ct)
        }
        ),
        wt ? (wt = !1,
        xt) : (At.forEach(Ct=>{
            const Pt = xt.get(Ct)
              , $t = Pt.pos
              , Ot = Pt.newPos
              , Nt = $t.left - Ot.left
              , zt = $t.top - Ot.top;
            if (Nt || zt) {
                Pt.moved = !0;
                const Wt = Ct.style;
                Wt.transform = `translate(${Nt}px,${zt}px)`,
                Wt.transitionDuration = "0s"
            }
        }
        ),
        document.body.offsetHeight,
        At.forEach(Ct=>{
            const Pt = xt.get(Ct);
            if (Pt.moved) {
                let $t = function(zt) {
                    zt && zt.target !== Ct || !Ct.parentNode || (!zt || /transform$/.test(zt.propertyName)) && (Ct.removeEventListener("transitionend", $t),
                    Ct.classList.remove(...Nt))
                };
                Pt.moved = !1;
                const Ot = Ct.style
                  , Nt = f().moveClass.split(" ");
                Ct.classList.add(...Nt),
                Ot.transform = Ot.transitionDuration = "",
                Ct.addEventListener("transitionend", $t)
            }
        }
        ),
        xt)
    }
    , new Map),
    yt
}
;
function clickOutside$1(r, d) {
    const f = m=>{
        var k;
        return !r.contains(m.target) && ((k = d()) == null ? void 0 : k())
    }
    ;
    document.body.addEventListener("click", f),
    onCleanup(()=>document.body.removeEventListener("click", f))
}
function escPressed(r, d) {
    const f = m=>{
        var k, y;
        m.key === "Escape" && ((k = document.activeElement) == null || k.blur(),
        (y = d()) == null || y())
    }
    ;
    document.body.addEventListener("keydown", f),
    onCleanup(()=>document.body.removeEventListener("keydown", f))
}
function androidBackHandler$1(r, d) {
    const {isEnabled: f, onClose: m} = d();
    if (!f || !(getUserAgent().os === "android"))
        return;
    window.history.pushState(ROUTE_STATE, "");
    const y = ee=>{
        ee.preventDefault(),
        m()
    }
    ;
    window.addEventListener("popstate", y, {
        once: !0
    }),
    onCleanup(()=>{
        window.removeEventListener("popstate", y),
        createMacrotask(()=>{
            var ee;
            ((ee = window.history.state) == null ? void 0 : ee[ROUTE_STATE_KEY]) === !0 && window.history.back()
        }
        )
    }
    )
}
const ROUTE_STATE_KEY = "androidBackHandler"
  , ROUTE_STATE = {
    [ROUTE_STATE_KEY]: !0
}
  , _tmpl$$v = template$1('<svg><path fill-rule="evenodd" clip-rule="evenodd" d="M10.2122 14.3407C10.5384 14.0854 10.5959 13.614 10.3406 13.2878L6.20237 8.00003L10.3406 2.71227C10.5959 2.38607 10.5384 1.91469 10.2122 1.6594C9.88604 1.40412 9.41465 1.46161 9.15937 1.7878L4.65937 7.5378C4.44688 7.80932 4.44688 8.19074 4.65937 8.46226L9.15937 14.2123C9.41465 14.5385 9.88604 14.5959 10.2122 14.3407Z"></path></svg>', 4, !0)
  , rotationDegrees = {
    left: 0,
    top: 90,
    right: 180,
    bottom: 270
}
  , ArrowIcon = r=>{
    const d = useTheme()
      , f = ()=>r.fill || d.colors.icon.secondary
      , m = ()=>r.direction || "left"
      , k = styled("svg")`
        transform: rotate(${y=>rotationDegrees[y.svgDirection]}deg);
        transition: transform 0.1s ease-in-out;
    `;
    return createComponent(k, {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 16 16",
        fill: "none",
        get svgDirection() {
            return m()
        },
        get children() {
            const y = _tmpl$$v.cloneNode(!0);
            return createRenderEffect(()=>setAttribute(y, "fill", f())),
            y
        }
    })
}
  , _tmpl$$u = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M2.71966 2.71968C3.01255 2.42678 3.48743 2.42677 3.78032 2.71966L8.00002 6.93925L12.2197 2.71967C12.5126 2.42677 12.9874 2.42678 13.2803 2.71967C13.5732 3.01257 13.5732 3.48744 13.2803 3.78033L9.06068 7.99991L13.2803 12.2197C13.5732 12.5126 13.5732 12.9874 13.2803 13.2803C12.9874 13.5732 12.5126 13.5732 12.2197 13.2803L8.00002 9.06057L3.78033 13.2803C3.48744 13.5732 3.01257 13.5732 2.71967 13.2803C2.42678 12.9874 2.42677 12.5126 2.71967 12.2197L6.93936 7.99991L2.71968 3.78034C2.42678 3.48745 2.42677 3.01257 2.71966 2.71968Z"></path></svg>')
  , CloseIcon = r=>{
    const d = useTheme()
      , f = ()=>r.fill || d.colors.icon.secondary;
    return (()=>{
        const m = _tmpl$$u.cloneNode(!0)
          , k = m.firstChild;
        return createRenderEffect(()=>setAttribute(k, "fill", f())),
        m
    }
    )()
}
  , IconButtonStyled = styled.button`
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background-color: ${r=>r.theme.colors.background.tint};
    border: none;
    cursor: pointer;

    transition: transform 0.125s ease-in-out;

    ${mediaNotTouch} {
        &:hover {
            transform: scale(1.04);
        }
    }

    &:active {
        transform: scale(0.96);
    }

    ${mediaTouch} {
        &:active {
            transform: scale(0.92);
        }
    }
`
  , IconButton = r=>{
    const d = useDataAttributes(r)
      , f = ()=>r.icon || "close";
    return createComponent(IconButtonStyled, mergeProps({
        get class() {
            return r.class
        },
        onClick: ()=>r.onClick(),
        "data-tc-icon-button": "true"
    }, d, {
        get children() {
            return [createComponent(Show, {
                get when() {
                    return !!r.children
                },
                get children() {
                    return r.children
                }
            }), createComponent(Show, {
                get when() {
                    return !r.children
                },
                get children() {
                    return createComponent(Switch, {
                        get children() {
                            return [createComponent(Match, {
                                get when() {
                                    return f() === "close"
                                },
                                get children() {
                                    return createComponent(CloseIcon, {
                                        get fill() {
                                            return r.fill
                                        }
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return f() === "arrow"
                                },
                                get children() {
                                    return createComponent(ArrowIcon, {
                                        get fill() {
                                            return r.fill
                                        }
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return f() === "question"
                                },
                                get children() {
                                    return createComponent(QuestionIcon, {
                                        get fill() {
                                            return r.fill
                                        }
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return typeof f() != "string"
                                },
                                get children() {
                                    return f()
                                }
                            })]
                        }
                    })
                }
            })]
        }
    }))
}
  , borders$4 = {
    m: "24px",
    s: "16px",
    none: "0"
}
  , ModalBackgroundStyled = styled.div`
    display: flex;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.4);
    padding: 20px 0;
    overflow-y: auto;

    ${media("mobile")} {
        padding-bottom: 0;
    }
`
  , ModalWrapperClass = u$1`
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08), 0 16px 64px rgba(0, 0, 0, 0.16);
    width: fit-content;
    margin: auto;

    ${media("mobile")} {
        width: 100%;
        height: fit-content;
        margin: auto 0 0 0;
    }
`
  , ModalBodyStyled = styled.div`
    position: relative;
    min-height: 100px;
    width: 416px;
    padding: 44px 56px 24px;

    box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.04);

    background-color: ${r=>r.theme.colors.background.primary};
    border-radius: ${r=>borders$4[r.theme.borderRadius]};

    ${media("mobile")} {
        width: 100%;
    }
`
  , CloseButtonStyled = styled(IconButton)`
    position: absolute;
    right: 16px;
    top: 16px;
`
  , ModalFooterStyled = styled.div`
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px 16px 16px 18px;
    border-radius: 0 0 ${r=>borders$4[r.theme.borderRadius]}
        ${r=>borders$4[r.theme.borderRadius]};
`
  , QuestionButtonStyled = styled(IconButton)`
    background-color: ${r=>rgba(r.theme.colors.icon.secondary, .12)};
`;
class AnimationTimelineNoop {
    constructor() {
        __publicField(this, "currentTime", 0)
    }
}
const _AnimationNoop = class {
    constructor() {
        __publicField(this, "currentTime", 0),
        __publicField(this, "playbackRate", 1),
        __publicField(this, "startTime", null),
        __publicField(this, "timeline", new AnimationTimelineNoop),
        __publicField(this, "finished", Promise.resolve(this)),
        __publicField(this, "effect", null),
        __publicField(this, "id", ""),
        __publicField(this, "pending", !1),
        __publicField(this, "playState", "finished"),
        __publicField(this, "replaceState", "active"),
        __publicField(this, "ready", Promise.resolve(this)),
        __publicField(this, "oncancel", null),
        __publicField(this, "onfinish", null),
        __publicField(this, "onremove", null)
    }
    static create() {
        return _AnimationNoop._instance || (logWarning("Animation is not supported in this environment: please consider using the `web-animations-js` polyfill to provide a fallback implementation of the Web Animations API."),
        _AnimationNoop._instance = new _AnimationNoop),
        _AnimationNoop._instance
    }
    cancel() {}
    finish() {}
    pause() {}
    play() {}
    reverse() {}
    addEventListener(r, d, f) {}
    dispatchEvent(r) {
        return !1
    }
    removeEventListener(r, d, f) {}
    updatePlaybackRate(r) {}
    commitStyles() {}
    persist() {}
}
;
let AnimationNoop = _AnimationNoop;
__publicField(AnimationNoop, "_instance", null);
function animate(r, d, f) {
    return "animate"in r ? r.animate(d, f) : AnimationNoop.create()
}
const _tmpl$$t = template$1("<div></div>")
  , clickOutside = clickOutside$1
  , keyPressed = escPressed
  , androidBackHandler = androidBackHandler$1
  , Modal = r=>{
    const d = useTheme()
      , f = useDataAttributes(r);
    return createEffect(()=>{
        r.opened ? disableScroll() : enableScroll()
    }
    ),
    createComponent(Transition, {
        onBeforeEnter: m=>{
            const k = isDevice("mobile") ? 200 : 100;
            animate(m, [{
                opacity: 0
            }, {
                opacity: 1
            }], {
                duration: k
            }),
            isDevice("mobile") && animate(m.firstElementChild, [{
                transform: "translateY(390px)"
            }, {
                transform: "translateY(0)"
            }], {
                duration: k
            })
        }
        ,
        onExit: (m,k)=>{
            const y = isDevice("mobile") ? 200 : 100
              , ee = animate(m, [{
                opacity: 1
            }, {
                opacity: 0
            }], {
                duration: y
            });
            if (isDevice("mobile")) {
                const dt = animate(m.firstElementChild, [{
                    transform: "translateY(0)"
                }, {
                    transform: "translateY(390px)"
                }], {
                    duration: y
                });
                Promise.all([ee.finished, dt.finished]).then(k)
            } else
                ee.finished.then(k)
        }
        ,
        get children() {
            return createComponent(Show, {
                get when() {
                    return r.opened
                },
                get children() {
                    return createComponent(ModalBackgroundStyled, mergeProps({
                        "data-tc-modal": "true"
                    }, f, {
                        get children() {
                            const m = _tmpl$$t.cloneNode(!0);
                            return use(androidBackHandler, m, ()=>({
                                isEnabled: r.enableAndroidBackHandler,
                                onClose: ()=>r.onClose()
                            })),
                            use(keyPressed, m, ()=>()=>r.onClose()),
                            use(clickOutside, m, ()=>()=>r.onClose()),
                            insert(m, createComponent(ModalBodyStyled, {
                                get class() {
                                    return r.class
                                },
                                get children() {
                                    return [createComponent(CloseButtonStyled, {
                                        icon: "close",
                                        onClick: ()=>r.onClose()
                                    }), createMemo(()=>r.children)]
                                }
                            }), null),
                            insert(m, createComponent(Show, {
                                get when() {
                                    return r.onClickQuestion
                                },
                                get children() {
                                    return createComponent(ModalFooterStyled, {
                                        get children() {
                                            return [createComponent(TonConnectBrand, {}), createComponent(QuestionButtonStyled, {
                                                get onClick() {
                                                    return r.onClickQuestion
                                                },
                                                icon: "question"
                                            })]
                                        }
                                    })
                                }
                            }), null),
                            createRenderEffect(()=>className(m, cn(ModalWrapperClass, u$1`
                                border-radius: ${borders$4[d.borderRadius]};
                                background-color: ${d.colors.background.tint};

                                ${media("mobile")} {
                                    border-radius: ${borders$4[d.borderRadius]}
                                        ${borders$4[d.borderRadius]} 0 0;
                                }
                            `))),
                            m
                        }
                    }))
                }
            })
        }
    })
}
  , wrapperBorderRadius = {
    m: "22px",
    s: "12px",
    none: "0"
}
  , sliderBorderRadius = {
    m: "18px",
    s: "8px",
    none: "0"
}
  , TabBarStyled = styled.div`
    display: grid;
    grid-template: 1fr / 1fr 1fr;
    width: fit-content;
    justify-items: center;
    gap: 4px;

    position: relative;
    padding: 4px;
    border-radius: ${r=>wrapperBorderRadius[r.theme.borderRadius]};

    background-color: ${r=>r.theme.colors.background.secondary};
`
  , SliderStyled = styled.div`
    position: absolute;
    top: 4px;
    left: 4px;

    height: calc(100% - 8px);
    width: calc(50% - 4px);

    border-radius: ${r=>sliderBorderRadius[r.theme.borderRadius]};
    background-color: ${r=>r.theme.colors.background.segment};

    transform: ${r=>r.right ? "translateX(100%)" : "translateX(0)"};

    transition: transform 0.13s ease-in-out;
`
  , InputStyled = styled.input`
    display: none;
`
  , LabelStyled = styled.label`
    padding: 9px 12px;
    z-index: 1;

    cursor: ${r=>r.isActive ? "default" : "pointer"};

    transition: transform 0.13s ease-in-out;

    &:hover {
        transform: ${r=>r.isActive ? "none" : "scale(1.025)"};
    }

    > * {
        ${r=>r.isActive ? "" : `color: ${r.theme.colors.text.secondary};`}
    }
`
  , TabBar = r=>{
    const d = "tabBar" + Math.floor(Math.random() * 1e4);
    return createComponent(TabBarStyled, {
        get class() {
            return r.class
        },
        "data-tc-tab-bar": "true",
        get children() {
            return [createComponent(SliderStyled, {
                get right() {
                    return r.selectedTabIndex === 1
                }
            }), createComponent(LabelStyled, {
                get isActive() {
                    return r.selectedTabIndex === 0
                },
                get children() {
                    return [createComponent(InputStyled, {
                        type: "radio",
                        name: d,
                        get checked() {
                            return r.selectedTabIndex === 0
                        },
                        onInput: ()=>{
                            var f;
                            return (f = r.onSelectedTabIndexChange) == null ? void 0 : f.call(r, 0)
                        }
                    }), createMemo(()=>r.tab1)]
                }
            }), createComponent(LabelStyled, {
                get isActive() {
                    return r.selectedTabIndex === 1
                },
                get children() {
                    return [createComponent(InputStyled, {
                        type: "radio",
                        get checked() {
                            return r.selectedTabIndex === 1
                        },
                        name: d,
                        onInput: ()=>{
                            var f;
                            return (f = r.onSelectedTabIndexChange) == null ? void 0 : f.call(r, 1)
                        }
                    }), createMemo(()=>r.tab2)]
                }
            })]
        }
    })
}
  , backgroundBorders = {
    m: "16px",
    s: "12px",
    none: "0"
}
  , imageBorders = {
    m: "12px",
    s: "8px",
    none: "0"
}
  , qrNormalSize = 256
  , imgSizeDefault = 60
  , picSizeDefault = 48
  , qrPaddingTop = 24
  , CopyIconButton = styled.div`
    width: 52px;
    height: 52px;
    background: transparent;
    position: absolute;
    right: 0;
    bottom: 0;

    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.125s ease-in-out;
`
  , QrCodeBackground = styled.button`
    display: flex;
    align-items: center;
    position: relative;
    background-color: ${r=>r.theme.colors.background.qr};
    border-radius: ${r=>backgroundBorders[r.theme.borderRadius]};
    padding: ${toPx(qrPaddingTop)} 0;
    height: ${toPx(qrNormalSize + qrPaddingTop * 2)};
    width: 100%;

    overflow: hidden;
    cursor: pointer;
    border: none;

    ${mediaNotTouch} {
        &:hover {
            ${CopyIconButton.class} {
                transform: scale(1.04);
            }
        }
    }

    &:active {
        ${CopyIconButton.class} {
            transform: scale(0.96);
        }
    }

    ${mediaTouch} {
        &:active {
            ${CopyIconButton.class} {
                transform: scale(0.92);
            }
        }
    }
`
  , QrCodeWrapper$2 = styled.div`
    position: relative;

    width: fit-content;
    margin: 0 auto;

    > div:first-child {
        display: flex;
        align-items: center;
        justify-content: center;
    }

    rect {
        fill: transparent;
    }

    path {
        fill: ${r=>r.theme.colors.constant.black};
    }
`
  , ImageBackground = styled.div`
    position: absolute;
    width: ${toPx(imgSizeDefault)};
    height: ${toPx(imgSizeDefault)};
    background: ${r=>r.theme.colors.background.qr};

    display: flex;
    align-items: center;
    justify-content: center;
`
  , ImageStyled$3 = styled(Image)`
    width: ${r=>toPx(r.size)};
    height: ${r=>toPx(r.size)};
    border-radius: ${r=>imageBorders[r.theme.borderRadius]};
    background-color: ${r=>r.theme.colors.background.qr};
`
  , CopiedBoxStyled = styled.div`
    position: absolute;
    bottom: 14px;
    left: 50%;
    transform: translate(-50%, 0);

    display: flex;
    gap: 6px;
    align-items: center;
    border-radius: 18px;
    min-width: 126px;
    padding: 9px 16px 9px 10px;

    filter: drop-shadow(0px 2px 8px rgba(0, 0, 0, 0.08));
    background-color: ${r=>r.theme.colors.background.segment};
`;
var qrcode$1 = {
    exports: {}
};
(function(r, d) {
    var f = function() {
        var m = function(Wt, Kt) {
            var ir = 236
              , or = 17
              , tr = Wt
              , wr = y[Kt]
              , Ht = null
              , Mt = 0
              , _t = null
              , gt = []
              , vt = {}
              , Et = function(Vt, rr) {
                Mt = tr * 4 + 17,
                Ht = function(fr) {
                    for (var Yt = new Array(fr), Xt = 0; Xt < fr; Xt += 1) {
                        Yt[Xt] = new Array(fr);
                        for (var Sr = 0; Sr < fr; Sr += 1)
                            Yt[Xt][Sr] = null
                    }
                    return Yt
                }(Mt),
                Bt(0, 0),
                Bt(Mt - 7, 0),
                Bt(0, Mt - 7),
                Tt(),
                kt(),
                St(Vt, rr),
                tr >= 7 && It(Vt),
                _t == null && (_t = gr(tr, wr, gt)),
                qt(_t, rr)
            }
              , Bt = function(Vt, rr) {
                for (var fr = -1; fr <= 7; fr += 1)
                    if (!(Vt + fr <= -1 || Mt <= Vt + fr))
                        for (var Yt = -1; Yt <= 7; Yt += 1)
                            rr + Yt <= -1 || Mt <= rr + Yt || (0 <= fr && fr <= 6 && (Yt == 0 || Yt == 6) || 0 <= Yt && Yt <= 6 && (fr == 0 || fr == 6) || 2 <= fr && fr <= 4 && 2 <= Yt && Yt <= 4 ? Ht[Vt + fr][rr + Yt] = !0 : Ht[Vt + fr][rr + Yt] = !1)
            }
              , Rt = function() {
                for (var Vt = 0, rr = 0, fr = 0; fr < 8; fr += 1) {
                    Et(!0, fr);
                    var Yt = dt.getLostPoint(vt);
                    (fr == 0 || Vt > Yt) && (Vt = Yt,
                    rr = fr)
                }
                return rr
            }
              , kt = function() {
                for (var Vt = 8; Vt < Mt - 8; Vt += 1)
                    Ht[Vt][6] == null && (Ht[Vt][6] = Vt % 2 == 0);
                for (var rr = 8; rr < Mt - 8; rr += 1)
                    Ht[6][rr] == null && (Ht[6][rr] = rr % 2 == 0)
            }
              , Tt = function() {
                for (var Vt = dt.getPatternPosition(tr), rr = 0; rr < Vt.length; rr += 1)
                    for (var fr = 0; fr < Vt.length; fr += 1) {
                        var Yt = Vt[rr]
                          , Xt = Vt[fr];
                        if (Ht[Yt][Xt] == null)
                            for (var Sr = -2; Sr <= 2; Sr += 1)
                                for (var Rr = -2; Rr <= 2; Rr += 1)
                                    Sr == -2 || Sr == 2 || Rr == -2 || Rr == 2 || Sr == 0 && Rr == 0 ? Ht[Yt + Sr][Xt + Rr] = !0 : Ht[Yt + Sr][Xt + Rr] = !1
                    }
            }
              , It = function(Vt) {
                for (var rr = dt.getBCHTypeNumber(tr), fr = 0; fr < 18; fr += 1) {
                    var Yt = !Vt && (rr >> fr & 1) == 1;
                    Ht[Math.floor(fr / 3)][fr % 3 + Mt - 8 - 3] = Yt
                }
                for (var fr = 0; fr < 18; fr += 1) {
                    var Yt = !Vt && (rr >> fr & 1) == 1;
                    Ht[fr % 3 + Mt - 8 - 3][Math.floor(fr / 3)] = Yt
                }
            }
              , St = function(Vt, rr) {
                for (var fr = wr << 3 | rr, Yt = dt.getBCHTypeInfo(fr), Xt = 0; Xt < 15; Xt += 1) {
                    var Sr = !Vt && (Yt >> Xt & 1) == 1;
                    Xt < 6 ? Ht[Xt][8] = Sr : Xt < 8 ? Ht[Xt + 1][8] = Sr : Ht[Mt - 15 + Xt][8] = Sr
                }
                for (var Xt = 0; Xt < 15; Xt += 1) {
                    var Sr = !Vt && (Yt >> Xt & 1) == 1;
                    Xt < 8 ? Ht[8][Mt - Xt - 1] = Sr : Xt < 9 ? Ht[8][15 - Xt - 1 + 1] = Sr : Ht[8][15 - Xt - 1] = Sr
                }
                Ht[Mt - 8][8] = !Vt
            }
              , qt = function(Vt, rr) {
                for (var fr = -1, Yt = Mt - 1, Xt = 7, Sr = 0, Rr = dt.getMaskFunction(rr), qr = Mt - 1; qr > 0; qr -= 2)
                    for (qr == 6 && (qr -= 1); ; ) {
                        for (var Nr = 0; Nr < 2; Nr += 1)
                            if (Ht[Yt][qr - Nr] == null) {
                                var Dr = !1;
                                Sr < Vt.length && (Dr = (Vt[Sr] >>> Xt & 1) == 1);
                                var Or = Rr(Yt, qr - Nr);
                                Or && (Dr = !Dr),
                                Ht[Yt][qr - Nr] = Dr,
                                Xt -= 1,
                                Xt == -1 && (Sr += 1,
                                Xt = 7)
                            }
                        if (Yt += fr,
                        Yt < 0 || Mt <= Yt) {
                            Yt -= fr,
                            fr = -fr;
                            break
                        }
                    }
            }
              , ur = function(Vt, rr) {
                for (var fr = 0, Yt = 0, Xt = 0, Sr = new Array(rr.length), Rr = new Array(rr.length), qr = 0; qr < rr.length; qr += 1) {
                    var Nr = rr[qr].dataCount
                      , Dr = rr[qr].totalCount - Nr;
                    Yt = Math.max(Yt, Nr),
                    Xt = Math.max(Xt, Dr),
                    Sr[qr] = new Array(Nr);
                    for (var Or = 0; Or < Sr[qr].length; Or += 1)
                        Sr[qr][Or] = 255 & Vt.getBuffer()[Or + fr];
                    fr += Nr;
                    var $r = dt.getErrorCorrectPolynomial(Dr)
                      , Zr = yt(Sr[qr], $r.getLength() - 1)
                      , Hr = Zr.mod($r);
                    Rr[qr] = new Array($r.getLength() - 1);
                    for (var Or = 0; Or < Rr[qr].length; Or += 1) {
                        var un = Or + Hr.getLength() - Rr[qr].length;
                        Rr[qr][Or] = un >= 0 ? Hr.getAt(un) : 0
                    }
                }
                for (var Qr = 0, Or = 0; Or < rr.length; Or += 1)
                    Qr += rr[Or].totalCount;
                for (var Gr = new Array(Qr), vr = 0, Or = 0; Or < Yt; Or += 1)
                    for (var qr = 0; qr < rr.length; qr += 1)
                        Or < Sr[qr].length && (Gr[vr] = Sr[qr][Or],
                        vr += 1);
                for (var Or = 0; Or < Xt; Or += 1)
                    for (var qr = 0; qr < rr.length; qr += 1)
                        Or < Rr[qr].length && (Gr[vr] = Rr[qr][Or],
                        vr += 1);
                return Gr
            }
              , gr = function(Vt, rr, fr) {
                for (var Yt = pt.getRSBlocks(Vt, rr), Xt = bt(), Sr = 0; Sr < fr.length; Sr += 1) {
                    var Rr = fr[Sr];
                    Xt.put(Rr.getMode(), 4),
                    Xt.put(Rr.getLength(), dt.getLengthInBits(Rr.getMode(), Vt)),
                    Rr.write(Xt)
                }
                for (var qr = 0, Sr = 0; Sr < Yt.length; Sr += 1)
                    qr += Yt[Sr].dataCount;
                if (Xt.getLengthInBits() > qr * 8)
                    throw "code length overflow. (" + Xt.getLengthInBits() + ">" + qr * 8 + ")";
                for (Xt.getLengthInBits() + 4 <= qr * 8 && Xt.put(0, 4); Xt.getLengthInBits() % 8 != 0; )
                    Xt.putBit(!1);
                for (; !(Xt.getLengthInBits() >= qr * 8 || (Xt.put(ir, 8),
                Xt.getLengthInBits() >= qr * 8)); )
                    Xt.put(or, 8);
                return ur(Xt, Yt)
            };
            vt.addData = function(Vt, rr) {
                rr = rr || "Byte";
                var fr = null;
                switch (rr) {
                case "Numeric":
                    fr = wt(Vt);
                    break;
                case "Alphanumeric":
                    fr = xt(Vt);
                    break;
                case "Byte":
                    fr = At(Vt);
                    break;
                case "Kanji":
                    fr = Ct(Vt);
                    break;
                default:
                    throw "mode:" + rr
                }
                gt.push(fr),
                _t = null
            }
            ,
            vt.isDark = function(Vt, rr) {
                if (Vt < 0 || Mt <= Vt || rr < 0 || Mt <= rr)
                    throw Vt + "," + rr;
                return Ht[Vt][rr]
            }
            ,
            vt.getModuleCount = function() {
                return Mt
            }
            ,
            vt.make = function() {
                if (tr < 1) {
                    for (var Vt = 1; Vt < 40; Vt++) {
                        for (var rr = pt.getRSBlocks(Vt, wr), fr = bt(), Yt = 0; Yt < gt.length; Yt++) {
                            var Xt = gt[Yt];
                            fr.put(Xt.getMode(), 4),
                            fr.put(Xt.getLength(), dt.getLengthInBits(Xt.getMode(), Vt)),
                            Xt.write(fr)
                        }
                        for (var Sr = 0, Yt = 0; Yt < rr.length; Yt++)
                            Sr += rr[Yt].dataCount;
                        if (fr.getLengthInBits() <= Sr * 8)
                            break
                    }
                    tr = Vt
                }
                Et(!1, Rt())
            }
            ,
            vt.createTableTag = function(Vt, rr) {
                Vt = Vt || 2,
                rr = typeof rr > "u" ? Vt * 4 : rr;
                var fr = "";
                fr += '<table style="',
                fr += " border-width: 0px; border-style: none;",
                fr += " border-collapse: collapse;",
                fr += " padding: 0px; margin: " + rr + "px;",
                fr += '">',
                fr += "<tbody>";
                for (var Yt = 0; Yt < vt.getModuleCount(); Yt += 1) {
                    fr += "<tr>";
                    for (var Xt = 0; Xt < vt.getModuleCount(); Xt += 1)
                        fr += '<td style="',
                        fr += " border-width: 0px; border-style: none;",
                        fr += " border-collapse: collapse;",
                        fr += " padding: 0px; margin: 0px;",
                        fr += " width: " + Vt + "px;",
                        fr += " height: " + Vt + "px;",
                        fr += " background-color: ",
                        fr += vt.isDark(Yt, Xt) ? "#000000" : "#ffffff",
                        fr += ";",
                        fr += '"/>';
                    fr += "</tr>"
                }
                return fr += "</tbody>",
                fr += "</table>",
                fr
            }
            ,
            vt.createSvgTag = function(Vt, rr, fr, Yt) {
                var Xt = {};
                typeof arguments[0] == "object" && (Xt = arguments[0],
                Vt = Xt.cellSize,
                rr = Xt.margin,
                fr = Xt.alt,
                Yt = Xt.title),
                Vt = Vt || 2,
                rr = typeof rr > "u" ? Vt * 4 : rr,
                fr = typeof fr == "string" ? {
                    text: fr
                } : fr || {},
                fr.text = fr.text || null,
                fr.id = fr.text ? fr.id || "qrcode-description" : null,
                Yt = typeof Yt == "string" ? {
                    text: Yt
                } : Yt || {},
                Yt.text = Yt.text || null,
                Yt.id = Yt.text ? Yt.id || "qrcode-title" : null;
                var Sr = vt.getModuleCount() * Vt + rr * 2, Rr, qr, Nr, Dr, Or = "", $r;
                for ($r = "l" + Vt + ",0 0," + Vt + " -" + Vt + ",0 0,-" + Vt + "z ",
                Or += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"',
                Or += Xt.scalable ? "" : ' width="' + Sr + 'px" height="' + Sr + 'px"',
                Or += ' viewBox="0 0 ' + Sr + " " + Sr + '" ',
                Or += ' preserveAspectRatio="xMinYMin meet"',
                Or += Yt.text || fr.text ? ' role="img" aria-labelledby="' + lr([Yt.id, fr.id].join(" ").trim()) + '"' : "",
                Or += ">",
                Or += Yt.text ? '<title id="' + lr(Yt.id) + '">' + lr(Yt.text) + "</title>" : "",
                Or += fr.text ? '<description id="' + lr(fr.id) + '">' + lr(fr.text) + "</description>" : "",
                Or += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>',
                Or += '<path d="',
                Nr = 0; Nr < vt.getModuleCount(); Nr += 1)
                    for (Dr = Nr * Vt + rr,
                    Rr = 0; Rr < vt.getModuleCount(); Rr += 1)
                        vt.isDark(Nr, Rr) && (qr = Rr * Vt + rr,
                        Or += "M" + qr + "," + Dr + $r);
                return Or += '" stroke="transparent" fill="black"/>',
                Or += "</svg>",
                Or
            }
            ,
            vt.createDataURL = function(Vt, rr) {
                Vt = Vt || 2,
                rr = typeof rr > "u" ? Vt * 4 : rr;
                var fr = vt.getModuleCount() * Vt + rr * 2
                  , Yt = rr
                  , Xt = fr - rr;
                return zt(fr, fr, function(Sr, Rr) {
                    if (Yt <= Sr && Sr < Xt && Yt <= Rr && Rr < Xt) {
                        var qr = Math.floor((Sr - Yt) / Vt)
                          , Nr = Math.floor((Rr - Yt) / Vt);
                        return vt.isDark(Nr, qr) ? 0 : 1
                    } else
                        return 1
                })
            }
            ,
            vt.createImgTag = function(Vt, rr, fr) {
                Vt = Vt || 2,
                rr = typeof rr > "u" ? Vt * 4 : rr;
                var Yt = vt.getModuleCount() * Vt + rr * 2
                  , Xt = "";
                return Xt += "<img",
                Xt += ' src="',
                Xt += vt.createDataURL(Vt, rr),
                Xt += '"',
                Xt += ' width="',
                Xt += Yt,
                Xt += '"',
                Xt += ' height="',
                Xt += Yt,
                Xt += '"',
                fr && (Xt += ' alt="',
                Xt += lr(fr),
                Xt += '"'),
                Xt += "/>",
                Xt
            }
            ;
            var lr = function(Vt) {
                for (var rr = "", fr = 0; fr < Vt.length; fr += 1) {
                    var Yt = Vt.charAt(fr);
                    switch (Yt) {
                    case "<":
                        rr += "&lt;";
                        break;
                    case ">":
                        rr += "&gt;";
                        break;
                    case "&":
                        rr += "&amp;";
                        break;
                    case '"':
                        rr += "&quot;";
                        break;
                    default:
                        rr += Yt;
                        break
                    }
                }
                return rr
            }
              , Zt = function(Vt) {
                var rr = 1;
                Vt = typeof Vt > "u" ? rr * 2 : Vt;
                var fr = vt.getModuleCount() * rr + Vt * 2, Yt = Vt, Xt = fr - Vt, Sr, Rr, qr, Nr, Dr, Or = {
                    "██": "█",
                    "█ ": "▀",
                    " █": "▄",
                    "  ": " "
                }, $r = {
                    "██": "▀",
                    "█ ": "▀",
                    " █": " ",
                    "  ": " "
                }, Zr = "";
                for (Sr = 0; Sr < fr; Sr += 2) {
                    for (qr = Math.floor((Sr - Yt) / rr),
                    Nr = Math.floor((Sr + 1 - Yt) / rr),
                    Rr = 0; Rr < fr; Rr += 1)
                        Dr = "█",
                        Yt <= Rr && Rr < Xt && Yt <= Sr && Sr < Xt && vt.isDark(qr, Math.floor((Rr - Yt) / rr)) && (Dr = " "),
                        Yt <= Rr && Rr < Xt && Yt <= Sr + 1 && Sr + 1 < Xt && vt.isDark(Nr, Math.floor((Rr - Yt) / rr)) ? Dr += " " : Dr += "█",
                        Zr += Vt < 1 && Sr + 1 >= Xt ? $r[Dr] : Or[Dr];
                    Zr += `
`
                }
                return fr % 2 && Vt > 0 ? Zr.substring(0, Zr.length - fr - 1) + Array(fr + 1).join("▀") : Zr.substring(0, Zr.length - 1)
            };
            return vt.createASCII = function(Vt, rr) {
                if (Vt = Vt || 1,
                Vt < 2)
                    return Zt(rr);
                Vt -= 1,
                rr = typeof rr > "u" ? Vt * 2 : rr;
                var fr = vt.getModuleCount() * Vt + rr * 2, Yt = rr, Xt = fr - rr, Sr, Rr, qr, Nr, Dr = Array(Vt + 1).join("██"), Or = Array(Vt + 1).join("  "), $r = "", Zr = "";
                for (Sr = 0; Sr < fr; Sr += 1) {
                    for (qr = Math.floor((Sr - Yt) / Vt),
                    Zr = "",
                    Rr = 0; Rr < fr; Rr += 1)
                        Nr = 1,
                        Yt <= Rr && Rr < Xt && Yt <= Sr && Sr < Xt && vt.isDark(qr, Math.floor((Rr - Yt) / Vt)) && (Nr = 0),
                        Zr += Nr ? Dr : Or;
                    for (qr = 0; qr < Vt; qr += 1)
                        $r += Zr + `
`
                }
                return $r.substring(0, $r.length - 1)
            }
            ,
            vt.renderTo2dContext = function(Vt, rr) {
                rr = rr || 2;
                for (var fr = vt.getModuleCount(), Yt = 0; Yt < fr; Yt++)
                    for (var Xt = 0; Xt < fr; Xt++)
                        Vt.fillStyle = vt.isDark(Yt, Xt) ? "black" : "white",
                        Vt.fillRect(Yt * rr, Xt * rr, rr, rr)
            }
            ,
            vt
        };
        m.stringToBytesFuncs = {
            default: function(Wt) {
                for (var Kt = [], ir = 0; ir < Wt.length; ir += 1) {
                    var or = Wt.charCodeAt(ir);
                    Kt.push(or & 255)
                }
                return Kt
            }
        },
        m.stringToBytes = m.stringToBytesFuncs.default,
        m.createStringToBytes = function(Wt, Kt) {
            var ir = function() {
                for (var tr = Ot(Wt), wr = function() {
                    var kt = tr.read();
                    if (kt == -1)
                        throw "eof";
                    return kt
                }, Ht = 0, Mt = {}; ; ) {
                    var _t = tr.read();
                    if (_t == -1)
                        break;
                    var gt = wr()
                      , vt = wr()
                      , Et = wr()
                      , Bt = String.fromCharCode(_t << 8 | gt)
                      , Rt = vt << 8 | Et;
                    Mt[Bt] = Rt,
                    Ht += 1
                }
                if (Ht != Kt)
                    throw Ht + " != " + Kt;
                return Mt
            }()
              , or = 63;
            return function(tr) {
                for (var wr = [], Ht = 0; Ht < tr.length; Ht += 1) {
                    var Mt = tr.charCodeAt(Ht);
                    if (Mt < 128)
                        wr.push(Mt);
                    else {
                        var _t = ir[tr.charAt(Ht)];
                        typeof _t == "number" ? (_t & 255) == _t ? wr.push(_t) : (wr.push(_t >>> 8),
                        wr.push(_t & 255)) : wr.push(or)
                    }
                }
                return wr
            }
        }
        ;
        var k = {
            MODE_NUMBER: 1,
            MODE_ALPHA_NUM: 2,
            MODE_8BIT_BYTE: 4,
            MODE_KANJI: 8
        }
          , y = {
            L: 1,
            M: 0,
            Q: 3,
            H: 2
        }
          , ee = {
            PATTERN000: 0,
            PATTERN001: 1,
            PATTERN010: 2,
            PATTERN011: 3,
            PATTERN100: 4,
            PATTERN101: 5,
            PATTERN110: 6,
            PATTERN111: 7
        }
          , dt = function() {
            var Wt = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]]
              , Kt = 1335
              , ir = 7973
              , or = 21522
              , tr = {}
              , wr = function(Ht) {
                for (var Mt = 0; Ht != 0; )
                    Mt += 1,
                    Ht >>>= 1;
                return Mt
            };
            return tr.getBCHTypeInfo = function(Ht) {
                for (var Mt = Ht << 10; wr(Mt) - wr(Kt) >= 0; )
                    Mt ^= Kt << wr(Mt) - wr(Kt);
                return (Ht << 10 | Mt) ^ or
            }
            ,
            tr.getBCHTypeNumber = function(Ht) {
                for (var Mt = Ht << 12; wr(Mt) - wr(ir) >= 0; )
                    Mt ^= ir << wr(Mt) - wr(ir);
                return Ht << 12 | Mt
            }
            ,
            tr.getPatternPosition = function(Ht) {
                return Wt[Ht - 1]
            }
            ,
            tr.getMaskFunction = function(Ht) {
                switch (Ht) {
                case ee.PATTERN000:
                    return function(Mt, _t) {
                        return (Mt + _t) % 2 == 0
                    }
                    ;
                case ee.PATTERN001:
                    return function(Mt, _t) {
                        return Mt % 2 == 0
                    }
                    ;
                case ee.PATTERN010:
                    return function(Mt, _t) {
                        return _t % 3 == 0
                    }
                    ;
                case ee.PATTERN011:
                    return function(Mt, _t) {
                        return (Mt + _t) % 3 == 0
                    }
                    ;
                case ee.PATTERN100:
                    return function(Mt, _t) {
                        return (Math.floor(Mt / 2) + Math.floor(_t / 3)) % 2 == 0
                    }
                    ;
                case ee.PATTERN101:
                    return function(Mt, _t) {
                        return Mt * _t % 2 + Mt * _t % 3 == 0
                    }
                    ;
                case ee.PATTERN110:
                    return function(Mt, _t) {
                        return (Mt * _t % 2 + Mt * _t % 3) % 2 == 0
                    }
                    ;
                case ee.PATTERN111:
                    return function(Mt, _t) {
                        return (Mt * _t % 3 + (Mt + _t) % 2) % 2 == 0
                    }
                    ;
                default:
                    throw "bad maskPattern:" + Ht
                }
            }
            ,
            tr.getErrorCorrectPolynomial = function(Ht) {
                for (var Mt = yt([1], 0), _t = 0; _t < Ht; _t += 1)
                    Mt = Mt.multiply(yt([1, mt.gexp(_t)], 0));
                return Mt
            }
            ,
            tr.getLengthInBits = function(Ht, Mt) {
                if (1 <= Mt && Mt < 10)
                    switch (Ht) {
                    case k.MODE_NUMBER:
                        return 10;
                    case k.MODE_ALPHA_NUM:
                        return 9;
                    case k.MODE_8BIT_BYTE:
                        return 8;
                    case k.MODE_KANJI:
                        return 8;
                    default:
                        throw "mode:" + Ht
                    }
                else if (Mt < 27)
                    switch (Ht) {
                    case k.MODE_NUMBER:
                        return 12;
                    case k.MODE_ALPHA_NUM:
                        return 11;
                    case k.MODE_8BIT_BYTE:
                        return 16;
                    case k.MODE_KANJI:
                        return 10;
                    default:
                        throw "mode:" + Ht
                    }
                else if (Mt < 41)
                    switch (Ht) {
                    case k.MODE_NUMBER:
                        return 14;
                    case k.MODE_ALPHA_NUM:
                        return 13;
                    case k.MODE_8BIT_BYTE:
                        return 16;
                    case k.MODE_KANJI:
                        return 12;
                    default:
                        throw "mode:" + Ht
                    }
                else
                    throw "type:" + Mt
            }
            ,
            tr.getLostPoint = function(Ht) {
                for (var Mt = Ht.getModuleCount(), _t = 0, gt = 0; gt < Mt; gt += 1)
                    for (var vt = 0; vt < Mt; vt += 1) {
                        for (var Et = 0, Bt = Ht.isDark(gt, vt), Rt = -1; Rt <= 1; Rt += 1)
                            if (!(gt + Rt < 0 || Mt <= gt + Rt))
                                for (var kt = -1; kt <= 1; kt += 1)
                                    vt + kt < 0 || Mt <= vt + kt || Rt == 0 && kt == 0 || Bt == Ht.isDark(gt + Rt, vt + kt) && (Et += 1);
                        Et > 5 && (_t += 3 + Et - 5)
                    }
                for (var gt = 0; gt < Mt - 1; gt += 1)
                    for (var vt = 0; vt < Mt - 1; vt += 1) {
                        var Tt = 0;
                        Ht.isDark(gt, vt) && (Tt += 1),
                        Ht.isDark(gt + 1, vt) && (Tt += 1),
                        Ht.isDark(gt, vt + 1) && (Tt += 1),
                        Ht.isDark(gt + 1, vt + 1) && (Tt += 1),
                        (Tt == 0 || Tt == 4) && (_t += 3)
                    }
                for (var gt = 0; gt < Mt; gt += 1)
                    for (var vt = 0; vt < Mt - 6; vt += 1)
                        Ht.isDark(gt, vt) && !Ht.isDark(gt, vt + 1) && Ht.isDark(gt, vt + 2) && Ht.isDark(gt, vt + 3) && Ht.isDark(gt, vt + 4) && !Ht.isDark(gt, vt + 5) && Ht.isDark(gt, vt + 6) && (_t += 40);
                for (var vt = 0; vt < Mt; vt += 1)
                    for (var gt = 0; gt < Mt - 6; gt += 1)
                        Ht.isDark(gt, vt) && !Ht.isDark(gt + 1, vt) && Ht.isDark(gt + 2, vt) && Ht.isDark(gt + 3, vt) && Ht.isDark(gt + 4, vt) && !Ht.isDark(gt + 5, vt) && Ht.isDark(gt + 6, vt) && (_t += 40);
                for (var It = 0, vt = 0; vt < Mt; vt += 1)
                    for (var gt = 0; gt < Mt; gt += 1)
                        Ht.isDark(gt, vt) && (It += 1);
                var St = Math.abs(100 * It / Mt / Mt - 50) / 5;
                return _t += St * 10,
                _t
            }
            ,
            tr
        }()
          , mt = function() {
            for (var Wt = new Array(256), Kt = new Array(256), ir = 0; ir < 8; ir += 1)
                Wt[ir] = 1 << ir;
            for (var ir = 8; ir < 256; ir += 1)
                Wt[ir] = Wt[ir - 4] ^ Wt[ir - 5] ^ Wt[ir - 6] ^ Wt[ir - 8];
            for (var ir = 0; ir < 255; ir += 1)
                Kt[Wt[ir]] = ir;
            var or = {};
            return or.glog = function(tr) {
                if (tr < 1)
                    throw "glog(" + tr + ")";
                return Kt[tr]
            }
            ,
            or.gexp = function(tr) {
                for (; tr < 0; )
                    tr += 255;
                for (; tr >= 256; )
                    tr -= 255;
                return Wt[tr]
            }
            ,
            or
        }();
        function yt(Wt, Kt) {
            if (typeof Wt.length > "u")
                throw Wt.length + "/" + Kt;
            var ir = function() {
                for (var tr = 0; tr < Wt.length && Wt[tr] == 0; )
                    tr += 1;
                for (var wr = new Array(Wt.length - tr + Kt), Ht = 0; Ht < Wt.length - tr; Ht += 1)
                    wr[Ht] = Wt[Ht + tr];
                return wr
            }()
              , or = {};
            return or.getAt = function(tr) {
                return ir[tr]
            }
            ,
            or.getLength = function() {
                return ir.length
            }
            ,
            or.multiply = function(tr) {
                for (var wr = new Array(or.getLength() + tr.getLength() - 1), Ht = 0; Ht < or.getLength(); Ht += 1)
                    for (var Mt = 0; Mt < tr.getLength(); Mt += 1)
                        wr[Ht + Mt] ^= mt.gexp(mt.glog(or.getAt(Ht)) + mt.glog(tr.getAt(Mt)));
                return yt(wr, 0)
            }
            ,
            or.mod = function(tr) {
                if (or.getLength() - tr.getLength() < 0)
                    return or;
                for (var wr = mt.glog(or.getAt(0)) - mt.glog(tr.getAt(0)), Ht = new Array(or.getLength()), Mt = 0; Mt < or.getLength(); Mt += 1)
                    Ht[Mt] = or.getAt(Mt);
                for (var Mt = 0; Mt < tr.getLength(); Mt += 1)
                    Ht[Mt] ^= mt.gexp(mt.glog(tr.getAt(Mt)) + wr);
                return yt(Ht, 0).mod(tr)
            }
            ,
            or
        }
        var pt = function() {
            var Wt = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12, 7, 37, 13], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]]
              , Kt = function(tr, wr) {
                var Ht = {};
                return Ht.totalCount = tr,
                Ht.dataCount = wr,
                Ht
            }
              , ir = {}
              , or = function(tr, wr) {
                switch (wr) {
                case y.L:
                    return Wt[(tr - 1) * 4 + 0];
                case y.M:
                    return Wt[(tr - 1) * 4 + 1];
                case y.Q:
                    return Wt[(tr - 1) * 4 + 2];
                case y.H:
                    return Wt[(tr - 1) * 4 + 3];
                default:
                    return
                }
            };
            return ir.getRSBlocks = function(tr, wr) {
                var Ht = or(tr, wr);
                if (typeof Ht > "u")
                    throw "bad rs block @ typeNumber:" + tr + "/errorCorrectionLevel:" + wr;
                for (var Mt = Ht.length / 3, _t = [], gt = 0; gt < Mt; gt += 1)
                    for (var vt = Ht[gt * 3 + 0], Et = Ht[gt * 3 + 1], Bt = Ht[gt * 3 + 2], Rt = 0; Rt < vt; Rt += 1)
                        _t.push(Kt(Et, Bt));
                return _t
            }
            ,
            ir
        }()
          , bt = function() {
            var Wt = []
              , Kt = 0
              , ir = {};
            return ir.getBuffer = function() {
                return Wt
            }
            ,
            ir.getAt = function(or) {
                var tr = Math.floor(or / 8);
                return (Wt[tr] >>> 7 - or % 8 & 1) == 1
            }
            ,
            ir.put = function(or, tr) {
                for (var wr = 0; wr < tr; wr += 1)
                    ir.putBit((or >>> tr - wr - 1 & 1) == 1)
            }
            ,
            ir.getLengthInBits = function() {
                return Kt
            }
            ,
            ir.putBit = function(or) {
                var tr = Math.floor(Kt / 8);
                Wt.length <= tr && Wt.push(0),
                or && (Wt[tr] |= 128 >>> Kt % 8),
                Kt += 1
            }
            ,
            ir
        }
          , wt = function(Wt) {
            var Kt = k.MODE_NUMBER
              , ir = Wt
              , or = {};
            or.getMode = function() {
                return Kt
            }
            ,
            or.getLength = function(Ht) {
                return ir.length
            }
            ,
            or.write = function(Ht) {
                for (var Mt = ir, _t = 0; _t + 2 < Mt.length; )
                    Ht.put(tr(Mt.substring(_t, _t + 3)), 10),
                    _t += 3;
                _t < Mt.length && (Mt.length - _t == 1 ? Ht.put(tr(Mt.substring(_t, _t + 1)), 4) : Mt.length - _t == 2 && Ht.put(tr(Mt.substring(_t, _t + 2)), 7))
            }
            ;
            var tr = function(Ht) {
                for (var Mt = 0, _t = 0; _t < Ht.length; _t += 1)
                    Mt = Mt * 10 + wr(Ht.charAt(_t));
                return Mt
            }
              , wr = function(Ht) {
                if ("0" <= Ht && Ht <= "9")
                    return Ht.charCodeAt(0) - 48;
                throw "illegal char :" + Ht
            };
            return or
        }
          , xt = function(Wt) {
            var Kt = k.MODE_ALPHA_NUM
              , ir = Wt
              , or = {};
            or.getMode = function() {
                return Kt
            }
            ,
            or.getLength = function(wr) {
                return ir.length
            }
            ,
            or.write = function(wr) {
                for (var Ht = ir, Mt = 0; Mt + 1 < Ht.length; )
                    wr.put(tr(Ht.charAt(Mt)) * 45 + tr(Ht.charAt(Mt + 1)), 11),
                    Mt += 2;
                Mt < Ht.length && wr.put(tr(Ht.charAt(Mt)), 6)
            }
            ;
            var tr = function(wr) {
                if ("0" <= wr && wr <= "9")
                    return wr.charCodeAt(0) - 48;
                if ("A" <= wr && wr <= "Z")
                    return wr.charCodeAt(0) - 65 + 10;
                switch (wr) {
                case " ":
                    return 36;
                case "$":
                    return 37;
                case "%":
                    return 38;
                case "*":
                    return 39;
                case "+":
                    return 40;
                case "-":
                    return 41;
                case ".":
                    return 42;
                case "/":
                    return 43;
                case ":":
                    return 44;
                default:
                    throw "illegal char :" + wr
                }
            };
            return or
        }
          , At = function(Wt) {
            var Kt = k.MODE_8BIT_BYTE
              , ir = m.stringToBytes(Wt)
              , or = {};
            return or.getMode = function() {
                return Kt
            }
            ,
            or.getLength = function(tr) {
                return ir.length
            }
            ,
            or.write = function(tr) {
                for (var wr = 0; wr < ir.length; wr += 1)
                    tr.put(ir[wr], 8)
            }
            ,
            or
        }
          , Ct = function(Wt) {
            var Kt = k.MODE_KANJI
              , ir = m.stringToBytesFuncs.SJIS;
            if (!ir)
                throw "sjis not supported.";
            (function(wr, Ht) {
                var Mt = ir(wr);
                if (Mt.length != 2 || (Mt[0] << 8 | Mt[1]) != Ht)
                    throw "sjis not supported."
            }
            )("友", 38726);
            var or = ir(Wt)
              , tr = {};
            return tr.getMode = function() {
                return Kt
            }
            ,
            tr.getLength = function(wr) {
                return ~~(or.length / 2)
            }
            ,
            tr.write = function(wr) {
                for (var Ht = or, Mt = 0; Mt + 1 < Ht.length; ) {
                    var _t = (255 & Ht[Mt]) << 8 | 255 & Ht[Mt + 1];
                    if (33088 <= _t && _t <= 40956)
                        _t -= 33088;
                    else if (57408 <= _t && _t <= 60351)
                        _t -= 49472;
                    else
                        throw "illegal char at " + (Mt + 1) + "/" + _t;
                    _t = (_t >>> 8 & 255) * 192 + (_t & 255),
                    wr.put(_t, 13),
                    Mt += 2
                }
                if (Mt < Ht.length)
                    throw "illegal char at " + (Mt + 1)
            }
            ,
            tr
        }
          , Pt = function() {
            var Wt = []
              , Kt = {};
            return Kt.writeByte = function(ir) {
                Wt.push(ir & 255)
            }
            ,
            Kt.writeShort = function(ir) {
                Kt.writeByte(ir),
                Kt.writeByte(ir >>> 8)
            }
            ,
            Kt.writeBytes = function(ir, or, tr) {
                or = or || 0,
                tr = tr || ir.length;
                for (var wr = 0; wr < tr; wr += 1)
                    Kt.writeByte(ir[wr + or])
            }
            ,
            Kt.writeString = function(ir) {
                for (var or = 0; or < ir.length; or += 1)
                    Kt.writeByte(ir.charCodeAt(or))
            }
            ,
            Kt.toByteArray = function() {
                return Wt
            }
            ,
            Kt.toString = function() {
                var ir = "";
                ir += "[";
                for (var or = 0; or < Wt.length; or += 1)
                    or > 0 && (ir += ","),
                    ir += Wt[or];
                return ir += "]",
                ir
            }
            ,
            Kt
        }
          , $t = function() {
            var Wt = 0
              , Kt = 0
              , ir = 0
              , or = ""
              , tr = {}
              , wr = function(Mt) {
                or += String.fromCharCode(Ht(Mt & 63))
            }
              , Ht = function(Mt) {
                if (!(Mt < 0)) {
                    if (Mt < 26)
                        return 65 + Mt;
                    if (Mt < 52)
                        return 97 + (Mt - 26);
                    if (Mt < 62)
                        return 48 + (Mt - 52);
                    if (Mt == 62)
                        return 43;
                    if (Mt == 63)
                        return 47
                }
                throw "n:" + Mt
            };
            return tr.writeByte = function(Mt) {
                for (Wt = Wt << 8 | Mt & 255,
                Kt += 8,
                ir += 1; Kt >= 6; )
                    wr(Wt >>> Kt - 6),
                    Kt -= 6
            }
            ,
            tr.flush = function() {
                if (Kt > 0 && (wr(Wt << 6 - Kt),
                Wt = 0,
                Kt = 0),
                ir % 3 != 0)
                    for (var Mt = 3 - ir % 3, _t = 0; _t < Mt; _t += 1)
                        or += "="
            }
            ,
            tr.toString = function() {
                return or
            }
            ,
            tr
        }
          , Ot = function(Wt) {
            var Kt = Wt
              , ir = 0
              , or = 0
              , tr = 0
              , wr = {};
            wr.read = function() {
                for (; tr < 8; ) {
                    if (ir >= Kt.length) {
                        if (tr == 0)
                            return -1;
                        throw "unexpected end of file./" + tr
                    }
                    var Mt = Kt.charAt(ir);
                    if (ir += 1,
                    Mt == "=")
                        return tr = 0,
                        -1;
                    if (Mt.match(/^\s$/))
                        continue;
                    or = or << 6 | Ht(Mt.charCodeAt(0)),
                    tr += 6
                }
                var _t = or >>> tr - 8 & 255;
                return tr -= 8,
                _t
            }
            ;
            var Ht = function(Mt) {
                if (65 <= Mt && Mt <= 90)
                    return Mt - 65;
                if (97 <= Mt && Mt <= 122)
                    return Mt - 97 + 26;
                if (48 <= Mt && Mt <= 57)
                    return Mt - 48 + 52;
                if (Mt == 43)
                    return 62;
                if (Mt == 47)
                    return 63;
                throw "c:" + Mt
            };
            return wr
        }
          , Nt = function(Wt, Kt) {
            var ir = Wt
              , or = Kt
              , tr = new Array(Wt * Kt)
              , wr = {};
            wr.setPixel = function(gt, vt, Et) {
                tr[vt * ir + gt] = Et
            }
            ,
            wr.write = function(gt) {
                gt.writeString("GIF87a"),
                gt.writeShort(ir),
                gt.writeShort(or),
                gt.writeByte(128),
                gt.writeByte(0),
                gt.writeByte(0),
                gt.writeByte(0),
                gt.writeByte(0),
                gt.writeByte(0),
                gt.writeByte(255),
                gt.writeByte(255),
                gt.writeByte(255),
                gt.writeString(","),
                gt.writeShort(0),
                gt.writeShort(0),
                gt.writeShort(ir),
                gt.writeShort(or),
                gt.writeByte(0);
                var vt = 2
                  , Et = Mt(vt);
                gt.writeByte(vt);
                for (var Bt = 0; Et.length - Bt > 255; )
                    gt.writeByte(255),
                    gt.writeBytes(Et, Bt, 255),
                    Bt += 255;
                gt.writeByte(Et.length - Bt),
                gt.writeBytes(Et, Bt, Et.length - Bt),
                gt.writeByte(0),
                gt.writeString(";")
            }
            ;
            var Ht = function(gt) {
                var vt = gt
                  , Et = 0
                  , Bt = 0
                  , Rt = {};
                return Rt.write = function(kt, Tt) {
                    if (kt >>> Tt)
                        throw "length over";
                    for (; Et + Tt >= 8; )
                        vt.writeByte(255 & (kt << Et | Bt)),
                        Tt -= 8 - Et,
                        kt >>>= 8 - Et,
                        Bt = 0,
                        Et = 0;
                    Bt = kt << Et | Bt,
                    Et = Et + Tt
                }
                ,
                Rt.flush = function() {
                    Et > 0 && vt.writeByte(Bt)
                }
                ,
                Rt
            }
              , Mt = function(gt) {
                for (var vt = 1 << gt, Et = (1 << gt) + 1, Bt = gt + 1, Rt = _t(), kt = 0; kt < vt; kt += 1)
                    Rt.add(String.fromCharCode(kt));
                Rt.add(String.fromCharCode(vt)),
                Rt.add(String.fromCharCode(Et));
                var Tt = Pt()
                  , It = Ht(Tt);
                It.write(vt, Bt);
                var St = 0
                  , qt = String.fromCharCode(tr[St]);
                for (St += 1; St < tr.length; ) {
                    var ur = String.fromCharCode(tr[St]);
                    St += 1,
                    Rt.contains(qt + ur) ? qt = qt + ur : (It.write(Rt.indexOf(qt), Bt),
                    Rt.size() < 4095 && (Rt.size() == 1 << Bt && (Bt += 1),
                    Rt.add(qt + ur)),
                    qt = ur)
                }
                return It.write(Rt.indexOf(qt), Bt),
                It.write(Et, Bt),
                It.flush(),
                Tt.toByteArray()
            }
              , _t = function() {
                var gt = {}
                  , vt = 0
                  , Et = {};
                return Et.add = function(Bt) {
                    if (Et.contains(Bt))
                        throw "dup key:" + Bt;
                    gt[Bt] = vt,
                    vt += 1
                }
                ,
                Et.size = function() {
                    return vt
                }
                ,
                Et.indexOf = function(Bt) {
                    return gt[Bt]
                }
                ,
                Et.contains = function(Bt) {
                    return typeof gt[Bt] < "u"
                }
                ,
                Et
            };
            return wr
        }
          , zt = function(Wt, Kt, ir) {
            for (var or = Nt(Wt, Kt), tr = 0; tr < Kt; tr += 1)
                for (var wr = 0; wr < Wt; wr += 1)
                    or.setPixel(wr, tr, ir(wr, tr));
            var Ht = Pt();
            or.write(Ht);
            for (var Mt = $t(), _t = Ht.toByteArray(), gt = 0; gt < _t.length; gt += 1)
                Mt.writeByte(_t[gt]);
            return Mt.flush(),
            "data:image/gif;base64," + Mt
        };
        return m
    }();
    (function() {
        f.stringToBytesFuncs["UTF-8"] = function(m) {
            function k(y) {
                for (var ee = [], dt = 0; dt < y.length; dt++) {
                    var mt = y.charCodeAt(dt);
                    mt < 128 ? ee.push(mt) : mt < 2048 ? ee.push(192 | mt >> 6, 128 | mt & 63) : mt < 55296 || mt >= 57344 ? ee.push(224 | mt >> 12, 128 | mt >> 6 & 63, 128 | mt & 63) : (dt++,
                    mt = 65536 + ((mt & 1023) << 10 | y.charCodeAt(dt) & 1023),
                    ee.push(240 | mt >> 18, 128 | mt >> 12 & 63, 128 | mt >> 6 & 63, 128 | mt & 63))
                }
                return ee
            }
            return k(m)
        }
    }
    )(),
    function(m) {
        r.exports = m()
    }(function() {
        return f
    })
}
)(qrcode$1);
const qrcode = qrcode$1.exports;
function copyToClipboard(r) {
    return __async(this, null, function*() {
        try {
            if (!(navigator != null && navigator.clipboard))
                throw new TonConnectUIError("Clipboard API not available");
            return yield navigator.clipboard.writeText(r)
        } catch {}
        fallbackCopyTextToClipboard(r)
    })
}
function fallbackCopyTextToClipboard(r) {
    const d = document.createElement("textarea");
    d.value = r,
    d.style.top = "0",
    d.style.left = "0",
    d.style.position = "fixed",
    document.body.appendChild(d),
    d.focus(),
    d.select();
    try {
        document.execCommand("copy")
    } finally {
        document.body.removeChild(d)
    }
}
const _tmpl$$s = template$1("<div></div>")
  , QRCode = r=>{
    let d, f, m;
    const [k,y] = createSignal(!1)
      , [ee,dt] = createSignal(picSizeDefault);
    createEffect(()=>{
        const wt = qrcode(0, "L");
        wt.addData(r.sourceUrl),
        wt.make(),
        d.innerHTML = wt.createSvgTag(4, 0);
        const xt = d.firstElementChild.clientWidth
          , At = Math.round(qrNormalSize / xt * 1e5) / 1e5;
        if (m) {
            const Ct = Math.ceil(imgSizeDefault / (At * 4)) * 4
              , Pt = toPx(Math.ceil((xt - Ct) / (2 * 4)) * 4);
            m.style.top = Pt,
            m.style.left = Pt,
            m.style.height = toPx(Ct),
            m.style.width = toPx(Ct),
            dt(Math.round(picSizeDefault / At))
        }
        f.style.transform = `scale(${At})`
    }
    );
    let mt = null;
    return createComponent(QrCodeBackground, {
        get class() {
            return r.class
        },
        onClick: ()=>{
            y(!0),
            copyToClipboard(r.sourceUrl),
            mt != null && clearTimeout(mt),
            mt = setTimeout(()=>y(!1), 1500)
        }
        ,
        get children() {
            return [createComponent(QrCodeWrapper$2, {
                ref(pt) {
                    const bt = f;
                    typeof bt == "function" ? bt(pt) : f = pt
                },
                get children() {
                    return [(()=>{
                        const pt = _tmpl$$s.cloneNode(!0)
                          , bt = d;
                        return typeof bt == "function" ? use(bt, pt) : d = pt,
                        pt
                    }
                    )(), createComponent(Show, {
                        get when() {
                            return r.imageUrl
                        },
                        get children() {
                            return createComponent(ImageBackground, {
                                ref(pt) {
                                    const bt = m;
                                    typeof bt == "function" ? bt(pt) : m = pt
                                },
                                get children() {
                                    return createComponent(ImageStyled$3, {
                                        get src() {
                                            return r.imageUrl
                                        },
                                        alt: "",
                                        get size() {
                                            return ee()
                                        }
                                    })
                                }
                            })
                        }
                    })]
                }
            }), createComponent(Transition, {
                onBeforeEnter: pt=>{
                    animate(pt, [{
                        opacity: 0,
                        transform: "translate(-50%, 44px)"
                    }, {
                        opacity: 1,
                        transform: "translate(-50%, 0)"
                    }], {
                        duration: 150,
                        easing: "ease-out"
                    })
                }
                ,
                onExit: (pt,bt)=>{
                    animate(pt, [{
                        opacity: 1,
                        transform: "translate(-50%, 0)"
                    }, {
                        opacity: 0,
                        transform: "translate(-50%, 44px)"
                    }], {
                        duration: 150,
                        easing: "ease-out"
                    }).finished.then(()=>{
                        bt()
                    }
                    )
                }
                ,
                get children() {
                    return createComponent(Show, {
                        get when() {
                            return k() && !r.disableCopy
                        },
                        get children() {
                            return createComponent(CopiedBoxStyled, {
                                get children() {
                                    return [createComponent(SuccessIcon, {
                                        size: "xs"
                                    }), createComponent(Text, {
                                        translationKey: "common.linkCopied",
                                        children: "Link Copied"
                                    })]
                                }
                            })
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return !r.disableCopy
                },
                get children() {
                    return createComponent(CopyIconButton, {
                        get children() {
                            return createComponent(CopyLightIcon, {})
                        }
                    })
                }
            })]
        }
    })
}
;
var deepReadObject = (r,d,f)=>{
    const m = d.trim().split(".").reduce((k,y)=>k ? k[y] : void 0, r);
    return m !== void 0 ? m : f
}
  , template = (r,d,f=/{{(.*?)}}/g)=>r.replace(f, (m,k)=>deepReadObject(d, k, ""))
  , createI18nContext = (r={},d=navigator.language in r ? navigator.language : Object.keys(r)[0])=>{
    const [f,m] = createSignal(d)
      , [k,y] = createStore(r);
    return [(mt,yt,pt)=>{
        const bt = deepReadObject(k[f()], mt, pt || "");
        return typeof bt == "function" ? bt(yt) : typeof bt == "string" ? template(bt, yt || {}) : bt
    }
    , {
        add(mt, yt) {
            y(mt, pt=>Object.assign(pt || {}, yt))
        },
        locale: mt=>mt ? m(mt) : f(),
        dict: mt=>deepReadObject(k, mt)
    }]
}
  , I18nContext = createContext({})
  , useI18n = ()=>useContext(I18nContext);
const TextStyled$3 = styled.div`
    font-style: normal;
    font-weight: ${r=>r.fontWeight};
    font-size: ${r=>r.fontSize};
    line-height: ${r=>r.lineHeight};

    color: ${r=>r.color};
`
  , Text = r=>{
    const d = useTheme()
      , [f] = useI18n();
    let m;
    const k = ()=>r.color || d.colors.text.primary
      , y = mergeProps({
        fontSize: "14px",
        fontWeight: "510",
        lineHeight: "130%"
    }, r);
    return createEffect(()=>{
        m && y.cursor !== "unset" && getComputedStyle(m).cursor !== "pointer" && (m.style.cursor = "default")
    }
    ),
    createComponent(TextStyled$3, {
        get fontSize() {
            return y.fontSize
        },
        get fontWeight() {
            return y.fontWeight
        },
        get lineHeight() {
            return y.lineHeight
        },
        get color() {
            return k()
        },
        get class() {
            return y.class
        },
        ref(ee) {
            const dt = m;
            typeof dt == "function" ? dt(ee) : m = ee
        },
        "data-tc-text": "true",
        get children() {
            var ee;
            return createMemo(()=>!!y.translationKey)() ? f(y.translationKey, y.translationValues, (ee = y.children) == null ? void 0 : ee.toString()) : y.children
        }
    })
}
  , ImageContainer = styled.div`
    position: relative;

    &::after {
        content: '';
        display: block;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        border: 0.5px solid rgba(0, 0, 0, 0.08);

        border-radius: inherit;
    }
`
  , ImageStyled$2 = styled(Image)`
    width: 100%;
    height: 100%;
    border-radius: inherit;
`
  , WalletImage = r=>createComponent(ImageContainer, {
    get class() {
        return r.class
    },
    get children() {
        return createComponent(ImageStyled$2, {
            get src() {
                return r.src
            }
        })
    }
})
  , borders$3 = {
    m: "16px",
    s: "12px",
    none: "0"
}
  , badgeBorders = {
    m: "6px",
    s: "6px",
    none: "0"
}
  , WalletItemStyled = styled.button`
    position: relative;
    cursor: pointer;
    border: none;
    background-color: unset;
    padding: 8px 4px;
    width: 92px;
    display: flex;
    flex-direction: column;
    align-items: center;

    transition: transform 0.125s ease-in-out;

    ${mediaNotTouch} {
        &:hover {
            transform: scale(1.04);
        }
    }

    &:active {
        transform: scale(0.96);
    }

    ${media("mobile")} {
        padding: 8px 4px;
        width: 82px;
    }

    ${mediaTouch} {
        &:active {
            transform: scale(0.92);
        }
    }
`
  , ImageStyled$1 = styled(WalletImage)`
    width: 60px;
    height: 60px;
    border-radius: ${r=>borders$3[r.theme.borderRadius]};

    margin-bottom: 8px;
`
  , BadgeStyled = styled(Image)`
    position: absolute;
    right: 10px;
    top: 50px;
    width: 24px;
    height: 24px;
    border-radius: ${r=>badgeBorders[r.theme.borderRadius]};
    box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.08);
`
  , StyledText = styled(Text)`
    max-width: 90px;
    font-weight: 590;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;

    ${media("mobile")} {
        max-width: 80px;
    }
`
  , StyledSecondLine = styled(Text)`
    font-weight: 510;
    max-width: 90px;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
    color: ${r=>r.colorPrimary ? r.theme.colors.text.primary : r.theme.colors.text.secondary};

    ${media("mobile")} {
        max-width: 80px;
    }
`
  , WalletItem = r=>createComponent(WalletItemStyled, {
    get class() {
        return r.class
    },
    onClick: ()=>r.onClick(),
    "data-tc-wallet-item": "true",
    get children() {
        return [createMemo(()=>createMemo(()=>typeof r.icon == "string")() ? createComponent(ImageStyled$1, {
            get src() {
                return r.icon
            }
        }) : r.icon), createMemo(()=>createMemo(()=>!!r.badgeUrl)() && createComponent(BadgeStyled, {
            get src() {
                return r.badgeUrl
            }
        })), createComponent(StyledText, {
            get children() {
                return r.name
            }
        }), createMemo(()=>createMemo(()=>!!r.secondLine)() && createComponent(StyledSecondLine, {
            get colorPrimary() {
                var d;
                return (d = r.secondLineColorPrimary) != null ? d : !0
            },
            get children() {
                return r.secondLine
            }
        }))]
    }
})
  , H1Styled$9 = styled.h1`
    font-style: normal;
    font-weight: 700;
    font-size: 20px;
    line-height: 28px;

    text-align: center;

    color: ${r=>r.theme.colors.text.primary};

    margin-top: 0;
    margin-bottom: 0;

    cursor: default;
`
  , H1 = r=>{
    const [d] = useI18n();
    return createComponent(H1Styled$9, {
        get class() {
            return r.class
        },
        "data-tc-h1": "true",
        get children() {
            var f;
            return createMemo(()=>!!r.translationKey)() ? d(r.translationKey, r.translationValues, (f = r.children) == null ? void 0 : f.toString()) : r.children
        }
    })
}
  , H2Styled$5 = styled.h2`
    font-style: normal;
    font-weight: 510;
    font-size: 16px;
    line-height: 22px;

    text-align: center;

    color: ${r=>r.theme.colors.text.secondary};

    margin-top: 0;
    margin-bottom: 32px;

    cursor: default;
`
  , H2 = r=>{
    const [d] = useI18n();
    return createComponent(H2Styled$5, {
        get class() {
            return r.class
        },
        "data-tc-h2": "true",
        get children() {
            var f;
            return createMemo(()=>!!r.translationKey)() ? d(r.translationKey, r.translationValues, (f = r.children) == null ? void 0 : f.toString()) : r.children
        }
    })
}
  , H3Styled$1 = styled.h3`
    font-style: normal;
    font-weight: 590;
    font-size: 16px;
    line-height: 20px;

    color: ${r=>r.theme.colors.text.primary};

    margin-top: 0;
    margin-bottom: 0;

    cursor: default;
`
  , H3 = r=>{
    const [d] = useI18n();
    return createComponent(H3Styled$1, {
        "data-tc-h3": "true",
        get class() {
            return r.class
        },
        get children() {
            var f;
            return createMemo(()=>!!r.translationKey)() ? d(r.translationKey, r.translationValues, (f = r.children) == null ? void 0 : f.toString()) : r.children
        }
    })
}
  , _tmpl$$r = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><path fill-rule="evenodd" clip-rule="evenodd" d="M9.75 7.5C9.33579 7.5 9 7.16421 9 6.75C9 6.33579 9.33579 6 9.75 6H21.25C21.6642 6 22 6.33579 22 6.75V18.25C22 18.6642 21.6642 19 21.25 19C20.8358 19 20.5 18.6642 20.5 18.25V8.56066L6.28033 22.7803C5.98744 23.0732 5.51256 23.0732 5.21967 22.7803C4.92678 22.4874 4.92678 22.0126 5.21967 21.7197L19.4393 7.5H9.75Z"></path></svg>')
  , LongArrowIcon = r=>{
    const d = useTheme()
      , f = ()=>r.fill || d.colors.icon.secondary;
    return (()=>{
        const m = _tmpl$$r.cloneNode(!0)
          , k = m.firstChild;
        return createRenderEffect(y=>{
            const ee = f()
              , dt = f();
            return ee !== y._v$ && setAttribute(m, "fill", y._v$ = ee),
            dt !== y._v$2 && setAttribute(k, "fill", y._v$2 = dt),
            y
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        m
    }
    )()
}
  , _tmpl$$q = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M14.1839 17.7069C13.6405 18.6507 13.3688 19.1226 13.0591 19.348C12.4278 19.8074 11.5723 19.8074 10.941 19.348C10.6312 19.1226 10.3595 18.6507 9.81613 17.7069L5.52066 10.2464C4.76864 8.94024 4.39263 8.28717 4.33762 7.75894C4.2255 6.68236 4.81894 5.65591 5.80788 5.21589C6.29309 5 7.04667 5 8.55383 5H15.4462C16.9534 5 17.7069 5 18.1922 5.21589C19.1811 5.65591 19.7745 6.68236 19.6624 7.75894C19.6074 8.28717 19.2314 8.94024 18.4794 10.2464L14.1839 17.7069ZM11.1 16.3412L6.56139 8.48002C6.31995 8.06185 6.19924 7.85276 6.18146 7.68365C6.14523 7.33896 6.33507 7.01015 6.65169 6.86919C6.80703 6.80002 7.04847 6.80002 7.53133 6.80002H7.53134L11.1 6.80002V16.3412ZM12.9 16.3412L17.4387 8.48002C17.6801 8.06185 17.8008 7.85276 17.8186 7.68365C17.8548 7.33896 17.665 7.01015 17.3484 6.86919C17.193 6.80002 16.9516 6.80002 16.4687 6.80002L12.9 6.80002V16.3412Z"></path></svg>')
  , TonIcon = r=>{
    const d = useTheme()
      , f = ()=>r.fill || d.colors.icon.primary;
    return (()=>{
        const m = _tmpl$$q.cloneNode(!0)
          , k = m.firstChild;
        return createRenderEffect(()=>setAttribute(k, "fill", f())),
        m
    }
    )()
}
  , _tmpl$$p = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><g clip-path="url(#clip0_3783_2045)"><circle cx="8" cy="8.00098" r="8"></circle><path d="M4.75 8.50098L7 10.751L11.75 6.00098" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></g><defs><clipPath id="clip0_3783_2045"><rect width="16" height="16" fill="white" transform="translate(0 0.000976562)"></rect></clipPath></defs></svg>')
  , _tmpl$2$3 = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="11"></circle><path d="M17.1364 9.6364C17.4879 9.28493 17.4879 8.71508 17.1364 8.36361C16.7849 8.01214 16.2151 8.01214 15.8636 8.36361L10 14.2272L8.1364 12.3636C7.78493 12.0121 7.21508 12.0121 6.86361 12.3636C6.51214 12.7151 6.51214 13.2849 6.86361 13.6364L9.36361 16.1364C9.71508 16.4879 10.2849 16.4879 10.6364 16.1364L17.1364 9.6364Z"></path></svg>')
  , _tmpl$3$2 = template$1('<svg width="72" height="72" viewBox="0 0 72 72" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="36" cy="36" r="33"></circle><path d="M50.9142 28.4142C51.6953 27.6332 51.6953 26.3668 50.9142 25.5858C50.1332 24.8047 48.8668 24.8047 48.0858 25.5858L30 43.6716L23.9142 37.5858C23.1332 36.8047 21.8668 36.8047 21.0858 37.5858C20.3047 38.3668 20.3047 39.6332 21.0858 40.4142L28.5858 47.9142C29.3668 48.6953 30.6332 48.6953 31.4142 47.9142L50.9142 28.4142Z"></path></svg>')
  , SuccessIcon = r=>{
    const d = useTheme()
      , f = ()=>r.size || "s"
      , m = ()=>r.fill || d.colors.icon.success;
    return createMemo((()=>{
        const k = createMemo(()=>f() === "xs");
        return ()=>k() ? (()=>{
            const y = _tmpl$$p.cloneNode(!0)
              , ee = y.firstChild
              , dt = ee.firstChild
              , mt = dt.nextSibling;
            return createRenderEffect(yt=>{
                const pt = r.class
                  , bt = m()
                  , wt = d.colors.constant.white;
                return pt !== yt._v$ && setAttribute(y, "class", yt._v$ = pt),
                bt !== yt._v$2 && setAttribute(dt, "fill", yt._v$2 = bt),
                wt !== yt._v$3 && setAttribute(mt, "stroke", yt._v$3 = wt),
                yt
            }
            , {
                _v$: void 0,
                _v$2: void 0,
                _v$3: void 0
            }),
            y
        }
        )() : (()=>{
            const y = createMemo(()=>f() === "s");
            return ()=>y() ? (()=>{
                const ee = _tmpl$2$3.cloneNode(!0)
                  , dt = ee.firstChild
                  , mt = dt.nextSibling;
                return createRenderEffect(yt=>{
                    const pt = r.class
                      , bt = m()
                      , wt = d.colors.constant.white;
                    return pt !== yt._v$4 && setAttribute(ee, "class", yt._v$4 = pt),
                    bt !== yt._v$5 && setAttribute(dt, "fill", yt._v$5 = bt),
                    wt !== yt._v$6 && setAttribute(mt, "fill", yt._v$6 = wt),
                    yt
                }
                , {
                    _v$4: void 0,
                    _v$5: void 0,
                    _v$6: void 0
                }),
                ee
            }
            )() : (()=>{
                const ee = _tmpl$3$2.cloneNode(!0)
                  , dt = ee.firstChild
                  , mt = dt.nextSibling;
                return createRenderEffect(yt=>{
                    const pt = r.class
                      , bt = m()
                      , wt = d.colors.constant.white;
                    return pt !== yt._v$7 && setAttribute(ee, "class", yt._v$7 = pt),
                    bt !== yt._v$8 && setAttribute(dt, "fill", yt._v$8 = bt),
                    wt !== yt._v$9 && setAttribute(mt, "fill", yt._v$9 = wt),
                    yt
                }
                , {
                    _v$7: void 0,
                    _v$8: void 0,
                    _v$9: void 0
                }),
                ee
            }
            )()
        }
        )()
    }
    )())
}
  , _tmpl$$o = template$1('<svg width="72" height="72" viewBox="0 0 72 72" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="36" cy="36" r="33"></circle><path d="M24.0858 26.9142C23.3047 26.1332 23.3047 24.8668 24.0858 24.0858C24.8668 23.3047 26.1332 23.3047 26.9142 24.0858L36 33.1716L45.0858 24.0858C45.8668 23.3047 47.1332 23.3047 47.9142 24.0858C48.6953 24.8668 48.6953 26.1332 47.9142 26.9142L38.8284 36L47.9142 45.0858C48.6953 45.8668 48.6953 47.1332 47.9142 47.9142C47.1332 48.6953 45.8668 48.6953 45.0858 47.9142L36 38.8284L26.9142 47.9142C26.1332 48.6953 24.8668 48.6953 24.0858 47.9142C23.3047 47.1332 23.3047 45.8668 24.0858 45.0858L33.1716 36L24.0858 26.9142Z"></path></svg>')
  , _tmpl$2$2 = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48" fill="none"><circle cx="24" cy="24.001" r="22"></circle><path d="M24 24.001L31.5 16.501M24 24.001L16.5 16.501M24 24.001L16.5 31.501M24 24.001L31.5 31.501" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"></path></svg>')
  , _tmpl$3$1 = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="11"></circle><path d="M7.86361 9.1364C7.51214 8.78493 7.51214 8.21508 7.86361 7.86361C8.21508 7.51214 8.78493 7.51214 9.1364 7.86361L12 10.7272L14.8636 7.86361C15.2151 7.51214 15.7849 7.51214 16.1364 7.86361C16.4879 8.21508 16.4879 8.78493 16.1364 9.1364L13.2728 12L16.1364 14.8636C16.4879 15.2151 16.4879 15.7849 16.1364 16.1364C15.7849 16.4879 15.2151 16.4879 14.8636 16.1364L12 13.2728L9.1364 16.1364C8.78493 16.4879 8.21508 16.4879 7.86361 16.1364C7.51214 15.7849 7.51214 15.2151 7.86361 14.8636L10.7272 12L7.86361 9.1364Z"></path></svg>')
  , ErrorIcon = r=>{
    const d = useTheme()
      , f = ()=>r.size || "m"
      , m = ()=>r.fill || d.colors.icon.error;
    return createMemo((()=>{
        const k = createMemo(()=>f() === "m");
        return ()=>k() ? (()=>{
            const y = _tmpl$$o.cloneNode(!0)
              , ee = y.firstChild
              , dt = ee.nextSibling;
            return createRenderEffect(mt=>{
                const yt = r.class
                  , pt = m()
                  , bt = d.colors.constant.white;
                return yt !== mt._v$ && setAttribute(y, "class", mt._v$ = yt),
                pt !== mt._v$2 && setAttribute(ee, "fill", mt._v$2 = pt),
                bt !== mt._v$3 && setAttribute(dt, "fill", mt._v$3 = bt),
                mt
            }
            , {
                _v$: void 0,
                _v$2: void 0,
                _v$3: void 0
            }),
            y
        }
        )() : (()=>{
            const y = createMemo(()=>f() === "s");
            return ()=>y() ? (()=>{
                const ee = _tmpl$2$2.cloneNode(!0)
                  , dt = ee.firstChild
                  , mt = dt.nextSibling;
                return createRenderEffect(yt=>{
                    const pt = r.class
                      , bt = m()
                      , wt = d.colors.constant.white;
                    return pt !== yt._v$4 && setAttribute(ee, "class", yt._v$4 = pt),
                    bt !== yt._v$5 && setAttribute(dt, "fill", yt._v$5 = bt),
                    wt !== yt._v$6 && setAttribute(mt, "stroke", yt._v$6 = wt),
                    yt
                }
                , {
                    _v$4: void 0,
                    _v$5: void 0,
                    _v$6: void 0
                }),
                ee
            }
            )() : (()=>{
                const ee = _tmpl$3$1.cloneNode(!0)
                  , dt = ee.firstChild
                  , mt = dt.nextSibling;
                return createRenderEffect(yt=>{
                    const pt = r.class
                      , bt = m()
                      , wt = d.colors.constant.white;
                    return pt !== yt._v$7 && setAttribute(ee, "class", yt._v$7 = pt),
                    bt !== yt._v$8 && setAttribute(dt, "fill", yt._v$8 = bt),
                    wt !== yt._v$9 && setAttribute(mt, "fill", yt._v$9 = wt),
                    yt
                }
                , {
                    _v$7: void 0,
                    _v$8: void 0,
                    _v$9: void 0
                }),
                ee
            }
            )()
        }
        )()
    }
    )())
}
  , _tmpl$$n = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M15.55 5.85123C18.9459 7.81184 20.1094 12.1541 18.1488 15.55C16.1882 18.9459 11.8459 20.1094 8.44998 18.1488C8.01952 17.9003 7.46909 18.0478 7.22056 18.4782C6.97203 18.9087 7.11952 19.4591 7.54998 19.7076C11.8068 22.1653 17.2499 20.7068 19.7076 16.45C22.1653 12.1932 20.7068 6.75005 16.45 4.29239C12.1932 1.83472 6.75003 3.29321 4.29236 7.55001C4.04383 7.98047 4.19132 8.53091 4.62178 8.77943C5.05224 9.02796 5.60268 8.88048 5.8512 8.45001C7.81181 5.05413 12.1541 3.89062 15.55 5.85123Z"></path></svg>')
  , _tmpl$2$1 = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="44" height="44" viewBox="0 0 44 44" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M22 2.99951C11.5066 2.99951 3 11.5061 3 21.9995C3 32.4929 11.5066 40.9995 22 40.9995C22.8284 40.9995 23.5 41.6711 23.5 42.4995C23.5 43.3279 22.8284 43.9995 22 43.9995C9.84974 43.9995 0 34.1498 0 21.9995C0 9.84925 9.84974 -0.000488281 22 -0.000488281C34.1503 -0.000488281 44 9.84925 44 21.9995C44 22.8279 43.3284 23.4995 42.5 23.4995C41.6716 23.4995 41 22.8279 41 21.9995C41 11.5061 32.4934 2.99951 22 2.99951Z"></path></svg>')
  , _tmpl$3 = template$1('<svg width="72" height="72" viewBox="0 0 72 72" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M24 56.7846C35.479 63.412 50.1572 59.479 56.7846 47.9999C63.412 36.5209 59.479 21.8427 48 15.2153C36.521 8.58791 21.8428 12.5209 15.2154 23.9999" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"></path></svg>')
  , LoaderIcon = r=>{
    const d = useTheme()
      , f = ()=>r.size || "xs"
      , m = ()=>r.fill || d.colors.icon.tertiary
      , k = h`
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
    `
      , y = u$1`
        animation: ${k} 1s linear infinite;
    `;
    return createMemo((()=>{
        const ee = createMemo(()=>f() === "xs");
        return ()=>ee() ? (()=>{
            const dt = _tmpl$$n.cloneNode(!0)
              , mt = dt.firstChild;
            return createRenderEffect(yt=>{
                const pt = cn(y, r.class)
                  , bt = m();
                return pt !== yt._v$ && setAttribute(dt, "class", yt._v$ = pt),
                bt !== yt._v$2 && setAttribute(mt, "fill", yt._v$2 = bt),
                yt
            }
            , {
                _v$: void 0,
                _v$2: void 0
            }),
            dt
        }
        )() : (()=>{
            const dt = createMemo(()=>f() === "s");
            return ()=>dt() ? (()=>{
                const mt = _tmpl$2$1.cloneNode(!0)
                  , yt = mt.firstChild;
                return createRenderEffect(pt=>{
                    const bt = cn(y, r.class)
                      , wt = m();
                    return bt !== pt._v$3 && setAttribute(mt, "class", pt._v$3 = bt),
                    wt !== pt._v$4 && setAttribute(yt, "fill", pt._v$4 = wt),
                    pt
                }
                , {
                    _v$3: void 0,
                    _v$4: void 0
                }),
                mt
            }
            )() : (()=>{
                const mt = _tmpl$3.cloneNode(!0)
                  , yt = mt.firstChild;
                return createRenderEffect(pt=>{
                    const bt = cn(y, r.class)
                      , wt = m();
                    return bt !== pt._v$5 && setAttribute(mt, "class", pt._v$5 = bt),
                    wt !== pt._v$6 && setAttribute(yt, "stroke", pt._v$6 = wt),
                    pt
                }
                , {
                    _v$5: void 0,
                    _v$6: void 0
                }),
                mt
            }
            )()
        }
        )()
    }
    )())
}
  , _tmpl$$m = template$1('<svg width="158" height="28" viewBox="0 0 158 28" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M28 14.001C28 21.733 21.732 28.001 14 28.001C6.26801 28.001 0 21.733 0 14.001C0 6.26899 6.26801 0.000976562 14 0.000976562C21.732 0.000976562 28 6.26899 28 14.001ZM9.21931 8.00098H18.7801H18.7813C20.538 8.00098 21.6522 9.89966 20.7691 11.4302L14.8672 21.6576C14.4822 22.3254 13.5172 22.3254 13.1322 21.6576L7.23158 11.4302C6.34721 9.89726 7.4614 8.00098 9.21931 8.00098ZM13.1262 18.5882V9.74806H9.21811C8.78976 9.74806 8.53708 10.2029 8.74163 10.5578L11.8423 16.1035L13.1262 18.5882ZM16.1559 16.1047L19.2554 10.5566C19.4599 10.2017 19.2073 9.74685 18.7789 9.74685H14.8709V18.5906L16.1559 16.1047Z" fill="#0098EA"></path><path d="M18.7802 8.00098H9.21936C7.46145 8.00098 6.34727 9.89726 7.23164 11.4302L13.1322 21.6576C13.5173 22.3254 14.4823 22.3254 14.8673 21.6576L20.7691 11.4302C21.6523 9.89966 20.5381 8.00098 18.7814 8.00098H18.7802ZM13.1274 18.5906L11.8424 16.1035L8.74168 10.5578C8.53714 10.2029 8.78981 9.74806 9.21816 9.74806H13.1262V18.5918L13.1274 18.5906ZM19.2555 10.5566L16.156 16.1047L14.8709 18.5906V9.74685H18.779C19.2073 9.74685 19.46 10.2017 19.2555 10.5566Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M51.7483 22.1967C55.7182 22.1967 58.9609 18.954 58.9609 14.9841C58.9609 11.0142 55.7182 7.77148 51.7483 7.77148C47.7588 7.77148 44.5357 11.0142 44.5357 14.9841C44.5357 18.954 47.7588 22.1967 51.7483 22.1967ZM51.7483 19.1702C49.4686 19.1702 47.6802 17.2442 47.6802 14.9841C47.6802 12.724 49.4686 10.798 51.7483 10.798C54.0084 10.798 55.7968 12.724 55.7968 14.9841C55.7968 17.2442 54.0084 19.1702 51.7483 19.1702ZM37.0698 21.9609H40.2142V10.9946H44.2843V8.00732H33V10.9946H37.0698V21.9609ZM69.9379 8.00732H73.0823V21.9609H70.3899L63.59 13.3333V21.9609H60.4652V8.00732H63.1576L69.9379 16.6153V8.00732ZM79.2259 14.9887C79.2259 10.9202 82.351 7.77539 86.4982 7.77539C89.8592 7.77539 92.5519 9.95709 93.2202 12.6891H90.7437C90.154 11.0971 88.4637 9.9964 86.4982 9.9964C83.5893 9.9964 81.5452 12.1781 81.5452 14.9887C81.5452 17.7994 83.5893 19.9811 86.4982 19.9811C88.4637 19.9811 90.154 18.8804 90.7437 17.2884H93.2202C92.5519 20.0204 89.8592 22.2021 86.4982 22.2021C82.351 22.2021 79.2259 19.0573 79.2259 14.9887ZM104.584 17.0525C104.584 19.9025 102.343 22.1628 99.4342 22.1628C96.5253 22.1628 94.2846 19.9025 94.2846 17.0525C94.2846 14.2025 96.5253 11.9422 99.4342 11.9422C102.343 11.9422 104.584 14.2025 104.584 17.0525ZM96.4663 17.0525C96.4663 18.8018 97.6849 20.158 99.4342 20.158C101.164 20.158 102.382 18.8018 102.382 17.0525C102.382 15.3032 101.164 13.947 99.4342 13.947C97.6849 13.947 96.4663 15.3032 96.4663 17.0525ZM108.626 12.1388H106.463V21.9662H108.626V17.1311C108.626 15.0281 109.726 13.9077 111.161 13.9077C112.419 13.9077 113.205 14.8512 113.205 16.4039V21.9662H115.367V16.0501C115.367 13.5539 113.893 11.9422 111.613 11.9422C110.335 11.9422 109.215 12.4926 108.626 13.4753V12.1388ZM117.839 12.1388H120.001V13.4753C120.59 12.4926 121.711 11.9422 122.988 11.9422C125.268 11.9422 126.742 13.5539 126.742 16.0501V21.9662H124.58V16.4039C124.58 14.8512 123.794 13.9077 122.536 13.9077C121.101 13.9077 120.001 15.0281 120.001 17.1311V21.9662H117.839V12.1388ZM133.558 22.1628C136.054 22.1628 137.823 20.728 138.373 18.8804H136.113C135.661 19.8238 134.717 20.2563 133.636 20.2563C131.887 20.2563 130.747 19.077 130.668 17.5832H138.491C138.688 14.2419 136.585 11.9422 133.577 11.9422C130.551 11.9422 128.526 14.1436 128.526 17.0525C128.526 20.0007 130.629 22.1628 133.558 22.1628ZM130.747 16.0501C131.042 14.5367 132.162 13.7505 133.518 13.7505C134.717 13.7505 135.838 14.4581 136.172 16.0501H130.747ZM149.851 18.3694C149.32 20.5511 147.453 22.1628 144.859 22.1628C141.871 22.1628 139.709 19.8828 139.709 17.0525C139.709 14.2222 141.871 11.9422 144.859 11.9422C147.453 11.9422 149.32 13.5539 149.851 15.7356H147.571C147.178 14.6743 146.215 13.9077 144.859 13.9077C143.109 13.9077 141.91 15.2246 141.91 17.0525C141.91 18.8804 143.109 20.1973 144.859 20.1973C146.215 20.1973 147.178 19.4307 147.571 18.3694H149.851ZM155.75 22.0645C156.418 22.0645 156.929 21.9859 157.362 21.8483V19.9221C157.047 20.0401 156.615 20.1187 156.202 20.1187C155.082 20.1187 154.551 19.6666 154.551 18.448V14.065H157.362V12.1388H154.551V9.40675H152.389V12.1388H150.345V14.065H152.389V18.8018C152.389 21.0228 153.863 22.0645 155.75 22.0645Z"></path></svg>')
  , TonConnectBrand = ()=>{
    const r = useTheme()
      , d = ()=>r.theme === THEME.DARK ? r.colors.constant.white : r.colors.constant.black;
    return (()=>{
        const f = _tmpl$$m.cloneNode(!0)
          , m = f.firstChild
          , k = m.nextSibling
          , y = k.nextSibling;
        return createRenderEffect(()=>setAttribute(y, "fill", d())),
        f
    }
    )()
}
  , _tmpl$$l = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M5.56608 4.42584C5.82527 3.32158 6.8176 2.5 8.00001 2.5C9.38072 2.5 10.5 3.61929 10.5 5C10.5 5.63026 10.3391 6.0386 10.1264 6.34455C9.90018 6.66993 9.58561 6.92478 9.18864 7.20877C9.12579 7.25372 9.05873 7.30025 8.9887 7.34883C8.27392 7.84472 7.25001 8.55507 7.25001 10V10.25C7.25001 10.6642 7.5858 11 8.00001 11C8.41422 11 8.75001 10.6642 8.75001 10.25V10C8.75001 9.36502 9.10777 9.1096 9.94554 8.51149L10.0614 8.42873C10.4769 8.13147 10.9748 7.75194 11.358 7.20076C11.7547 6.63015 12 5.91973 12 5C12 2.79086 10.2091 1 8.00001 1C6.10564 1 4.5205 2.31615 4.10577 4.08308C4.01112 4.48634 4.26129 4.88997 4.66454 4.98462C5.0678 5.07927 5.47143 4.8291 5.56608 4.42584ZM8.00001 15C8.60752 15 9.10001 14.5075 9.10001 13.9C9.10001 13.2925 8.60752 12.8 8.00001 12.8C7.39249 12.8 6.90001 13.2925 6.90001 13.9C6.90001 14.5075 7.39249 15 8.00001 15Z"></path></svg>')
  , QuestionIcon = r=>{
    const d = useTheme()
      , f = ()=>r.fill || d.colors.icon.secondary;
    return (()=>{
        const m = _tmpl$$l.cloneNode(!0)
          , k = m.firstChild;
        return createRenderEffect(()=>setAttribute(k, "fill", f())),
        m
    }
    )()
}
  , _tmpl$$k = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M9.98156 8.75C9.84854 11.4328 9.01206 13.5 8 13.5C6.98794 13.5 6.15146 11.4328 6.01844 8.75H9.98156ZM11.4832 8.75C11.4217 10.1155 11.1929 11.3869 10.8239 12.4017C10.7734 12.5405 10.7188 12.6789 10.6595 12.8154C12.1454 11.993 13.2103 10.5029 13.4493 8.75H11.4832ZM13.4493 7.25H11.4832C11.4217 5.88453 11.1929 4.61314 10.8239 3.5983C10.7734 3.4595 10.7188 3.32111 10.6595 3.18459C12.1454 4.00697 13.2103 5.49709 13.4493 7.25ZM9.98156 7.25H6.01844C6.15144 4.56764 6.98769 2.50062 7.99955 2.5H8C9.01206 2.5 9.84854 4.56724 9.98156 7.25ZM4.51678 7.25C4.57826 5.88453 4.80706 4.61314 5.1761 3.5983C5.22657 3.4595 5.28124 3.32111 5.3405 3.18459C3.85463 4.00697 2.78972 5.49709 2.55071 7.25H4.51678ZM2.55071 8.75C2.78972 10.5029 3.85463 11.993 5.3405 12.8154C5.28124 12.6789 5.22657 12.5405 5.1761 12.4017C4.80706 11.3869 4.57826 10.1155 4.51678 8.75H2.55071ZM15 8C15 11.866 11.866 15 8 15C4.13401 15 1 11.866 1 8C1 4.13401 4.13401 1 8 1C11.866 1 15 4.13401 15 8Z"></path></svg>')
  , BrowserIcon = r=>{
    const d = useTheme()
      , f = ()=>r.fill || d.colors.icon.primary;
    return (()=>{
        const m = _tmpl$$k.cloneNode(!0)
          , k = m.firstChild;
        return createRenderEffect(()=>setAttribute(k, "fill", f())),
        m
    }
    )()
}
  , _tmpl$$j = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M2.5 4.8C2.5 3.11984 2.5 2.27976 2.82698 1.63803C3.1146 1.07354 3.57354 0.614601 4.13803 0.32698C4.77976 0 5.61984 0 7.3 0H8.7C10.3802 0 11.2202 0 11.862 0.32698C12.4265 0.614601 12.8854 1.07354 13.173 1.63803C13.5 2.27976 13.5 3.11984 13.5 4.8V11.2C13.5 12.8802 13.5 13.7202 13.173 14.362C12.8854 14.9265 12.4265 15.3854 11.862 15.673C11.2202 16 10.3802 16 8.7 16H7.3C5.61984 16 4.77976 16 4.13803 15.673C3.57354 15.3854 3.1146 14.9265 2.82698 14.362C2.5 13.7202 2.5 12.8802 2.5 11.2V4.8ZM4 3.9C4 3.05992 4 2.63988 4.16349 2.31901C4.3073 2.03677 4.53677 1.8073 4.81901 1.66349C5.13988 1.5 5.55992 1.5 6.4 1.5H9.6C10.4401 1.5 10.8601 1.5 11.181 1.66349C11.4632 1.8073 11.6927 2.03677 11.8365 2.31901C12 2.63988 12 3.05992 12 3.9V12.1C12 12.9401 12 13.3601 11.8365 13.681C11.6927 13.9632 11.4632 14.1927 11.181 14.3365C10.8601 14.5 10.4401 14.5 9.6 14.5H6.4C5.55992 14.5 5.13988 14.5 4.81901 14.3365C4.53677 14.1927 4.3073 13.9632 4.16349 13.681C4 13.3601 4 12.9401 4 12.1V3.9ZM7 2.5C6.58579 2.5 6.25 2.83579 6.25 3.25C6.25 3.66421 6.58579 4 7 4H9C9.41421 4 9.75 3.66421 9.75 3.25C9.75 2.83579 9.41421 2.5 9 2.5H7Z"></path></svg>')
  , MobileIcon = r=>{
    const d = useTheme()
      , f = ()=>r.fill || d.colors.icon.primary;
    return (()=>{
        const m = _tmpl$$j.cloneNode(!0)
          , k = m.firstChild;
        return createRenderEffect(()=>setAttribute(k, "fill", f())),
        m
    }
    )()
}
  , _tmpl$$i = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 6.8C1.5 5.11984 1.5 4.27976 1.82698 3.63803C2.1146 3.07354 2.57354 2.6146 3.13803 2.32698C3.77976 2 4.61984 2 6.3 2H9.7C11.3802 2 12.2202 2 12.862 2.32698C13.4265 2.6146 13.8854 3.07354 14.173 3.63803C14.5 4.27976 14.5 5.11984 14.5 6.8V11.5H15.25C15.6642 11.5 16 11.8358 16 12.25C16 12.6642 15.6642 13 15.25 13H0.75C0.335786 13 0 12.6642 0 12.25C0 11.8358 0.335786 11.5 0.75 11.5H1.5V6.8ZM3 11.5H13V5.9C13 5.05992 13 4.63988 12.8365 4.31901C12.6927 4.03677 12.4632 3.8073 12.181 3.66349C11.8601 3.5 11.4401 3.5 10.6 3.5H5.4C4.55992 3.5 4.13988 3.5 3.81901 3.66349C3.53677 3.8073 3.3073 4.03677 3.16349 4.31901C3 4.63988 3 5.05992 3 5.9V11.5Z"></path></svg>')
  , DesktopIcon = r=>{
    const d = useTheme()
      , f = ()=>r.fill || d.colors.icon.primary;
    return (()=>{
        const m = _tmpl$$i.cloneNode(!0)
          , k = m.firstChild;
        return createRenderEffect(()=>setAttribute(k, "fill", f())),
        m
    }
    )()
}
  , _tmpl$$h = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="17" height="16" viewBox="0 0 17 16" fill="none"><g clip-path="url(#clip0_3676_1603)"><path fill-rule="evenodd" clip-rule="evenodd" d="M15.5 1.25049C15.5 0.836275 15.1642 0.500488 14.75 0.500488C14.3358 0.500488 14 0.836275 14 1.25049V3.67012C12.7187 2.04487 10.7318 1.00049 8.5 1.00049C4.63401 1.00049 1.5 4.1345 1.5 8.00049C1.5 11.8665 4.63401 15.0005 8.5 15.0005C11.6844 15.0005 14.3703 12.8748 15.2199 9.96661C15.3361 9.56902 15.1079 9.15254 14.7103 9.03638C14.3127 8.92023 13.8962 9.14838 13.7801 9.54597C13.1123 11.8319 11 13.5005 8.5 13.5005C5.46243 13.5005 3 11.0381 3 8.00049C3 4.96292 5.46243 2.50049 8.5 2.50049C10.321 2.50049 11.9363 3.3855 12.9377 4.75049H10.5C10.0858 4.75049 9.75 5.08627 9.75 5.50049C9.75 5.9147 10.0858 6.25049 10.5 6.25049H14.75C15.1642 6.25049 15.5 5.9147 15.5 5.50049V1.25049Z"></path></g><defs><clipPath id="clip0_3676_1603"><rect width="16" height="16" fill="white" transform="translate(0.5 0.000488281)"></rect></clipPath></defs></svg>')
  , RetryIcon = r=>{
    const d = useTheme()
      , f = ()=>r.fill || d.colors.accent;
    return (()=>{
        const m = _tmpl$$h.cloneNode(!0)
          , k = m.firstChild
          , y = k.firstChild;
        return createRenderEffect(()=>setAttribute(y, "fill", f())),
        m
    }
    )()
}
  , _tmpl$$g = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M13 4.06119V6.75053C13 7.16474 13.3358 7.50053 13.75 7.50053C14.1642 7.50053 14.5 7.16474 14.5 6.75053V2.75053L14.5 2.72807C14.5001 2.63191 14.5003 2.49627 14.4842 2.37627C14.4638 2.22503 14.4063 1.99261 14.2071 1.79342C14.0079 1.59423 13.7755 1.5367 13.6243 1.51637C13.5043 1.50023 13.3686 1.50039 13.2725 1.50051L13.25 1.50053H9.25C8.83579 1.50053 8.5 1.83631 8.5 2.25053C8.5 2.66474 8.83579 3.00053 9.25 3.00053H11.9393L7.21967 7.7202C6.92678 8.01309 6.92678 8.48796 7.21967 8.78086C7.51256 9.07375 7.98744 9.07375 8.28033 8.78086L13 4.06119ZM5.85 1.50053H5.81903H5.81899C5.21528 1.50052 4.71702 1.50051 4.31113 1.53367C3.88956 1.56812 3.50203 1.64204 3.13803 1.82751C2.57354 2.11513 2.1146 2.57407 1.82698 3.13856C1.64151 3.50256 1.56759 3.89009 1.53315 4.31166C1.49998 4.71755 1.49999 5.21581 1.5 5.81953V5.81955V5.85053V10.1505V10.1815V10.1815C1.49999 10.7852 1.49998 11.2835 1.53315 11.6894C1.56759 12.111 1.64151 12.4985 1.82698 12.8625C2.1146 13.427 2.57354 13.8859 3.13803 14.1735C3.50203 14.359 3.88956 14.4329 4.31113 14.4674C4.71702 14.5005 5.21527 14.5005 5.81897 14.5005H5.81901H5.85H10.15H10.181H10.181C10.7847 14.5005 11.283 14.5005 11.6889 14.4674C12.1104 14.4329 12.498 14.359 12.862 14.1735C13.4265 13.8859 13.8854 13.427 14.173 12.8625C14.3585 12.4985 14.4324 12.111 14.4669 11.6894C14.5 11.2835 14.5 10.7853 14.5 10.1816V10.1815V10.1505V9.75053C14.5 9.33631 14.1642 9.00053 13.75 9.00053C13.3358 9.00053 13 9.33631 13 9.75053V10.1505C13 10.793 12.9994 11.2297 12.9718 11.5672C12.945 11.8961 12.8963 12.0642 12.8365 12.1815C12.6927 12.4638 12.4632 12.6932 12.181 12.837C12.0637 12.8968 11.8955 12.9455 11.5667 12.9724C11.2292 12.9999 10.7924 13.0005 10.15 13.0005H5.85C5.20757 13.0005 4.77085 12.9999 4.43328 12.9724C4.10447 12.9455 3.93632 12.8968 3.81902 12.837C3.53677 12.6932 3.3073 12.4638 3.16349 12.1815C3.10372 12.0642 3.05503 11.8961 3.02816 11.5672C3.00058 11.2297 3 10.793 3 10.1505V5.85053C3 5.20809 3.00058 4.77137 3.02816 4.43381C3.05503 4.10499 3.10372 3.93684 3.16349 3.81954C3.3073 3.5373 3.53677 3.30783 3.81902 3.16402C3.93632 3.10425 4.10447 3.05556 4.43328 3.02869C4.77085 3.00111 5.20757 3.00053 5.85 3.00053H6.25C6.66422 3.00053 7 2.66474 7 2.25053C7 1.83631 6.66422 1.50053 6.25 1.50053H5.85Z"></path></svg>')
  , LinkIcon = r=>{
    const d = useTheme()
      , f = ()=>r.fill || d.colors.accent;
    return (()=>{
        const m = _tmpl$$g.cloneNode(!0)
          , k = m.firstChild;
        return createRenderEffect(()=>setAttribute(k, "fill", f())),
        m
    }
    )()
}
  , _tmpl$$f = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="17" height="16" viewBox="0 0 17 16" fill="none"><g clip-path="url(#clip0_3676_1274)"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.82698 2.63901C1.5 3.28074 1.5 4.12082 1.5 5.80098V8.80098V9.00098V10.201C1.5 11.8811 1.5 12.7212 1.82698 13.3629C2.1146 13.9274 2.57354 14.3864 3.13803 14.674C3.77976 15.001 4.61984 15.001 6.3 15.001H11.7C13.3802 15.001 14.2202 15.001 14.862 14.674C15.4265 14.3864 15.8854 13.9274 16.173 13.3629C16.5 12.7212 16.5 11.8811 16.5 10.201V8.80098C16.5 7.12082 16.5 6.28074 16.173 5.63901C15.8854 5.07452 15.4265 4.61558 14.862 4.32796C14.743 4.26733 14.6172 4.21795 14.4805 4.17772C14.4501 3.49449 14.3722 3.02994 14.173 2.63901C13.8854 2.07452 13.4265 1.61558 12.862 1.32796C12.2202 1.00098 11.3802 1.00098 9.7 1.00098H6.3C4.61984 1.00098 3.77976 1.00098 3.13803 1.32796C2.57354 1.61558 2.1146 2.07452 1.82698 2.63901ZM12.9861 4.00942C12.9684 3.7108 12.9281 3.49982 12.8365 3.31999C12.6927 3.03775 12.4632 2.80828 12.181 2.66447C11.8601 2.50098 11.4401 2.50098 10.6 2.50098H5.4C4.55992 2.50098 4.13988 2.50098 3.81901 2.66447C3.53677 2.80828 3.3073 3.03775 3.16349 3.31999C3.03615 3.56991 3.00799 3.88 3.00177 4.40188C3.04646 4.37612 3.09189 4.35146 3.13803 4.32796C3.77976 4.00098 4.61984 4.00098 6.3 4.00098H11.7C12.1966 4.00098 12.6197 4.00098 12.9861 4.00942ZM3 7.90098V8.10098C3 8.47468 3 8.76527 3.01439 9.00098H3V11.101C3 11.9411 3 12.3611 3.16349 12.682C3.3073 12.9642 3.53677 13.1937 3.81901 13.3375C4.13988 13.501 4.55992 13.501 5.4 13.501H12.6C13.4401 13.501 13.8601 13.501 14.181 13.3375C14.4632 13.1937 14.6927 12.9642 14.8365 12.682C15 12.3611 15 11.9411 15 11.101V7.90098C15 7.0609 15 6.64086 14.8365 6.31999C14.6927 6.03775 14.4632 5.80828 14.181 5.66447C13.8601 5.50098 13.4401 5.50098 12.6 5.50098H5.4C4.55992 5.50098 4.13988 5.50098 3.81901 5.66447C3.53677 5.80828 3.3073 6.03775 3.16349 6.31999C3 6.64086 3 7.0609 3 7.90098ZM10.5 9.75098C10.5 9.33676 10.8358 9.00098 11.25 9.00098H12.75C13.1642 9.00098 13.5 9.33676 13.5 9.75098C13.5 10.1652 13.1642 10.501 12.75 10.501H11.25C10.8358 10.501 10.5 10.1652 10.5 9.75098Z"></path></g><defs><clipPath id="clip0_3676_1274"><rect width="16" height="16" fill="white" transform="translate(0.5 0.000976562)"></rect></clipPath></defs></svg>')
  , WalletIcon = r=>{
    const d = useTheme()
      , f = ()=>r.fill || d.colors.accent;
    return (()=>{
        const m = _tmpl$$f.cloneNode(!0)
          , k = m.firstChild
          , y = k.firstChild;
        return createRenderEffect(()=>setAttribute(y, "fill", f())),
        m
    }
    )()
}
  , _tmpl$$e = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M39.6319 16.8719C38.3212 16.2041 36.7002 16.0478 34 16.0112V11C34 5.47715 29.5228 1 24 1C18.4772 1 14 5.47715 14 11V16.0112C11.2998 16.0478 9.6788 16.2041 8.36808 16.8719C6.86278 17.6389 5.63893 18.8628 4.87195 20.3681C4 22.0794 4 24.3196 4 28.8V32.2C4 36.6804 4 38.9206 4.87195 40.6319C5.63893 42.1372 6.86278 43.3611 8.36808 44.1281C10.0794 45 12.3196 45 16.8 45H31.2C35.6804 45 37.9206 45 39.6319 44.1281C41.1372 43.3611 42.3611 42.1372 43.1281 40.6319C44 38.9206 44 36.6804 44 32.2V28.8C44 24.3196 44 22.0794 43.1281 20.3681C42.3611 18.8628 41.1372 17.6389 39.6319 16.8719ZM31 11V16H17V11C17 7.13401 20.134 4 24 4C27.866 4 31 7.13401 31 11ZM7.54497 21.73C7 22.7996 7 24.1997 7 27V34C7 36.8003 7 38.2004 7.54497 39.27C8.02433 40.2108 8.78924 40.9757 9.73005 41.455C10.7996 42 12.1997 42 15 42H33C35.8003 42 37.2004 42 38.27 41.455C39.2108 40.9757 39.9757 40.2108 40.455 39.27C41 38.2004 41 36.8003 41 34V27C41 24.1997 41 22.7996 40.455 21.73C39.9757 20.7892 39.2108 20.0243 38.27 19.545C37.2004 19 35.8003 19 33 19H15C12.1997 19 10.7996 19 9.73005 19.545C8.78924 20.0243 8.02433 20.7892 7.54497 21.73ZM24 24C23.1716 24 22.5 24.6716 22.5 25.5V29.5C22.5 30.3284 23.1716 31 24 31C24.8284 31 25.5 30.3284 25.5 29.5V25.5C25.5 24.6716 24.8284 24 24 24Z"></path></svg>')
  , SecurityIcon = r=>{
    const d = useTheme()
      , f = ()=>r.fill || d.colors.icon.secondary;
    return (()=>{
        const m = _tmpl$$e.cloneNode(!0)
          , k = m.firstChild;
        return createRenderEffect(y=>{
            const ee = r.class
              , dt = f();
            return ee !== y._v$ && setAttribute(m, "class", y._v$ = ee),
            dt !== y._v$2 && setAttribute(k, "fill", y._v$2 = dt),
            y
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        m
    }
    )()
}
  , _tmpl$$d = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M37.485 37.3849C40.894 33.9506 43 29.2212 43 24C43 13.5066 34.4934 5 24 5C13.5066 5 5 13.5066 5 24C5 29.2213 7.1061 33.9507 10.5151 37.385C13.3583 32.9438 18.3354 30 24.0001 30C29.6647 30 34.6418 32.9437 37.485 37.3849ZM35.1809 39.3635C32.9143 35.5532 28.7554 33 24.0001 33C19.2448 33 15.0858 35.5533 12.8193 39.3636C15.9564 41.6506 19.8206 43 24 43C28.1795 43 32.0437 41.6505 35.1809 39.3635ZM24 46C36.1503 46 46 36.1503 46 24C46 11.8497 36.1503 2 24 2C11.8497 2 2 11.8497 2 24C2 36.1503 11.8497 46 24 46ZM24 24C26.7614 24 29 21.7614 29 19C29 16.2386 26.7614 14 24 14C21.2386 14 19 16.2386 19 19C19 21.7614 21.2386 24 24 24ZM24 27C28.4183 27 32 23.4183 32 19C32 14.5817 28.4183 11 24 11C19.5817 11 16 14.5817 16 19C16 23.4183 19.5817 27 24 27Z"></path></svg>')
  , PersonalityIcon = r=>{
    const d = useTheme()
      , f = ()=>r.fill || d.colors.icon.secondary;
    return (()=>{
        const m = _tmpl$$d.cloneNode(!0)
          , k = m.firstChild;
        return createRenderEffect(y=>{
            const ee = r.class
              , dt = f();
            return ee !== y._v$ && setAttribute(m, "class", y._v$ = ee),
            dt !== y._v$2 && setAttribute(k, "fill", y._v$2 = dt),
            y
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        m
    }
    )()
}
  , _tmpl$$c = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M34.5607 4.43934C33.9749 3.85355 33.0251 3.85355 32.4393 4.43934C31.8536 5.02513 31.8536 5.97487 32.4393 6.56066L37.8787 12H10.5C9.67157 12 9 12.6716 9 13.5C9 14.3284 9.67157 15 10.5 15H37.8787L32.4393 20.4393C31.8536 21.0251 31.8536 21.9749 32.4393 22.5607C33.0251 23.1464 33.9749 23.1464 34.5607 22.5607L42.5607 14.5607C43.1464 13.9749 43.1464 13.0251 42.5607 12.4393L34.5607 4.43934ZM13.4393 25.4393C14.0251 24.8536 14.9749 24.8536 15.5607 25.4393C16.1464 26.0251 16.1464 26.9749 15.5607 27.5607L10.1213 33H37.5C38.3284 33 39 33.6716 39 34.5C39 35.3284 38.3284 36 37.5 36H10.1213L15.5607 41.4393C16.1464 42.0251 16.1464 42.9749 15.5607 43.5607C14.9749 44.1464 14.0251 44.1464 13.4393 43.5607L5.43934 35.5607C4.85355 34.9749 4.85355 34.0251 5.43934 33.4393L13.4393 25.4393Z"></path></svg>')
  , SwapIcon = r=>{
    const d = useTheme()
      , f = ()=>r.fill || d.colors.icon.secondary;
    return (()=>{
        const m = _tmpl$$c.cloneNode(!0)
          , k = m.firstChild;
        return createRenderEffect(y=>{
            const ee = r.class
              , dt = f();
            return ee !== y._v$ && setAttribute(m, "class", y._v$ = ee),
            dt !== y._v$2 && setAttribute(k, "fill", y._v$2 = dt),
            y
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        m
    }
    )()
}
  , _tmpl$$b = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="28" height="29" viewBox="0 0 28 29" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.75 12.002C1.75 9.20169 1.75 7.80156 2.29497 6.732C2.77433 5.79119 3.53924 5.02629 4.48005 4.54692C5.54961 4.00195 6.94974 4.00195 9.75 4.00195H17.25C20.0503 4.00195 21.4504 4.00195 22.52 4.54692C23.4608 5.02629 24.2257 5.79119 24.705 6.732C24.8256 6.96861 24.9195 7.2214 24.9926 7.50195H21.5C19.6377 7.50195 18.7065 7.50195 17.9609 7.77334C16.711 8.22828 15.7263 9.21291 15.2714 10.4629C15 11.2085 15 12.1396 15 14.002C15 15.8643 15 16.7954 15.2714 17.541C15.7263 18.791 16.711 19.7756 17.9609 20.2306C18.7065 20.502 19.6377 20.502 21.5 20.502H24.9926C24.9195 20.7825 24.8256 21.0353 24.705 21.2719C24.2257 22.2127 23.4608 22.9776 22.52 23.457C21.4504 24.002 20.0503 24.002 17.25 24.002H9.75C6.94974 24.002 5.54961 24.002 4.48005 23.457C3.53924 22.9776 2.77433 22.2127 2.29497 21.2719C1.75 20.2023 1.75 18.8022 1.75 16.002V12.002ZM16.4999 13.802C16.4999 12.1218 16.4999 11.2817 16.8269 10.64C17.1145 10.0755 17.5735 9.61656 18.138 9.32894C18.7797 9.00196 19.6198 9.00196 21.2999 9.00196H23.1999C24.8801 9.00196 25.7202 9.00196 26.3619 9.32894C26.9264 9.61656 27.3853 10.0755 27.673 10.64C27.9999 11.2817 27.9999 12.1218 27.9999 13.802V14.202C27.9999 15.8821 27.9999 16.7222 27.673 17.3639C27.3853 17.9284 26.9264 18.3874 26.3619 18.675C25.7202 19.002 24.8801 19.002 23.1999 19.002H21.2999C19.6198 19.002 18.7797 19.002 18.138 18.675C17.5735 18.3874 17.1145 17.9284 16.8269 17.3639C16.4999 16.7222 16.4999 15.8821 16.4999 14.202V13.802ZM22.4999 14.002C22.4999 14.9685 21.7164 15.752 20.7499 15.752C19.7834 15.752 18.9999 14.9685 18.9999 14.002C18.9999 13.0355 19.7834 12.252 20.7499 12.252C21.7164 12.252 22.4999 13.0355 22.4999 14.002Z"></path></svg>')
  , AtWalletIcon = r=>{
    const d = useTheme()
      , f = ()=>r.fill || d.colors.constant.white;
    return (()=>{
        const m = _tmpl$$b.cloneNode(!0)
          , k = m.firstChild;
        return createRenderEffect(y=>{
            const ee = r.class
              , dt = f();
            return ee !== y._v$ && setAttribute(m, "class", y._v$ = ee),
            dt !== y._v$2 && setAttribute(k, "fill", y._v$2 = dt),
            y
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        m
    }
    )()
}
  , _tmpl$$a = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M24.7803 7.21967C25.0732 7.51256 25.0732 7.98744 24.7803 8.28033L11.5303 21.5303C11.2374 21.8232 10.7626 21.8232 10.4697 21.5303L4.21967 15.2803C3.92678 14.9874 3.92678 14.5126 4.21967 14.2197C4.51256 13.9268 4.98744 13.9268 5.28033 14.2197L11 19.9393L23.7197 7.21967C24.0126 6.92678 24.4874 6.92678 24.7803 7.21967Z"></path></svg>')
  , DoneIcon = r=>{
    const d = useTheme()
      , f = ()=>r.fill || d.colors.icon.secondary;
    return (()=>{
        const m = _tmpl$$a.cloneNode(!0)
          , k = m.firstChild;
        return createRenderEffect(y=>{
            const ee = r.class
              , dt = f();
            return ee !== y._v$ && setAttribute(m, "class", y._v$ = ee),
            dt !== y._v$2 && setAttribute(k, "fill", y._v$2 = dt),
            y
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        m
    }
    )()
}
  , _tmpl$$9 = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.0001 10.0001C10.0016 8.02333 10.0267 6.98719 10.436 6.18404C10.8195 5.43139 11.4314 4.81947 12.184 4.43597C13.0397 4 14.1598 4 16.4 4H17.6C19.8402 4 20.9603 4 21.816 4.43597C22.5686 4.81947 23.1805 5.43139 23.564 6.18404C24 7.03969 24 8.15979 24 10.4V11.6C24 13.8402 24 14.9603 23.564 15.816C23.1805 16.5686 22.5686 17.1805 21.816 17.564C21.0128 17.9733 19.9767 17.9984 17.9999 17.9999C17.9984 19.9767 17.9733 21.0128 17.564 21.816C17.1805 22.5686 16.5686 23.1805 15.816 23.564C14.9603 24 13.8402 24 11.6 24H10.4C8.15979 24 7.03969 24 6.18404 23.564C5.43139 23.1805 4.81947 22.5686 4.43597 21.816C4 20.9603 4 19.8402 4 17.6V16.4C4 14.1598 4 13.0397 4.43597 12.184C4.81947 11.4314 5.43139 10.8195 6.18404 10.436C6.98719 10.0267 8.02333 10.0016 10.0001 10.0001ZM10 11.5H9.5C8.09987 11.5 7.3998 11.5 6.86502 11.7725C6.39462 12.0122 6.01217 12.3946 5.77248 12.865C5.5 13.3998 5.5 14.0999 5.5 15.5V18.5C5.5 19.9001 5.5 20.6002 5.77248 21.135C6.01217 21.6054 6.39462 21.9878 6.86502 22.2275C7.3998 22.5 8.09987 22.5 9.5 22.5H12.5C13.9001 22.5 14.6002 22.5 15.135 22.2275C15.6054 21.9878 15.9878 21.6054 16.2275 21.135C16.5 20.6002 16.5 19.9001 16.5 18.5V18H16.4C14.1598 18 13.0397 18 12.184 17.564C11.4314 17.1805 10.8195 16.5686 10.436 15.816C10 14.9603 10 13.8402 10 11.6V11.5ZM11.5 9.5C11.5 8.09987 11.5 7.3998 11.7725 6.86502C12.0122 6.39462 12.3946 6.01217 12.865 5.77248C13.3998 5.5 14.0999 5.5 15.5 5.5H18.5C19.9001 5.5 20.6002 5.5 21.135 5.77248C21.6054 6.01217 21.9878 6.39462 22.2275 6.86502C22.5 7.3998 22.5 8.09987 22.5 9.5V12.5C22.5 13.9001 22.5 14.6002 22.2275 15.135C21.9878 15.6054 21.6054 15.9878 21.135 16.2275C20.6002 16.5 19.9001 16.5 18.5 16.5H15.5C14.0999 16.5 13.3998 16.5 12.865 16.2275C12.3946 15.9878 12.0122 15.6054 11.7725 15.135C11.5 14.6002 11.5 13.9001 11.5 12.5V9.5Z"></path></svg>')
  , CopyLightIcon = r=>{
    const d = useTheme()
      , f = ()=>r.fill || d.colors.icon.secondary;
    return (()=>{
        const m = _tmpl$$9.cloneNode(!0)
          , k = m.firstChild;
        return createRenderEffect(y=>{
            const ee = f()
              , dt = f();
            return ee !== y._v$ && setAttribute(m, "fill", y._v$ = ee),
            dt !== y._v$2 && setAttribute(k, "fill", y._v$2 = dt),
            y
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        m
    }
    )()
}
  , _tmpl$$8 = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="17" viewBox="0 0 16 17" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 4.12695C1 3.07754 1 2.55284 1.19202 2.14684C1.38986 1.72856 1.7266 1.39181 2.14489 1.19397C2.55088 1.00195 3.07559 1.00195 4.125 1.00195C5.17441 1.00195 5.69912 1.00195 6.10511 1.19397C6.5234 1.39181 6.86014 1.72856 7.05798 2.14684C7.25 2.55284 7.25 3.07754 7.25 4.12695C7.25 5.17636 7.25 5.70107 7.05798 6.10706C6.86014 6.52535 6.5234 6.8621 6.10511 7.05993C5.69912 7.25195 5.17441 7.25195 4.125 7.25195C3.07559 7.25195 2.55088 7.25195 2.14489 7.05993C1.7266 6.8621 1.38986 6.52535 1.19202 6.10706C1 5.70107 1 5.17636 1 4.12695ZM2.5 3.30195C2.5 3.02193 2.5 2.88191 2.5545 2.77496C2.60243 2.68088 2.67892 2.60439 2.773 2.55645C2.87996 2.50195 3.01997 2.50195 3.3 2.50195H4.95C5.23003 2.50195 5.37004 2.50195 5.477 2.55645C5.57108 2.60439 5.64757 2.68088 5.6955 2.77496C5.75 2.88191 5.75 3.02193 5.75 3.30195V4.95195C5.75 5.23198 5.75 5.37199 5.6955 5.47895C5.64757 5.57303 5.57108 5.64952 5.477 5.69746C5.37004 5.75195 5.23003 5.75195 4.95 5.75195H3.3C3.01997 5.75195 2.87996 5.75195 2.773 5.69746C2.67892 5.64952 2.60243 5.57303 2.5545 5.47895C2.5 5.37199 2.5 5.23198 2.5 4.95195V3.30195ZM1 11.877C1 10.8275 1 10.3028 1.19202 9.89684C1.38986 9.47856 1.7266 9.14181 2.14489 8.94397C2.55088 8.75195 3.07559 8.75195 4.125 8.75195C5.17441 8.75195 5.69912 8.75195 6.10511 8.94397C6.5234 9.14181 6.86014 9.47856 7.05798 9.89684C7.25 10.3028 7.25 10.8275 7.25 11.877C7.25 12.9264 7.25 13.4511 7.05798 13.8571C6.86014 14.2753 6.5234 14.6121 6.10511 14.8099C5.69912 15.002 5.17441 15.002 4.125 15.002C3.07559 15.002 2.55088 15.002 2.14489 14.8099C1.7266 14.6121 1.38986 14.2753 1.19202 13.8571C1 13.4511 1 12.9264 1 11.877ZM2.5 11.052C2.5 10.7719 2.5 10.6319 2.5545 10.525C2.60243 10.4309 2.67892 10.3544 2.773 10.3064C2.87996 10.252 3.01997 10.252 3.3 10.252H4.95C5.23003 10.252 5.37004 10.252 5.477 10.3064C5.57108 10.3544 5.64757 10.4309 5.6955 10.525C5.75 10.6319 5.75 10.7719 5.75 11.052V12.702C5.75 12.982 5.75 13.122 5.6955 13.2289C5.64757 13.323 5.57108 13.3995 5.477 13.4475C5.37004 13.502 5.23003 13.502 4.95 13.502H3.3C3.01997 13.502 2.87996 13.502 2.773 13.4475C2.67892 13.3995 2.60243 13.323 2.5545 13.2289C2.5 13.122 2.5 12.982 2.5 12.702V11.052ZM8.94202 2.14684C8.75 2.55284 8.75 3.07754 8.75 4.12695C8.75 5.17636 8.75 5.70107 8.94202 6.10706C9.13986 6.52535 9.4766 6.8621 9.89489 7.05993C10.3009 7.25195 10.8256 7.25195 11.875 7.25195C12.9244 7.25195 13.4491 7.25195 13.8551 7.05993C14.2734 6.8621 14.6101 6.52535 14.808 6.10706C15 5.70107 15 5.17636 15 4.12695C15 3.07754 15 2.55284 14.808 2.14684C14.6101 1.72856 14.2734 1.39181 13.8551 1.19397C13.4491 1.00195 12.9244 1.00195 11.875 1.00195C10.8256 1.00195 10.3009 1.00195 9.89489 1.19397C9.4766 1.39181 9.13986 1.72856 8.94202 2.14684ZM10.3045 2.77496C10.25 2.88191 10.25 3.02193 10.25 3.30195V4.95195C10.25 5.23198 10.25 5.37199 10.3045 5.47895C10.3524 5.57303 10.4289 5.64952 10.523 5.69746C10.63 5.75195 10.77 5.75195 11.05 5.75195H12.7C12.98 5.75195 13.12 5.75195 13.227 5.69746C13.3211 5.64952 13.3976 5.57303 13.4455 5.47895C13.5 5.37199 13.5 5.23198 13.5 4.95195V3.30195C13.5 3.02193 13.5 2.88191 13.4455 2.77496C13.3976 2.68088 13.3211 2.60439 13.227 2.55645C13.12 2.50195 12.98 2.50195 12.7 2.50195H11.05C10.77 2.50195 10.63 2.50195 10.523 2.55645C10.4289 2.60439 10.3524 2.68088 10.3045 2.77496ZM8.80727 9.13518C8.75 9.26242 8.75 9.4256 8.75 9.75195C8.75 10.0783 8.75 10.2415 8.80727 10.3687C8.87245 10.5136 8.9884 10.6295 9.13323 10.6947C9.26047 10.752 9.42365 10.752 9.75 10.752C10.0764 10.752 10.2395 10.752 10.3668 10.6947C10.5116 10.6295 10.6276 10.5136 10.6927 10.3687C10.75 10.2415 10.75 10.0783 10.75 9.75195C10.75 9.4256 10.75 9.26242 10.6927 9.13518C10.6276 8.99035 10.5116 8.8744 10.3668 8.80922C10.2395 8.75195 10.0764 8.75195 9.75 8.75195C9.42365 8.75195 9.26047 8.75195 9.13323 8.80922C8.9884 8.8744 8.87245 8.99035 8.80727 9.13518ZM10.87 11.8771C10.87 11.546 10.87 11.3805 10.9289 11.2517C10.9938 11.1098 11.1077 10.9959 11.2497 10.931C11.3784 10.8721 11.5439 10.8721 11.875 10.8721C12.2061 10.8721 12.3716 10.8721 12.5003 10.931C12.6423 10.9959 12.7562 11.1098 12.8211 11.2517C12.88 11.3805 12.88 11.546 12.88 11.8771C12.88 12.2081 12.88 12.3737 12.8211 12.5024C12.7562 12.6444 12.6423 12.7583 12.5003 12.8232C12.3716 12.8821 12.2061 12.8821 11.875 12.8821C11.5439 12.8821 11.3784 12.8821 11.2497 12.8232C11.1077 12.7583 10.9938 12.6444 10.9289 12.5024C10.87 12.3737 10.87 12.2081 10.87 11.8771ZM8.80727 13.3852C8.75 13.5124 8.75 13.6756 8.75 14.002C8.75 14.3283 8.75 14.4915 8.80727 14.6187C8.87245 14.7636 8.9884 14.8795 9.13323 14.9447C9.26047 15.002 9.42365 15.002 9.75 15.002C10.0764 15.002 10.2395 15.002 10.3668 14.9447C10.5116 14.8795 10.6276 14.7636 10.6927 14.6187C10.75 14.4915 10.75 14.3283 10.75 14.002C10.75 13.6756 10.75 13.5124 10.6927 13.3852C10.6276 13.2404 10.5116 13.1244 10.3668 13.0592C10.2395 13.002 10.0764 13.002 9.75 13.002C9.42365 13.002 9.26047 13.002 9.13323 13.0592C8.9884 13.1244 8.87245 13.2404 8.80727 13.3852ZM13 9.75195C13 9.4256 13 9.26242 13.0573 9.13518C13.1224 8.99035 13.2384 8.8744 13.3832 8.80922C13.5105 8.75195 13.6736 8.75195 14 8.75195C14.3264 8.75195 14.4895 8.75195 14.6168 8.80922C14.7616 8.8744 14.8776 8.99035 14.9427 9.13518C15 9.26242 15 9.4256 15 9.75195C15 10.0783 15 10.2415 14.9427 10.3687C14.8776 10.5136 14.7616 10.6295 14.6168 10.6947C14.4895 10.752 14.3264 10.752 14 10.752C13.6736 10.752 13.5105 10.752 13.3832 10.6947C13.2384 10.6295 13.1224 10.5136 13.0573 10.3687C13 10.2415 13 10.0783 13 9.75195ZM13.0573 13.3852C13 13.5124 13 13.6756 13 14.002C13 14.3283 13 14.4915 13.0573 14.6187C13.1224 14.7636 13.2384 14.8795 13.3832 14.9447C13.5105 15.002 13.6736 15.002 14 15.002C14.3264 15.002 14.4895 15.002 14.6168 14.9447C14.7616 14.8795 14.8776 14.7636 14.9427 14.6187C15 14.4915 15 14.3283 15 14.002C15 13.6756 15 13.5124 14.9427 13.3852C14.8776 13.2404 14.7616 13.1244 14.6168 13.0592C14.4895 13.002 14.3264 13.002 14 13.002C13.6736 13.002 13.5105 13.002 13.3832 13.0592C13.2384 13.1244 13.1224 13.2404 13.0573 13.3852Z"></path></svg>')
  , QRIcon = r=>{
    const d = useTheme()
      , f = ()=>r.fill || d.colors.icon.secondary;
    return (()=>{
        const m = _tmpl$$8.cloneNode(!0)
          , k = m.firstChild;
        return createRenderEffect(()=>setAttribute(k, "fill", f())),
        m
    }
    )()
}
  , containerBorders = {
    m: "16px",
    s: "12px",
    none: "0"
}
  , walletBorders = {
    m: "6px",
    s: "6px",
    none: "0"
}
  , FourWalletsCard = styled.div`
    width: 60px;
    height: 60px;
    padding: 8px;
    margin-bottom: 8px;
    border-radius: ${r=>containerBorders[r.theme.borderRadius]};
    background-color: ${r=>r.theme.colors.background.tint};
    display: grid;
    grid-template: 1fr 1fr / 1fr 1fr;
    gap: 4px;
`
  , FourWalletsImage = styled(WalletImage)`
    width: 20px;
    height: 20px;
    border-radius: ${r=>walletBorders[r.theme.borderRadius]};
`
  , FourWalletsItem = r=>createComponent(WalletItem, {
    get name() {
        return r.labelLine1
    },
    get secondLine() {
        return r.labelLine2
    },
    get icon() {
        return createComponent(FourWalletsCard, {
            get children() {
                return createComponent(For, {
                    each: [0, 1, 2, 3],
                    children: d=>createComponent(FourWalletsImage, {
                        get src() {
                            return r.images[d]
                        }
                    })
                })
            }
        })
    },
    onClick: ()=>r.onClick()
})
  , AT_WALLET_APP_NAME = "telegram-wallet"
  , IMG = {
    TON: "https://raw.githubusercontent.com/ton-connect/sdk/main/assets/ton-icon-48.png",
    TG: "https://raw.githubusercontent.com/ton-connect/sdk/main/assets/tg.png"
}
  , WalletLabeledItem = r=>{
    const [d] = useI18n()
      , f = ()=>{
        if (r.wallet.appName !== AT_WALLET_APP_NAME) {
            if ("isPreferred"in r.wallet && r.wallet.isPreferred)
                return d("walletItem.recent", {}, "Recent");
            if (isWalletInfoCurrentlyInjected(r.wallet))
                return d("walletItem.installed", {}, "Installed");
            if (r.wallet.name === "Tonkeeper")
                return d("walletItem.popular", {}, "Popular")
        }
    }
    ;
    return createMemo((()=>{
        const m = createMemo(()=>r.wallet.appName === AT_WALLET_APP_NAME);
        return ()=>m() ? createComponent(WalletItem, {
            get icon() {
                return r.wallet.imageUrl
            },
            get name() {
                return d("walletItem.walletOn", {}, "Wallet On")
            },
            secondLine: "Telegram",
            get badgeUrl() {
                return IMG.TG
            },
            onClick: ()=>r.onClick()
        }) : createComponent(WalletItem, {
            get icon() {
                return r.wallet.imageUrl
            },
            get name() {
                return r.wallet.name
            },
            get secondLine() {
                return f()
            },
            secondLineColorPrimary: !1,
            onClick: ()=>r.onClick()
        })
    }
    )())
}
  , ScrollContainerStyled = styled.div`
    width: 100%;
    overflow-y: auto;
    max-height: ${r=>r.maxHeight};

    scrollbar-width: none;
    &&::-webkit-scrollbar {
        display: none;
    }

    &&::-webkit-scrollbar-track {
        background: transparent;
    }

    &&::-webkit-scrollbar-thumb {
        display: none;
    }
`
  , ScrollDivider = styled.div`
    height: 1px;
    margin: 0 -24px;
    width: calc(100% + 48px);
    opacity: 0.08;
    background: ${r=>r.isShown ? r.theme.colors.icon.secondary : "transparent"};
    transition: background 0.15s ease-in-out;

    ${media("mobile")} {
        width: 100%;
        margin: 0;
    }
`
  , [windowHeight,setWindowHeight] = createSignal(((_h = getWindow$1()) == null ? void 0 : _h.innerHeight) || 0);
getWindow$1() && window.addEventListener("resize", ()=>setWindowHeight(window.innerHeight));
const [isMobile,setIsMobile] = createSignal(isDevice("mobile"))
  , updateIsMobile = ()=>setIsMobile(isDevice("mobile"));
getWindow$1() && (window.addEventListener("resize", ()=>updateIsMobile()),
window.addEventListener("load", ()=>updateIsMobile(), {
    once: !0
}));
const ScrollContainer = r=>{
    const [d,f] = createSignal(!1)
      , m = ee=>{
        f(ee.target.scrollTop > 0)
    }
      , k = ()=>isMobile() ? 150 : 200
      , y = ()=>r.maxHeight !== void 0 ? `${r.maxHeight}px` : `${windowHeight() - k()}px`;
    return [createComponent(ScrollDivider, {
        get isShown() {
            return d()
        }
    }), createComponent(ScrollContainerStyled, {
        get maxHeight() {
            return y()
        },
        onScroll: m,
        get class() {
            return r.class
        },
        get children() {
            return r.children
        }
    })]
}
  , AStyled = styled.a`
    display: block;
    text-decoration: unset;
`
  , Link = r=>createComponent(AStyled, mergeProps({
    get href() {
        return r.href
    },
    get target() {
        return r.blank ? "_blank" : "_self"
    },
    get class() {
        return r.class
    }
}, ()=>r.blank ? {
    rel: "noreferrer noopener"
} : {}, {
    get children() {
        return r.children
    }
}))
  , TonConnectUiContext = createContext()
  , _tmpl$$7 = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M7.76228 2.09998H10.2378C11.0458 2.09997 11.7067 2.09996 12.2438 2.14384C12.7997 2.18926 13.3017 2.28614 13.7706 2.52505C14.5045 2.89896 15.1011 3.49558 15.475 4.22941C15.7139 4.6983 15.8108 5.20038 15.8562 5.75629C15.9001 6.29337 15.9001 6.95422 15.9001 7.76227V8.1H16.2377C17.0457 8.09999 17.7066 8.09998 18.2437 8.14386C18.7996 8.18928 19.3017 8.28616 19.7705 8.52507C20.5044 8.89898 21.101 9.4956 21.4749 10.2294C21.7138 10.6983 21.8107 11.2004 21.8561 11.7563C21.9 12.2934 21.9 12.9542 21.9 13.7623V16.2377C21.9 17.0458 21.9 17.7066 21.8561 18.2437C21.8107 18.7996 21.7138 19.3017 21.4749 19.7706C21.101 20.5044 20.5044 21.101 19.7705 21.4749C19.3017 21.7138 18.7996 21.8107 18.2437 21.8561C17.7066 21.9 17.0458 21.9 16.2378 21.9H13.7623C12.9543 21.9 12.2934 21.9 11.7563 21.8561C11.2004 21.8107 10.6983 21.7138 10.2294 21.4749C9.49561 21.101 8.89898 20.5044 8.52508 19.7706C8.28616 19.3017 8.18928 18.7996 8.14386 18.2437C8.09998 17.7066 8.09999 17.0458 8.1 16.2377V15.9H7.76227C6.95426 15.9 6.29335 15.9 5.75629 15.8561C5.20038 15.8107 4.6983 15.7138 4.22941 15.4749C3.49558 15.101 2.89896 14.5044 2.52505 13.7705C2.28614 13.3017 2.18926 12.7996 2.14384 12.2437C2.09996 11.7066 2.09997 11.0458 2.09998 10.2377V7.76228C2.09997 6.95424 2.09996 6.29336 2.14384 5.75629C2.18926 5.20038 2.28614 4.6983 2.52505 4.22941C2.89896 3.49558 3.49558 2.89896 4.22941 2.52505C4.6983 2.28614 5.20038 2.18926 5.75629 2.14384C6.29336 2.09996 6.95425 2.09997 7.76228 2.09998ZM8.1 14.1V13.7623C8.09999 12.9542 8.09998 12.2934 8.14386 11.7563C8.18928 11.2004 8.28616 10.6983 8.52508 10.2294C8.89898 9.4956 9.49561 8.89898 10.2294 8.52507C10.6983 8.28616 11.2004 8.18928 11.7563 8.14386C12.2934 8.09998 12.9542 8.09999 13.7623 8.1H14.1001V7.79998C14.1001 6.94505 14.0994 6.35798 14.0622 5.90287C14.0259 5.45827 13.9593 5.21944 13.8712 5.0466C13.6699 4.65146 13.3486 4.3302 12.9535 4.12886C12.7806 4.04079 12.5418 3.97419 12.0972 3.93786C11.6421 3.90068 11.055 3.89998 10.2001 3.89998H7.79998C6.94505 3.89998 6.35798 3.90068 5.90287 3.93786C5.45827 3.97419 5.21944 4.04079 5.0466 4.12886C4.65146 4.3302 4.3302 4.65146 4.12886 5.0466C4.04079 5.21944 3.97419 5.45827 3.93786 5.90287C3.90068 6.35798 3.89998 6.94505 3.89998 7.79998V10.2C3.89998 11.0549 3.90068 11.642 3.93786 12.0971C3.97419 12.5417 4.04079 12.7805 4.12886 12.9534C4.3302 13.3485 4.65146 13.6698 5.0466 13.8711C5.21944 13.9592 5.45827 14.0258 5.90287 14.0621C6.35798 14.0993 6.94505 14.1 7.79998 14.1H8.1ZM11.0466 10.1289C11.2195 10.0408 11.4583 9.97421 11.9029 9.93788C12.358 9.9007 12.9451 9.9 13.8 9.9H16.2C17.0549 9.9 17.642 9.9007 18.0971 9.93788C18.5417 9.97421 18.7805 10.0408 18.9534 10.1289C19.3485 10.3302 19.6698 10.6515 19.8711 11.0466C19.9592 11.2195 20.0258 11.4583 20.0621 11.9029C20.0993 12.358 20.1 12.9451 20.1 13.8V16.2C20.1 17.0549 20.0993 17.642 20.0621 18.0971C20.0258 18.5417 19.9592 18.7805 19.8711 18.9534C19.6698 19.3485 19.3485 19.6698 18.9534 19.8711C18.7805 19.9592 18.5417 20.0258 18.0971 20.0621C17.642 20.0993 17.0549 20.1 16.2 20.1H13.8C12.9451 20.1 12.358 20.0993 11.9029 20.0621C11.4583 20.0258 11.2195 19.9592 11.0466 19.8711C10.6515 19.6698 10.3302 19.3485 10.1289 18.9534C10.0408 18.7805 9.97421 18.5417 9.93788 18.0971C9.9007 17.642 9.9 17.0549 9.9 16.2V13.8C9.9 12.9451 9.9007 12.358 9.93788 11.9029C9.97421 11.4583 10.0408 11.2195 10.1289 11.0466C10.3302 10.6515 10.6515 10.3302 11.0466 10.1289Z"></path></svg>')
  , CopyIcon = r=>{
    const d = useTheme()
      , f = ()=>r.fill || d.colors.icon.primary;
    return (()=>{
        const m = _tmpl$$7.cloneNode(!0)
          , k = m.firstChild;
        return createRenderEffect(y=>{
            const ee = r.class
              , dt = f();
            return ee !== y._v$ && setAttribute(m, "class", y._v$ = ee),
            dt !== y._v$2 && setAttribute(k, "fill", y._v$2 = dt),
            y
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        m
    }
    )()
}
  , _tmpl$$6 = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.7624 3.10001C7.95435 3.1 7.29349 3.09999 6.75642 3.14387C6.2005 3.18929 5.69842 3.28617 5.22954 3.52508C4.4957 3.89899 3.89908 4.49561 3.52517 5.22944C3.28626 5.69833 3.18938 6.20041 3.14396 6.75632C3.10008 7.2934 3.10009 7.95424 3.1001 8.76229V15.2377C3.10009 16.0458 3.10008 16.7066 3.14396 17.2437C3.18938 17.7996 3.28626 18.3017 3.52517 18.7706C3.89908 19.5044 4.4957 20.101 5.22954 20.4749C5.69842 20.7138 6.2005 20.8107 6.75642 20.8561C7.29349 20.9 7.95434 20.9 8.76239 20.9H12.0001C12.4972 20.9 12.9001 20.4971 12.9001 20C12.9001 19.503 12.4972 19.1 12.0001 19.1H8.8001C7.94517 19.1 7.3581 19.0993 6.90299 19.0621C6.45839 19.0258 6.21956 18.9592 6.04672 18.8711C5.65158 18.6698 5.33032 18.3485 5.12898 17.9534C5.04092 17.7805 4.97431 17.5417 4.93798 17.0971C4.9008 16.642 4.9001 16.0549 4.9001 15.2V8.80001C4.9001 7.94508 4.9008 7.35801 4.93798 6.9029C4.97431 6.4583 5.04092 6.21947 5.12898 6.04663C5.33032 5.65149 5.65158 5.33023 6.04672 5.12889C6.21956 5.04082 6.45839 4.97422 6.90299 4.93789C7.3581 4.90071 7.94517 4.90001 8.8001 4.90001H12.0001C12.4972 4.90001 12.9001 4.49706 12.9001 4.00001C12.9001 3.50295 12.4972 3.10001 12.0001 3.10001H8.7624Z"></path><path d="M17.6364 7.3636C17.2849 7.01212 16.7151 7.01212 16.3636 7.3636C16.0121 7.71507 16.0121 8.28492 16.3636 8.63639L18.8272 11.1H9.00001C8.50295 11.1 8.10001 11.5029 8.10001 12C8.10001 12.497 8.50295 12.9 9.00001 12.9H18.8272L16.3636 15.3636C16.0121 15.7151 16.0121 16.2849 16.3636 16.6364C16.7151 16.9879 17.2849 16.9879 17.6364 16.6364L21.6364 12.6364C21.9879 12.2849 21.9879 11.7151 21.6364 11.3636L17.6364 7.3636Z"></path></svg>')
  , DisconnectIcon = r=>{
    const d = useTheme()
      , f = ()=>r.fill || d.colors.icon.primary;
    return (()=>{
        const m = _tmpl$$6.cloneNode(!0)
          , k = m.firstChild
          , y = k.nextSibling;
        return createRenderEffect(ee=>{
            const dt = f()
              , mt = f();
            return dt !== ee._v$ && setAttribute(k, "fill", ee._v$ = dt),
            mt !== ee._v$2 && setAttribute(y, "fill", ee._v$2 = mt),
            ee
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        m
    }
    )()
}
  , hoverBorders$1 = {
    m: "8px",
    s: "4px",
    none: "0"
}
  , dropdownBorders = {
    m: "16px",
    s: "8px",
    none: "0"
}
  , AccountButtonDropdownStyled = styled.div`
    width: 256px;
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);
    border-radius: ${r=>dropdownBorders[r.theme.borderRadius]};

    background-color: ${r=>r.theme.colors.background.primary}
           
    color: ${r=>r.theme.colors.text.primary}
`
  , UlStyled$1 = styled.ul`
    background-color: ${r=>r.theme.colors.background.primary};
    padding: 8px;
`
  , MenuButtonStyled = styled.button`
    display: flex;
    align-items: center;
    gap: 8px;
    height: 40px;
    padding-left: 8px;
    width: 100%;

    background-color: ${r=>r.theme.colors.background.primary};
    border: none;
    border-radius: ${r=>hoverBorders$1[r.theme.borderRadius]};
    cursor: pointer;

    transition: background-color, transform 0.1s ease-in-out;

    &:hover {
        background-color: ${r=>r.theme.colors.background.secondary};
    }

    &:active {
        transform: scale(0.96);
    }
`
  , _tmpl$$5 = template$1("<li></li>")
  , MenuItemText = r=>createComponent(Text, {
    get translationKey() {
        return r.translationKey
    },
    fontSize: "15px",
    fontWeight: "590",
    get children() {
        return r.children
    }
})
  , AccountButtonDropdown = r=>{
    const d = useContext(TonConnectUiContext)
      , [f,m] = createSignal(!1)
      , k = ()=>__async(void 0, null, function*() {
        const ee = toUserFriendlyAddress(d.account.address, d.account.chain === CHAIN.TESTNET);
        yield copyToClipboard(ee),
        m(!0),
        setTimeout(()=>m(!1), 1e3)
    })
      , y = ()=>{
        d.disconnect(),
        r.onClose()
    }
    ;
    return createComponent(AccountButtonDropdownStyled, {
        ref(ee) {
            const dt = r.ref;
            typeof dt == "function" ? dt(ee) : r.ref = ee
        },
        get class() {
            return r.class
        },
        "data-tc-dropdown": "true",
        get children() {
            return createComponent(UlStyled$1, {
                get children() {
                    return [(()=>{
                        const ee = _tmpl$$5.cloneNode(!0);
                        return insert(ee, createComponent(MenuButtonStyled, {
                            onClick: ()=>k(),
                            get children() {
                                return [createComponent(CopyIcon, {}), createComponent(Show, {
                                    get when() {
                                        return !f()
                                    },
                                    get children() {
                                        return createComponent(MenuItemText, {
                                            translationKey: "button.dropdown.copy",
                                            children: "Copy address"
                                        })
                                    }
                                }), createComponent(Show, {
                                    get when() {
                                        return f()
                                    },
                                    get children() {
                                        return createComponent(MenuItemText, {
                                            translationKey: "button.dropdown.copied",
                                            children: "Address copied!"
                                        })
                                    }
                                })]
                            }
                        })),
                        ee
                    }
                    )(), (()=>{
                        const ee = _tmpl$$5.cloneNode(!0);
                        return insert(ee, createComponent(MenuButtonStyled, {
                            onClick: ()=>y(),
                            get children() {
                                return [createComponent(DisconnectIcon, {}), createComponent(MenuItemText, {
                                    translationKey: "button.dropdown.disconnect",
                                    children: "Disconnect"
                                })]
                            }
                        })),
                        ee
                    }
                    )()]
                }
            })
        }
    })
}
  , borders$2 = {
    m: "16px",
    s: "8px",
    none: "0"
}
  , NotificationStyled = styled.div`
    width: 256px;
    padding: 12px 16px;
    display: flex;
    gap: 9px;

    background-color: ${r=>r.theme.colors.background.primary};
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);
    border-radius: ${r=>borders$2[r.theme.borderRadius]};
`
  , NotificationContentStyled = styled.div`
    width: 192px;

    > h3 {
        font-size: 15px;
    }
`
  , TextStyled$2 = styled(Text)`
    margin-top: 4px;
    color: ${r=>r.theme.colors.text.secondary};
`
  , Notification = r=>{
    const d = useDataAttributes(r);
    return createComponent(NotificationStyled, mergeProps({
        get class() {
            return r.class
        },
        "data-tc-notification": "true"
    }, d, {
        get children() {
            return [createComponent(NotificationContentStyled, {
                get children() {
                    return [createComponent(H3, {
                        get translationKey() {
                            return r.header.translationKey
                        },
                        get translationValues() {
                            return r.header.translationValues
                        },
                        get children() {
                            return r.children
                        }
                    }), createComponent(Show, {
                        get when() {
                            return r.text
                        },
                        get children() {
                            return createComponent(TextStyled$2, {
                                get translationKey() {
                                    return r.text.translationKey
                                },
                                get translationValues() {
                                    return r.text.translationValues
                                }
                            })
                        }
                    })]
                }
            }), createMemo(()=>r.icon)]
        }
    }))
}
  , LoaderIconStyled$2 = styled(LoaderIcon)`
    align-self: center;
`
  , ConfirmOperationNotification = r=>{
    const d = useContext(TonConnectUiContext)
      , [f] = useI18n()
      , m = ()=>d.wallet && "name"in d.wallet ? d.wallet.name : f("common.yourWallet", {}, "Your wallet");
    return createComponent(Notification, {
        get header() {
            return {
                translationKey: "notifications.confirm.header",
                translationValues: {
                    name: m()
                }
            }
        },
        get class() {
            return r.class
        },
        get icon() {
            return createComponent(LoaderIconStyled$2, {})
        },
        "data-tc-notification-confirm": "true",
        children: "Confirm operation in your wallet"
    })
}
  , ErrorIconStyled$2 = styled(ErrorIcon)`
    margin-top: 2px;
`
  , ErrorTransactionNotification = r=>createComponent(Notification, {
    header: {
        translationKey: "notifications.transactionCanceled.header"
    },
    text: {
        translationKey: "notifications.transactionCanceled.text"
    },
    get icon() {
        return createComponent(ErrorIconStyled$2, {
            size: "xs"
        })
    },
    get class() {
        return r.class
    },
    "data-tc-notification-tx-cancelled": "true",
    children: "Transaction cancelled"
})
  , SuccessIconStyled = styled(SuccessIcon)`
    margin-top: 2px;
`
  , SuccessTransactionNotification = r=>createComponent(Notification, {
    header: {
        translationKey: "notifications.transactionSent.header"
    },
    text: {
        translationKey: "notifications.transactionSent.text"
    },
    get icon() {
        return createComponent(SuccessIconStyled, {})
    },
    get class() {
        return r.class
    },
    "data-tc-notification-tx-sent": "true",
    children: "Transaction sent"
})
  , NotificationClass = u$1`
    transform: translateY(-8px);
    margin-bottom: 12px;
`
  , defaultConfig = {
    timeout: 4500
}
  , [latestAction,setLatestAction] = createSignal(null);
function useOpenedNotifications(r) {
    const {timeout: d} = __spreadValues(__spreadValues({}, defaultConfig), r)
      , [f,m] = createSignal([])
      , [k,y] = createSignal([]);
    return createEffect(on(action, ee=>{
        var dt;
        if (!ee || !ee.showNotification || latestAction() === ee || ((dt = latestAction()) == null ? void 0 : dt.name) === "confirm-transaction" && ee.name === "confirm-transaction")
            return;
        setLatestAction(ee),
        m(pt=>pt.filter(bt=>bt.action !== "confirm-transaction"));
        const mt = {
            action: ee.name
        };
        m(pt=>[...pt, mt]);
        const yt = setTimeout(()=>{
            m(pt=>pt.filter(bt=>bt !== mt)),
            y(pt=>pt.filter(bt=>bt !== yt))
        }
        , d);
        y(pt=>[...pt, yt])
    }
    )),
    onCleanup(()=>{
        k().forEach(ee=>clearTimeout(ee))
    }
    ),
    f
}
const _tmpl$$4 = template$1('<div data-tc-list-notifications="true"></div>')
  , Notifications = r=>{
    const d = useOpenedNotifications();
    return (()=>{
        const f = _tmpl$$4.cloneNode(!0);
        return insert(f, createComponent(TransitionGroup, {
            onBeforeEnter: m=>{
                animate(m, [{
                    opacity: 0,
                    transform: "translateY(0)"
                }, {
                    opacity: 1,
                    transform: "translateY(-8px)"
                }], {
                    duration: 200
                })
            }
            ,
            onExit: (m,k)=>{
                animate(m, [{
                    opacity: 1,
                    transform: "translateY(-8px)"
                }, {
                    opacity: 0,
                    transform: "translateY(-30px)"
                }], {
                    duration: 200
                }).finished.then(k)
            }
            ,
            get children() {
                return createComponent(For, {
                    get each() {
                        return d()
                    },
                    children: m=>createComponent(Switch, {
                        get children() {
                            return [createComponent(Match, {
                                get when() {
                                    return m.action === "transaction-sent"
                                },
                                get children() {
                                    return createComponent(SuccessTransactionNotification, {
                                        class: NotificationClass
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return m.action === "transaction-canceled"
                                },
                                get children() {
                                    return createComponent(ErrorTransactionNotification, {
                                        class: NotificationClass
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return m.action === "confirm-transaction"
                                },
                                get children() {
                                    return createComponent(ConfirmOperationNotification, {
                                        class: NotificationClass
                                    })
                                }
                            })]
                        }
                    })
                })
            }
        })),
        createRenderEffect(()=>className(f, r.class)),
        f
    }
    )()
}
  , AccountButtonStyled = styled(Button)`
    background-color: ${r=>r.theme.colors.connectButton.background};
    color: ${r=>r.theme.colors.connectButton.foreground};
    box-shadow: ${r=>`0 4px 24px ${rgba(r.theme.colors.constant.black, .16)}`};
    padding: 8px 16px 8px 12px;

    display: flex;
    align-items: center;
    gap: 4px;
    height: 40px;
`
  , DropdownButtonStyled = styled(AccountButtonStyled)`
    padding: 12px 16px;
    min-width: 148px;
    justify-content: center;
    background-color: ${r=>r.theme.colors.background.primary};
`
  , LoaderButtonStyled$1 = styled(Button)`
    min-width: 148px;
    height: 40px;

    background-color: ${r=>r.theme.colors.background.primary};
    color: ${r=>r.theme.colors.connectButton.foreground};
    box-shadow: ${r=>`0 4px 24px ${rgba(r.theme.colors.constant.black, .16)}`};

    display: flex;
    align-items: center;
    justify-content: center;
`
  , LoaderIconStyled$1 = styled(LoaderIcon)`
    height: 18px;
    width: 18px;
`
  , DropdownContainerStyled = styled.div`
    width: fit-content;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
`
  , DropdownStyled = styled(AccountButtonDropdown)`
    box-sizing: border-box;
    overflow: hidden;
    margin-top: 12px;
`
  , NotificationsStyled = styled(Notifications)`
    > div:first-child {
        margin-top: 20px;
    }
`;
function getSide(r) {
    return r.split("-")[0]
}
function getAlignment(r) {
    return r.split("-")[1]
}
function getMainAxisFromPlacement(r) {
    return ["top", "bottom"].includes(getSide(r)) ? "x" : "y"
}
function getLengthFromAxis(r) {
    return r === "y" ? "height" : "width"
}
function computeCoordsFromPlacement(r, d, f) {
    let {reference: m, floating: k} = r;
    const y = m.x + m.width / 2 - k.width / 2
      , ee = m.y + m.height / 2 - k.height / 2
      , dt = getMainAxisFromPlacement(d)
      , mt = getLengthFromAxis(dt)
      , yt = m[mt] / 2 - k[mt] / 2
      , pt = getSide(d)
      , bt = dt === "x";
    let wt;
    switch (pt) {
    case "top":
        wt = {
            x: y,
            y: m.y - k.height
        };
        break;
    case "bottom":
        wt = {
            x: y,
            y: m.y + m.height
        };
        break;
    case "right":
        wt = {
            x: m.x + m.width,
            y: ee
        };
        break;
    case "left":
        wt = {
            x: m.x - k.width,
            y: ee
        };
        break;
    default:
        wt = {
            x: m.x,
            y: m.y
        }
    }
    switch (getAlignment(d)) {
    case "start":
        wt[dt] -= yt * (f && bt ? -1 : 1);
        break;
    case "end":
        wt[dt] += yt * (f && bt ? -1 : 1);
        break
    }
    return wt
}
const computePosition$1 = (r,d,f)=>__async(void 0, null, function*() {
    const {placement: m="bottom", strategy: k="absolute", middleware: y=[], platform: ee} = f
      , dt = y.filter(Boolean)
      , mt = yield ee.isRTL == null ? void 0 : ee.isRTL(d);
    if ({}.NODE_ENV !== "production") {
        if (ee == null && console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" ")),
        dt.filter(Ct=>{
            let {name: Pt} = Ct;
            return Pt === "autoPlacement" || Pt === "flip"
        }
        ).length > 1)
            throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement` middleware", "detected. This will lead to an infinite loop. Ensure only one of", "either has been passed to the `middleware` array."].join(" "));
        (!r || !d) && console.error(["Floating UI: The reference and/or floating element was not defined", "when `computePosition()` was called. Ensure that both elements have", "been created and can be measured."].join(" "))
    }
    let yt = yield ee.getElementRects({
        reference: r,
        floating: d,
        strategy: k
    })
      , {x: pt, y: bt} = computeCoordsFromPlacement(yt, m, mt)
      , wt = m
      , xt = {}
      , At = 0;
    for (let Ct = 0; Ct < dt.length; Ct++) {
        const {name: Pt, fn: $t} = dt[Ct]
          , {x: Ot, y: Nt, data: zt, reset: Wt} = yield $t({
            x: pt,
            y: bt,
            initialPlacement: m,
            placement: wt,
            strategy: k,
            middlewareData: xt,
            rects: yt,
            platform: ee,
            elements: {
                reference: r,
                floating: d
            }
        });
        if (pt = Ot ?? pt,
        bt = Nt ?? bt,
        xt = __spreadProps(__spreadValues({}, xt), {
            [Pt]: __spreadValues(__spreadValues({}, xt[Pt]), zt)
        }),
        {}.NODE_ENV !== "production" && At > 50 && console.warn(["Floating UI: The middleware lifecycle appears to be running in an", "infinite loop. This is usually caused by a `reset` continually", "being returned without a break condition."].join(" ")),
        Wt && At <= 50) {
            At++,
            typeof Wt == "object" && (Wt.placement && (wt = Wt.placement),
            Wt.rects && (yt = Wt.rects === !0 ? yield ee.getElementRects({
                reference: r,
                floating: d,
                strategy: k
            }) : Wt.rects),
            {x: pt, y: bt} = computeCoordsFromPlacement(yt, wt, mt)),
            Ct = -1;
            continue
        }
    }
    return {
        x: pt,
        y: bt,
        placement: wt,
        strategy: k,
        middlewareData: xt
    }
});
function rectToClientRect(r) {
    return __spreadProps(__spreadValues({}, r), {
        top: r.y,
        left: r.x,
        right: r.x + r.width,
        bottom: r.y + r.height
    })
}
function getWindow(r) {
    var d;
    return ((d = r.ownerDocument) == null ? void 0 : d.defaultView) || window
}
function getComputedStyle$1(r) {
    return getWindow(r).getComputedStyle(r)
}
function getNodeName(r) {
    return isNode(r) ? (r.nodeName || "").toLowerCase() : ""
}
let uaString;
function getUAString() {
    if (uaString)
        return uaString;
    const r = navigator.userAgentData;
    return r && Array.isArray(r.brands) ? (uaString = r.brands.map(d=>d.brand + "/" + d.version).join(" "),
    uaString) : navigator.userAgent
}
function isHTMLElement(r) {
    return r instanceof getWindow(r).HTMLElement
}
function isElement(r) {
    return r instanceof getWindow(r).Element
}
function isNode(r) {
    return r instanceof getWindow(r).Node
}
function isShadowRoot(r) {
    if (typeof ShadowRoot > "u")
        return !1;
    const d = getWindow(r).ShadowRoot;
    return r instanceof d || r instanceof ShadowRoot
}
function isOverflowElement(r) {
    const {overflow: d, overflowX: f, overflowY: m, display: k} = getComputedStyle$1(r);
    return /auto|scroll|overlay|hidden/.test(d + m + f) && !["inline", "contents"].includes(k)
}
function isTableElement(r) {
    return ["table", "td", "th"].includes(getNodeName(r))
}
function isContainingBlock(r) {
    const d = /firefox/i.test(getUAString())
      , f = getComputedStyle$1(r)
      , m = f.backdropFilter || f.WebkitBackdropFilter;
    return f.transform !== "none" || f.perspective !== "none" || (m ? m !== "none" : !1) || d && f.willChange === "filter" || d && (f.filter ? f.filter !== "none" : !1) || ["transform", "perspective"].some(k=>f.willChange.includes(k)) || ["paint", "layout", "strict", "content"].some(k=>{
        const y = f.contain;
        return y != null ? y.includes(k) : !1
    }
    )
}
function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString())
}
function isLastTraversableNode(r) {
    return ["html", "body", "#document"].includes(getNodeName(r))
}
const min = Math.min
  , max = Math.max
  , round = Math.round
  , FALLBACK_SCALE = {
    x: 1,
    y: 1
};
function getScale(r) {
    const d = !isElement(r) && r.contextElement ? r.contextElement : isElement(r) ? r : null;
    if (!d)
        return FALLBACK_SCALE;
    const f = d.getBoundingClientRect()
      , m = getComputedStyle$1(d);
    if (m.boxSizing !== "border-box")
        return isHTMLElement(d) ? {
            x: d.offsetWidth > 0 && round(f.width) / d.offsetWidth || 1,
            y: d.offsetHeight > 0 && round(f.height) / d.offsetHeight || 1
        } : FALLBACK_SCALE;
    let k = f.width / parseFloat(m.width)
      , y = f.height / parseFloat(m.height);
    return (!k || !Number.isFinite(k)) && (k = 1),
    (!y || !Number.isFinite(y)) && (y = 1),
    {
        x: k,
        y
    }
}
function getBoundingClientRect(r, d, f, m) {
    var k, y, ee, dt;
    d === void 0 && (d = !1),
    f === void 0 && (f = !1);
    const mt = r.getBoundingClientRect();
    let yt = FALLBACK_SCALE;
    d && (m ? isElement(m) && (yt = getScale(m)) : yt = getScale(r));
    const pt = isElement(r) ? getWindow(r) : window
      , bt = !isLayoutViewport() && f
      , wt = (mt.left + (bt && (k = (y = pt.visualViewport) == null ? void 0 : y.offsetLeft) != null ? k : 0)) / yt.x
      , xt = (mt.top + (bt && (ee = (dt = pt.visualViewport) == null ? void 0 : dt.offsetTop) != null ? ee : 0)) / yt.y
      , At = mt.width / yt.x
      , Ct = mt.height / yt.y;
    return {
        width: At,
        height: Ct,
        top: xt,
        right: wt + At,
        bottom: xt + Ct,
        left: wt,
        x: wt,
        y: xt
    }
}
function getDocumentElement(r) {
    return ((isNode(r) ? r.ownerDocument : r.document) || window.document).documentElement
}
function getNodeScroll(r) {
    return isElement(r) ? {
        scrollLeft: r.scrollLeft,
        scrollTop: r.scrollTop
    } : {
        scrollLeft: r.pageXOffset,
        scrollTop: r.pageYOffset
    }
}
function getWindowScrollBarX(r) {
    return getBoundingClientRect(getDocumentElement(r)).left + getNodeScroll(r).scrollLeft
}
function getRectRelativeToOffsetParent(r, d, f) {
    const m = isHTMLElement(d)
      , k = getDocumentElement(d)
      , y = getBoundingClientRect(r, !0, f === "fixed", d);
    let ee = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const dt = {
        x: 0,
        y: 0
    };
    if (m || !m && f !== "fixed")
        if ((getNodeName(d) !== "body" || isOverflowElement(k)) && (ee = getNodeScroll(d)),
        isHTMLElement(d)) {
            const mt = getBoundingClientRect(d, !0);
            dt.x = mt.x + d.clientLeft,
            dt.y = mt.y + d.clientTop
        } else
            k && (dt.x = getWindowScrollBarX(k));
    return {
        x: y.left + ee.scrollLeft - dt.x,
        y: y.top + ee.scrollTop - dt.y,
        width: y.width,
        height: y.height
    }
}
function getParentNode(r) {
    if (getNodeName(r) === "html")
        return r;
    const d = r.assignedSlot || r.parentNode || (isShadowRoot(r) ? r.host : null) || getDocumentElement(r);
    return isShadowRoot(d) ? d.host : d
}
function getTrueOffsetParent(r) {
    return !isHTMLElement(r) || getComputedStyle$1(r).position === "fixed" ? null : r.offsetParent
}
function getContainingBlock(r) {
    let d = getParentNode(r);
    for (; isHTMLElement(d) && !isLastTraversableNode(d); ) {
        if (isContainingBlock(d))
            return d;
        d = getParentNode(d)
    }
    return null
}
function getOffsetParent(r) {
    const d = getWindow(r);
    let f = getTrueOffsetParent(r);
    for (; f && isTableElement(f) && getComputedStyle$1(f).position === "static"; )
        f = getTrueOffsetParent(f);
    return f && (getNodeName(f) === "html" || getNodeName(f) === "body" && getComputedStyle$1(f).position === "static" && !isContainingBlock(f)) ? d : f || getContainingBlock(r) || d
}
function getDimensions(r) {
    if (isHTMLElement(r))
        return {
            width: r.offsetWidth,
            height: r.offsetHeight
        };
    const d = getBoundingClientRect(r);
    return {
        width: d.width,
        height: d.height
    }
}
function convertOffsetParentRelativeRectToViewportRelativeRect(r) {
    let {rect: d, offsetParent: f, strategy: m} = r;
    const k = isHTMLElement(f)
      , y = getDocumentElement(f);
    if (f === y)
        return d;
    let ee = {
        scrollLeft: 0,
        scrollTop: 0
    }
      , dt = {
        x: 1,
        y: 1
    };
    const mt = {
        x: 0,
        y: 0
    };
    if ((k || !k && m !== "fixed") && ((getNodeName(f) !== "body" || isOverflowElement(y)) && (ee = getNodeScroll(f)),
    isHTMLElement(f))) {
        const yt = getBoundingClientRect(f);
        dt = getScale(f),
        mt.x = yt.x + f.clientLeft,
        mt.y = yt.y + f.clientTop
    }
    return {
        width: d.width * dt.x,
        height: d.height * dt.y,
        x: d.x * dt.x - ee.scrollLeft * dt.x + mt.x,
        y: d.y * dt.y - ee.scrollTop * dt.y + mt.y
    }
}
function getViewportRect(r, d) {
    const f = getWindow(r)
      , m = getDocumentElement(r)
      , k = f.visualViewport;
    let y = m.clientWidth
      , ee = m.clientHeight
      , dt = 0
      , mt = 0;
    if (k) {
        y = k.width,
        ee = k.height;
        const yt = isLayoutViewport();
        (yt || !yt && d === "fixed") && (dt = k.offsetLeft,
        mt = k.offsetTop)
    }
    return {
        width: y,
        height: ee,
        x: dt,
        y: mt
    }
}
function getDocumentRect(r) {
    var d;
    const f = getDocumentElement(r)
      , m = getNodeScroll(r)
      , k = (d = r.ownerDocument) == null ? void 0 : d.body
      , y = max(f.scrollWidth, f.clientWidth, k ? k.scrollWidth : 0, k ? k.clientWidth : 0)
      , ee = max(f.scrollHeight, f.clientHeight, k ? k.scrollHeight : 0, k ? k.clientHeight : 0);
    let dt = -m.scrollLeft + getWindowScrollBarX(r);
    const mt = -m.scrollTop;
    return getComputedStyle$1(k || f).direction === "rtl" && (dt += max(f.clientWidth, k ? k.clientWidth : 0) - y),
    {
        width: y,
        height: ee,
        x: dt,
        y: mt
    }
}
function getNearestOverflowAncestor(r) {
    const d = getParentNode(r);
    return isLastTraversableNode(d) ? r.ownerDocument.body : isHTMLElement(d) && isOverflowElement(d) ? d : getNearestOverflowAncestor(d)
}
function getOverflowAncestors(r, d) {
    var f;
    d === void 0 && (d = []);
    const m = getNearestOverflowAncestor(r)
      , k = m === ((f = r.ownerDocument) == null ? void 0 : f.body)
      , y = getWindow(m);
    return k ? d.concat(y, y.visualViewport || [], isOverflowElement(m) ? m : []) : d.concat(m, getOverflowAncestors(m))
}
function getInnerBoundingClientRect(r, d) {
    const f = getBoundingClientRect(r, !0, d === "fixed")
      , m = f.top + r.clientTop
      , k = f.left + r.clientLeft
      , y = isHTMLElement(r) ? getScale(r) : {
        x: 1,
        y: 1
    }
      , ee = r.clientWidth * y.x
      , dt = r.clientHeight * y.y
      , mt = k * y.x
      , yt = m * y.y;
    return {
        top: yt,
        left: mt,
        right: mt + ee,
        bottom: yt + dt,
        x: mt,
        y: yt,
        width: ee,
        height: dt
    }
}
function getClientRectFromClippingAncestor(r, d, f) {
    return d === "viewport" ? rectToClientRect(getViewportRect(r, f)) : isElement(d) ? getInnerBoundingClientRect(d, f) : rectToClientRect(getDocumentRect(getDocumentElement(r)))
}
function getClippingElementAncestors(r, d) {
    const f = d.get(r);
    if (f)
        return f;
    let m = getOverflowAncestors(r).filter(dt=>isElement(dt) && getNodeName(dt) !== "body")
      , k = null;
    const y = getComputedStyle$1(r).position === "fixed";
    let ee = y ? getParentNode(r) : r;
    for (; isElement(ee) && !isLastTraversableNode(ee); ) {
        const dt = getComputedStyle$1(ee)
          , mt = isContainingBlock(ee);
        (y ? !mt && !k : !mt && dt.position === "static" && !!k && ["absolute", "fixed"].includes(k.position)) ? m = m.filter(pt=>pt !== ee) : k = dt,
        ee = getParentNode(ee)
    }
    return d.set(r, m),
    m
}
function getClippingRect(r) {
    let {element: d, boundary: f, rootBoundary: m, strategy: k} = r;
    const ee = [...f === "clippingAncestors" ? getClippingElementAncestors(d, this._c) : [].concat(f), m]
      , dt = ee[0]
      , mt = ee.reduce((yt,pt)=>{
        const bt = getClientRectFromClippingAncestor(d, pt, k);
        return yt.top = max(bt.top, yt.top),
        yt.right = min(bt.right, yt.right),
        yt.bottom = min(bt.bottom, yt.bottom),
        yt.left = max(bt.left, yt.left),
        yt
    }
    , getClientRectFromClippingAncestor(d, dt, k));
    return {
        width: mt.right - mt.left,
        height: mt.bottom - mt.top,
        x: mt.left,
        y: mt.top
    }
}
const platform$2 = {
    getClippingRect,
    convertOffsetParentRelativeRectToViewportRelativeRect,
    isElement,
    getDimensions,
    getOffsetParent,
    getDocumentElement,
    getScale,
    getElementRects(r) {
        return __async(this, null, function*() {
            let {reference: d, floating: f, strategy: m} = r;
            const k = this.getOffsetParent || getOffsetParent
              , y = this.getDimensions;
            return {
                reference: getRectRelativeToOffsetParent(d, yield k(f), m),
                floating: __spreadValues({
                    x: 0,
                    y: 0
                }, yield y(f))
            }
        })
    },
    getClientRects: r=>Array.from(r.getClientRects()),
    isRTL: r=>getComputedStyle$1(r).direction === "rtl"
};
function autoUpdate(r, d, f, m) {
    m === void 0 && (m = {});
    const {ancestorScroll: k=!0, ancestorResize: y=!0, elementResize: ee=!0, animationFrame: dt=!1} = m
      , mt = k && !dt
      , yt = mt || y ? [...isElement(r) ? getOverflowAncestors(r) : r.contextElement ? getOverflowAncestors(r.contextElement) : [], ...getOverflowAncestors(d)] : [];
    yt.forEach(At=>{
        mt && At.addEventListener("scroll", f, {
            passive: !0
        }),
        y && At.addEventListener("resize", f)
    }
    );
    let pt = null;
    if (ee) {
        let At = !0;
        pt = new ResizeObserver(()=>{
            At || f(),
            At = !1
        }
        ),
        isElement(r) && !dt && pt.observe(r),
        !isElement(r) && r.contextElement && !dt && pt.observe(r.contextElement),
        pt.observe(d)
    }
    let bt, wt = dt ? getBoundingClientRect(r) : null;
    dt && xt();
    function xt() {
        const At = getBoundingClientRect(r);
        wt && (At.x !== wt.x || At.y !== wt.y || At.width !== wt.width || At.height !== wt.height) && f(),
        wt = At,
        bt = requestAnimationFrame(xt)
    }
    return f(),
    ()=>{
        var At;
        yt.forEach(Ct=>{
            mt && Ct.removeEventListener("scroll", f),
            y && Ct.removeEventListener("resize", f)
        }
        ),
        (At = pt) == null || At.disconnect(),
        pt = null,
        dt && cancelAnimationFrame(bt)
    }
}
const computePosition = (r,d,f)=>{
    const m = new Map
      , k = __spreadValues({
        platform: platform$2
    }, f)
      , y = __spreadProps(__spreadValues({}, k.platform), {
        _c: m
    });
    return computePosition$1(r, d, __spreadProps(__spreadValues({}, k), {
        platform: y
    }))
}
;
function P$1(r, d, f) {
    let m = ()=>{
        var bt;
        return (bt = f == null ? void 0 : f.placement) != null ? bt : "bottom"
    }
      , k = ()=>{
        var bt;
        return (bt = f == null ? void 0 : f.strategy) != null ? bt : "absolute"
    }
      , [y,ee] = createSignal({
        x: null,
        y: null,
        placement: m(),
        strategy: k(),
        middlewareData: {}
    })
      , [dt,mt] = createSignal();
    createEffect(()=>{
        let bt = dt();
        if (bt)
            throw bt.value
    }
    );
    let yt = createMemo(()=>(r(),
    d(),
    {}));
    function pt() {
        let bt = r()
          , wt = d();
        if (bt && wt) {
            let xt = yt();
            computePosition(bt, wt, {
                middleware: f == null ? void 0 : f.middleware,
                placement: m(),
                strategy: k()
            }).then(At=>{
                xt === yt() && ee(At)
            }
            , At=>{
                mt(At)
            }
            )
        }
    }
    return createEffect(()=>{
        let bt = r()
          , wt = d();
        if (f == null || f.middleware,
        m(),
        k(),
        bt && wt)
            if (f != null && f.whileElementsMounted) {
                let xt = f.whileElementsMounted(bt, wt, pt);
                xt && onCleanup(xt)
            } else
                pt()
    }
    ),
    {
        get x() {
            return y().x
        },
        get y() {
            return y().y
        },
        get placement() {
            return y().placement
        },
        get strategy() {
            return y().strategy
        },
        get middlewareData() {
            return y().middlewareData
        },
        update: pt
    }
}
const _tmpl$$3 = template$1('<tc-root data-tc-dropdown-container="true"></tc-root>')
  , AccountButton = ()=>{
    const r = useTheme()
      , d = useContext(ConnectorContext)
      , f = useContext(TonConnectUiContext)
      , [m,k] = createSignal(!1)
      , [y,ee] = createSignal(d.account)
      , [dt,mt] = createSignal(!d.account);
    let yt;
    const [pt,bt] = createSignal()
      , [wt,xt] = createSignal()
      , At = P$1(wt, pt, {
        whileElementsMounted: autoUpdate,
        placement: "bottom-end"
    })
      , Ct = ()=>{
        const Ot = y();
        if (Ot) {
            const Nt = toUserFriendlyAddress(Ot.address, Ot.chain === CHAIN.TESTNET);
            return Nt.slice(0, 4) + "…" + Nt.slice(-4)
        }
        return ""
    }
    ;
    f.connectionRestored.then(()=>mt(!1));
    const Pt = d.onStatusChange(Ot=>{
        if (!Ot) {
            k(!1),
            ee(null),
            mt(!1);
            return
        }
        ee(Ot.account),
        mt(!1)
    }
    )
      , $t = Ot=>{
        if (!y() || !m())
            return;
        const Nt = wt().contains(Ot.target)
          , zt = yt.contains(Ot.target);
        !Nt && !zt && k(!1)
    }
    ;
    return onMount(()=>{
        document.body.addEventListener("click", $t)
    }
    ),
    onCleanup(()=>{
        document.body.removeEventListener("click", $t),
        Pt()
    }
    ),
    createComponent(Dynamic, {
        component: globalStylesTag,
        get children() {
            return [createComponent(Show, {
                get when() {
                    return dt()
                },
                get children() {
                    return createComponent(LoaderButtonStyled$1, {
                        disabled: !0,
                        "data-tc-connect-button-loading": "true",
                        get children() {
                            return createComponent(LoaderIconStyled$1, {})
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return !dt()
                },
                get children() {
                    return [createComponent(Show, {
                        get when() {
                            return !y()
                        },
                        get children() {
                            return createComponent(AccountButtonStyled, {
                                onClick: ()=>f.openModal(),
                                "data-tc-connect-button": "true",
                                scale: "s",
                                get children() {
                                    return [createComponent(TonIcon, {
                                        get fill() {
                                            return r.colors.connectButton.foreground
                                        }
                                    }), createComponent(Text, {
                                        translationKey: "button.connectWallet",
                                        fontSize: "15px",
                                        lineHeight: "18px",
                                        fontWeight: "590",
                                        get color() {
                                            return r.colors.connectButton.foreground
                                        },
                                        children: "Connect wallet"
                                    })]
                                }
                            })
                        }
                    }), createComponent(Show, {
                        get when() {
                            return y()
                        },
                        get children() {
                            return createComponent(DropdownContainerStyled, {
                                get children() {
                                    return [createComponent(DropdownButtonStyled, {
                                        onClick: ()=>k(Ot=>!Ot),
                                        ref: xt,
                                        "data-tc-dropdown-button": "true",
                                        scale: "s",
                                        get children() {
                                            return [createComponent(Text, {
                                                fontSize: "15px",
                                                fontWeight: "590",
                                                lineHeight: "18px",
                                                get children() {
                                                    return Ct()
                                                }
                                            }), createComponent(ArrowIcon, {
                                                direction: "bottom"
                                            })]
                                        }
                                    }), createComponent(Portal, {
                                        get children() {
                                            const Ot = untrack(()=>document.importNode(_tmpl$$3, !0));
                                            return use(bt, Ot),
                                            Ot.style.setProperty("z-index", "999"),
                                            Ot._$owner = getOwner(),
                                            insert(Ot, createComponent(Transition, {
                                                onBeforeEnter: Nt=>{
                                                    animate(Nt, [{
                                                        opacity: 0,
                                                        transform: "translateY(-8px)"
                                                    }, {
                                                        opacity: 1,
                                                        transform: "translateY(0)"
                                                    }], {
                                                        duration: 150
                                                    })
                                                }
                                                ,
                                                onExit: (Nt,zt)=>{
                                                    animate(Nt, [{
                                                        opacity: 1,
                                                        transform: "translateY(0)"
                                                    }, {
                                                        opacity: 0,
                                                        transform: "translateY(-8px)"
                                                    }], {
                                                        duration: 150
                                                    }).finished.then(zt)
                                                }
                                                ,
                                                get children() {
                                                    return createComponent(Show, {
                                                        get when() {
                                                            return m()
                                                        },
                                                        get children() {
                                                            return createComponent(DropdownStyled, {
                                                                get hidden() {
                                                                    return !m()
                                                                },
                                                                onClose: ()=>k(!1),
                                                                ref(Nt) {
                                                                    const zt = yt;
                                                                    typeof zt == "function" ? zt(Nt) : yt = Nt
                                                                }
                                                            })
                                                        }
                                                    })
                                                }
                                            }), null),
                                            insert(Ot, createComponent(NotificationsStyled, {}), null),
                                            createRenderEffect(Nt=>{
                                                var zt, Wt;
                                                const Kt = At.strategy
                                                  , ir = `${(zt = At.y) != null ? zt : 0}px`
                                                  , or = `${(Wt = At.x) != null ? Wt : 0}px`;
                                                return Kt !== Nt._v$ && Ot.style.setProperty("position", Nt._v$ = Kt),
                                                ir !== Nt._v$2 && Ot.style.setProperty("top", Nt._v$2 = ir),
                                                or !== Nt._v$3 && Ot.style.setProperty("left", Nt._v$3 = or),
                                                Nt
                                            }
                                            , {
                                                _v$: void 0,
                                                _v$2: void 0,
                                                _v$3: void 0
                                            }),
                                            Ot
                                        }
                                    })]
                                }
                            })
                        }
                    })]
                }
            })]
        }
    })
}
  , StyledModal = styled(Modal)`
    padding-left: 24px;
    padding-right: 24px;
    padding-top: 18px;
    padding-bottom: 0;

    ${media("mobile")} {
        padding-left: 0;
        padding-right: 0;

        min-height: 364px;
    }
`
  , H1Styled$8 = styled(H1)`
    margin-top: 12px;

    ${media("mobile")} {
        padding: 0 10px;
    }
`
  , LoaderContainerStyled = styled.div`
    margin: 30px 0;
    width: 100%;
    display: flex;
    justify-content: center;

    ${media("mobile")} {
        height: 160px;
        align-items: center;
    }
`;
styled(Text)`
    min-width: 84px;
    text-align: center;
    font-weight: 590;
`;
styled(TabBar)`
    margin: 0 auto 22px;
`;
const [appState,setAppState] = createStore({
    buttonRootId: null,
    language: "en",
    returnStrategy: "back",
    twaReturnUrl: void 0,
    walletsListConfiguration: {},
    enableAndroidBackHandler: !0
});
function uniq(r) {
    return [...new Set(r)]
}
function mergeConcat(r, d, f) {
    return d.map(m=>{
        const k = f.find(y=>y[r] === m[r]);
        return f = f.filter(y=>y[r] !== m[r]),
        k === void 0 ? m : k
    }
    ).concat(f)
}
function uiWalletToWalletInfo(r) {
    return "jsBridgeKey"in r ? __spreadProps(__spreadValues({}, r), {
        injected: TonConnect.isWalletInjected(r.jsBridgeKey),
        embedded: TonConnect.isInsideWalletBrowser(r.jsBridgeKey)
    }) : r
}
function applyWalletsListConfiguration(r, d) {
    var f;
    return d && (f = d.includeWallets) != null && f.length && (r = mergeConcat("name", r, d.includeWallets.map(uiWalletToWalletInfo))),
    r
}
function supportsDesktop(r) {
    return r.platforms.some(d=>["macos", "linux", "windows"].includes(d))
}
function supportsMobile(r) {
    return r.platforms.some(d=>["ios", "android"].includes(d))
}
function supportsExtension(r) {
    return r.platforms.some(d=>["chrome", "firefox", "safari"].includes(d))
}
function eqWalletName(r, d) {
    return d ? r.name.toLowerCase() === d.toLowerCase() || r.appName.toLowerCase() === d.toLowerCase() : !1
}
const DesktopSelectWalletModalStyled = styled.div`
    display: flex;
    flex-direction: column;
    align-items: center;
`
  , H1Styled$7 = styled(H1)`
    margin-bottom: 18px;
`;
styled.div`
    height: 1px;
    margin: 0 -24px;
    width: calc(100% + 48px);
    opacity: 0.12;
    background: ${r=>r.isShown ? r.theme.colors.icon.secondary : "transparent"};
    transition: background 0.15s ease-in-out;

    ${media("mobile")} {
        width: 100%;
    }
`;
const WalletsUl = styled.ul`
    display: grid;
    grid-template-columns: repeat(auto-fit, 92px);
    grid-template-rows: auto;
    align-content: flex-start;
    justify-content: center;
    row-gap: 8px;
    width: 100%;
    padding: 0 0 16px;
    align-self: flex-start;
    max-width: 400px;
    margin: 0 auto;

    > li {
        display: block;
        height: fit-content;
    }

    ${media("mobile")} {
        grid-template-columns: repeat(auto-fit, 82px);
    }
`;
styled(Button)`
    display: block;
    margin: 0 auto 1px;
    font-size: 15px;
`;
const StyledIconButton$3 = styled(IconButton)`
    position: absolute;
    top: 16px;
    left: 16px;
`
  , WalletLabeledItemStyled = styled(WalletLabeledItem)`
    height: 100%;
`
  , _tmpl$$2 = template$1("<li></li>")
  , AllWalletsListModal = r=>{
    const d = ()=>isMobile() ? void 0 : 510
      , f = ()=>isMobile() ? r.walletsList.filter(supportsMobile) : r.walletsList;
    return createComponent(DesktopSelectWalletModalStyled, {
        "data-tc-wallets-modal-list": "true",
        get children() {
            return [createComponent(StyledIconButton$3, {
                icon: "arrow",
                onClick: ()=>r.onBack()
            }), createComponent(H1Styled$7, {
                translationKey: "walletModal.wallets",
                children: "Wallets"
            }), createComponent(ScrollContainer, {
                get maxHeight() {
                    return d()
                },
                get children() {
                    return createComponent(WalletsUl, {
                        get children() {
                            return createComponent(For, {
                                get each() {
                                    return f()
                                },
                                children: m=>(()=>{
                                    const k = _tmpl$$2.cloneNode(!0);
                                    return insert(k, createComponent(WalletLabeledItemStyled, {
                                        wallet: m,
                                        onClick: ()=>r.onSelect(m)
                                    })),
                                    k
                                }
                                )()
                            })
                        }
                    })
                }
            })]
        }
    })
}
  , tgButtonBorders = {
    m: "16px",
    s: "12px",
    none: "0"
}
  , tgIconBorders = {
    m: "6px",
    s: "6px",
    none: "0"
}
  , DesktopConnectionModalStyled = styled.div`
    display: flex;
    flex-direction: column;
`
  , BodyStyled$1 = styled.div`
    flex: 1;
    margin-top: ${r=>r.qr ? "0" : "18px"};
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 232px;
`
  , QRCodeStyled$1 = styled(QRCode)`
    margin-bottom: 24px;
`
  , H1Styled$6 = styled(H1)`
    max-width: 288px;
    margin: 0 auto 2px;
`
  , H2Styled$4 = styled(H2)`
    max-width: 288px;
    text-align: center;
    margin: 0 auto 20px;
`
  , StyledIconButton$2 = styled(IconButton)`
    position: absolute;
    top: 16px;
    left: 16px;
`
  , ButtonsContainerStyled$1 = styled.div`
    display: flex;
    justify-content: center;
    gap: 8px;
    padding-bottom: 16px;
`
  , BottomButtonsContainerStyled = styled(ButtonsContainerStyled$1)`
    padding-bottom: 0;
`
  , FooterButton$1 = styled(Button)`
    margin-bottom: 24px;
`
  , LoaderStyled$1 = styled(LoaderIcon)`
    margin-bottom: 18px;
    margin-top: 2px;
`
  , ErrorIconStyled$1 = styled(ErrorIcon)`
    margin-bottom: 16px;
`
  , BodyTextStyled$1 = styled(H2)`
    color: ${r=>r.theme.colors.text.secondary};
    text-align: center;
    margin-bottom: 20px;
`
  , TgButtonStyled = styled(Button)`
    margin-top: -8px;
    margin-bottom: 24px;
    width: 100%;
    padding: 12px 12px 12px 20px;
    border-radius: ${r=>tgButtonBorders[r.theme.borderRadius]};
    font-size: 16px;
    line-height: 20px;
`
  , TgImageStyled = styled(Image)`
    width: 32px;
    height: 32px;
    border-radius: ${r=>tgIconBorders[r.theme.borderRadius]};
`
  , Translation = r=>{
    const [d] = useI18n();
    return createMemo(()=>{
        var f;
        return d(r.translationKey, r.translationValues, (f = r.children) == null ? void 0 : f.toString())
    }
    )
}
;
function addReturnStrategy(r, d) {
    let f;
    typeof d == "string" ? f = d : f = isInTMA() ? d.twaReturnUrl || d.returnStrategy : "none";
    const m = addQueryParameter(r, "ret", f);
    if (!isTelegramUrl(r))
        return m;
    const k = m.slice(m.lastIndexOf("&") + 1);
    return m.slice(0, m.lastIndexOf("&")) + "-" + encodeTelegramUrlParameters(k)
}
function redirectToTelegram(r, d) {
    d = __spreadValues({}, d);
    const f = convertToTGDirectLink(r)
      , m = new URL(f);
    if (m.searchParams.has("startapp") || m.searchParams.append("startapp", "tonconnect"),
    isInTMA())
        isTmaPlatform("ios", "android", "macos") ? (d.returnStrategy = "back",
        d.twaReturnUrl = void 0,
        sendOpenTelegramLink(addReturnStrategy(m.toString(), d))) : isTmaPlatform("tdesktop") || isTmaPlatform("weba") ? sendOpenTelegramLink(addReturnStrategy(m.toString(), d)) : isTmaPlatform("web") ? (d.returnStrategy = "back",
        d.twaReturnUrl = void 0,
        sendOpenTelegramLink(addReturnStrategy(m.toString(), d))) : openLinkBlank(addReturnStrategy(m.toString(), d));
    else if (isOS("ios")) {
        d.returnStrategy === "back" && (isBrowser("safari") ? d.returnStrategy = "back" : isBrowser("chrome") ? d.returnStrategy = "googlechrome://" : isBrowser("firefox") ? d.returnStrategy = "firefox://" : isBrowser("opera") ? d.returnStrategy = "opera-http://" : d.returnStrategy = location.href);
        const k = isBrowser("chrome")
          , y = isBrowser("firefox");
        if ((k || y) && !d.forceRedirect) {
            const dt = addReturnStrategy(m.toString(), d.returnStrategy)
              , mt = convertToTGDeepLink(dt);
            openDeeplinkWithFallback(mt, ()=>openLinkBlank(dt))
        } else {
            const dt = addReturnStrategy(m.toString(), d.returnStrategy);
            openLinkBlank(dt)
        }
    } else if (isOS("android")) {
        d.returnStrategy = "none";
        const k = isBrowser("chrome")
          , y = isBrowser("firefox");
        if ((k || y) && !d.forceRedirect) {
            const dt = addReturnStrategy(m.toString(), d.returnStrategy)
              , mt = convertToTGDeepLink(dt);
            openDeeplinkWithFallback(mt, ()=>openLinkBlank(dt))
        } else {
            const dt = addReturnStrategy(m.toString(), d.returnStrategy);
            openLinkBlank(dt)
        }
    } else if (isOS("ipad")) {
        d.returnStrategy === "back" && (isBrowser("safari") ? d.returnStrategy = "back" : isBrowser("chrome") ? d.returnStrategy = "googlechrome://" : isBrowser("firefox") ? d.returnStrategy = "firefox://" : isBrowser("opera") ? d.returnStrategy = "opera-http://" : d.returnStrategy = location.href);
        const k = isBrowser("chrome")
          , y = isBrowser("firefox");
        if ((k || y) && !d.forceRedirect) {
            const dt = addReturnStrategy(m.toString(), d.returnStrategy)
              , mt = convertToTGDeepLink(dt);
            openDeeplinkWithFallback(mt, ()=>openLinkBlank(dt))
        } else {
            const dt = addReturnStrategy(m.toString(), d.returnStrategy);
            openLinkBlank(dt)
        }
    } else if (isOS("macos", "windows", "linux"))
        if (d.returnStrategy = "none",
        d.twaReturnUrl = void 0,
        d.forceRedirect)
            openLinkBlank(addReturnStrategy(m.toString(), d));
        else {
            const k = addReturnStrategy(m.toString(), d)
              , y = convertToTGDeepLink(k);
            openDeeplinkWithFallback(y, ()=>openLinkBlank(k))
        }
    else
        openLinkBlank(addReturnStrategy(m.toString(), d))
}
function redirectToWallet(r, d, f, m) {
    if (f = __spreadValues({}, f),
    isInTMA())
        if (isTmaPlatform("ios", "android")) {
            f.returnStrategy === "back" && (f.returnStrategy = "tg://resolve"),
            m("universal-link");
            const k = addReturnStrategy(r, f.returnStrategy);
            sendOpenTelegramLink(k, ()=>{
                m("universal-link"),
                openLinkBlank(k)
            }
            )
        } else if (isTmaPlatform("macos", "tdesktop")) {
            f.returnStrategy === "back" && (f.returnStrategy = "tg://resolve");
            const k = addReturnStrategy(r, f.returnStrategy);
            !!d && !f.forceRedirect ? (m("custom-deeplink"),
            openDeeplinkWithFallback(toDeeplink(k, d), ()=>{
                m("universal-link"),
                openLinkBlank(k)
            }
            )) : (m("universal-link"),
            openLinkBlank(k))
        } else if (isTmaPlatform("weba")) {
            f.returnStrategy === "back" && (isBrowser("safari") ? f.returnStrategy = location.href : isBrowser("chrome") ? f.returnStrategy = "googlechrome://" : isBrowser("firefox") ? f.returnStrategy = "firefox://" : isBrowser("opera") ? f.returnStrategy = "opera-http://" : f.returnStrategy = location.href);
            const k = addReturnStrategy(r, f.returnStrategy);
            !!d && !f.forceRedirect ? (m("custom-deeplink"),
            openDeeplinkWithFallback(toDeeplink(k, d), ()=>{
                m("universal-link"),
                openLinkBlank(k)
            }
            )) : (m("universal-link"),
            openLinkBlank(k))
        } else if (isTmaPlatform("web")) {
            f.returnStrategy === "back" && (isBrowser("safari") ? f.returnStrategy = location.href : isBrowser("chrome") ? f.returnStrategy = "googlechrome://" : isBrowser("firefox") ? f.returnStrategy = "firefox://" : isBrowser("opera") ? f.returnStrategy = "opera-http://" : f.returnStrategy = location.href);
            const k = addReturnStrategy(r, f.returnStrategy);
            !!d && !f.forceRedirect ? (m("custom-deeplink"),
            openDeeplinkWithFallback(toDeeplink(k, d), ()=>{
                m("universal-link"),
                openLinkBlank(k)
            }
            )) : (m("universal-link"),
            openLinkBlank(k))
        } else {
            m("universal-link");
            const k = addReturnStrategy(r, f.returnStrategy);
            openLinkBlank(k)
        }
    else if (isOS("ios"))
        f.returnStrategy === "back" && (isBrowser("safari") ? f.returnStrategy = "none" : isBrowser("chrome") ? f.returnStrategy = "googlechrome://" : isBrowser("firefox") ? f.returnStrategy = "firefox://" : isBrowser("opera") ? f.returnStrategy = "opera-http://" : f.returnStrategy = location.href),
        isBrowser("chrome") ? (m("universal-link"),
        openLink(addReturnStrategy(r, f.returnStrategy), "_self")) : (m("universal-link"),
        openLinkBlank(addReturnStrategy(r, f.returnStrategy)));
    else if (isOS("android"))
        f.returnStrategy === "back" && (isBrowser("chrome") ? f.returnStrategy = "googlechrome://" : isBrowser("firefox") ? f.returnStrategy = "firefox://" : isBrowser("opera") ? f.returnStrategy = "opera-http://" : f.returnStrategy = location.href),
        m("universal-link"),
        openLinkBlank(addReturnStrategy(r, f.returnStrategy));
    else if (isOS("ipad"))
        f.returnStrategy === "back" && (isBrowser("safari") ? f.returnStrategy = "none" : isBrowser("chrome") ? f.returnStrategy = "googlechrome://" : isBrowser("firefox") ? f.returnStrategy = "firefox://" : isBrowser("opera") ? f.returnStrategy = "opera-http://" : f.returnStrategy = location.href),
        isBrowser("chrome") ? (m("universal-link"),
        openLink(addReturnStrategy(r, f.returnStrategy), "_self")) : (m("universal-link"),
        openLinkBlank(addReturnStrategy(r, f.returnStrategy)));
    else if (isOS("macos", "windows", "linux")) {
        f.returnStrategy === "back" && (isBrowser("safari") ? f.returnStrategy = "none" : isBrowser("chrome") ? f.returnStrategy = "googlechrome://" : isBrowser("firefox") ? f.returnStrategy = "firefox://" : isBrowser("opera") ? f.returnStrategy = "opera-http://" : f.returnStrategy = "none");
        const k = addReturnStrategy(r, f.returnStrategy);
        !!d && !f.forceRedirect ? (m("custom-deeplink"),
        openDeeplinkWithFallback(toDeeplink(k, d), ()=>{
            m("universal-link"),
            openLinkBlank(k)
        }
        )) : (m("universal-link"),
        openLinkBlank(k))
    } else
        m("universal-link"),
        openLinkBlank(addReturnStrategy(r, f.returnStrategy))
}
function addQueryParameter(r, d, f) {
    const m = new URL(r);
    return m.searchParams.append(d, f),
    m.toString()
}
function convertToTGDirectLink(r) {
    const d = new URL(r);
    return d.searchParams.has("attach") && (d.searchParams.delete("attach"),
    d.pathname += "/start"),
    d.toString()
}
function convertToTGDeepLink(r) {
    const d = new URL(r)
      , [,f,m] = d.pathname.split("/")
      , k = d.searchParams.get("startapp");
    return `tg://resolve?domain=${f}&appname=${m}&startapp=${k}`
}
const DesktopConnectionModal = r=>{
    const [d,f] = createSignal("mobile")
      , [m,k] = createSignal(!1)
      , [y,ee] = createSignal()
      , [dt,mt] = createSignal(!0)
      , yt = useContext(ConnectorContext)
      , pt = yt.onStatusChange(()=>{}
    , ()=>{
        r.wallet.appName !== AT_WALLET_APP_NAME && k(!0)
    }
    );
    onCleanup(pt);
    const bt = ()=>{
        try {
            const Pt = yt.connect({
                universalLink: r.wallet.universalLink,
                bridgeUrl: r.wallet.bridgeUrl
            }, r.additionalRequest);
            ee(Pt)
        } catch {}
    }
    ;
    createEffect(()=>{
        untrack(d) !== "extension" && (supportsMobile(r.wallet) || supportsDesktop(r.wallet)) && bt()
    }
    );
    const wt = ()=>{
        k(!1),
        d() === "extension" && bt(),
        f("mobile"),
        setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, r.wallet), {
            openMethod: "qrcode"
        }))
    }
      , xt = ()=>{
        k(!1),
        d() === "extension" && bt(),
        f("desktop");
        const Pt = !dt();
        mt(!1),
        redirectToWallet(y(), r.wallet.deepLink, {
            returnStrategy: appState.returnStrategy,
            forceRedirect: Pt
        }, $t=>{
            setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, r.wallet), {
                openMethod: $t
            }))
        }
        )
    }
      , At = ()=>{
        const Pt = !dt();
        mt(!1),
        setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, r.wallet), {
            openMethod: "universal-link"
        })),
        redirectToTelegram(y(), {
            returnStrategy: appState.returnStrategy,
            twaReturnUrl: appState.twaReturnUrl,
            forceRedirect: Pt
        })
    }
      , Ct = ()=>{
        k(!1),
        f("extension"),
        isWalletInfoCurrentlyInjected(r.wallet) && (setLastSelectedWalletInfo(r.wallet),
        yt.connect({
            jsBridgeKey: r.wallet.jsBridgeKey
        }, r.additionalRequest))
    }
    ;
    return supportsMobile(r.wallet) ? wt() : supportsExtension(r.wallet) ? Ct() : xt(),
    createComponent(DesktopConnectionModalStyled, {
        "data-tc-wallets-modal-connection-desktop": "true",
        get children() {
            return [createComponent(Show, {
                get when() {
                    return !r.backDisabled
                },
                get children() {
                    return createComponent(StyledIconButton$2, {
                        icon: "arrow",
                        onClick: ()=>r.onBackClick()
                    })
                }
            }), createComponent(H1Styled$6, {
                get children() {
                    return r.wallet.name
                }
            }), createComponent(Show, {
                get when() {
                    return d() === "mobile"
                },
                get children() {
                    return createComponent(H2Styled$4, {
                        translationKey: "walletModal.desktopConnectionModal.scanQR",
                        get translationValues() {
                            return {
                                name: r.wallet.name
                            }
                        },
                        get children() {
                            return ["Scan the QR code below with your phone’s or ", createMemo(()=>r.wallet.name), "’s camera"]
                        }
                    })
                }
            }), createComponent(BodyStyled$1, {
                get qr() {
                    return d() === "mobile"
                },
                get children() {
                    return createComponent(Switch, {
                        get children() {
                            return [createComponent(Match, {
                                get when() {
                                    return d() === "mobile"
                                },
                                get children() {
                                    return createComponent(QRCodeStyled$1, {
                                        disableCopy: !1,
                                        get sourceUrl() {
                                            return addReturnStrategy(y(), "none")
                                        },
                                        get imageUrl() {
                                            return r.wallet.imageUrl
                                        }
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return m()
                                },
                                get children() {
                                    return [createComponent(ErrorIconStyled$1, {
                                        size: "s"
                                    }), createComponent(BodyTextStyled$1, {
                                        translationKey: "walletModal.desktopConnectionModal.connectionDeclined",
                                        children: "Connection declined"
                                    }), createComponent(ButtonsContainerStyled$1, {
                                        get children() {
                                            return createComponent(Button, {
                                                get leftIcon() {
                                                    return createComponent(RetryIcon, {})
                                                },
                                                get onClick() {
                                                    return d() === "extension" ? Ct : xt
                                                },
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "common.retry",
                                                        children: "Retry"
                                                    })
                                                }
                                            })
                                        }
                                    })]
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return d() === "extension"
                                },
                                get children() {
                                    return [createComponent(Show, {
                                        get when() {
                                            return isWalletInfoCurrentlyInjected(r.wallet)
                                        },
                                        get children() {
                                            return [createComponent(LoaderStyled$1, {
                                                size: "s"
                                            }), createComponent(BodyTextStyled$1, {
                                                translationKey: "walletModal.desktopConnectionModal.continueInExtension",
                                                get translationValues() {
                                                    return {
                                                        name: r.wallet.name
                                                    }
                                                },
                                                get children() {
                                                    return ["Continue in ", createMemo(()=>r.wallet.name), " browser extension…"]
                                                }
                                            }), createComponent(ButtonsContainerStyled$1, {
                                                get children() {
                                                    return createComponent(Button, {
                                                        get leftIcon() {
                                                            return createComponent(RetryIcon, {})
                                                        },
                                                        onClick: Ct,
                                                        get children() {
                                                            return createComponent(Translation, {
                                                                translationKey: "common.retry",
                                                                children: "Retry"
                                                            })
                                                        }
                                                    })
                                                }
                                            })]
                                        }
                                    }), createComponent(Show, {
                                        get when() {
                                            return !isWalletInfoCurrentlyInjected(r.wallet)
                                        },
                                        get children() {
                                            return [createComponent(BodyTextStyled$1, {
                                                translationKey: "walletModal.desktopConnectionModal.dontHaveExtension",
                                                get translationValues() {
                                                    return {
                                                        name: r.wallet.name
                                                    }
                                                },
                                                get children() {
                                                    return ["Seems you don't have installed ", createMemo(()=>r.wallet.name), " browser extension"]
                                                }
                                            }), createComponent(ButtonsContainerStyled$1, {
                                                get children() {
                                                    return createComponent(Link, {
                                                        get href() {
                                                            return r.wallet.aboutUrl
                                                        },
                                                        blank: !0,
                                                        get children() {
                                                            return createComponent(Button, {
                                                                get rightIcon() {
                                                                    return createComponent(LinkIcon, {})
                                                                },
                                                                onClick: Ct,
                                                                get children() {
                                                                    return createComponent(Translation, {
                                                                        translationKey: "walletModal.desktopConnectionModal.getWallet",
                                                                        get translationValues() {
                                                                            return {
                                                                                name: r.wallet.name
                                                                            }
                                                                        },
                                                                        get children() {
                                                                            return ["Get ", createMemo(()=>r.wallet.name)]
                                                                        }
                                                                    })
                                                                }
                                                            })
                                                        }
                                                    })
                                                }
                                            })]
                                        }
                                    })]
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return d() === "desktop"
                                },
                                get children() {
                                    return [createComponent(LoaderIcon, {
                                        size: "m"
                                    }), createComponent(BodyTextStyled$1, {
                                        translationKey: "walletModal.desktopConnectionModal.continueOnDesktop",
                                        get translationValues() {
                                            return {
                                                name: r.wallet.name
                                            }
                                        },
                                        get children() {
                                            return ["Continue in ", createMemo(()=>r.wallet.name), " on desktop…"]
                                        }
                                    }), createComponent(ButtonsContainerStyled$1, {
                                        get children() {
                                            return [createComponent(Button, {
                                                get leftIcon() {
                                                    return createComponent(RetryIcon, {})
                                                },
                                                onClick: xt,
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "common.retry",
                                                        children: "Retry"
                                                    })
                                                }
                                            }), createComponent(Link, {
                                                get href() {
                                                    return r.wallet.aboutUrl
                                                },
                                                blank: !0,
                                                get children() {
                                                    return createComponent(Button, {
                                                        get rightIcon() {
                                                            return createComponent(LinkIcon, {})
                                                        },
                                                        get children() {
                                                            return createComponent(Translation, {
                                                                translationKey: "walletModal.desktopConnectionModal.getWallet",
                                                                get translationValues() {
                                                                    return {
                                                                        name: r.wallet.name
                                                                    }
                                                                },
                                                                get children() {
                                                                    return ["Get ", createMemo(()=>r.wallet.name)]
                                                                }
                                                            })
                                                        }
                                                    })
                                                }
                                            })]
                                        }
                                    })]
                                }
                            })]
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return r.wallet.appName === AT_WALLET_APP_NAME
                },
                get children() {
                    return createComponent(TgButtonStyled, {
                        get rightIcon() {
                            return createComponent(TgImageStyled, {
                                get src() {
                                    return IMG.TG
                                }
                            })
                        },
                        scale: "s",
                        onClick: At,
                        get children() {
                            return createComponent(Translation, {
                                translationKey: "walletModal.desktopConnectionModal.openWalletOnTelegram",
                                children: "Open Wallet in Telegram on desktop"
                            })
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return r.wallet.appName !== AT_WALLET_APP_NAME
                },
                get children() {
                    return createComponent(BottomButtonsContainerStyled, {
                        get children() {
                            return [createComponent(Show, {
                                get when() {
                                    return createMemo(()=>d() !== "mobile")() && supportsMobile(r.wallet)
                                },
                                get children() {
                                    return createComponent(FooterButton$1, {
                                        appearance: "secondary",
                                        get leftIcon() {
                                            return createComponent(MobileIcon, {})
                                        },
                                        onClick: wt,
                                        get children() {
                                            return createComponent(Translation, {
                                                translationKey: "common.mobile",
                                                children: "Mobile"
                                            })
                                        }
                                    })
                                }
                            }), createComponent(Show, {
                                get when() {
                                    return createMemo(()=>d() !== "extension")() && supportsExtension(r.wallet)
                                },
                                get children() {
                                    return createComponent(FooterButton$1, {
                                        appearance: "secondary",
                                        get leftIcon() {
                                            return createComponent(BrowserIcon, {})
                                        },
                                        onClick: Ct,
                                        get children() {
                                            return createComponent(Translation, {
                                                translationKey: "common.browserExtension",
                                                children: "Browser Extension"
                                            })
                                        }
                                    })
                                }
                            }), createComponent(Show, {
                                get when() {
                                    return createMemo(()=>d() !== "desktop")() && supportsDesktop(r.wallet)
                                },
                                get children() {
                                    return createComponent(FooterButton$1, {
                                        appearance: "secondary",
                                        get leftIcon() {
                                            return createComponent(DesktopIcon, {})
                                        },
                                        onClick: xt,
                                        get children() {
                                            return createComponent(Translation, {
                                                translationKey: "common.desktop",
                                                children: "Desktop"
                                            })
                                        }
                                    })
                                }
                            })]
                        }
                    })
                }
            })]
        }
    })
}
  , InfoModalStyled = styled.div``
  , StyledIconButton$1 = styled(IconButton)`
    position: absolute;
    top: 16px;
    left: 16px;
`
  , H1Styled$5 = styled(H1)`
    margin-bottom: 18px;
`
  , InfoBlock = styled.div`
    padding: 16px 0;
    display: flex;
    flex-direction: column;
    align-items: center;
`
  , InfoBlockIconClass = u$1`
    margin-bottom: 12px;
`
  , H3Styled = styled(H3)`
    text-align: center;
    margin-bottom: 4px;
`
  , TextStyled$1 = styled(Text)`
    text-align: center;
    max-width: 352px;
    color: ${r=>r.theme.colors.text.secondary};
`
  , ButtonsBlock = styled.div`
    padding: 16px 24px 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
`
  , LINKS = {
    GET_A_WALLET: "https://ton.org/wallets?filters[wallet_features][slug][$in]=dapp-auth&pagination[limit]=-1"
}
  , InfoModal = r=>createComponent(InfoModalStyled, {
    "data-tc-wallets-modal-info": "true",
    get children() {
        return [createComponent(StyledIconButton$1, {
            icon: "arrow",
            onClick: ()=>r.onBackClick()
        }), createComponent(H1Styled$5, {
            translationKey: "walletModal.infoModal.whatIsAWallet",
            children: "What is a wallet"
        }), createComponent(ScrollContainer, {
            get children() {
                return [createComponent(InfoBlock, {
                    get children() {
                        return [createComponent(SecurityIcon, {
                            class: InfoBlockIconClass
                        }), createComponent(H3Styled, {
                            translationKey: "walletModal.infoModal.secureDigitalAssets",
                            children: "Secure digital assets storage"
                        }), createComponent(TextStyled$1, {
                            translationKey: "walletModal.infoModal.walletProtects",
                            children: "A wallet protects and manages your digital assets including TON, tokens and collectables."
                        })]
                    }
                }), createComponent(InfoBlock, {
                    get children() {
                        return [createComponent(PersonalityIcon, {
                            class: InfoBlockIconClass
                        }), createComponent(H3Styled, {
                            translationKey: "walletModal.infoModal.controlIdentity",
                            children: "Control your Web3 identity"
                        }), createComponent(TextStyled$1, {
                            translationKey: "walletModal.infoModal.manageIdentity",
                            children: "Manage your digital identity and access decentralized applications with ease. Maintain control over your data and engage securely in the blockchain ecosystem."
                        })]
                    }
                }), createComponent(InfoBlock, {
                    get children() {
                        return [createComponent(SwapIcon, {
                            class: InfoBlockIconClass
                        }), createComponent(H3Styled, {
                            translationKey: "walletModal.infoModal.effortlessCryptoTransactions",
                            children: "Effortless crypto transactions"
                        }), createComponent(TextStyled$1, {
                            translationKey: "walletModal.infoModal.easilySend",
                            children: "Easily send, receive, monitor your cryptocurrencies. Streamline your operations with decentralized applications."
                        })]
                    }
                }), createComponent(ButtonsBlock, {
                    get children() {
                        return createComponent(Link, {
                            get href() {
                                return LINKS.GET_A_WALLET
                            },
                            blank: !0,
                            get children() {
                                return createComponent(Button, {
                                    get rightIcon() {
                                        return createComponent(WalletIcon, {})
                                    },
                                    get children() {
                                        return createComponent(Translation, {
                                            translationKey: "walletModal.infoModal.getAWallet",
                                            children: "Get a Wallet"
                                        })
                                    }
                                })
                            }
                        })
                    }
                })]
            }
        })]
    }
})
  , MobileConnectionModalStyled = styled.div``
  , BodyStyled = styled.div`
    flex: 1;
    margin-top: 18px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 232px;
`
  , H1Styled$4 = styled(H1)`
    max-width: 262px;
    margin: 0 auto 8px;
`
  , StyledIconButton = styled(IconButton)`
    position: absolute;
    top: 16px;
    left: 16px;
`
  , FooterStyled = styled.div`
    padding: 16px;
    display: flex;
    align-items: center;
    gap: 12px;
    border-top: 0.5px solid ${r=>rgba(r.theme.colors.icon.secondary, .2)};
`
  , ImageStyled = styled(Image)`
    width: 36px;
    height: 36px;
    border-radius: 10px;
`
  , FooterButton = styled(Link)`
    margin-left: auto;
`
  , LoaderStyled = styled(LoaderIcon)`
    margin-bottom: 18px;
    margin-top: 2px;
`
  , ErrorIconStyled = styled(ErrorIcon)`
    margin-bottom: 16px;
`
  , BodyTextStyled = styled(H2)`
    color: ${r=>r.theme.colors.text.secondary};
    text-align: center;
    margin-bottom: 20px;
`
  , ButtonsContainerStyled = styled.div`
    display: flex;
    justify-content: center;
    gap: 8px;
    padding-bottom: 16px;
`
  , H1Styled$3 = styled(H1)`
    margin-bottom: 2px;
    padding: 0 64px;
`
  , H2Styled$3 = styled(H2)`
    margin-bottom: 20px;
    padding: 0 64px;
    min-height: 44px;
`
  , QrCodeWrapper$1 = styled.div`
    padding: 0 24px 24px;
`
  , MobileConnectionQR = r=>[createComponent(H1Styled$3, {
    get children() {
        return r.walletInfo.name
    }
}), createComponent(H2Styled$3, {
    translationKey: "walletModal.mobileConnectionModal.scanQR",
    get translationValues() {
        return {
            name: r.walletInfo.name
        }
    },
    get children() {
        return ["Scan the QR code below with your phone’s or ", createMemo(()=>r.walletInfo.name), "’s camera"]
    }
}), createComponent(QrCodeWrapper$1, {
    get children() {
        return createComponent(QRCode, {
            get imageUrl() {
                return r.walletInfo.imageUrl
            },
            get sourceUrl() {
                return addReturnStrategy(r.universalLink, "none")
            },
            disableCopy: !0
        })
    }
})]
  , MobileConnectionModal = r=>{
    const d = useTheme()
      , [f,m] = createSignal(!0)
      , [k,y] = createSignal(!1)
      , [ee,dt] = createSignal(!1)
      , mt = useContext(ConnectorContext)
      , yt = mt.onStatusChange(()=>{}
    , ()=>{
        dt(!0)
    }
    )
      , pt = createMemo(()=>mt.connect({
        universalLink: r.wallet.universalLink,
        bridgeUrl: r.wallet.bridgeUrl
    }, r.additionalRequest))
      , bt = ()=>{
        setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, r.wallet), {
            openMethod: "universal-link"
        })),
        redirectToTelegram(pt(), {
            returnStrategy: appState.returnStrategy,
            twaReturnUrl: appState.twaReturnUrl,
            forceRedirect: !0
        })
    }
      , wt = ()=>{
        const Pt = pt();
        if (isTelegramUrl(Pt))
            return bt();
        dt(!1);
        const $t = !f();
        m(!1),
        redirectToWallet(pt(), r.wallet.deepLink, {
            returnStrategy: appState.returnStrategy,
            forceRedirect: $t
        }, Ot=>{
            setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, r.wallet), {
                openMethod: Ot
            }))
        }
        )
    }
      , xt = ()=>{
        dt(!1),
        y(!0),
        setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, r.wallet), {
            openMethod: "qrcode"
        }))
    }
      , At = ()=>{
        y(!1),
        setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, r.wallet), {
            openMethod: "universal-link"
        }))
    }
      , Ct = ()=>{
        k() ? At() : r.onBackClick()
    }
    ;
    return onCleanup(yt),
    wt(),
    createComponent(MobileConnectionModalStyled, {
        "data-tc-wallets-modal-connection-mobile": "true",
        get children() {
            return [createComponent(Show, {
                get when() {
                    return !r.backDisabled || k()
                },
                get children() {
                    return createComponent(StyledIconButton, {
                        icon: "arrow",
                        onClick: Ct
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return k()
                },
                get children() {
                    return createComponent(MobileConnectionQR, {
                        get universalLink() {
                            return pt()
                        },
                        get walletInfo() {
                            return r.wallet
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return !k()
                },
                get children() {
                    return [createComponent(H1Styled$4, {
                        get children() {
                            return r.wallet.name
                        }
                    }), createComponent(BodyStyled, {
                        get children() {
                            return [createComponent(Show, {
                                get when() {
                                    return ee()
                                },
                                get children() {
                                    return [createComponent(ErrorIconStyled, {
                                        size: "s"
                                    }), createComponent(BodyTextStyled, {
                                        translationKey: "walletModal.mobileConnectionModal.connectionDeclined",
                                        children: "Connection declined"
                                    }), createComponent(ButtonsContainerStyled, {
                                        get children() {
                                            return [createComponent(Button, {
                                                get leftIcon() {
                                                    return createComponent(RetryIcon, {})
                                                },
                                                onClick: wt,
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "common.retry",
                                                        children: "Retry"
                                                    })
                                                }
                                            }), createComponent(Button, {
                                                get leftIcon() {
                                                    return createComponent(QRIcon, {
                                                        get fill() {
                                                            return d.colors.accent
                                                        }
                                                    })
                                                },
                                                onClick: xt,
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "walletModal.mobileConnectionModal.showQR",
                                                        children: "Show QR Code"
                                                    })
                                                }
                                            })]
                                        }
                                    })]
                                }
                            }), createComponent(Show, {
                                get when() {
                                    return !ee()
                                },
                                get children() {
                                    return [createComponent(LoaderStyled, {
                                        size: "s"
                                    }), createComponent(BodyTextStyled, {
                                        translationKey: "walletModal.mobileConnectionModal.continueIn",
                                        get translationValues() {
                                            return {
                                                name: r.wallet.name
                                            }
                                        },
                                        get children() {
                                            return ["Continue in ", createMemo(()=>r.wallet.name), "…"]
                                        }
                                    }), createComponent(ButtonsContainerStyled, {
                                        get children() {
                                            return [createComponent(Button, {
                                                get leftIcon() {
                                                    return createComponent(RetryIcon, {})
                                                },
                                                onClick: wt,
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "common.retry",
                                                        children: "Retry"
                                                    })
                                                }
                                            }), createComponent(Button, {
                                                get leftIcon() {
                                                    return createComponent(QRIcon, {
                                                        get fill() {
                                                            return d.colors.accent
                                                        }
                                                    })
                                                },
                                                onClick: xt,
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "walletModal.mobileConnectionModal.showQR",
                                                        children: "Show QR Code"
                                                    })
                                                }
                                            })]
                                        }
                                    })]
                                }
                            })]
                        }
                    }), createComponent(FooterStyled, {
                        get children() {
                            return [createComponent(ImageStyled, {
                                get src() {
                                    return r.wallet.imageUrl
                                }
                            }), createComponent(H3, {
                                get children() {
                                    return r.wallet.name
                                }
                            }), createComponent(FooterButton, {
                                get href() {
                                    return r.wallet.aboutUrl
                                },
                                blank: !0,
                                get children() {
                                    return createComponent(Button, {
                                        get children() {
                                            return createComponent(Translation, {
                                                translationKey: "common.get",
                                                children: "GET"
                                            })
                                        }
                                    })
                                }
                            })]
                        }
                    })]
                }
            })]
        }
    })
}
  , borders$1 = {
    m: "16px",
    s: "12px",
    none: "0"
}
  , tgBorders = {
    m: "6px",
    s: "6px",
    none: "0"
}
  , UlStyled = styled.ul`
    display: flex;
    justify-content: space-between;
    margin: 0 auto;
    width: fit-content;
    max-width: 100%;
    min-width: 100%;
    height: fit-content;
    overflow-x: auto;
    overflow-y: hidden;
    padding: 0 13px 24px;

    &&::-webkit-scrollbar {
        display: none;
    }

    -ms-overflow-style: none;
    scrollbar-width: none;

    > li {
        height: fit-content;
    }
`
  , OtherOptionButton = styled.li`
    width: 82px;
    min-width: 82px;
    height: 124px;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 8px 4px;

    text-align: center;
    cursor: pointer;

    transition: transform 0.1s ease-in-out;

    ${mediaNotTouch} {
        &:hover {
            transform: scale(1.04);
        }
    }

    &:active {
        transform: scale(0.96);
    }

    ${mediaTouch} {
        &:active {
            transform: scale(0.92);
        }
    }
`
  , Divider = styled.div`
    width: 1px;
    margin: 0 10px;
    height: 24px;
    position: relative;
    top: 26px;

    background-color: ${r=>r.theme.colors.icon.secondary};
    opacity: 0.2;
`
  , IconContainer = styled.div`
    width: 60px;
    height: 60px;
    border-radius: ${r=>borders$1[r.theme.borderRadius]};
    display: flex;
    align-items: center;
    justify-content: center;

    background-color: ${r=>r.theme.colors.background.tint};
    margin-bottom: 8px;
`
  , H1Styled$2 = styled(H1)`
    margin-top: 38px;
    margin-bottom: 4px;
    padding: 0 24px;
`
  , H2Styled$2 = styled(H2)`
    margin-bottom: 24px;
    padding: 0 24px;
    min-height: 44px;
`;
styled(Button)`
    display: block;
    margin: 0 auto;
`;
const TelegramButtonStyled = styled(Button)`
    margin: 0 24px 24px;
    width: calc(100% - 48px);
    border-radius: ${r=>borders$1[r.theme.borderRadius]};
    padding: 14px 16px 14px 14px;
    background-color: ${r=>r.theme.colors.telegramButton};

    color: ${r=>r.theme.colors.constant.white};
    font-weight: 590;
    font-size: 16px;
    line-height: 20px;
`
  , TGImageStyled = styled(Image)`
    border-radius: ${r=>tgBorders[r.theme.borderRadius]};
    width: 24px;
    height: 24px;
`
  , StyledLeftActionButton = styled(IconButton)`
    position: absolute;
    top: 16px;
    left: 16px;
`
  , H1Styled$1 = styled(H1)`
    margin-bottom: 2px;
    padding: 0 64px;
`
  , H2Styled$1 = styled(H2)`
    margin-bottom: 20px;
    padding: 0 64px;
`
  , QrCodeWrapper = styled.div`
    padding: 0 24px 24px;
`
  , MobileUniversalQR = r=>[createComponent(H1Styled$1, {
    translationKey: "walletModal.mobileUniversalModal.connectYourWallet",
    children: "Connect your wallet"
}), createComponent(H2Styled$1, {
    translationKey: "walletModal.mobileUniversalModal.scan",
    children: "Scan with your mobile wallet"
}), createComponent(QrCodeWrapper, {
    get children() {
        return createComponent(QRCode, {
            get imageUrl() {
                return IMG.TON
            },
            get sourceUrl() {
                return addReturnStrategy(r.universalLink, "none")
            },
            disableCopy: !0
        })
    }
})];
function getUniqueBridges(r) {
    const d = new Set(r.filter(isWalletInfoRemote).map(f=>f.bridgeUrl));
    return Array.from(d).map(f=>({
        bridgeUrl: f
    }))
}
function bridgesIsEqual(r, d) {
    const f = new Set(r == null ? void 0 : r.map(k=>k.bridgeUrl))
      , m = new Set(d == null ? void 0 : d.map(k=>k.bridgeUrl));
    return f.size === m.size && [...f].every(k=>m.has(k))
}
const _tmpl$$1 = template$1("<li></li>")
  , _tmpl$2 = template$1('<div data-tc-wallets-modal-universal-mobile="true"></div>')
  , MobileUniversalModal = r=>{
    const [d,f] = createSignal(!1)
      , [m,k] = createSignal(!0)
      , [y,ee] = createSignal(null)
      , dt = appState.connector
      , mt = ()=>r.walletsList.filter(Nt=>supportsMobile(Nt) && Nt.appName !== AT_WALLET_APP_NAME)
      , yt = ()=>mt().length > 7
      , pt = createMemo(()=>getUniqueBridges(r.walletsList), null, {
        equals: bridgesIsEqual
    })
      , bt = ()=>(y() || ee(dt.connect(pt(), r.additionalRequest)),
    y());
    setLastSelectedWalletInfo({
        openMethod: "universal-link"
    });
    const [wt,xt] = createSignal(void 0)
      , At = ()=>__async(void 0, null, function*() {
        wt() !== void 0 && clearTimeout(wt()),
        yield copyToClipboard(bt());
        const Nt = setTimeout(()=>xt(void 0), 1500);
        xt(Nt)
    })
      , Ct = ()=>{
        const Nt = !m();
        k(!1),
        redirectToWallet(bt(), void 0, {
            returnStrategy: appState.returnStrategy,
            forceRedirect: Nt
        }, zt=>{
            setLastSelectedWalletInfo({
                openMethod: zt
            })
        }
        )
    }
      , Pt = ()=>{
        ee(null);
        const Nt = r.walletsList.find(Kt=>Kt.appName === AT_WALLET_APP_NAME);
        if (!Nt || !isWalletInfoRemote(Nt))
            throw new TonConnectUIError("@wallet bot not found in the wallets list");
        const zt = dt.connect({
            bridgeUrl: Nt.bridgeUrl,
            universalLink: Nt.universalLink
        }, r.additionalRequest)
          , Wt = !m();
        k(!1),
        redirectToTelegram(zt, {
            returnStrategy: appState.returnStrategy,
            twaReturnUrl: appState.twaReturnUrl,
            forceRedirect: Wt
        })
    }
      , $t = ()=>{
        f(!0),
        setLastSelectedWalletInfo({
            openMethod: "qrcode"
        })
    }
      , Ot = ()=>{
        f(!1),
        setLastSelectedWalletInfo({
            openMethod: "universal-link"
        })
    }
    ;
    return (()=>{
        const Nt = _tmpl$2.cloneNode(!0);
        return insert(Nt, createComponent(Show, {
            get when() {
                return d()
            },
            get children() {
                return [createComponent(StyledLeftActionButton, {
                    icon: "arrow",
                    onClick: Ot
                }), createComponent(MobileUniversalQR, {
                    get universalLink() {
                        return bt()
                    }
                })]
            }
        }), null),
        insert(Nt, createComponent(Show, {
            get when() {
                return !d()
            },
            get children() {
                return [createComponent(StyledLeftActionButton, {
                    get icon() {
                        return createComponent(QRIcon, {})
                    },
                    onClick: $t
                }), createComponent(H1Styled$2, {
                    translationKey: "walletModal.mobileUniversalModal.connectYourWallet",
                    children: "Connect your wallet"
                }), createComponent(H2Styled$2, {
                    translationKey: "walletModal.mobileUniversalModal.openWalletOnTelegramOrSelect",
                    children: "Open Wallet in Telegram or select your wallet to connect"
                }), createComponent(TelegramButtonStyled, {
                    get leftIcon() {
                        return createComponent(AtWalletIcon, {})
                    },
                    get rightIcon() {
                        return createComponent(TGImageStyled, {
                            get src() {
                                return IMG.TG
                            }
                        })
                    },
                    onClick: Pt,
                    scale: "s",
                    get children() {
                        return createComponent(Translation, {
                            translationKey: "walletModal.mobileUniversalModal.openWalletOnTelegram",
                            children: "Open Wallet in Telegram"
                        })
                    }
                }), createComponent(UlStyled, {
                    get children() {
                        return [createComponent(For, {
                            get each() {
                                return createMemo(()=>!!yt())() ? mt().slice(0, 4) : mt()
                            },
                            children: zt=>(()=>{
                                const Wt = _tmpl$$1.cloneNode(!0);
                                return insert(Wt, createComponent(WalletItem, {
                                    get icon() {
                                        return zt.imageUrl
                                    },
                                    get name() {
                                        return zt.name
                                    },
                                    onClick: ()=>r.onSelect(zt)
                                })),
                                Wt
                            }
                            )()
                        }), createComponent(Show, {
                            get when() {
                                return yt()
                            },
                            get children() {
                                const zt = _tmpl$$1.cloneNode(!0);
                                return insert(zt, createComponent(FourWalletsItem, {
                                    labelLine1: "View all",
                                    labelLine2: "wallets",
                                    get images() {
                                        return mt().slice(3, 7).map(Wt=>Wt.imageUrl)
                                    },
                                    onClick: ()=>r.onSelectAllWallets()
                                })),
                                zt
                            }
                        }), createComponent(Divider, {
                            children: " "
                        }), createComponent(OtherOptionButton, {
                            onClick: Ct,
                            get children() {
                                return [createComponent(IconContainer, {
                                    get children() {
                                        return createComponent(LongArrowIcon, {})
                                    }
                                }), createComponent(Text, {
                                    fontWeight: 590,
                                    translationKey: "walletModal.mobileUniversalModal.openLink",
                                    children: "Open Link"
                                })]
                            }
                        }), createComponent(OtherOptionButton, {
                            onClick: At,
                            get children() {
                                return [createComponent(IconContainer, {
                                    get children() {
                                        return createMemo(()=>wt() !== void 0)() ? createComponent(DoneIcon, {}) : createComponent(CopyLightIcon, {})
                                    }
                                }), createComponent(Text, {
                                    fontWeight: 590,
                                    get translationKey() {
                                        return wt() !== void 0 ? "common.copied" : "common.copyLink"
                                    },
                                    get children() {
                                        return wt() !== void 0 ? "Copied" : "Copy Link"
                                    }
                                })]
                            }
                        })]
                    }
                })]
            }
        }), null),
        Nt
    }
    )()
}
  , borders = {
    m: "16px",
    s: "8px",
    none: "0"
}
  , hoverBorders = {
    m: "8px",
    s: "4px",
    none: "0"
}
  , DesktopUniversalModalStyled = styled.div`
    display: flex;
    flex-direction: column;
    align-items: center;
    padding-bottom: 16px;
`
  , H2Styled = styled(H2)`
    max-width: 320px;
    margin-top: 2px;
    margin-bottom: 20px;
`
  , H2AvailableWalletsStyled = styled(H2)`
    margin-bottom: 16px;
`
  , QRCodeStyled = styled(QRCode)`
    margin-bottom: 24px;
`
  , WalletsContainerStyled = styled.ul`
    display: flex;
`;
styled.div`
    display: flex;
    gap: 16px;
    width: 100%;
`;
styled(Button)`
    position: relative;
    font-size: 16px;
    line-height: 20px;
    width: 100%;
    padding: 0 16px;
    height: 56px;
    border-radius: ${r=>borders[r.theme.borderRadius]};

    &:hover {
        ${r=>r.disableEventsAnimation ? "transform: unset;" : ""}
    }

    &:active {
        ${r=>r.disableEventsAnimation ? "transform: unset;" : ""}
    }
`;
styled.ul`
    position: absolute;
    bottom: 100%;
    left: 0;
    margin: 0;
    padding: 8px;
    width: 188px;
    transform: translateY(-16px);

    background-color: ${r=>r.theme.colors.background.primary};
    border-radius: ${r=>borders[r.theme.borderRadius]};
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);
`;
styled.li`
    padding: 8px;

    display: flex;
    align-items: center;
    gap: 8px;

    cursor: pointer;
    border-radius: ${r=>hoverBorders[r.theme.borderRadius]};

    transition: background-color, transform 0.1s ease-in-out;

    &:hover {
        background-color: ${r=>r.theme.colors.background.secondary};
    }

    &:active {
        transform: scale(0.96);
    }
`;
styled(Image)`
    width: 24px;
    height: 24px;

    border-radius: 6px;
`;
styled.div`
    margin-top: 23px;
    margin-bottom: 1px;
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
`;
styled(Text)`
    color: ${r=>r.theme.colors.text.secondary};
    font-size: 16px;
`;
const _tmpl$ = template$1("<li></li>")
  , DesktopUniversalModal = r=>{
    const [d,f] = createSignal(!1)
      , m = appState.connector
      , k = createMemo(()=>getUniqueBridges(r.walletsList), null, {
        equals: bridgesIsEqual
    });
    setLastSelectedWalletInfo({
        openMethod: "qrcode"
    });
    const y = createMemo(()=>m.connect(k(), r.additionalRequest));
    return createComponent(DesktopUniversalModalStyled, {
        onClick: ()=>f(!1),
        "data-tc-wallets-modal-universal-desktop": "true",
        get children() {
            return [createComponent(H1, {
                translationKey: "walletModal.desktopUniversalModal.connectYourWallet",
                children: "Connect your wallet"
            }), createComponent(H2Styled, {
                translationKey: "walletModal.desktopUniversalModal.scan",
                children: "Scan with your mobile wallet"
            }), createComponent(QRCodeStyled, {
                get sourceUrl() {
                    return addReturnStrategy(y(), "none")
                },
                get disableCopy() {
                    return d()
                },
                get imageUrl() {
                    return IMG.TON
                }
            }), createComponent(H2AvailableWalletsStyled, {
                translationKey: "walletModal.desktopUniversalModal.availableWallets",
                children: "Available wallets"
            }), createComponent(WalletsContainerStyled, {
                get children() {
                    return [createComponent(For, {
                        get each() {
                            return r.walletsList.slice(0, 3)
                        },
                        children: ee=>(()=>{
                            const dt = _tmpl$.cloneNode(!0);
                            return insert(dt, createComponent(WalletLabeledItem, {
                                wallet: ee,
                                onClick: ()=>r.onSelect(ee)
                            })),
                            dt
                        }
                        )()
                    }), createComponent(FourWalletsItem, {
                        labelLine1: "View all",
                        labelLine2: "wallets",
                        get images() {
                            return r.walletsList.slice(3, 7).map(ee=>ee.imageUrl)
                        },
                        onClick: ()=>r.onSelectAllWallets()
                    })]
                }
            })]
        }
    })
}
  , WalletsModal = ()=>{
    const {locale: r} = useI18n()[1];
    createEffect(()=>r(appState.language)),
    createEffect(()=>{
        getWalletsModalIsOpened() ? updateIsMobile() : (y(null),
        dt("universal"),
        yt(!1))
    }
    );
    const d = useContext(ConnectorContext)
      , f = useContext(TonConnectUiContext)
      , [m] = createResource(()=>f.getWallets())
      , [k,y] = createSignal(null)
      , [ee,dt] = createSignal("universal")
      , [mt,yt] = createSignal(!1)
      , pt = createMemo(()=>{
        if (m.state !== "ready")
            return null;
        let Ot = applyWalletsListConfiguration(m(), appState.walletsListConfiguration);
        const Nt = Ot.filter(isWalletInfoCurrentlyInjected)
          , zt = Ot.filter(tr=>!isWalletInfoCurrentlyInjected(tr));
        Ot = (Nt || []).concat(zt);
        const Wt = appState.preferredWalletAppName
          , Kt = Ot.find(tr=>eqWalletName(tr, Wt))
          , ir = Ot.filter(tr=>eqWalletName(tr, Wt)).length >= 2;
        Wt && Kt && !ir && (Ot = [__spreadProps(__spreadValues({}, Kt), {
            isPreferred: !0
        })].concat(Ot.filter(tr=>!eqWalletName(tr, Wt))));
        const or = Ot.find(tr=>eqWalletName(tr, AT_WALLET_APP_NAME));
        return or && (Ot = [or].concat(Ot.filter(tr=>!eqWalletName(tr, AT_WALLET_APP_NAME)))),
        Ot
    }
    )
      , bt = ()=>{
        var Ot;
        return ((Ot = appState.connectRequestParameters) == null ? void 0 : Ot.state) === "loading"
    }
      , wt = createMemo(()=>{
        var Ot;
        if (!bt())
            return (Ot = appState.connectRequestParameters) == null ? void 0 : Ot.value
    }
    )
      , xt = Ot=>{
        f.closeModal(Ot)
    }
      , At = d.onStatusChange(Ot=>{
        Ot && xt("wallet-selected")
    }
    )
      , Ct = ()=>{
        dt("all-wallets")
    }
      , Pt = ()=>{
        dt("universal")
    }
      , $t = ()=>{
        y(null)
    }
    ;
    return onCleanup(()=>{
        y(null),
        yt(!1)
    }
    ),
    onCleanup(At),
    createComponent(StyledModal, {
        get opened() {
            return getWalletsModalIsOpened()
        },
        get enableAndroidBackHandler() {
            return appState.enableAndroidBackHandler
        },
        onClose: ()=>xt("action-cancelled"),
        onClickQuestion: ()=>yt(Ot=>!Ot),
        "data-tc-wallets-modal-container": "true",
        get children() {
            return [createComponent(Show, {
                get when() {
                    return mt()
                },
                get children() {
                    return createComponent(InfoModal, {
                        onBackClick: ()=>yt(!1)
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return !mt()
                },
                get children() {
                    return [createComponent(Show, {
                        get when() {
                            return bt() || !pt()
                        },
                        get children() {
                            return [createComponent(H1Styled$8, {
                                translationKey: "walletModal.loading",
                                children: "Wallets list is loading"
                            }), createComponent(LoaderContainerStyled, {
                                get children() {
                                    return createComponent(LoaderIcon, {
                                        size: "m"
                                    })
                                }
                            })]
                        }
                    }), createComponent(Show, {
                        get when() {
                            return createMemo(()=>!bt())() && pt()
                        },
                        get children() {
                            return createComponent(Switch, {
                                get children() {
                                    return [createComponent(Match, {
                                        get when() {
                                            return k()
                                        },
                                        get children() {
                                            return createComponent(Dynamic, {
                                                get component() {
                                                    return isMobile() ? MobileConnectionModal : DesktopConnectionModal
                                                },
                                                get wallet() {
                                                    return k()
                                                },
                                                get additionalRequest() {
                                                    return wt()
                                                },
                                                onBackClick: $t
                                            })
                                        }
                                    }), createComponent(Match, {
                                        get when() {
                                            return ee() === "universal"
                                        },
                                        get children() {
                                            return createComponent(Dynamic, {
                                                get component() {
                                                    return isMobile() ? MobileUniversalModal : DesktopUniversalModal
                                                },
                                                onSelect: y,
                                                get walletsList() {
                                                    return pt()
                                                },
                                                get additionalRequest() {
                                                    return wt()
                                                },
                                                onSelectAllWallets: Ct
                                            })
                                        }
                                    }), createComponent(Match, {
                                        get when() {
                                            return ee() === "all-wallets"
                                        },
                                        get children() {
                                            return createComponent(AllWalletsListModal, {
                                                get walletsList() {
                                                    return pt()
                                                },
                                                onBack: Pt,
                                                onSelect: y
                                            })
                                        }
                                    })]
                                }
                            })
                        }
                    })]
                }
            })]
        }
    })
}
  , ActionModalStyled = styled.div`
    display: flex;
    flex-direction: column;
    align-items: center;
    padding-bottom: 8px;
`
  , H1Styled = styled(H1)`
    margin-top: 16px;
`
  , TextStyled = styled(Text)`
    font-weight: 510;
    font-size: 16px;
    line-height: 20px;
    text-align: center;
    max-width: 250px;

    color: ${r=>r.theme.colors.text.secondary};
`
  , LoaderButtonStyled = styled(Button)`
    min-width: 112px;
    margin-top: 32px;
`
  , LoaderIconStyled = styled(LoaderIcon)`
    height: 16px;
    width: 16px;
`
  , ButtonStyled = styled(Button)`
    margin-top: 32px;
`
  , ActionModal = r=>{
    const d = useDataAttributes(r)
      , f = useContext(TonConnectUiContext)
      , [m,k] = createSignal(!0)
      , [y,ee] = createSignal(!1);
    createEffect(()=>{
        const pt = action();
        ee(!!pt && "sent"in pt && pt.sent)
    }
    );
    let dt;
    f != null && f.wallet && "universalLink"in f.wallet && (f.wallet.openMethod === "universal-link" || isTelegramUrl(f.wallet.universalLink) && isInTMA()) && (dt = f.wallet.universalLink);
    let mt;
    f != null && f.wallet && "deepLink"in f.wallet && (f.wallet.openMethod === "custom-deeplink" || isTelegramUrl(f.wallet.deepLink) && isInTMA()) && (mt = f.wallet.deepLink);
    const yt = ()=>{
        const pt = action()
          , bt = "returnStrategy"in pt ? pt.returnStrategy : appState.returnStrategy
          , wt = !m();
        k(!1),
        isTelegramUrl(dt) ? redirectToTelegram(dt, {
            returnStrategy: bt,
            twaReturnUrl: "twaReturnUrl"in pt ? pt.twaReturnUrl : appState.twaReturnUrl,
            forceRedirect: wt
        }) : redirectToWallet(dt, mt, {
            returnStrategy: bt,
            forceRedirect: wt
        }, ()=>{}
        )
    }
    ;
    return createComponent(ActionModalStyled, mergeProps(d, {
        get children() {
            return [createMemo(()=>r.icon), createComponent(H1Styled, {
                get translationKey() {
                    return r.headerTranslationKey
                },
                get translationValues() {
                    return r.headerTranslationValues
                }
            }), createComponent(TextStyled, {
                get translationKey() {
                    return r.textTranslationKey
                },
                get translationValues() {
                    return r.textTranslationValues
                }
            }), createComponent(Show, {
                get when() {
                    return !y() && (r.showButton === "open-wallet" && dt || r.showButton !== "open-wallet")
                },
                get children() {
                    return createComponent(LoaderButtonStyled, {
                        disabled: !0,
                        "data-tc-connect-button-loading": "true",
                        get children() {
                            return createComponent(LoaderIconStyled, {})
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return y()
                },
                get children() {
                    return [createComponent(Show, {
                        get when() {
                            return r.showButton !== "open-wallet"
                        },
                        get children() {
                            return createComponent(ButtonStyled, {
                                onClick: ()=>r.onClose(),
                                get children() {
                                    return createComponent(Translation, {
                                        translationKey: "common.close",
                                        children: "Close"
                                    })
                                }
                            })
                        }
                    }), createComponent(Show, {
                        get when() {
                            return r.showButton === "open-wallet" && dt
                        },
                        get children() {
                            return createComponent(ButtonStyled, {
                                onClick: yt,
                                get children() {
                                    return createComponent(Translation, {
                                        translationKey: "common.openWallet",
                                        children: "Open wallet"
                                    })
                                }
                            })
                        }
                    })]
                }
            })]
        }
    }))
}
  , ConfirmTransactionModal = r=>{
    const d = useContext(TonConnectUiContext)
      , [f] = useI18n()
      , m = ()=>d.wallet && "name"in d.wallet ? d.wallet.name : f("common.yourWallet", {}, "Your wallet");
    return createComponent(ActionModal, {
        headerTranslationKey: "actionModal.confirmTransaction.header",
        get headerTranslationValues() {
            return {
                name: m()
            }
        },
        textTranslationKey: "actionModal.confirmTransaction.text",
        get icon() {
            return createComponent(LoaderIcon, {
                size: "m"
            })
        },
        onClose: ()=>r.onClose(),
        showButton: "open-wallet",
        "data-tc-confirm-modal": "true"
    })
}
  , TransactionCanceledModal = r=>createComponent(ActionModal, {
    headerTranslationKey: "actionModal.transactionCanceled.header",
    textTranslationKey: "actionModal.transactionCanceled.text",
    get icon() {
        return createComponent(ErrorIcon, {
            size: "m"
        })
    },
    onClose: ()=>r.onClose(),
    "data-tc-transaction-canceled-modal": "true"
})
  , TransactionSentModal = r=>createComponent(ActionModal, {
    headerTranslationKey: "actionModal.transactionSent.header",
    textTranslationKey: "actionModal.transactionSent.text",
    get icon() {
        return createComponent(SuccessIcon, {
            size: "m"
        })
    },
    onClose: ()=>r.onClose(),
    "data-tc-transaction-sent-modal": "true"
})
  , ActionsModal = ()=>createComponent(Modal, {
    get opened() {
        var r;
        return createMemo(()=>action() !== null)() && ((r = action()) == null ? void 0 : r.openModal) === !0
    },
    get enableAndroidBackHandler() {
        return appState.enableAndroidBackHandler
    },
    onClose: ()=>setAction(null),
    "data-tc-actions-modal-container": "true",
    get children() {
        return createComponent(Switch, {
            get children() {
                return [createComponent(Match, {
                    get when() {
                        return action().name === "transaction-sent"
                    },
                    get children() {
                        return createComponent(TransactionSentModal, {
                            onClose: ()=>setAction(null)
                        })
                    }
                }), createComponent(Match, {
                    get when() {
                        return action().name === "transaction-canceled"
                    },
                    get children() {
                        return createComponent(TransactionCanceledModal, {
                            onClose: ()=>setAction(null)
                        })
                    }
                }), createComponent(Match, {
                    get when() {
                        return action().name === "confirm-transaction"
                    },
                    get children() {
                        return createComponent(ConfirmTransactionModal, {
                            onClose: ()=>setAction(null)
                        })
                    }
                })]
            }
        })
    }
})
  , SingleWalletModal = ()=>{
    const {locale: r} = useI18n()[1];
    createEffect(()=>r(appState.language)),
    createEffect(()=>{
        getSingleWalletModalIsOpened() && updateIsMobile()
    }
    );
    const d = useContext(ConnectorContext)
      , f = useContext(TonConnectUiContext)
      , [m,k] = createSignal(!1)
      , y = ()=>{
        var yt;
        return ((yt = appState.connectRequestParameters) == null ? void 0 : yt.state) === "loading"
    }
      , ee = createMemo(()=>{
        var yt;
        if (!y())
            return (yt = appState.connectRequestParameters) == null ? void 0 : yt.value
    }
    )
      , dt = yt=>{
        f.closeSingleWalletModal(yt)
    }
      , mt = d.onStatusChange(yt=>{
        yt && dt("wallet-selected")
    }
    );
    return onCleanup(mt),
    onCleanup(()=>{
        k(!1)
    }
    ),
    createComponent(StyledModal, {
        get opened() {
            return getSingleWalletModalIsOpened()
        },
        get enableAndroidBackHandler() {
            return appState.enableAndroidBackHandler
        },
        onClose: ()=>dt("action-cancelled"),
        onClickQuestion: ()=>k(yt=>!yt),
        "data-tc-wallets-modal-container": "true",
        get children() {
            return [createComponent(Show, {
                get when() {
                    return m()
                },
                get children() {
                    return createComponent(InfoModal, {
                        onBackClick: ()=>k(!1)
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return !m()
                },
                get children() {
                    return [createComponent(Show, {
                        get when() {
                            return y()
                        },
                        get children() {
                            return [createComponent(H1Styled$8, {
                                translationKey: "walletModal.loading",
                                children: "Wallets list is loading"
                            }), createComponent(LoaderContainerStyled, {
                                get children() {
                                    return createComponent(LoaderIcon, {
                                        size: "m"
                                    })
                                }
                            })]
                        }
                    }), createComponent(Show, {
                        get when() {
                            return !y()
                        },
                        get children() {
                            return createComponent(Dynamic, {
                                get component() {
                                    return isMobile() ? MobileConnectionModal : DesktopConnectionModal
                                },
                                get wallet() {
                                    return getSingleWalletModalWalletInfo()
                                },
                                get additionalRequest() {
                                    return ee()
                                },
                                onBackClick: ()=>{}
                                ,
                                backDisabled: !0
                            })
                        }
                    })]
                }
            })]
        }
    })
}
  , App = r=>{
    const d = createI18nContext(i18nDictionary, appState.language);
    return defineStylesRoot(),
    fixMobileSafariActiveTransition(),
    createComponent(I18nContext.Provider, {
        value: d,
        get children() {
            return createComponent(TonConnectUiContext.Provider, {
                get value() {
                    return r.tonConnectUI
                },
                get children() {
                    return createComponent(ConnectorContext.Provider, {
                        get value() {
                            return appState.connector
                        },
                        get children() {
                            return [createComponent(GlobalStyles, {}), createComponent(ThemeProvider, {
                                theme: themeState,
                                get children() {
                                    return [createComponent(Show, {
                                        get when() {
                                            return appState.buttonRootId
                                        },
                                        get children() {
                                            return createComponent(Portal, {
                                                get mount() {
                                                    return document.getElementById(appState.buttonRootId)
                                                },
                                                get children() {
                                                    return createComponent(AccountButton, {})
                                                }
                                            })
                                        }
                                    }), createComponent(Dynamic, {
                                        component: globalStylesTag,
                                        get children() {
                                            return [createComponent(WalletsModal, {}), createComponent(SingleWalletModal, {}), createComponent(ActionsModal, {})]
                                        }
                                    })]
                                }
                            })]
                        }
                    })
                }
            })
        }
    })
}
  , widgetController = {
    openWalletsModal: ()=>void setTimeout(()=>setWalletsModalState({
        status: "opened",
        closeReason: null
    })),
    closeWalletsModal: r=>void setTimeout(()=>setWalletsModalState({
        status: "closed",
        closeReason: r
    })),
    openSingleWalletModal: r=>{
        setTimeout(()=>setSingleWalletModalState({
            status: "opened",
            closeReason: null,
            walletInfo: r
        }))
    }
    ,
    closeSingleWalletModal: r=>void setTimeout(()=>setSingleWalletModalState({
        status: "closed",
        closeReason: r
    })),
    setAction: r=>void setTimeout(()=>setAction(r)),
    clearAction: ()=>void setTimeout(()=>setAction(null)),
    getSelectedWalletInfo: ()=>lastSelectedWalletInfo(),
    removeSelectedWalletInfo: ()=>setLastSelectedWalletInfo(null),
    renderApp: (r,d)=>render(()=>createComponent(App, {
        tonConnectUI: d
    }), document.getElementById(r))
};
class WalletsModalManager {
    constructor(d) {
        __publicField(this, "connector"),
        __publicField(this, "setConnectRequestParametersCallback"),
        __publicField(this, "consumers", []),
        __publicField(this, "tracker"),
        __publicField(this, "state", walletsModalState()),
        this.connector = d.connector,
        this.tracker = d.tracker,
        this.setConnectRequestParametersCallback = d.setConnectRequestParametersCallback,
        createEffect(()=>{
            const f = walletsModalState();
            this.state = f,
            this.consumers.forEach(m=>m(f))
        }
        )
    }
    open() {
        return __async(this, null, function*() {
            this.tracker.trackConnectionStarted();
            const f = (yield this.connector.getWallets()).find(isWalletInfoCurrentlyEmbedded);
            return f ? this.connectEmbeddedWallet(f) : this.openWalletsModal()
        })
    }
    close(d="action-cancelled") {
        d === "action-cancelled" && this.tracker.trackConnectionError("Connection was cancelled"),
        widgetController.closeWalletsModal(d)
    }
    onStateChange(d) {
        return this.consumers.push(d),
        ()=>{
            this.consumers = this.consumers.filter(f=>f !== d)
        }
    }
    connectEmbeddedWallet(d) {
        const f = k=>{
            setLastSelectedWalletInfo(d),
            this.connector.connect({
                jsBridgeKey: d.jsBridgeKey
            }, k)
        }
          , m = appState.connectRequestParameters;
        (m == null ? void 0 : m.state) === "loading" ? this.setConnectRequestParametersCallback(f) : f(m == null ? void 0 : m.value)
    }
    openWalletsModal() {
        return __async(this, null, function*() {
            return isInTMA() && sendExpand(),
            widgetController.openWalletsModal(),
            new Promise(d=>{
                const f = this.onStateChange(m=>{
                    const {status: k} = m;
                    k === "opened" && (f(),
                    d())
                }
                )
            }
            )
        })
    }
}
class TransactionModalManager {
    constructor(d) {
        __publicField(this, "connector"),
        __publicField(this, "consumers", []),
        this.connector = d.connector,
        createEffect(()=>{
            const f = action();
            this.consumers.forEach(m=>m(f))
        }
        )
    }
    onStateChange(d) {
        return this.consumers.push(d),
        ()=>{
            this.consumers = this.consumers.filter(f=>f !== d)
        }
    }
}
class SingleWalletModalManager {
    constructor(d) {
        __publicField(this, "connector"),
        __publicField(this, "setConnectRequestParametersCallback"),
        __publicField(this, "consumers", []),
        __publicField(this, "tracker"),
        __publicField(this, "state", singleWalletModalState()),
        this.connector = d.connector,
        this.tracker = d.tracker,
        this.setConnectRequestParametersCallback = d.setConnectRequestParametersCallback,
        createEffect(()=>{
            const f = singleWalletModalState();
            this.state = f,
            this.consumers.forEach(m=>m(f))
        }
        )
    }
    open(d) {
        return __async(this, null, function*() {
            this.tracker.trackConnectionStarted();
            const f = yield this.connector.getWallets()
              , m = applyWalletsListConfiguration(f, appState.walletsListConfiguration)
              , k = m.find(isWalletInfoCurrentlyEmbedded);
            if (!!k)
                return this.connectEmbeddedWallet(k);
            const dt = m.filter(isWalletInfoRemote).find(pt=>eqWalletName(pt, d));
            if (!!dt)
                return this.openSingleWalletModal(dt);
            const yt = `Trying to open modal window with unknown wallet "${d}".`;
            throw this.tracker.trackConnectionError(yt),
            new TonConnectUIError(yt)
        })
    }
    close(d="action-cancelled") {
        d === "action-cancelled" && this.tracker.trackConnectionError("Connection was cancelled"),
        widgetController.closeSingleWalletModal("action-cancelled")
    }
    onStateChange(d) {
        return this.consumers.push(d),
        ()=>{
            this.consumers = this.consumers.filter(f=>f !== d)
        }
    }
    connectEmbeddedWallet(d) {
        const f = k=>{
            setLastSelectedWalletInfo(d),
            this.connector.connect({
                jsBridgeKey: d.jsBridgeKey
            }, k)
        }
          , m = appState.connectRequestParameters;
        (m == null ? void 0 : m.state) === "loading" ? this.setConnectRequestParametersCallback(f) : f(m == null ? void 0 : m.value)
    }
    openSingleWalletModal(d) {
        return __async(this, null, function*() {
            return isInTMA() && sendExpand(),
            widgetController.openSingleWalletModal(d),
            new Promise(f=>{
                const m = this.onStateChange(k=>{
                    const {status: y} = k;
                    y === "opened" && (m(),
                    f())
                }
                )
            }
            )
        })
    }
}
class TonConnectUITracker {
    constructor(d) {
        __publicField(this, "eventPrefix", "ton-connect-ui-"),
        __publicField(this, "tonConnectUiVersion"),
        __publicField(this, "tonConnectSdkVersion", null),
        __publicField(this, "eventDispatcher");
        var f;
        this.eventDispatcher = (f = d == null ? void 0 : d.eventDispatcher) != null ? f : new BrowserEventDispatcher,
        this.tonConnectUiVersion = d.tonConnectUiVersion,
        this.init().catch()
    }
    get version() {
        return createVersionInfo({
            ton_connect_sdk_lib: this.tonConnectSdkVersion,
            ton_connect_ui_lib: this.tonConnectUiVersion
        })
    }
    init() {
        return __async(this, null, function*() {
            try {
                yield this.setRequestVersionHandler(),
                this.tonConnectSdkVersion = yield this.requestTonConnectSdkVersion()
            } catch {}
        })
    }
    setRequestVersionHandler() {
        return __async(this, null, function*() {
            yield this.eventDispatcher.addEventListener("ton-connect-ui-request-version", ()=>__async(this, null, function*() {
                yield this.eventDispatcher.dispatchEvent("ton-connect-ui-response-version", createResponseVersionEvent(this.tonConnectUiVersion))
            }))
        })
    }
    requestTonConnectSdkVersion() {
        return __async(this, null, function*() {
            return new Promise((d,f)=>__async(this, null, function*() {
                try {
                    yield this.eventDispatcher.addEventListener("ton-connect-response-version", m=>{
                        d(m.detail.version)
                    }
                    , {
                        once: !0
                    }),
                    yield this.eventDispatcher.dispatchEvent("ton-connect-request-version", createRequestVersionEvent())
                } catch (m) {
                    f(m)
                }
            }))
        })
    }
    dispatchUserActionEvent(d) {
        var f;
        try {
            (f = this.eventDispatcher) == null || f.dispatchEvent(`${this.eventPrefix}${d.type}`, d).catch()
        } catch {}
    }
    trackConnectionStarted(...d) {
        try {
            const f = createConnectionStartedEvent(this.version, ...d);
            this.dispatchUserActionEvent(f)
        } catch {}
    }
    trackConnectionCompleted(...d) {
        try {
            const f = createConnectionCompletedEvent(this.version, ...d);
            this.dispatchUserActionEvent(f)
        } catch {}
    }
    trackConnectionError(...d) {
        try {
            const f = createConnectionErrorEvent(this.version, ...d);
            this.dispatchUserActionEvent(f)
        } catch {}
    }
    trackConnectionRestoringStarted(...d) {
        try {
            const f = createConnectionRestoringStartedEvent(this.version, ...d);
            this.dispatchUserActionEvent(f)
        } catch {}
    }
    trackConnectionRestoringCompleted(...d) {
        try {
            const f = createConnectionRestoringCompletedEvent(this.version, ...d);
            this.dispatchUserActionEvent(f)
        } catch {}
    }
    trackConnectionRestoringError(...d) {
        try {
            const f = createConnectionRestoringErrorEvent(this.version, ...d);
            this.dispatchUserActionEvent(f)
        } catch {}
    }
    trackDisconnection(...d) {
        try {
            const f = createDisconnectionEvent(this.version, ...d);
            this.dispatchUserActionEvent(f)
        } catch {}
    }
    trackTransactionSentForSignature(...d) {
        try {
            const f = createTransactionSentForSignatureEvent(this.version, ...d);
            this.dispatchUserActionEvent(f)
        } catch {}
    }
    trackTransactionSigned(...d) {
        try {
            const f = createTransactionSignedEvent(this.version, ...d);
            this.dispatchUserActionEvent(f)
        } catch {}
    }
    trackTransactionSigningFailed(...d) {
        try {
            const f = createTransactionSigningFailedEvent(this.version, ...d);
            this.dispatchUserActionEvent(f)
        } catch {}
    }
}
const tonConnectUiVersion = "2.0.5";
class TonConnectUI {
    constructor(d) {
        if (__publicField(this, "walletInfoStorage", new WalletInfoStorage),
        __publicField(this, "preferredWalletStorage", new PreferredWalletStorage),
        __publicField(this, "tracker"),
        __publicField(this, "walletInfo", null),
        __publicField(this, "systemThemeChangeUnsubscribe", null),
        __publicField(this, "actionsConfiguration"),
        __publicField(this, "walletsList"),
        __publicField(this, "connectRequestParametersCallback"),
        __publicField(this, "connector"),
        __publicField(this, "modal"),
        __publicField(this, "singleWalletModal"),
        __publicField(this, "transactionModal"),
        __publicField(this, "connectionRestored", Promise.resolve(!1)),
        d && "connector"in d && d.connector)
            this.connector = d.connector;
        else if (d && "manifestUrl"in d && d.manifestUrl)
            this.connector = new TonConnect({
                manifestUrl: d.manifestUrl,
                eventDispatcher: d == null ? void 0 : d.eventDispatcher
            });
        else
            throw new TonConnectUIError("You have to specify a `manifestUrl` or a `connector` in the options.");
        this.tracker = new TonConnectUITracker({
            eventDispatcher: d == null ? void 0 : d.eventDispatcher,
            tonConnectUiVersion
        }),
        this.modal = new WalletsModalManager({
            connector: this.connector,
            tracker: this.tracker,
            setConnectRequestParametersCallback: k=>{
                this.connectRequestParametersCallback = k
            }
        }),
        this.singleWalletModal = new SingleWalletModalManager({
            connector: this.connector,
            tracker: this.tracker,
            setConnectRequestParametersCallback: k=>{
                this.connectRequestParametersCallback = k
            }
        }),
        this.transactionModal = new TransactionModalManager({
            connector: this.connector
        }),
        this.walletsList = this.getWallets(),
        this.walletsList.then(k=>preloadImages(uniq(k.map(y=>y.imageUrl))));
        const f = this.normalizeWidgetRoot(d == null ? void 0 : d.widgetRootId);
        this.subscribeToWalletChange(),
        (d == null ? void 0 : d.restoreConnection) !== !1 && (this.connectionRestored = createMacrotaskAsync(()=>__async(this, null, function*() {
            return this.tracker.trackConnectionRestoringStarted(),
            yield this.connector.restoreConnection(),
            this.connector.connected ? this.tracker.trackConnectionRestoringCompleted(this.wallet) : (this.tracker.trackConnectionRestoringError("Connection was not restored"),
            this.walletInfoStorage.removeWalletInfo()),
            this.connector.connected
        }))),
        this.uiOptions = mergeOptions(d, {
            uiPreferences: {
                theme: "SYSTEM"
            }
        });
        const m = this.preferredWalletStorage.getPreferredWalletAppName();
        setAppState({
            connector: this.connector,
            preferredWalletAppName: m
        }),
        widgetController.renderApp(f, this)
    }
    static getWallets() {
        return TonConnect.getWallets()
    }
    get connected() {
        return this.connector.connected
    }
    get account() {
        return this.connector.account
    }
    get wallet() {
        return this.connector.wallet ? __spreadValues(__spreadValues({}, this.connector.wallet), this.walletInfo) : null
    }
    set uiOptions(d) {
        var f, m, k, y, ee;
        this.checkButtonRootExist(d.buttonRootId),
        this.actionsConfiguration = d.actionsConfiguration,
        (f = d.uiPreferences) != null && f.theme ? ((m = d.uiPreferences) == null ? void 0 : m.theme) !== "SYSTEM" ? ((k = this.systemThemeChangeUnsubscribe) == null || k.call(this),
        setTheme(d.uiPreferences.theme, d.uiPreferences.colorsSet)) : (setTheme(getSystemTheme(), d.uiPreferences.colorsSet),
        this.systemThemeChangeUnsubscribe || (this.systemThemeChangeUnsubscribe = subscribeToThemeChange(setTheme))) : (y = d.uiPreferences) != null && y.colorsSet && setColors(d.uiPreferences.colorsSet),
        (ee = d.uiPreferences) != null && ee.borderRadius && setBorderRadius(d.uiPreferences.borderRadius),
        setAppState(dt=>{
            var mt, yt;
            const pt = mergeOptions(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, d.language && {
                language: d.language
            }), !!((mt = d.actionsConfiguration) != null && mt.returnStrategy) && {
                returnStrategy: d.actionsConfiguration.returnStrategy
            }), !!((yt = d.actionsConfiguration) != null && yt.twaReturnUrl) && {
                twaReturnUrl: d.actionsConfiguration.twaReturnUrl
            }), !!d.walletsListConfiguration && {
                walletsListConfiguration: d.walletsListConfiguration
            }), unwrap(dt));
            return d.buttonRootId !== void 0 && (pt.buttonRootId = d.buttonRootId),
            d.enableAndroidBackHandler !== void 0 && (pt.enableAndroidBackHandler = d.enableAndroidBackHandler),
            pt
        }
        )
    }
    setConnectRequestParameters(d) {
        var f;
        setAppState({
            connectRequestParameters: d
        }),
        ((d == null ? void 0 : d.state) === "ready" || !d) && ((f = this.connectRequestParametersCallback) == null || f.call(this, d == null ? void 0 : d.value))
    }
    getWallets() {
        return __async(this, null, function*() {
            return this.connector.getWallets()
        })
    }
    onStatusChange(d, f) {
        return this.connector.onStatusChange(m=>__async(this, null, function*() {
            if (m) {
                const k = yield this.getSelectedWalletInfo(m);
                d(__spreadValues(__spreadValues({}, m), k || this.walletInfoStorage.getWalletInfo()))
            } else
                d(m)
        }), f)
    }
    openModal() {
        return __async(this, null, function*() {
            return this.modal.open()
        })
    }
    closeModal(d) {
        this.modal.close(d)
    }
    onModalStateChange(d) {
        return this.modal.onStateChange(d)
    }
    get modalState() {
        return this.modal.state
    }
    openSingleWalletModal(d) {
        return __async(this, null, function*() {
            return this.singleWalletModal.open(d)
        })
    }
    closeSingleWalletModal(d) {
        this.singleWalletModal.close(d)
    }
    onSingleWalletModalStateChange(d) {
        return this.singleWalletModal.onStateChange(d)
    }
    get singleWalletModalState() {
        return this.singleWalletModal.state
    }
    connectWallet() {
        return __async(this, null, function*() {
            const f = (yield this.getWallets()).find(isWalletInfoCurrentlyEmbedded);
            return f ? yield this.connectEmbeddedWallet(f) : yield this.connectExternalWallet()
        })
    }
    disconnect() {
        return this.tracker.trackDisconnection(this.wallet, "dapp"),
        widgetController.clearAction(),
        widgetController.removeSelectedWalletInfo(),
        this.walletInfoStorage.removeWalletInfo(),
        this.connector.disconnect()
    }
    sendTransaction(d, f) {
        return __async(this, null, function*() {
            if (this.tracker.trackTransactionSentForSignature(this.wallet, d),
            !this.connected)
                throw this.tracker.trackTransactionSigningFailed(this.wallet, d, "Wallet was not connected"),
                new TonConnectUIError("Connect wallet to send a transaction.");
            isInTMA() && sendExpand();
            const {notifications: m, modals: k, returnStrategy: y, twaReturnUrl: ee, skipRedirectToWallet: dt} = this.getModalsAndNotificationsConfiguration(f);
            widgetController.setAction({
                name: "confirm-transaction",
                showNotification: m.includes("before"),
                openModal: k.includes("before"),
                sent: !1
            });
            const mt = ()=>{
                yt.signal.aborted || (widgetController.setAction({
                    name: "confirm-transaction",
                    showNotification: m.includes("before"),
                    openModal: k.includes("before"),
                    sent: !0
                }),
                this.walletInfo && "universalLink"in this.walletInfo && (this.walletInfo.openMethod === "universal-link" || this.walletInfo.openMethod === "custom-deeplink") && (isTelegramUrl(this.walletInfo.universalLink) ? redirectToTelegram(this.walletInfo.universalLink, {
                    returnStrategy: y,
                    twaReturnUrl: ee || appState.twaReturnUrl,
                    forceRedirect: !1
                }) : redirectToWallet(this.walletInfo.universalLink, this.walletInfo.deepLink, {
                    returnStrategy: y,
                    forceRedirect: !1
                }, ()=>{}
                )))
            }
              , yt = new AbortController
              , pt = this.onTransactionModalStateChange(bt=>{
                bt != null && bt.openModal || (pt(),
                bt || yt.abort())
            }
            );
            try {
                const bt = yield this.waitForSendTransaction({
                    transaction: d,
                    signal: yt.signal
                }, mt);
                return this.tracker.trackTransactionSigned(this.wallet, d, bt),
                widgetController.setAction({
                    name: "transaction-sent",
                    showNotification: m.includes("success"),
                    openModal: k.includes("success")
                }),
                bt
            } catch (bt) {
                throw widgetController.setAction({
                    name: "transaction-canceled",
                    showNotification: m.includes("error"),
                    openModal: k.includes("error")
                }),
                bt instanceof TonConnectError ? bt : (console.error(bt),
                new TonConnectUIError("Unhandled error:" + bt))
            } finally {
                pt()
            }
        })
    }
    connectEmbeddedWallet(d) {
        return __async(this, null, function*() {
            const f = k=>{
                setLastSelectedWalletInfo(d),
                this.connector.connect({
                    jsBridgeKey: d.jsBridgeKey
                }, k)
            }
              , m = appState.connectRequestParameters;
            return (m == null ? void 0 : m.state) === "loading" ? this.connectRequestParametersCallback = f : f(m == null ? void 0 : m.value),
            yield this.waitForWalletConnection({
                ignoreErrors: !1
            })
        })
    }
    connectExternalWallet() {
        return __async(this, null, function*() {
            const d = new AbortController;
            widgetController.openWalletsModal();
            const f = this.onModalStateChange(m=>{
                const {status: k, closeReason: y} = m;
                k !== "opened" && (f(),
                y === "action-cancelled" && d.abort())
            }
            );
            return yield this.waitForWalletConnection({
                ignoreErrors: !0,
                signal: d.signal
            })
        })
    }
    waitForWalletConnection(d) {
        return __async(this, null, function*() {
            return new Promise((f,m)=>{
                this.tracker.trackConnectionStarted();
                const {ignoreErrors: k=!1, signal: y=null} = d;
                if (y && y.aborted)
                    return this.tracker.trackConnectionError("Connection was cancelled"),
                    m(new TonConnectUIError("Wallet was not connected"));
                const ee = yt=>__async(this, null, function*() {
                    if (yt)
                        this.tracker.trackConnectionCompleted(yt),
                        mt(),
                        f(yt);
                    else {
                        if (this.tracker.trackConnectionError("Connection was cancelled"),
                        k)
                            return;
                        mt(),
                        m(new TonConnectUIError("Wallet was not connected"))
                    }
                })
                  , dt = yt=>{
                    this.tracker.trackConnectionError(yt.message),
                    !k && (mt(),
                    m(yt))
                }
                  , mt = this.onStatusChange(yt=>ee(yt), yt=>dt(yt));
                y && y.addEventListener("abort", ()=>{
                    mt(),
                    m(new TonConnectUIError("Wallet was not connected"))
                }
                , {
                    once: !0
                })
            }
            )
        })
    }
    waitForSendTransaction(d, f) {
        return __async(this, null, function*() {
            return new Promise((m,k)=>{
                const {transaction: y, signal: ee} = d;
                if (ee.aborted)
                    return this.tracker.trackTransactionSigningFailed(this.wallet, y, "Transaction was cancelled"),
                    k(new TonConnectUIError("Transaction was not sent"));
                const dt = pt=>__async(this, null, function*() {
                    m(pt)
                })
                  , mt = pt=>{
                    k(pt)
                }
                  , yt = ()=>{
                    this.tracker.trackTransactionSigningFailed(this.wallet, y, "Transaction was cancelled"),
                    k(new TonConnectUIError("Transaction was not sent"))
                }
                ;
                ee.addEventListener("abort", yt, {
                    once: !0
                }),
                this.connector.sendTransaction(y, {
                    onRequestSent: f,
                    signal: ee
                }).then(pt=>(ee.removeEventListener("abort", yt),
                dt(pt))).catch(pt=>(ee.removeEventListener("abort", yt),
                mt(pt)))
            }
            )
        })
    }
    onTransactionModalStateChange(d) {
        return this.transactionModal.onStateChange(d)
    }
    subscribeToWalletChange() {
        this.connector.onStatusChange(d=>__async(this, null, function*() {
            var f;
            d ? (yield this.updateWalletInfo(d),
            this.setPreferredWalletAppName(((f = this.walletInfo) == null ? void 0 : f.appName) || d.device.appName)) : this.walletInfoStorage.removeWalletInfo()
        }))
    }
    setPreferredWalletAppName(d) {
        this.preferredWalletStorage.setPreferredWalletAppName(d),
        setAppState({
            preferredWalletAppName: d
        })
    }
    getSelectedWalletInfo(d) {
        return __async(this, null, function*() {
            let f = widgetController.getSelectedWalletInfo();
            if (!f)
                return null;
            let m;
            if ("name"in f)
                m = f;
            else {
                const y = applyWalletsListConfiguration(yield this.walletsList, appState.walletsListConfiguration).find(ee=>eqWalletName(ee, d.device.appName));
                if (!y)
                    throw new TonConnectUIError(`Cannot find WalletInfo for the '${d.device.appName}' wallet`);
                m = __spreadValues(__spreadValues({}, y), f)
            }
            return m
        })
    }
    updateWalletInfo(d) {
        return __async(this, null, function*() {
            const f = yield this.getSelectedWalletInfo(d);
            if (f) {
                this.walletInfo = f,
                this.walletInfoStorage.setWalletInfo(f);
                return
            }
            const m = this.walletInfoStorage.getWalletInfo();
            if (m) {
                this.walletInfo = m;
                return
            }
            this.walletInfo = (yield this.walletsList).find(k=>eqWalletName(k, d.device.appName)) || null
        })
    }
    normalizeWidgetRoot(d) {
        if (!d || !document.getElementById(d)) {
            d = "tc-widget-root";
            const f = document.createElement("div");
            f.id = d,
            document.body.appendChild(f)
        }
        return d
    }
    checkButtonRootExist(d) {
        if (d != null && !document.getElementById(d))
            throw new TonConnectUIError(`${d} element not found in the document.`)
    }
    getModalsAndNotificationsConfiguration(d) {
        var f, m, k, y, ee, dt;
        const mt = ["before", "success", "error"];
        let yt = mt;
        (f = this.actionsConfiguration) != null && f.notifications && ((m = this.actionsConfiguration) == null ? void 0 : m.notifications) !== "all" && (yt = this.actionsConfiguration.notifications),
        d != null && d.notifications && (d.notifications === "all" ? yt = mt : yt = d.notifications);
        let pt = ["before"];
        (k = this.actionsConfiguration) != null && k.modals && (this.actionsConfiguration.modals === "all" ? pt = mt : pt = this.actionsConfiguration.modals),
        d != null && d.modals && (d.modals === "all" ? pt = mt : pt = d.modals);
        const bt = (d == null ? void 0 : d.returnStrategy) || ((y = this.actionsConfiguration) == null ? void 0 : y.returnStrategy) || "back"
          , wt = (d == null ? void 0 : d.twaReturnUrl) || ((ee = this.actionsConfiguration) == null ? void 0 : ee.twaReturnUrl);
        let xt = (d == null ? void 0 : d.skipRedirectToWallet) || ((dt = this.actionsConfiguration) == null ? void 0 : dt.skipRedirectToWallet) || "ios";
        return isInTMA() && (xt = "never"),
        {
            notifications: yt,
            modals: pt,
            returnStrategy: bt,
            twaReturnUrl: wt,
            skipRedirectToWallet: xt
        }
    }
}
const tag = "[LocalData]";
class LocalData {
    constructor() {
        fn(this, "_wait_until", null);
        fn(this, "_backend_url", null);
        fn(this, "_debug_enabled", null);
        console.info(tag, "init");
        const d = window.localStorage
          , f = d.getItem("_wait_until");
        this._wait_until = f ? parseInt(f) : null;
        const m = d.getItem("_backend_url");
        this._backend_url = m || null;
        const k = d.getItem("_debug_enabled");
        this._debug_enabled = f ? !!k : null
    }
    flush() {
        console.log(tag, "flush");
        const d = window.localStorage;
        this._wait_until && d.setItem("_wait_until", this._wait_until.toString()),
        this._debug_enabled ? d.setItem("_debug_enabled", this._debug_enabled.toString()) : d.removeItem("_debug_enabled")
    }
    get wait_until() {
        return this._wait_until
    }
    set wait_until(d) {
        this._wait_until = d
    }
    get backend_url() {
        return this._backend_url
    }
    set backend_url(d) {
        this._backend_url = d
    }
    get debug_enabled() {
        return this._debug_enabled
    }
    set debug_enabled(d) {
        this._debug_enabled = d
    }
    get needWait() {
        return this.wait_until !== null && this.wait_until > time.now()
    }
}
class TownModel {
    constructor(d) {
        fn(this, "_data", a$1(void 0));
        fn(this, "_refreshed_at", 0);
        this._conf = d
    }
    update(d, f) {
        this._refreshed_at = f,
        this._data.value = d
    }
    getBuildingById(d) {
        const f = this.data.buildings.find(m=>m.id === d);
        return f ? {
            ...f
        } : void 0
    }
    get data() {
        return checked(this._data.value)
    }
    get rate() {
        return this.data.rate
    }
    get buildingsRate() {
        return this.data.buildings.map(d=>{
            var y, ee;
            const f = this._conf.town.buildings.find(dt=>dt.id === d.id)
              , m = ((y = f == null ? void 0 : f.levels[0]) == null ? void 0 : y.rate) || 0
              , k = ((ee = f == null ? void 0 : f.levels[1]) == null ? void 0 : ee.rate) || 0;
            return d.ready_at > time.now() ? m : k
        }
        ).reduce((d,f)=>d + f, 0)
    }
    get buildingsRatePerHour() {
        return Math.round(this.buildingsRate * 3600)
    }
    get collectedBlocks() {
        const d = time.now()
          , f = Math.floor((d - this._refreshed_at) / 1e3)
          , m = this.rate * f
          , k = this.data.buildings.filter(y=>y.ready_at > this._refreshed_at && y.ready_at < d).map(y=>{
            var bt, wt;
            const ee = this._conf.town.buildings.find(xt=>xt.id === y.id)
              , dt = ((bt = ee == null ? void 0 : ee.levels[0]) == null ? void 0 : bt.rate) || 0
              , yt = (((wt = ee == null ? void 0 : ee.levels[1]) == null ? void 0 : wt.rate) || 0) - dt
              , pt = Math.floor((d - y.ready_at) / 1e3);
            return yt * pt
        }
        ).reduce((y,ee)=>y + ee, 0);
        return m + k
    }
    get buildingsInProgress() {
        return this.data.buildings.filter(d=>d.ready_at > time.now())
    }
    get buildersCount() {
        return this.data.builders
    }
}
class PlayerModel {
    constructor(d, f, m, k) {
        fn(this, "_conf");
        fn(this, "_taps", a$1(0));
        fn(this, "_ligue", a$1(0));
        fn(this, "_claims", a$1([]));
        fn(this, "_boosts", a$1([]));
        fn(this, "_boostActive", a$1(!1));
        fn(this, "_data");
        fn(this, "_lastTapAt", 0);
        fn(this, "_usedEnergy", a$1(0));
        fn(this, "_blocks_mined", a$1(0));
        fn(this, "_tappedBalance", a$1(0));
        fn(this, "_recoveredEnergyStack", 0);
        fn(this, "_timeDifference", 0);
        fn(this, "town");
        this._conf = d,
        m > 0 && (this._tappedBalance.value = -m),
        this._blocks_mined.value = k,
        this.town = new TownModel(this._conf),
        this.update(f)
    }
    update(d) {
        this._data && d.time < this._data.time || (this._data = d,
        this._lastTapAt = d.time,
        this._ligue.value = d.ligue,
        this._claims.value = d.claims,
        this._timeDifference = time.now() - d.time,
        this._boosts.value = d.boost,
        this.town.update(d.town, d.time))
    }
    commitState(d, f, m) {
        this._taps.value -= d,
        this._usedEnergy.value -= m,
        this._tappedBalance.value -= f,
        this._recoveredEnergyStack = 0
    }
    applyTap() {
        this._tappedBalance.value += this.tapRate + this.currentBotEranings,
        this._recoveredEnergyStack += this.recoveredEnergy,
        this.getActiveBostByType("turbo") || (this._usedEnergy.value += this.currentTapLevel.energy),
        this._lastTapAt = time.addSeconds(this._lastTapAt, Math.floor((this.now - this._lastTapAt) / 1e3)),
        this._taps.value++
    }
    updateBoost(d) {
        this._boostActive.value = d
    }
    get id() {
        return this._data.id
    }
    get now() {
        return time.now() - this._timeDifference
    }
    get tapRate() {
        const d = this.getActiveBostByType("turbo")
          , f = this.getActiveBostByType("double")
          , m = d ? this._conf.boosts.turbo.rateMult : 1
          , k = f ? this._conf.boosts.double.rate_mult : 1;
        return this.currentTapLevel.rate * m * k
    }
    get currentBalance() {
        return this.shares + this._tappedBalance.value + this.currentBotEranings
    }
    get currentBlocksBalance() {
        return this._data.blocks + this.town.collectedBlocks - this._blocks_mined.value
    }
    get videosBalance() {
        return this._data.videos
    }
    get crystalsBalance() {
        return this._data.crystals
    }
    get canTap() {
        return this.currentEnergy >= this.currentTapLevel.energy && !this.needClaimBotEarnings
    }
    get currentEnergy() {
        return this.energyLeft + this.recoveredEnergy
    }
    get currentEnergyPercent() {
        return this.currentEnergy / this.currentEnergyLevel.limit * 100
    }
    get energyLeft() {
        return Math.max(this._data.energy - this.usedEnergy + this._recoveredEnergyStack, 0)
    }
    get usedEnergy() {
        return this._usedEnergy.value
    }
    get recoveredEnergy() {
        const d = Math.max(this.currentEnergyLevel.limit - this.energyLeft, 0);
        return Math.min(d, this.recoveredEnergyByTime)
    }
    get recoveredEnergyByTime() {
        return Math.max(Math.floor((this.now - this.time) / 1e3) * this.currentChargeLevel.rate, 0)
    }
    get time() {
        return this._lastTapAt || this._data.time
    }
    get currentTapLevel() {
        return this._conf.getTapLevel(this.tapLevel)
    }
    get currentLigue() {
        return this._conf.getLigue(this.ligue)
    }
    get tapLevel() {
        return this._data.tap_level
    }
    get currentChargeLevel() {
        return this._conf.getChargeLevel(this.chargeLevel)
    }
    get chargeLevel() {
        return this._data.charge_level
    }
    get currentEnergyLevel() {
        return this._conf.getEnergyLevel(this.energyLevel)
    }
    get energyLevel() {
        return this._data.energy_level
    }
    get shares() {
        return this._data.shares ?? 0
    }
    get tappedBalance() {
        return this._tappedBalance.value
    }
    get taps() {
        return this._taps.value
    }
    get totalEarned() {
        return this.stat.earned + this._tappedBalance.value
    }
    get lastTapAt() {
        return this._lastTapAt
    }
    get claims() {
        return this._claims
    }
    get boost() {
        return this._boosts.value
    }
    getBoostByType(d) {
        return this.boost.find(f=>f.type === d)
    }
    getActiveBostByType(d) {
        if (d === "turbo" && !this._boostActive.value)
            return;
        const f = this.getBoostByType(d);
        if (f && f.end > this.now)
            return f
    }
    get activeBoosts() {
        return this.boost.filter(d=>d.end > this.now)
    }
    getClaimsByType(d) {
        return this._claims.value.filter(f=>f[0] === d).map(f=>parseInt(f.substring(1)))
    }
    get notificationClaim() {
        const d = this._claims.value.find(f=>f[0] === "N");
        return d ? this._conf.getNotificationById(d) : void 0
    }
    get cinemaClaim() {
        return this._claims.value.find(d=>d === "CINEMA")
    }
    get ligue() {
        return this._ligue.value
    }
    get haveTapBot() {
        return this._data.tap_bot
    }
    get stat() {
        return this._data.stat
    }
    get login_ts() {
        return this._data.login_ts
    }
    set login_ts(d) {
        this._data.login_ts = d
    }
    get needClaimBotEarnings() {
        return this.haveTapBot && this.climableBotEarnings > 0
    }
    get climableBotEarnings() {
        return this._tappedBalance.value >= 0 ? 0 : Math.abs(this._tappedBalance.value)
    }
    get currentBotEranings() {
        if (!this.haveTapBot || this.needClaimBotEarnings)
            return 0;
        const d = this._conf.tapBot.duration * this.currentTapLevel.rate;
        return Math.min(d, Math.max(this.energyLeft + this.recoveredEnergyByTime - this.currentEnergyLevel.limit, 0))
    }
    claimBotEarnings() {
        this.needClaimBotEarnings && (this._tappedBalance.value = 0)
    }
    get blocksMined() {
        return this._blocks_mined.value
    }
    claimTownEarnings() {
        this._blocks_mined.value = 0
    }
    get boughtAssets() {
        return this._data.bought_assets
    }
}
class AdsService {
    constructor(d, f, m, k) {
        fn(this, "_adControllers", {});
        fn(this, "_boost_addons", []);
        fn(this, "_wait_ad", {});
        this._api = d,
        this._player = f,
        this._log = m,
        Math.random() < (k.payment_chance || 0) && k.ads_enabled && k.boost_addons && k.boost_addons.length > 0 && (this._boost_addons = k.boost_addons)
    }
    canUseAdForBoost(d) {
        if (this._boost_addons.length === 0)
            return !1;
        const f = this._boost_addons.find(k=>k.type === d);
        if (!f)
            return !1;
        const m = this._player.boost.find(k=>k.type === d);
        return m ? m.cnt === 0 && (m.addons_cnt || 0) < f.max_day_use_cnt : !1
    }
    getAdController(d) {
        return this._adControllers[d] || (this._adControllers[d] = window.Adsgram.init({
            blockId: d
        })),
        this._adControllers[d]
    }
    async showAd(d) {
        var k;
        if (this.getWaitTime(d) > time.now())
            return;
        const m = this._boost_addons.find(y=>y.type === d);
        if (m) {
            const y = this.getAdController(m.blockId);
            try {
                if ((await y.show()).done) {
                    const dt = await this._api.player_applyBoostAddon.post({
                        type: d
                    });
                    (k = this._player) == null || k.update(dt.player)
                }
            } catch (ee) {
                this._wait_ad[m.blockId] = time.addSeconds(time.now(), 30);
                try {
                    this._log.error("showAd error", JSON.stringify(ee))
                } catch (dt) {
                    this._log.error("showAd error catch", dt)
                }
            }
        }
    }
    getWaitTime(d) {
        const f = this._boost_addons.find(m=>m.type === d);
        return f && this._wait_ad[f.blockId] || 0
    }
}
class InvoicesService {
    constructor(d) {
        fn(this, "_interval");
        fn(this, "_last_check_at", 0);
        this.app = d
    }
    async checkInvoice(d) {
        const f = (this.app.account.pendingInvoices || []).find(k=>k.id === d);
        if (!f || !f.isAwaitingConfirmations)
            return;
        const m = await this.app.api.invoices_getInvoice.post({
            id: d
        });
        if (m.invoice.status !== "pending" && this.app.account.updateInvoice(m.invoice),
        m.invoice.status === "paid") {
            const k = await this.app.api.player_getPlayer.post();
            k.player && this.app.player.update(k.player)
        }
        this._last_check_at = time.now()
    }
    async updateInvoices() {
        if (this.app.account.pendingInvoices)
            return;
        const d = await this.app.api.invoices_getInvoices.post({
            skip: 0,
            statuses: ["pending"]
        });
        this.app.account.pendingInvoices = d.invoices.map(f=>new InvoiceModel(f))
    }
    async getInvoice(d, f) {
        var k;
        let m = (k = this.app.account.pendingInvoices) == null ? void 0 : k.find(y=>y.itemId === d && y.paymentDetails.payment_method === f && y.status === "pending");
        if (!m)
            try {
                const ee = await (f === "TON" ? this.app.api.market_buyWithTon : this.app.api.market_buyWithStars).post({
                    item_id: d
                });
                m = this.app.account.updateInvoice(ee.invoice)
            } catch (y) {
                this.app.notification.showError(y.message)
            }
        return m
    }
    runCheckInvoice(d) {
        this._interval || (time.now() - this._last_check_at > 1e4 && this.checkInvoice(d).catch(console.error),
        this._interval = setInterval(()=>{
            this.checkInvoice(d).catch(console.error)
        }
        , 1e4))
    }
    stopCheckInvoice() {
        this._interval && (clearInterval(this._interval),
        this._interval = void 0)
    }
}
class NavService {
    constructor() {
        fn(this, "_history", []);
        fn(this, "_page", a$1("taps"));
        fn(this, "_pageProps")
    }
    back() {
        if (this._history.length === 0)
            return;
        const d = this._history.pop();
        d && d(),
        this._history.length === 0 && Telegram.WebApp.BackButton.hide()
    }
    init() {
        this._history = [],
        Telegram.WebApp.onEvent("backButtonClicked", ()=>this.back()),
        Telegram.WebApp.BackButton.hide()
    }
    regBackFunction(d) {
        Telegram.WebApp.BackButton.show(),
        this._history.push(d)
    }
    get page() {
        return this._page.value
    }
    get pageProps() {
        return this._pageProps
    }
    clean() {
        this._history = [],
        Telegram.WebApp.BackButton.hide()
    }
    setPage(d) {
        this.clean(),
        this._pageProps = void 0,
        this._page.value = d,
        Telegram.WebApp.HapticFeedback.impactOccurred("light")
    }
    setPageWithBack(d, f) {
        const m = this._page.value.toString();
        this.regBackFunction(()=>this.setPage(m)),
        this._pageProps = f,
        this._page.value = d
    }
}
class NotificationService {
    constructor() {
        fn(this, "_message", a$1(""));
        fn(this, "_type", a$1("info"))
    }
    start() {
        setTimeout(()=>{
            this.close()
        }
        , 5e3)
    }
    showError(d) {
        this._message.value = d,
        this._type.value = "error",
        this.start()
    }
    showInfo(d) {
        this._message.value = d,
        this._type.value = "info",
        this.start()
    }
    close() {
        this._message.value = ""
    }
    get message() {
        return this._message.value
    }
    get type() {
        return this._type.value
    }
}
const global$1 = globalThis || void 0 || self
  , te = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/
  , re = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/
  , se = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function oe(r, d) {
    if (r === "__proto__" || r === "constructor" && d && typeof d == "object" && "prototype"in d) {
        ne(r);
        return
    }
    return d
}
function ne(r) {
    console.warn(`[destr] Dropping "${r}" key to prevent prototype pollution.`)
}
function ae(r, d={}) {
    if (typeof r != "string")
        return r;
    const f = r.trim();
    if (r[0] === '"' && r.endsWith('"') && !r.includes("\\"))
        return f.slice(1, -1);
    if (f.length <= 9) {
        const m = f.toLowerCase();
        if (m === "true")
            return !0;
        if (m === "false")
            return !1;
        if (m === "undefined")
            return;
        if (m === "null")
            return null;
        if (m === "nan")
            return Number.NaN;
        if (m === "infinity")
            return Number.POSITIVE_INFINITY;
        if (m === "-infinity")
            return Number.NEGATIVE_INFINITY
    }
    if (!se.test(r)) {
        if (d.strict)
            throw new SyntaxError("[destr] Invalid JSON");
        return r
    }
    try {
        if (te.test(r) || re.test(r)) {
            if (d.strict)
                throw new Error("[destr] Possible prototype pollution");
            return JSON.parse(r, oe)
        }
        return JSON.parse(r)
    } catch (m) {
        if (d.strict)
            throw m;
        return r
    }
}
const ie = /#/g
  , ce = /&/g
  , he = /\//g
  , fe = /=/g
  , T = /\+/g
  , le = /%5e/gi
  , ue = /%60/gi
  , pe = /%7c/gi
  , de = /%20/gi;
function ye(r) {
    return encodeURI("" + r).replace(pe, "|")
}
function _(r) {
    return ye(typeof r == "string" ? r : JSON.stringify(r)).replace(T, "%2B").replace(de, "+").replace(ie, "%23").replace(ce, "%26").replace(ue, "`").replace(le, "^").replace(he, "%2F")
}
function g(r) {
    return _(r).replace(fe, "%3D")
}
function M(r="") {
    try {
        return decodeURIComponent("" + r)
    } catch {
        return "" + r
    }
}
function me(r) {
    return M(r.replace(T, " "))
}
function ge(r) {
    return M(r.replace(T, " "))
}
function Ee(r="") {
    const d = {};
    r[0] === "?" && (r = r.slice(1));
    for (const f of r.split("&")) {
        const m = f.match(/([^=]+)=?(.*)/) || [];
        if (m.length < 2)
            continue;
        const k = me(m[1]);
        if (k === "__proto__" || k === "constructor")
            continue;
        const y = ge(m[2] || "");
        d[k] === void 0 ? d[k] = y : Array.isArray(d[k]) ? d[k].push(y) : d[k] = [d[k], y]
    }
    return d
}
function we(r, d) {
    return (typeof d == "number" || typeof d == "boolean") && (d = String(d)),
    d ? Array.isArray(d) ? d.map(f=>`${g(r)}=${_(f)}`).join("&") : `${g(r)}=${_(d)}` : g(r)
}
function _e(r) {
    return Object.keys(r).filter(d=>r[d] !== void 0).map(d=>we(d, r[d])).filter(Boolean).join("&")
}
const Ae = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/
  , be = /^[\s\w\0+.-]{2,}:([/\\]{2})?/
  , Re = /^([/\\]\s*){2,}[^/\\]/
  , Te = /\/$|\/\?|\/#/
  , Ce = /^\.?\//;
function W(r, d={}) {
    return typeof d == "boolean" && (d = {
        acceptRelative: d
    }),
    d.strict ? Ae.test(r) : be.test(r) || (d.acceptRelative ? Re.test(r) : !1)
}
function A(r="", d) {
    return d ? Te.test(r) : r.endsWith("/")
}
function Se(r="", d) {
    if (!d)
        return (A(r) ? r.slice(0, -1) : r) || "/";
    if (!A(r, !0))
        return r || "/";
    let f = r
      , m = "";
    const k = r.indexOf("#");
    k >= 0 && (f = r.slice(0, k),
    m = r.slice(k));
    const [y,...ee] = f.split("?");
    return ((y.endsWith("/") ? y.slice(0, -1) : y) || "/") + (ee.length > 0 ? `?${ee.join("?")}` : "") + m
}
function Le(r="", d) {
    if (!d)
        return r.endsWith("/") ? r : r + "/";
    if (A(r, !0))
        return r || "/";
    let f = r
      , m = "";
    const k = r.indexOf("#");
    if (k >= 0 && (f = r.slice(0, k),
    m = r.slice(k),
    !f))
        return m;
    const [y,...ee] = f.split("?");
    return y + "/" + (ee.length > 0 ? `?${ee.join("?")}` : "") + m
}
function Ie(r, d) {
    if ($e(d) || W(r))
        return r;
    const f = Se(d);
    return r.startsWith(f) ? r : xe(f, r)
}
function Oe(r, d) {
    const f = K(r)
      , m = {
        ...Ee(f.search),
        ...d
    };
    return f.search = _e(m),
    Fe(f)
}
function $e(r) {
    return !r || r === "/"
}
function Pe(r) {
    return r && r !== "/"
}
function xe(r, ...d) {
    let f = r || "";
    for (const m of d.filter(k=>Pe(k)))
        if (f) {
            const k = m.replace(Ce, "");
            f = Le(f) + k
        } else
            f = m;
    return f
}
const J = Symbol.for("ufo:protocolRelative");
function K(r="", d) {
    const f = r.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i);
    if (f) {
        const [,bt,wt=""] = f;
        return {
            protocol: bt.toLowerCase(),
            pathname: wt,
            href: bt + wt,
            auth: "",
            host: "",
            search: "",
            hash: ""
        }
    }
    if (!W(r, {
        acceptRelative: !0
    }))
        return d ? K(d + r) : I(r);
    const [,m="",k,y=""] = r.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || []
      , [,ee="",dt=""] = y.match(/([^#/?]*)(.*)?/) || []
      , {pathname: mt, search: yt, hash: pt} = I(dt.replace(/\/(?=[A-Za-z]:)/, ""));
    return {
        protocol: m.toLowerCase(),
        auth: k ? k.slice(0, Math.max(0, k.length - 1)) : "",
        host: ee,
        pathname: mt,
        search: yt,
        hash: pt,
        [J]: !m
    }
}
function I(r="") {
    const [d="",f="",m=""] = (r.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
    return {
        pathname: d,
        search: f,
        hash: m
    }
}
function Fe(r) {
    const d = r.pathname || ""
      , f = r.search ? (r.search.startsWith("?") ? "" : "?") + r.search : ""
      , m = r.hash || ""
      , k = r.auth ? r.auth + "@" : ""
      , y = r.host || "";
    return (r.protocol || r[J] ? (r.protocol || "") + "//" : "") + k + y + d + f + m
}
class ve extends Error {
    constructor(d, f) {
        super(d, f),
        this.name = "FetchError",
        f != null && f.cause && !this.cause && (this.cause = f.cause)
    }
}
function Ne(r) {
    var d, f, m, k, y;
    const ee = ((d = r.error) == null ? void 0 : d.message) || ((f = r.error) == null ? void 0 : f.toString()) || ""
      , dt = ((m = r.request) == null ? void 0 : m.method) || ((k = r.options) == null ? void 0 : k.method) || "GET"
      , mt = ((y = r.request) == null ? void 0 : y.url) || String(r.request) || "/"
      , yt = `[${dt}] ${JSON.stringify(mt)}`
      , pt = r.response ? `${r.response.status} ${r.response.statusText}` : "<no response>"
      , bt = `${yt}: ${pt}${ee ? ` ${ee}` : ""}`
      , wt = new ve(bt,r.error ? {
        cause: r.error
    } : void 0);
    for (const xt of ["request", "options", "response"])
        Object.defineProperty(wt, xt, {
            get() {
                return r[xt]
            }
        });
    for (const [xt,At] of [["data", "_data"], ["status", "status"], ["statusCode", "status"], ["statusText", "statusText"], ["statusMessage", "statusText"]])
        Object.defineProperty(wt, xt, {
            get() {
                return r.response && r.response[At]
            }
        });
    return wt
}
const Ue = new Set(Object.freeze(["PATCH", "POST", "PUT", "DELETE"]));
function O(r="GET") {
    return Ue.has(r.toUpperCase())
}
function je(r) {
    if (r === void 0)
        return !1;
    const d = typeof r;
    return d === "string" || d === "number" || d === "boolean" || d === null ? !0 : d !== "object" ? !1 : Array.isArray(r) ? !0 : r.buffer ? !1 : r.constructor && r.constructor.name === "Object" || typeof r.toJSON == "function"
}
const qe = new Set(["image/svg", "application/xml", "application/xhtml", "application/html"])
  , ze = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function De(r="") {
    if (!r)
        return "json";
    const d = r.split(";").shift() || "";
    return ze.test(d) ? "json" : qe.has(d) || d.startsWith("text/") ? "text" : "blob"
}
function Ge(r, d, f=globalThis.Headers) {
    const m = {
        ...d,
        ...r
    };
    if (d != null && d.params && r != null && r.params && (m.params = {
        ...d == null ? void 0 : d.params,
        ...r == null ? void 0 : r.params
    }),
    d != null && d.query && r != null && r.query && (m.query = {
        ...d == null ? void 0 : d.query,
        ...r == null ? void 0 : r.query
    }),
    d != null && d.headers && r != null && r.headers) {
        m.headers = new f((d == null ? void 0 : d.headers) || {});
        for (const [k,y] of new f((r == null ? void 0 : r.headers) || {}))
            m.headers.set(k, y)
    }
    return m
}
const Me = new Set([408, 409, 425, 429, 500, 502, 503, 504])
  , We = new Set([101, 204, 205, 304]);
function V(r={}) {
    const {fetch: d=globalThis.fetch, Headers: f=globalThis.Headers, AbortController: m=globalThis.AbortController} = r;
    async function k(dt) {
        const mt = dt.error && dt.error.name === "AbortError" && !dt.options.timeout || !1;
        if (dt.options.retry !== !1 && !mt) {
            let pt;
            typeof dt.options.retry == "number" ? pt = dt.options.retry : pt = O(dt.options.method) ? 0 : 1;
            const bt = dt.response && dt.response.status || 500;
            if (pt > 0 && (Array.isArray(dt.options.retryStatusCodes) ? dt.options.retryStatusCodes.includes(bt) : Me.has(bt))) {
                const wt = dt.options.retryDelay || 0;
                return wt > 0 && await new Promise(xt=>setTimeout(xt, wt)),
                y(dt.request, {
                    ...dt.options,
                    retry: pt - 1
                })
            }
        }
        const yt = Ne(dt);
        throw Error.captureStackTrace && Error.captureStackTrace(yt, y),
        yt
    }
    const y = async function(dt, mt={}) {
        var yt;
        const pt = {
            request: dt,
            options: Ge(mt, r.defaults, f),
            response: void 0,
            error: void 0
        };
        pt.options.method = (yt = pt.options.method) == null ? void 0 : yt.toUpperCase(),
        pt.options.onRequest && await pt.options.onRequest(pt),
        typeof pt.request == "string" && (pt.options.baseURL && (pt.request = Ie(pt.request, pt.options.baseURL)),
        (pt.options.query || pt.options.params) && (pt.request = Oe(pt.request, {
            ...pt.options.params,
            ...pt.options.query
        }))),
        pt.options.body && O(pt.options.method) && (je(pt.options.body) ? (pt.options.body = typeof pt.options.body == "string" ? pt.options.body : JSON.stringify(pt.options.body),
        pt.options.headers = new f(pt.options.headers || {}),
        pt.options.headers.has("content-type") || pt.options.headers.set("content-type", "application/json"),
        pt.options.headers.has("accept") || pt.options.headers.set("accept", "application/json")) : ("pipeTo"in pt.options.body && typeof pt.options.body.pipeTo == "function" || typeof pt.options.body.pipe == "function") && ("duplex"in pt.options || (pt.options.duplex = "half")));
        let bt;
        if (!pt.options.signal && pt.options.timeout) {
            const wt = new m;
            bt = setTimeout(()=>wt.abort(), pt.options.timeout),
            pt.options.signal = wt.signal
        }
        try {
            pt.response = await d(pt.request, pt.options)
        } catch (wt) {
            return pt.error = wt,
            pt.options.onRequestError && await pt.options.onRequestError(pt),
            await k(pt)
        } finally {
            bt && clearTimeout(bt)
        }
        if (pt.response.body && !We.has(pt.response.status) && pt.options.method !== "HEAD") {
            const wt = (pt.options.parseResponse ? "json" : pt.options.responseType) || De(pt.response.headers.get("content-type") || "");
            switch (wt) {
            case "json":
                {
                    const xt = await pt.response.text()
                      , At = pt.options.parseResponse || ae;
                    pt.response._data = At(xt);
                    break
                }
            case "stream":
                {
                    pt.response._data = pt.response.body;
                    break
                }
            default:
                pt.response._data = await pt.response[wt]()
            }
        }
        return pt.options.onResponse && await pt.options.onResponse(pt),
        !pt.options.ignoreResponseError && pt.response.status >= 400 && pt.response.status < 600 ? (pt.options.onResponseError && await pt.options.onResponseError(pt),
        await k(pt)) : pt.response
    }
      , ee = async function(dt, mt) {
        return (await y(dt, mt))._data
    };
    return ee.raw = y,
    ee.native = (...dt)=>d(...dt),
    ee.create = (dt={})=>V({
        ...r,
        defaults: {
            ...r.defaults,
            ...dt
        }
    }),
    ee
}
const C = function() {
    if (typeof globalThis < "u")
        return globalThis;
    if (typeof self < "u")
        return self;
    if (typeof window < "u")
        return window;
    if (typeof global$1 < "u")
        return global$1;
    throw new Error("unable to locate global object")
}()
  , Je = C.fetch || (()=>Promise.reject(new Error("[ofetch] global.fetch is not supported!")))
  , Ke = C.Headers
  , Ve = C.AbortController
  , Qe = V({
    fetch: Je,
    Headers: Ke,
    AbortController: Ve
});
function He(r) {
    return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r
}
var S = {
    exports: {}
};
const Q = r=>typeof r == "object" && r !== null
  , H = Symbol("skip")
  , $ = r=>Q(r) && !(r instanceof RegExp) && !(r instanceof Error) && !(r instanceof Date)
  , b = (r,d,f,m=new WeakMap)=>{
    if (f = {
        deep: !1,
        target: {},
        ...f
    },
    m.has(r))
        return m.get(r);
    m.set(r, f.target);
    const {target: k} = f;
    delete f.target;
    const y = ee=>ee.map(dt=>$(dt) ? b(dt, d, f, m) : dt);
    if (Array.isArray(r))
        return y(r);
    for (const [ee,dt] of Object.entries(r)) {
        const mt = d(ee, dt, r);
        if (mt === H)
            continue;
        let[yt,pt,{shouldRecurse: bt=!0}={}] = mt;
        yt !== "__proto__" && (f.deep && bt && $(pt) && (pt = Array.isArray(pt) ? y(pt) : b(pt, d, f, m)),
        k[yt] = pt)
    }
    return k
}
;
S.exports = (r,d,f)=>{
    if (!Q(r))
        throw new TypeError(`Expected an object, got \`${r}\` (${typeof r})`);
    return b(r, d, f)
}
;
S.exports.mapObjectSkip = H;
var Be = S.exports;
const P = He(Be);
class B extends Map {
    constructor(d={}) {
        if (super(),
        !(d.maxSize && d.maxSize > 0))
            throw new TypeError("`maxSize` must be a number greater than 0");
        if (typeof d.maxAge == "number" && d.maxAge === 0)
            throw new TypeError("`maxAge` must be a number greater than 0");
        this.maxSize = d.maxSize,
        this.maxAge = d.maxAge || Number.POSITIVE_INFINITY,
        this.onEviction = d.onEviction,
        this.cache = new Map,
        this.oldCache = new Map,
        this._size = 0
    }
    _emitEvictions(d) {
        if (typeof this.onEviction == "function")
            for (const [f,m] of d)
                this.onEviction(f, m.value)
    }
    _deleteIfExpired(d, f) {
        return typeof f.expiry == "number" && f.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(d, f.value),
        this.delete(d)) : !1
    }
    _getOrDeleteIfExpired(d, f) {
        if (this._deleteIfExpired(d, f) === !1)
            return f.value
    }
    _getItemValue(d, f) {
        return f.expiry ? this._getOrDeleteIfExpired(d, f) : f.value
    }
    _peek(d, f) {
        const m = f.get(d);
        return this._getItemValue(d, m)
    }
    _set(d, f) {
        this.cache.set(d, f),
        this._size++,
        this._size >= this.maxSize && (this._size = 0,
        this._emitEvictions(this.oldCache),
        this.oldCache = this.cache,
        this.cache = new Map)
    }
    _moveToRecent(d, f) {
        this.oldCache.delete(d),
        this._set(d, f)
    }
    *_entriesAscending() {
        for (const d of this.oldCache) {
            const [f,m] = d;
            this.cache.has(f) || this._deleteIfExpired(f, m) === !1 && (yield d)
        }
        for (const d of this.cache) {
            const [f,m] = d;
            this._deleteIfExpired(f, m) === !1 && (yield d)
        }
    }
    get(d) {
        if (this.cache.has(d)) {
            const f = this.cache.get(d);
            return this._getItemValue(d, f)
        }
        if (this.oldCache.has(d)) {
            const f = this.oldCache.get(d);
            if (this._deleteIfExpired(d, f) === !1)
                return this._moveToRecent(d, f),
                f.value
        }
    }
    set(d, f, {maxAge: m=this.maxAge}={}) {
        const k = typeof m == "number" && m !== Number.POSITIVE_INFINITY ? Date.now() + m : void 0;
        return this.cache.has(d) ? this.cache.set(d, {
            value: f,
            expiry: k
        }) : this._set(d, {
            value: f,
            expiry: k
        }),
        this
    }
    has(d) {
        return this.cache.has(d) ? !this._deleteIfExpired(d, this.cache.get(d)) : this.oldCache.has(d) ? !this._deleteIfExpired(d, this.oldCache.get(d)) : !1
    }
    peek(d) {
        if (this.cache.has(d))
            return this._peek(d, this.cache);
        if (this.oldCache.has(d))
            return this._peek(d, this.oldCache)
    }
    delete(d) {
        const f = this.cache.delete(d);
        return f && this._size--,
        this.oldCache.delete(d) || f
    }
    clear() {
        this.cache.clear(),
        this.oldCache.clear(),
        this._size = 0
    }
    resize(d) {
        if (!(d && d > 0))
            throw new TypeError("`maxSize` must be a number greater than 0");
        const f = [...this._entriesAscending()]
          , m = f.length - d;
        m < 0 ? (this.cache = new Map(f),
        this.oldCache = new Map,
        this._size = f.length) : (m > 0 && this._emitEvictions(f.slice(0, m)),
        this.oldCache = new Map(f.slice(m)),
        this.cache = new Map,
        this._size = 0),
        this.maxSize = d
    }
    *keys() {
        for (const [d] of this)
            yield d
    }
    *values() {
        for (const [,d] of this)
            yield d
    }
    *[Symbol.iterator]() {
        for (const d of this.cache) {
            const [f,m] = d;
            this._deleteIfExpired(f, m) === !1 && (yield[f, m.value])
        }
        for (const d of this.oldCache) {
            const [f,m] = d;
            this.cache.has(f) || this._deleteIfExpired(f, m) === !1 && (yield[f, m.value])
        }
    }
    *entriesDescending() {
        let d = [...this.cache];
        for (let f = d.length - 1; f >= 0; --f) {
            const m = d[f]
              , [k,y] = m;
            this._deleteIfExpired(k, y) === !1 && (yield[k, y.value])
        }
        d = [...this.oldCache];
        for (let f = d.length - 1; f >= 0; --f) {
            const m = d[f]
              , [k,y] = m;
            this.cache.has(k) || this._deleteIfExpired(k, y) === !1 && (yield[k, y.value])
        }
    }
    *entriesAscending() {
        for (const [d,f] of this._entriesAscending())
            yield[d, f.value]
    }
    get size() {
        if (!this._size)
            return this.oldCache.size;
        let d = 0;
        for (const f of this.oldCache.keys())
            this.cache.has(f) || d++;
        return Math.min(this._size + d, this.maxSize)
    }
    entries() {
        return this.entriesAscending()
    }
    forEach(d, f=this) {
        for (const [m,k] of this.entriesAscending())
            d.call(f, k, m, this)
    }
    get[Symbol.toStringTag]() {
        return JSON.stringify([...this.entriesAscending()])
    }
}
const Ye = (r,d)=>(r = r.replace(new RegExp("((?<![\\p{Uppercase_Letter}\\d])[\\p{Uppercase_Letter}\\d](?![\\p{Uppercase_Letter}\\d]))","gu"), f=>f.toLowerCase()),
r.replace(new RegExp("(\\p{Uppercase_Letter}+)(\\p{Uppercase_Letter}\\p{Lowercase_Letter}+)","gu"), (f,m,k)=>m + d + k.toLowerCase()));
function Xe(r, {separator: d="_", preserveConsecutiveUppercase: f=!1}={}) {
    if (!(typeof r == "string" && typeof d == "string"))
        throw new TypeError("The `text` and `separator` arguments should be of type `string`");
    if (r.length < 2)
        return f ? r : r.toLowerCase();
    const m = `$1${d}$2`
      , k = r.replace(new RegExp("([\\p{Lowercase_Letter}\\d])(\\p{Uppercase_Letter})","gu"), m);
    return f ? Ye(k, d) : k.replace(new RegExp("(\\p{Uppercase_Letter})(\\p{Uppercase_Letter}\\p{Lowercase_Letter}+)","gu"), m).toLowerCase()
}
const Ze = (r,d)=>r.some(f=>typeof f == "string" ? f === d : (f.lastIndex = 0,
f.test(d)))
  , E = new B({
    maxSize: 1e5
})
  , x = r=>typeof r == "object" && r !== null && !(r instanceof RegExp) && !(r instanceof Error) && !(r instanceof Date)
  , F = (r,d={})=>{
    if (!x(r))
        return r;
    const {separator: f="_", exclude: m, deep: k=!1} = d
      , y = ee=>(dt,mt)=>{
        if (k && x(mt) && (mt = P(mt, y())),
        !(m && Ze(m, dt))) {
            const yt = `${f}${dt}`;
            if (E.has(yt))
                dt = E.get(yt);
            else {
                const pt = Xe(dt, {
                    separator: f
                });
                dt.length < 100 && E.set(yt, pt),
                dt = pt
            }
        }
        return [dt, mt]
    }
    ;
    return P(r, y())
}
;
function ke(r, d) {
    return Array.isArray(r) ? Object.keys(r).map(f=>F(r[f], d)) : F(r, d)
}
function et(r) {
    return ke(r, {
        deep: !0
    })
}
function v(r) {
    let d = r;
    for (; d.indexOf("/") >= 0; )
        d = d.replace("/", "_");
    for (; d.indexOf("+") >= 0; )
        d = d.replace("+", "-");
    for (; d.indexOf("=") >= 0; )
        d = d.replace("=", "");
    return d
}
function u(r, d) {
    const f = r.replace(/{([a-zA-Z0-9_]+)}/g, (m,k)=>{
        var y, ee;
        const dt = (y = d == null ? void 0 : d.query) == null ? void 0 : y[k];
        if (!dt)
            throw new Error(`Missing value for path parameter "${k}"`);
        return (ee = d == null ? void 0 : d.query) == null || delete ee[k],
        v(dt)
    }
    );
    if (d != null && d.query) {
        for (const m in d.query) {
            const k = d.query[m];
            typeof k == "string" && (d.query[m] = v(k))
        }
        d.query = et(d.query)
    }
    return [f, d]
}
const Y = r=>typeof r == "object" && r !== null
  , N = r=>Y(r) && !(r instanceof RegExp) && !(r instanceof Error) && !(r instanceof Date)
  , tt = Symbol("mapObjectSkip")
  , R = (r,d,f,m=new WeakMap)=>{
    if (f = {
        deep: !1,
        target: {},
        ...f
    },
    m.has(r))
        return m.get(r);
    m.set(r, f.target);
    const {target: k} = f;
    delete f.target;
    const y = ee=>ee.map(dt=>N(dt) ? R(dt, d, f, m) : dt);
    if (Array.isArray(r))
        return y(r);
    for (const [ee,dt] of Object.entries(r)) {
        const mt = d(ee, dt, r);
        if (mt === tt)
            continue;
        let[yt,pt,{shouldRecurse: bt=!0}={}] = mt;
        yt !== "__proto__" && (f.deep && bt && N(pt) && (pt = Array.isArray(pt) ? y(pt) : R(pt, d, f, m)),
        k[yt] = pt)
    }
    return k
}
;
function U(r, d, f) {
    if (!Y(r))
        throw new TypeError(`Expected an object, got \`${r}\` (${typeof r})`);
    return R(r, d, f)
}
const rt = /[\p{Lu}]/u
  , st = /[\p{Ll}]/u
  , j = /^[\p{Lu}](?![\p{Lu}])/gu
  , X = /([\p{Alpha}\p{N}_]|$)/u
  , L$1 = /[_.\- ]+/
  , ot = new RegExp("^" + L$1.source)
  , q = new RegExp(L$1.source + X.source,"gu")
  , z = new RegExp("\\d+" + X.source,"gu")
  , nt = (r,d,f,m)=>{
    let k = !1
      , y = !1
      , ee = !1
      , dt = !1;
    for (let mt = 0; mt < r.length; mt++) {
        const yt = r[mt];
        dt = mt > 2 ? r[mt - 3] === "-" : !0,
        k && rt.test(yt) ? (r = r.slice(0, mt) + "-" + r.slice(mt),
        k = !1,
        ee = y,
        y = !0,
        mt++) : y && ee && st.test(yt) && (!dt || m) ? (r = r.slice(0, mt - 1) + "-" + r.slice(mt - 1),
        ee = y,
        y = !1,
        k = !0) : (k = d(yt) === yt && f(yt) !== yt,
        ee = y,
        y = f(yt) === yt && d(yt) !== yt)
    }
    return r
}
  , at = (r,d)=>(j.lastIndex = 0,
r.replaceAll(j, f=>d(f)))
  , it = (r,d)=>(q.lastIndex = 0,
z.lastIndex = 0,
r.replaceAll(z, (f,m,k)=>["_", "-"].includes(r.charAt(k + f.length)) ? f : d(f)).replaceAll(q, (f,m)=>d(m)));
function ct(r, d) {
    if (!(typeof r == "string" || Array.isArray(r)))
        throw new TypeError("Expected the input to be `string | string[]`");
    if (d = {
        pascalCase: !1,
        preserveConsecutiveUppercase: !1,
        ...d
    },
    Array.isArray(r) ? r = r.map(k=>k.trim()).filter(k=>k.length).join("-") : r = r.trim(),
    r.length === 0)
        return "";
    const f = d.locale === !1 ? k=>k.toLowerCase() : k=>k.toLocaleLowerCase(d.locale)
      , m = d.locale === !1 ? k=>k.toUpperCase() : k=>k.toLocaleUpperCase(d.locale);
    return r.length === 1 ? L$1.test(r) ? "" : d.pascalCase ? m(r) : f(r) : (r !== f(r) && (r = nt(r, f, m, d.preserveConsecutiveUppercase)),
    r = r.replace(ot, ""),
    r = d.preserveConsecutiveUppercase ? at(r, f) : f(r),
    d.pascalCase && (r = m(r.charAt(0)) + r.slice(1)),
    it(r, m))
}
const ht = (r,d)=>r.some(f=>typeof f == "string" ? f === d : (f.lastIndex = 0,
f.test(d)))
  , w = new B({
    maxSize: 1e5
})
  , D = r=>typeof r == "object" && r !== null && !(r instanceof RegExp) && !(r instanceof Error) && !(r instanceof Date)
  , G = (r,d={})=>{
    if (!D(r))
        return r;
    const {exclude: f, pascalCase: m=!1, stopPaths: k, deep: y=!1, preserveConsecutiveUppercase: ee=!1} = d
      , dt = new Set(k)
      , mt = yt=>(pt,bt)=>{
        if (y && D(bt)) {
            const wt = yt === void 0 ? pt : `${yt}.${pt}`;
            dt.has(wt) || (bt = U(bt, mt(wt)))
        }
        if (!(f && ht(f, pt))) {
            const wt = m ? `${pt}_` : pt;
            if (w.has(wt))
                pt = w.get(wt);
            else {
                const xt = ct(pt, {
                    pascalCase: m,
                    locale: !1,
                    preserveConsecutiveUppercase: ee
                });
                pt.length < 100 && w.set(wt, xt),
                pt = xt
            }
        }
        return [pt, bt]
    }
    ;
    return U(r, mt(void 0))
}
;
function ft(r, d) {
    return Array.isArray(r) ? Object.keys(r).map(f=>G(r[f], d)) : G(r, d)
}
function lt(r) {
    return ft(r, {
        deep: !0
    })
}
function Z(r) {
    const d = {};
    for (const f in r) {
        const m = r[f];
        d[f] = m === null ? void 0 : m && typeof m == "object" && m.__proto__.constructor === Object ? Z(m) : m
    }
    return d
}
function p(r) {
    return Z(lt(r))
}
class ut {
    constructor(d) {
        const f = new URL((d == null ? void 0 : d.baseURL) ?? (d == null ? void 0 : d.baseUrl) ?? "https://api.ston.fi")
          , m = [...new URLSearchParams(f.search)].reduce((k,[y,ee])=>({
            ...k,
            [y]: ee
        }), {});
        this.apiFetch = Qe.create({
            baseURL: `${f.origin}${f.pathname}`,
            query: m
        })
    }
    async getAsset(d) {
        return p(await this.apiFetch(...u("/v1/assets/{assetAddress}", {
            method: "GET",
            query: {
                assetAddress: d
            }
        }))).asset
    }
    async getAssets() {
        return p(await this.apiFetch(...u("/v1/assets", {
            method: "GET"
        }))).assetList
    }
    async getFarm(d) {
        return p(await this.apiFetch(...u("/v1/farms/{farmAddress}", {
            method: "GET",
            query: {
                farmAddress: d
            }
        }))).farm
    }
    async getFarms() {
        return p(await this.apiFetch(...u("/v1/farms", {
            method: "GET"
        }))).farmList
    }
    async getFarmsByPool(d) {
        return p(await this.apiFetch(...u("/v1/farms_by_pool/{poolAddress}", {
            method: "GET",
            query: {
                poolAddress: d
            }
        }))).farmList
    }
    async getSwapPairs() {
        return p(await this.apiFetch(...u("/v1/markets", {
            method: "GET"
        }))).pairs
    }
    async getSwapStatus(d) {
        return p(await this.apiFetch(...u("/v1/swap/status", {
            method: "GET",
            query: d
        })))
    }
    async getPool(d) {
        return p(await this.apiFetch(...u("/v1/pools/{poolAddress}", {
            method: "GET",
            query: {
                poolAddress: d
            }
        }))).pool
    }
    async getPools() {
        return p(await this.apiFetch(...u("/v1/pools", {
            method: "GET"
        }))).poolList
    }
    async simulateSwap(d) {
        return p(await this.apiFetch(...u("/v1/swap/simulate", {
            method: "POST",
            query: {
                ...d,
                units: d.offerUnits
            }
        })))
    }
    async simulateReverseSwap(d) {
        return p(await this.apiFetch(...u("/v1/reverse_swap/simulate", {
            method: "POST",
            query: {
                ...d,
                units: d.askUnits
            }
        })))
    }
    async getJettonWalletAddress(d) {
        return p(await this.apiFetch(...u("/v1/jetton/{jettonAddress}/address", {
            method: "GET",
            query: d
        }))).address
    }
    async getWalletAsset(d) {
        return p(await this.apiFetch(...u("/v1/wallets/{walletAddress}/assets/{assetAddress}", {
            method: "GET",
            query: d
        }))).asset
    }
    async getWalletAssets(d) {
        return p(await this.apiFetch(...u("/v1/wallets/{walletAddress}/assets", {
            method: "GET",
            query: {
                walletAddress: d
            }
        }))).assetList
    }
    async getWalletFarm(d) {
        return p(await this.apiFetch(...u("/v1/wallets/{walletAddress}/farms/{farmAddress}", {
            method: "GET",
            query: d
        }))).farm
    }
    async getWalletFarms(d) {
        return p(await this.apiFetch(...u("/v1/wallets/{walletAddress}/farms", {
            method: "GET",
            query: {
                walletAddress: d
            }
        }))).farmList
    }
    async getWalletPool(d) {
        return p(await this.apiFetch(...u("/v1/wallets/{walletAddress}/pools/{poolAddress}", {
            method: "GET",
            query: d
        }))).pool
    }
    async getWalletPools(d) {
        return p(await this.apiFetch(...u("/v1/wallets/{walletAddress}/pools", {
            method: "GET",
            query: {
                walletAddress: d
            }
        }))).poolList
    }
}
var dist$2 = {}
  , dist$1 = {}
  , Address$1 = {};
const SymbolInspect = Symbol.for("nodejs.util.inspect.custom");
var symbol_inspect = SymbolInspect
  , crc16$2 = {};
Object.defineProperty(crc16$2, "__esModule", {
    value: !0
});
crc16$2.crc16 = void 0;
function crc16$1(r) {
    let f = 0;
    const m = Buffer.alloc(r.length + 2);
    m.set(r);
    for (let k of m) {
        let y = 128;
        for (; y > 0; )
            f <<= 1,
            k & y && (f += 1),
            y >>= 1,
            f > 65535 && (f &= 65535,
            f ^= 4129)
    }
    return Buffer.from([Math.floor(f / 256), f % 256])
}
crc16$2.crc16 = crc16$1;
var __importDefault$a = commonjsGlobal && commonjsGlobal.__importDefault || function(r) {
    return r && r.__esModule ? r : {
        default: r
    }
}
, _a$2;
Object.defineProperty(Address$1, "__esModule", {
    value: !0
});
Address$1.address = Address$1.Address = void 0;
const symbol_inspect_1$2 = __importDefault$a(symbol_inspect)
  , crc16_1$1 = crc16$2
  , bounceable_tag = 17
  , non_bounceable_tag = 81
  , test_flag = 128;
function parseFriendlyAddress(r) {
    if (typeof r == "string" && !Address.isFriendly(r))
        throw new Error("Unknown address type");
    const d = Buffer.isBuffer(r) ? r : Buffer.from(r, "base64");
    if (d.length !== 36)
        throw new Error("Unknown address type: byte length is not equal to 36");
    const f = d.subarray(0, 34)
      , m = d.subarray(34, 36)
      , k = (0,
    crc16_1$1.crc16)(f);
    if (!(k[0] === m[0] && k[1] === m[1]))
        throw new Error("Invalid checksum: " + r);
    let y = f[0]
      , ee = !1
      , dt = !1;
    if (y & test_flag && (ee = !0,
    y = y ^ test_flag),
    y !== bounceable_tag && y !== non_bounceable_tag)
        throw "Unknown address tag";
    dt = y === bounceable_tag;
    let mt = null;
    f[1] === 255 ? mt = -1 : mt = f[1];
    const yt = f.subarray(2, 34);
    return {
        isTestOnly: ee,
        isBounceable: dt,
        workchain: mt,
        hashPart: yt
    }
}
class Address {
    static isAddress(d) {
        return d instanceof Address
    }
    static isFriendly(d) {
        return !(d.length !== 48 || !/[A-Za-z0-9+/_-]+/.test(d))
    }
    static isRaw(d) {
        if (d.indexOf(":") === -1)
            return !1;
        let[f,m] = d.split(":");
        return !(!Number.isInteger(parseFloat(f)) || !/[a-f0-9]+/.test(m.toLowerCase()) || m.length !== 64)
    }
    static normalize(d) {
        return typeof d == "string" ? Address.parse(d).toString() : d.toString()
    }
    static parse(d) {
        if (Address.isFriendly(d))
            return this.parseFriendly(d).address;
        if (Address.isRaw(d))
            return this.parseRaw(d);
        throw new Error("Unknown address type: " + d)
    }
    static parseRaw(d) {
        let f = parseInt(d.split(":")[0])
          , m = Buffer.from(d.split(":")[1], "hex");
        return new Address(f,m)
    }
    static parseFriendly(d) {
        if (Buffer.isBuffer(d)) {
            let f = parseFriendlyAddress(d);
            return {
                isBounceable: f.isBounceable,
                isTestOnly: f.isTestOnly,
                address: new Address(f.workchain,f.hashPart)
            }
        } else {
            let f = d.replace(/\-/g, "+").replace(/_/g, "/")
              , m = parseFriendlyAddress(f);
            return {
                isBounceable: m.isBounceable,
                isTestOnly: m.isTestOnly,
                address: new Address(m.workchain,m.hashPart)
            }
        }
    }
    constructor(d, f) {
        if (this.toRawString = ()=>this.workChain + ":" + this.hash.toString("hex"),
        this.toRaw = ()=>{
            const m = Buffer.alloc(36);
            return m.set(this.hash),
            m.set([this.workChain, this.workChain, this.workChain, this.workChain], 32),
            m
        }
        ,
        this.toStringBuffer = m=>{
            let k = m && m.testOnly !== void 0 ? m.testOnly : !1
              , ee = (m && m.bounceable !== void 0 ? m.bounceable : !0) ? bounceable_tag : non_bounceable_tag;
            k && (ee |= test_flag);
            const dt = Buffer.alloc(34);
            dt[0] = ee,
            dt[1] = this.workChain,
            dt.set(this.hash, 2);
            const mt = Buffer.alloc(36);
            return mt.set(dt),
            mt.set((0,
            crc16_1$1.crc16)(dt), 34),
            mt
        }
        ,
        this.toString = m=>{
            let k = m && m.urlSafe !== void 0 ? m.urlSafe : !0
              , y = this.toStringBuffer(m);
            return k ? y.toString("base64").replace(/\+/g, "-").replace(/\//g, "_") : y.toString("base64")
        }
        ,
        this[_a$2] = ()=>this.toString(),
        f.length !== 32)
            throw new Error("Invalid address hash length: " + f.length);
        this.workChain = d,
        this.hash = f,
        Object.freeze(this)
    }
    equals(d) {
        return d.workChain !== this.workChain ? !1 : d.hash.equals(this.hash)
    }
}
Address$1.Address = Address;
_a$2 = symbol_inspect_1$2.default;
function address(r) {
    return Address.parse(r)
}
Address$1.address = address;
var ExternalAddress$1 = {}, __importDefault$9 = commonjsGlobal && commonjsGlobal.__importDefault || function(r) {
    return r && r.__esModule ? r : {
        default: r
    }
}
, _a$1;
Object.defineProperty(ExternalAddress$1, "__esModule", {
    value: !0
});
ExternalAddress$1.ExternalAddress = void 0;
const symbol_inspect_1$1 = __importDefault$9(symbol_inspect);
class ExternalAddress {
    static isAddress(d) {
        return d instanceof ExternalAddress
    }
    constructor(d, f) {
        this[_a$1] = ()=>this.toString(),
        this.value = d,
        this.bits = f
    }
    toString() {
        return `External<${this.bits}:${this.value}>`
    }
}
ExternalAddress$1.ExternalAddress = ExternalAddress;
_a$1 = symbol_inspect_1$1.default;
var ADNLAddress$1 = {}
  , base32 = {};
Object.defineProperty(base32, "__esModule", {
    value: !0
});
base32.base32Decode = base32.base32Encode = void 0;
const alphabet = "abcdefghijklmnopqrstuvwxyz234567";
function base32Encode(r) {
    const d = r.byteLength;
    let f = 0
      , m = 0
      , k = "";
    for (let y = 0; y < d; y++)
        for (m = m << 8 | r[y],
        f += 8; f >= 5; )
            k += alphabet[m >>> f - 5 & 31],
            f -= 5;
    return f > 0 && (k += alphabet[m << 5 - f & 31]),
    k
}
base32.base32Encode = base32Encode;
function readChar(r, d) {
    const f = r.indexOf(d);
    if (f === -1)
        throw new Error("Invalid character found: " + d);
    return f
}
function base32Decode(r) {
    let d;
    d = r.toLowerCase();
    const {length: f} = d;
    let m = 0
      , k = 0
      , y = 0;
    const ee = Buffer.alloc(f * 5 / 8 | 0);
    for (let dt = 0; dt < f; dt++)
        k = k << 5 | readChar(alphabet, d[dt]),
        m += 5,
        m >= 8 && (ee[y++] = k >>> m - 8 & 255,
        m -= 8);
    return ee
}
base32.base32Decode = base32Decode;
var __importDefault$8 = commonjsGlobal && commonjsGlobal.__importDefault || function(r) {
    return r && r.__esModule ? r : {
        default: r
    }
}
, _a;
Object.defineProperty(ADNLAddress$1, "__esModule", {
    value: !0
});
ADNLAddress$1.ADNLAddress = void 0;
const symbol_inspect_1 = __importDefault$8(symbol_inspect)
  , base32_1 = base32
  , crc16_1 = crc16$2;
class ADNLAddress {
    static parseFriendly(d) {
        if (d.length !== 55)
            throw Error("Invalid address");
        d = "f" + d;
        let f = (0,
        base32_1.base32Decode)(d);
        if (f[0] !== 45)
            throw Error("Invalid address");
        let m = f.slice(33);
        if (!(0,
        crc16_1.crc16)(f.slice(0, 33)).equals(m))
            throw Error("Invalid address");
        return new ADNLAddress(f.slice(1, 33))
    }
    static parseRaw(d) {
        const f = Buffer.from(d, "base64");
        return new ADNLAddress(f)
    }
    constructor(d) {
        if (this.toRaw = ()=>this.address.toString("hex").toUpperCase(),
        this.toString = ()=>{
            let f = Buffer.concat([Buffer.from([45]), this.address])
              , m = (0,
            crc16_1.crc16)(f);
            return f = Buffer.concat([f, m]),
            (0,
            base32_1.base32Encode)(f).slice(1)
        }
        ,
        this[_a] = ()=>this.toString(),
        d.length !== 32)
            throw Error("Invalid address");
        this.address = d
    }
    equals(d) {
        return this.address.equals(d.address)
    }
}
ADNLAddress$1.ADNLAddress = ADNLAddress;
_a = symbol_inspect_1.default;
var contractAddress$1 = {}, Builder = {}, BitBuilder = {}, BitString = {}, paddedBits = {}, hasRequiredPaddedBits;
function requirePaddedBits() {
    if (hasRequiredPaddedBits)
        return paddedBits;
    hasRequiredPaddedBits = 1,
    Object.defineProperty(paddedBits, "__esModule", {
        value: !0
    }),
    paddedBits.paddedBufferToBits = paddedBits.bitsToPaddedBuffer = void 0;
    const r = requireBitBuilder()
      , d = requireBitString();
    function f(k) {
        let y = new r.BitBuilder(Math.ceil(k.length / 8) * 8);
        y.writeBits(k);
        let ee = Math.ceil(k.length / 8) * 8 - k.length;
        for (let dt = 0; dt < ee; dt++)
            dt === 0 ? y.writeBit(1) : y.writeBit(0);
        return y.buffer()
    }
    paddedBits.bitsToPaddedBuffer = f;
    function m(k) {
        let y = 0;
        for (let ee = k.length - 1; ee >= 0; ee--)
            if (k[ee] !== 0) {
                const dt = k[ee];
                let mt = dt & -dt;
                mt & 1 || (mt = Math.log2(mt) + 1),
                ee > 0 && (y = ee << 3),
                y += 8 - mt;
                break
            }
        return new d.BitString(k,0,y)
    }
    return paddedBits.paddedBufferToBits = m,
    paddedBits
}
var hasRequiredBitString;
function requireBitString() {
    if (hasRequiredBitString)
        return BitString;
    hasRequiredBitString = 1;
    var r = commonjsGlobal && commonjsGlobal.__importDefault || function(y) {
        return y && y.__esModule ? y : {
            default: y
        }
    }
    , d;
    Object.defineProperty(BitString, "__esModule", {
        value: !0
    }),
    BitString.BitString = void 0;
    const f = requirePaddedBits()
      , m = r(symbol_inspect);
    let k = class Gn {
        static isBitString(ee) {
            return ee instanceof Gn
        }
        constructor(ee, dt, mt) {
            if (this[d] = ()=>this.toString(),
            mt < 0)
                throw new Error(`Length ${mt} is out of bounds`);
            this._length = mt,
            this._data = ee,
            this._offset = dt
        }
        get length() {
            return this._length
        }
        at(ee) {
            if (ee >= this._length)
                throw new Error(`Index ${ee} > ${this._length} is out of bounds`);
            if (ee < 0)
                throw new Error(`Index ${ee} < 0 is out of bounds`);
            let dt = this._offset + ee >> 3
              , mt = 7 - (this._offset + ee) % 8;
            return (this._data[dt] & 1 << mt) !== 0
        }
        substring(ee, dt) {
            if (ee > this._length)
                throw new Error(`Offset(${ee}) > ${this._length} is out of bounds`);
            if (ee < 0)
                throw new Error(`Offset(${ee}) < 0 is out of bounds`);
            if (dt === 0)
                return Gn.EMPTY;
            if (ee + dt > this._length)
                throw new Error(`Offset ${ee} + Length ${dt} > ${this._length} is out of bounds`);
            return new Gn(this._data,this._offset + ee,dt)
        }
        subbuffer(ee, dt) {
            if (ee > this._length)
                throw new Error(`Offset ${ee} is out of bounds`);
            if (ee < 0)
                throw new Error(`Offset ${ee} is out of bounds`);
            if (ee + dt > this._length)
                throw new Error(`Offset + Lenght = ${ee + dt} is out of bounds`);
            if (dt % 8 !== 0 || (this._offset + ee) % 8 !== 0)
                return null;
            let mt = this._offset + ee >> 3
              , yt = mt + (dt >> 3);
            return this._data.subarray(mt, yt)
        }
        equals(ee) {
            if (this._length !== ee._length)
                return !1;
            for (let dt = 0; dt < this._length; dt++)
                if (this.at(dt) !== ee.at(dt))
                    return !1;
            return !0
        }
        toString() {
            const ee = (0,
            f.bitsToPaddedBuffer)(this);
            if (this._length % 4 === 0) {
                const dt = ee.subarray(0, Math.ceil(this._length / 8)).toString("hex").toUpperCase();
                return this._length % 8 === 0 ? dt : dt.substring(0, dt.length - 1)
            } else {
                const dt = ee.toString("hex").toUpperCase();
                return this._length % 8 <= 4 ? dt.substring(0, dt.length - 1) + "_" : dt + "_"
            }
        }
    }
    ;
    return BitString.BitString = k,
    d = m.default,
    k.EMPTY = new k(Buffer.alloc(0),0,0),
    BitString
}
var hasRequiredBitBuilder;
function requireBitBuilder() {
    if (hasRequiredBitBuilder)
        return BitBuilder;
    hasRequiredBitBuilder = 1,
    Object.defineProperty(BitBuilder, "__esModule", {
        value: !0
    }),
    BitBuilder.BitBuilder = void 0;
    const r = Address$1
      , d = ExternalAddress$1
      , f = requireBitString();
    let m = class {
        constructor(y=1023) {
            this._buffer = Buffer.alloc(Math.ceil(y / 8)),
            this._length = 0
        }
        get length() {
            return this._length
        }
        writeBit(y) {
            let ee = this._length;
            if (ee > this._buffer.length * 8)
                throw new Error("BitBuilder overflow");
            (typeof y == "boolean" && y === !0 || typeof y == "number" && y > 0) && (this._buffer[ee / 8 | 0] |= 1 << 7 - ee % 8),
            this._length++
        }
        writeBits(y) {
            for (let ee = 0; ee < y.length; ee++)
                this.writeBit(y.at(ee))
        }
        writeBuffer(y) {
            if (this._length % 8 === 0) {
                if (this._length + y.length * 8 > this._buffer.length * 8)
                    throw new Error("BitBuilder overflow");
                y.copy(this._buffer, this._length / 8),
                this._length += y.length * 8
            } else
                for (let ee = 0; ee < y.length; ee++)
                    this.writeUint(y[ee], 8)
        }
        writeUint(y, ee) {
            if (ee < 0 || !Number.isSafeInteger(ee))
                throw Error(`invalid bit length. Got ${ee}`);
            const dt = BigInt(y);
            if (ee === 0) {
                if (dt !== 0n)
                    throw Error(`value is not zero for ${ee} bits. Got ${y}`);
                return
            }
            const mt = 1n << BigInt(ee);
            if (dt < 0 || dt >= mt)
                throw Error(`bitLength is too small for a value ${y}. Got ${ee}`);
            if (this._length + ee > this._buffer.length * 8)
                throw new Error("BitBuilder overflow");
            const yt = 8 - this._length % 8;
            if (yt > 0) {
                const pt = Math.floor(this._length / 8);
                if (ee < yt) {
                    const bt = Number(dt);
                    this._buffer[pt] |= bt << yt - ee,
                    this._length += ee
                } else {
                    const bt = Number(dt >> BigInt(ee - yt));
                    this._buffer[pt] |= bt,
                    this._length += yt
                }
            }
            for (ee -= yt; ee > 0; )
                ee >= 8 ? (this._buffer[this._length / 8] = Number(dt >> BigInt(ee - 8) & 0xffn),
                this._length += 8,
                ee -= 8) : (this._buffer[this._length / 8] = Number(dt << BigInt(8 - ee) & 0xffn),
                this._length += ee,
                ee = 0)
        }
        writeInt(y, ee) {
            let dt = BigInt(y);
            if (ee < 0 || !Number.isSafeInteger(ee))
                throw Error(`invalid bit length. Got ${ee}`);
            if (ee === 0) {
                if (y !== 0n)
                    throw Error(`value is not zero for ${ee} bits. Got ${y}`);
                return
            }
            if (ee === 1) {
                if (y !== -1n && y !== 0n)
                    throw Error(`value is not zero or -1 for ${ee} bits. Got ${y}`);
                this.writeBit(y === -1n);
                return
            }
            let mt = 1n << BigInt(ee) - 1n;
            if (dt < -mt || dt >= mt)
                throw Error(`value is out of range for ${ee} bits. Got ${y}`);
            dt < 0 ? (this.writeBit(!0),
            dt = mt + dt) : this.writeBit(!1),
            this.writeUint(dt, ee - 1)
        }
        writeVarUint(y, ee) {
            let dt = BigInt(y);
            if (ee < 0 || !Number.isSafeInteger(ee))
                throw Error(`invalid bit length. Got ${ee}`);
            if (dt < 0)
                throw Error(`value is negative. Got ${y}`);
            if (dt === 0n) {
                this.writeUint(0, ee);
                return
            }
            const mt = Math.ceil(dt.toString(2).length / 8)
              , yt = mt * 8;
            this.writeUint(mt, ee),
            this.writeUint(dt, yt)
        }
        writeVarInt(y, ee) {
            let dt = BigInt(y);
            if (ee < 0 || !Number.isSafeInteger(ee))
                throw Error(`invalid bit length. Got ${ee}`);
            if (dt === 0n) {
                this.writeUint(0, ee);
                return
            }
            let mt = dt > 0 ? dt : -dt;
            const yt = 1 + Math.ceil(mt.toString(2).length / 8)
              , pt = yt * 8;
            this.writeUint(yt, ee),
            this.writeInt(dt, pt)
        }
        writeCoins(y) {
            this.writeVarUint(y, 4)
        }
        writeAddress(y) {
            if (y == null) {
                this.writeUint(0, 2);
                return
            }
            if (r.Address.isAddress(y)) {
                this.writeUint(2, 2),
                this.writeUint(0, 1),
                this.writeInt(y.workChain, 8),
                this.writeBuffer(y.hash);
                return
            }
            if (d.ExternalAddress.isAddress(y)) {
                this.writeUint(1, 2),
                this.writeUint(y.bits, 9),
                this.writeUint(y.value, y.bits);
                return
            }
            throw Error(`Invalid address. Got ${y}`)
        }
        build() {
            return new f.BitString(this._buffer,0,this._length)
        }
        buffer() {
            if (this._length % 8 !== 0)
                throw new Error("BitBuilder buffer is not byte aligned");
            return this._buffer.subarray(0, this._length / 8)
        }
    }
    ;
    return BitBuilder.BitBuilder = m,
    BitBuilder
}
var Cell = {}
  , CellType$1 = {};
Object.defineProperty(CellType$1, "__esModule", {
    value: !0
});
CellType$1.CellType = void 0;
var CellType;
(function(r) {
    r[r.Ordinary = -1] = "Ordinary",
    r[r.PrunedBranch = 1] = "PrunedBranch",
    r[r.Library = 2] = "Library",
    r[r.MerkleProof = 3] = "MerkleProof",
    r[r.MerkleUpdate = 4] = "MerkleUpdate"
}
)(CellType || (CellType$1.CellType = CellType = {}));
var Slice = {}
  , Dictionary = {}
  , generateMerkleProof = {}
  , readUnaryLength$2 = {};
Object.defineProperty(readUnaryLength$2, "__esModule", {
    value: !0
});
readUnaryLength$2.readUnaryLength = void 0;
function readUnaryLength$1(r) {
    let d = 0;
    for (; r.loadBit(); )
        d++;
    return d
}
readUnaryLength$2.readUnaryLength = readUnaryLength$1;
var hasRequiredGenerateMerkleProof;
function requireGenerateMerkleProof() {
    if (hasRequiredGenerateMerkleProof)
        return generateMerkleProof;
    hasRequiredGenerateMerkleProof = 1,
    Object.defineProperty(generateMerkleProof, "__esModule", {
        value: !0
    }),
    generateMerkleProof.generateMerkleProof = void 0;
    const r = requireBuilder()
      , d = readUnaryLength$2;
    function f(ee) {
        return (0,
        r.beginCell)().storeUint(1, 8).storeUint(1, 8).storeBuffer(ee.hash(0)).storeUint(ee.depth(0), 16).endCell({
            exotic: !0
        })
    }
    function m(ee) {
        return (0,
        r.beginCell)().storeUint(3, 8).storeBuffer(ee.hash(0)).storeUint(ee.depth(0), 16).storeRef(ee).endCell({
            exotic: !0
        })
    }
    function k(ee, dt, mt, yt) {
        const pt = dt.asCell();
        let bt = dt.loadBit() ? 1 : 0
          , wt = 0
          , xt = ee;
        if (bt === 0) {
            wt = (0,
            d.readUnaryLength)(dt);
            for (let At = 0; At < wt; At++)
                xt += dt.loadBit() ? "1" : "0"
        } else if ((dt.loadBit() ? 1 : 0) === 0) {
            wt = dt.loadUint(Math.ceil(Math.log2(mt + 1)));
            for (let Ct = 0; Ct < wt; Ct++)
                xt += dt.loadBit() ? "1" : "0"
        } else {
            let Ct = dt.loadBit() ? "1" : "0";
            wt = dt.loadUint(Math.ceil(Math.log2(mt + 1)));
            for (let Pt = 0; Pt < wt; Pt++)
                xt += Ct
        }
        if (mt - wt === 0)
            return pt;
        {
            let At = pt.beginParse()
              , Ct = At.loadRef()
              , Pt = At.loadRef();
            return Ct.isExotic || (xt + "0" === yt.slice(0, xt.length + 1) ? Ct = k(xt + "0", Ct.beginParse(), mt - wt - 1, yt) : Ct = f(Ct)),
            Pt.isExotic || (xt + "1" === yt.slice(0, xt.length + 1) ? Pt = k(xt + "1", Pt.beginParse(), mt - wt - 1, yt) : Pt = f(Pt)),
            (0,
            r.beginCell)().storeSlice(At).storeRef(Ct).storeRef(Pt).endCell()
        }
    }
    function y(ee, dt, mt) {
        const yt = (0,
        r.beginCell)().storeDictDirect(ee).endCell().beginParse();
        return m(k("", yt, mt.bits, mt.serialize(dt).toString(2).padStart(mt.bits, "0")))
    }
    return generateMerkleProof.generateMerkleProof = y,
    generateMerkleProof
}
var generateMerkleUpdate = {}, hasRequiredGenerateMerkleUpdate;
function requireGenerateMerkleUpdate() {
    if (hasRequiredGenerateMerkleUpdate)
        return generateMerkleUpdate;
    hasRequiredGenerateMerkleUpdate = 1,
    Object.defineProperty(generateMerkleUpdate, "__esModule", {
        value: !0
    }),
    generateMerkleUpdate.generateMerkleUpdate = void 0;
    const r = requireBuilder()
      , d = requireGenerateMerkleProof();
    function f(k, y) {
        return (0,
        r.beginCell)().storeUint(4, 8).storeBuffer(k.hash(0)).storeBuffer(y.hash(0)).storeUint(k.depth(0), 16).storeUint(y.depth(0), 16).storeRef(k).storeRef(y).endCell({
            exotic: !0
        })
    }
    function m(k, y, ee, dt) {
        const mt = (0,
        d.generateMerkleProof)(k, y, ee).refs[0];
        k.set(y, dt);
        const yt = (0,
        d.generateMerkleProof)(k, y, ee).refs[0];
        return f(mt, yt)
    }
    return generateMerkleUpdate.generateMerkleUpdate = m,
    generateMerkleUpdate
}
var parseDict$1 = {};
Object.defineProperty(parseDict$1, "__esModule", {
    value: !0
});
parseDict$1.parseDict = void 0;
function readUnaryLength(r) {
    let d = 0;
    for (; r.loadBit(); )
        d++;
    return d
}
function doParse(r, d, f, m, k) {
    let y = d.loadBit() ? 1 : 0
      , ee = 0
      , dt = r;
    if (y === 0) {
        ee = readUnaryLength(d);
        for (let mt = 0; mt < ee; mt++)
            dt += d.loadBit() ? "1" : "0"
    } else if ((d.loadBit() ? 1 : 0) === 0) {
        ee = d.loadUint(Math.ceil(Math.log2(f + 1)));
        for (let yt = 0; yt < ee; yt++)
            dt += d.loadBit() ? "1" : "0"
    } else {
        let yt = d.loadBit() ? "1" : "0";
        ee = d.loadUint(Math.ceil(Math.log2(f + 1)));
        for (let pt = 0; pt < ee; pt++)
            dt += yt
    }
    if (f - ee === 0)
        m.set(BigInt("0b" + dt), k(d));
    else {
        let mt = d.loadRef()
          , yt = d.loadRef();
        mt.isExotic || doParse(dt + "0", mt.beginParse(), f - ee - 1, m, k),
        yt.isExotic || doParse(dt + "1", yt.beginParse(), f - ee - 1, m, k)
    }
}
function parseDict(r, d, f) {
    let m = new Map;
    return r && doParse("", r, d, m, f),
    m
}
parseDict$1.parseDict = parseDict;
var serializeDict = {}
  , findCommonPrefix$1 = {};
Object.defineProperty(findCommonPrefix$1, "__esModule", {
    value: !0
});
findCommonPrefix$1.findCommonPrefix = void 0;
function findCommonPrefix(r, d=0) {
    if (r.length === 0)
        return "";
    let f = r[0].slice(d);
    for (let m = 1; m < r.length; m++) {
        const k = r[m];
        for (; k.indexOf(f, d) !== d; )
            if (f = f.substring(0, f.length - 1),
            f === "")
                return f
    }
    return f
}
findCommonPrefix$1.findCommonPrefix = findCommonPrefix;
var hasRequiredSerializeDict;
function requireSerializeDict() {
    if (hasRequiredSerializeDict)
        return serializeDict;
    hasRequiredSerializeDict = 1,
    Object.defineProperty(serializeDict, "__esModule", {
        value: !0
    }),
    serializeDict.serializeDict = serializeDict.detectLabelType = serializeDict.writeLabelSame = serializeDict.writeLabelLong = serializeDict.writeLabelShort = serializeDict.buildTree = void 0;
    const r = requireBuilder()
      , d = findCommonPrefix$1;
    function f(Nt, zt) {
        for (; Nt.length < zt; )
            Nt = "0" + Nt;
        return Nt
    }
    function m(Nt, zt) {
        if (Nt.size === 0)
            throw Error("Internal inconsistency");
        let Wt = new Map
          , Kt = new Map;
        for (let[ir,or] of Nt.entries())
            ir[zt] === "0" ? Wt.set(ir, or) : Kt.set(ir, or);
        if (Wt.size === 0)
            throw Error("Internal inconsistency. Left emtpy.");
        if (Kt.size === 0)
            throw Error("Internal inconsistency. Right emtpy.");
        return {
            left: Wt,
            right: Kt
        }
    }
    function k(Nt, zt) {
        if (Nt.size === 0)
            throw Error("Internal inconsistency");
        if (Nt.size === 1)
            return {
                type: "leaf",
                value: Array.from(Nt.values())[0]
            };
        let {left: Wt, right: Kt} = m(Nt, zt);
        return {
            type: "fork",
            left: y(Wt, zt + 1),
            right: y(Kt, zt + 1)
        }
    }
    function y(Nt, zt=0) {
        if (Nt.size === 0)
            throw Error("Internal inconsistency");
        const Wt = (0,
        d.findCommonPrefix)(Array.from(Nt.keys()), zt);
        return {
            label: Wt,
            node: k(Nt, Wt.length + zt)
        }
    }
    function ee(Nt, zt) {
        let Wt = new Map;
        for (let Kt of Array.from(Nt.keys())) {
            const ir = f(Kt.toString(2), zt);
            Wt.set(ir, Nt.get(Kt))
        }
        return y(Wt)
    }
    serializeDict.buildTree = ee;
    function dt(Nt, zt) {
        zt.storeBit(0);
        for (let Wt = 0; Wt < Nt.length; Wt++)
            zt.storeBit(1);
        return zt.storeBit(0),
        Nt.length > 0 && zt.storeUint(BigInt("0b" + Nt), Nt.length),
        zt
    }
    serializeDict.writeLabelShort = dt;
    function mt(Nt) {
        return 1 + Nt.length + 1 + Nt.length
    }
    function yt(Nt, zt, Wt) {
        Wt.storeBit(1),
        Wt.storeBit(0);
        let Kt = Math.ceil(Math.log2(zt + 1));
        return Wt.storeUint(Nt.length, Kt),
        Nt.length > 0 && Wt.storeUint(BigInt("0b" + Nt), Nt.length),
        Wt
    }
    serializeDict.writeLabelLong = yt;
    function pt(Nt, zt) {
        return 2 + Math.ceil(Math.log2(zt + 1)) + Nt.length
    }
    function bt(Nt, zt, Wt, Kt) {
        Kt.storeBit(1),
        Kt.storeBit(1),
        Kt.storeBit(Nt);
        let ir = Math.ceil(Math.log2(Wt + 1));
        Kt.storeUint(zt, ir)
    }
    serializeDict.writeLabelSame = bt;
    function wt(Nt) {
        return 3 + Math.ceil(Math.log2(Nt + 1))
    }
    function xt(Nt) {
        if (Nt.length === 0 || Nt.length === 1)
            return !0;
        for (let zt = 1; zt < Nt.length; zt++)
            if (Nt[zt] !== Nt[0])
                return !1;
        return !0
    }
    function At(Nt, zt) {
        let Wt = "short"
          , Kt = mt(Nt)
          , ir = pt(Nt, zt);
        if (ir < Kt && (Kt = ir,
        Wt = "long"),
        xt(Nt)) {
            let or = wt(zt);
            or < Kt && (Kt = or,
            Wt = "same")
        }
        return Wt
    }
    serializeDict.detectLabelType = At;
    function Ct(Nt, zt, Wt) {
        let Kt = At(Nt, zt);
        Kt === "short" ? dt(Nt, Wt) : Kt === "long" ? yt(Nt, zt, Wt) : Kt === "same" && bt(Nt[0] === "1", Nt.length, zt, Wt)
    }
    function Pt(Nt, zt, Wt, Kt) {
        if (Nt.type === "leaf" && Wt(Nt.value, Kt),
        Nt.type === "fork") {
            const ir = (0,
            r.beginCell)()
              , or = (0,
            r.beginCell)();
            $t(Nt.left, zt - 1, Wt, ir),
            $t(Nt.right, zt - 1, Wt, or),
            Kt.storeRef(ir),
            Kt.storeRef(or)
        }
    }
    function $t(Nt, zt, Wt, Kt) {
        Ct(Nt.label, zt, Kt),
        Pt(Nt.node, zt - Nt.label.length, Wt, Kt)
    }
    function Ot(Nt, zt, Wt, Kt) {
        const ir = ee(Nt, zt);
        $t(ir, zt, Wt, Kt)
    }
    return serializeDict.serializeDict = Ot,
    serializeDict
}
var internalKeySerializer = {};
Object.defineProperty(internalKeySerializer, "__esModule", {
    value: !0
});
internalKeySerializer.deserializeInternalKey = internalKeySerializer.serializeInternalKey = void 0;
const Address_1$4 = Address$1
  , BitString_1$1 = requireBitString()
  , paddedBits_1$1 = requirePaddedBits();
function serializeInternalKey(r) {
    if (typeof r == "number") {
        if (!Number.isSafeInteger(r))
            throw Error("Invalid key type: not a safe integer: " + r);
        return "n:" + r.toString(10)
    } else {
        if (typeof r == "bigint")
            return "b:" + r.toString(10);
        if (Address_1$4.Address.isAddress(r))
            return "a:" + r.toString();
        if (Buffer.isBuffer(r))
            return "f:" + r.toString("hex");
        if (BitString_1$1.BitString.isBitString(r))
            return "B:" + r.toString();
        throw Error("Invalid key type")
    }
}
internalKeySerializer.serializeInternalKey = serializeInternalKey;
function deserializeInternalKey(r) {
    let d = r.slice(0, 2)
      , f = r.slice(2);
    if (d === "n:")
        return parseInt(f, 10);
    if (d === "b:")
        return BigInt(f);
    if (d === "a:")
        return Address_1$4.Address.parse(f);
    if (d === "f:")
        return Buffer.from(f, "hex");
    if (d === "B:") {
        const m = f.slice(-1) == "_";
        if (m || f.length % 2 != 0) {
            let y = m ? f.length - 1 : f.length;
            const ee = f.substr(0, y) + "0";
            return !m && y & 1 ? new BitString_1$1.BitString(Buffer.from(ee, "hex"),0,y << 2) : (0,
            paddedBits_1$1.paddedBufferToBits)(Buffer.from(ee, "hex"))
        } else
            return new BitString_1$1.BitString(Buffer.from(f, "hex"),0,f.length << 2)
    }
    throw Error("Invalid key type: " + d)
}
internalKeySerializer.deserializeInternalKey = deserializeInternalKey;
var hasRequiredDictionary;
function requireDictionary() {
    if (hasRequiredDictionary)
        return Dictionary;
    hasRequiredDictionary = 1,
    Object.defineProperty(Dictionary, "__esModule", {
        value: !0
    }),
    Dictionary.Dictionary = void 0;
    const r = Address$1
      , d = requireBuilder()
      , f = requireCell()
      , m = requireBitString()
      , k = requireGenerateMerkleProof()
      , y = requireGenerateMerkleUpdate()
      , ee = parseDict$1
      , dt = requireSerializeDict()
      , mt = internalKeySerializer;
    let yt = class Hn {
        static empty(gt, vt) {
            return gt && vt ? new Hn(new Map,gt,vt) : new Hn(new Map,null,null)
        }
        static load(gt, vt, Et) {
            let Bt;
            if (Et instanceof f.Cell) {
                if (Et.isExotic)
                    return Hn.empty(gt, vt);
                Bt = Et.beginParse()
            } else
                Bt = Et;
            let Rt = Bt.loadMaybeRef();
            return Rt && !Rt.isExotic ? Hn.loadDirect(gt, vt, Rt.beginParse()) : Hn.empty(gt, vt)
        }
        static loadDirect(gt, vt, Et) {
            if (!Et)
                return Hn.empty(gt, vt);
            let Bt;
            Et instanceof f.Cell ? Bt = Et.beginParse() : Bt = Et;
            let Rt = (0,
            ee.parseDict)(Bt, gt.bits, vt.parse)
              , kt = new Map;
            for (let[Tt,It] of Rt)
                kt.set((0,
                mt.serializeInternalKey)(gt.parse(Tt)), It);
            return new Hn(kt,gt,vt)
        }
        constructor(gt, vt, Et) {
            this._key = vt,
            this._value = Et,
            this._map = gt
        }
        get size() {
            return this._map.size
        }
        get(gt) {
            return this._map.get((0,
            mt.serializeInternalKey)(gt))
        }
        has(gt) {
            return this._map.has((0,
            mt.serializeInternalKey)(gt))
        }
        set(gt, vt) {
            return this._map.set((0,
            mt.serializeInternalKey)(gt), vt),
            this
        }
        delete(gt) {
            const vt = (0,
            mt.serializeInternalKey)(gt);
            return this._map.delete(vt)
        }
        clear() {
            this._map.clear()
        }
        *[Symbol.iterator]() {
            for (const [gt,vt] of this._map)
                yield[(0,
                mt.deserializeInternalKey)(gt), vt]
        }
        keys() {
            return Array.from(this._map.keys()).map(gt=>(0,
            mt.deserializeInternalKey)(gt))
        }
        values() {
            return Array.from(this._map.values())
        }
        store(gt, vt, Et) {
            if (this._map.size === 0)
                gt.storeBit(0);
            else {
                let Bt = this._key;
                vt != null && (Bt = vt);
                let Rt = this._value;
                if (Et != null && (Rt = Et),
                !Bt)
                    throw Error("Key serializer is not defined");
                if (!Rt)
                    throw Error("Value serializer is not defined");
                let kt = new Map;
                for (const [It,St] of this._map)
                    kt.set(Bt.serialize((0,
                    mt.deserializeInternalKey)(It)), St);
                gt.storeBit(1);
                let Tt = (0,
                d.beginCell)();
                (0,
                dt.serializeDict)(kt, Bt.bits, Rt.serialize, Tt),
                gt.storeRef(Tt.endCell())
            }
        }
        storeDirect(gt, vt, Et) {
            if (this._map.size === 0)
                throw Error("Cannot store empty dictionary directly");
            let Bt = this._key;
            vt != null && (Bt = vt);
            let Rt = this._value;
            if (Et != null && (Rt = Et),
            !Bt)
                throw Error("Key serializer is not defined");
            if (!Rt)
                throw Error("Value serializer is not defined");
            let kt = new Map;
            for (const [Tt,It] of this._map)
                kt.set(Bt.serialize((0,
                mt.deserializeInternalKey)(Tt)), It);
            (0,
            dt.serializeDict)(kt, Bt.bits, Rt.serialize, gt)
        }
        generateMerkleProof(gt) {
            return (0,
            k.generateMerkleProof)(this, gt, this._key)
        }
        generateMerkleUpdate(gt, vt) {
            return (0,
            y.generateMerkleUpdate)(this, gt, this._key, vt)
        }
    }
    ;
    Dictionary.Dictionary = yt,
    yt.Keys = {
        Address: ()=>pt(),
        BigInt: _t=>bt(_t),
        Int: _t=>wt(_t),
        BigUint: _t=>xt(_t),
        Uint: _t=>At(_t),
        Buffer: _t=>Ct(_t),
        BitString: _t=>Pt(_t)
    },
    yt.Values = {
        BigInt: _t=>Ot(_t),
        Int: _t=>$t(_t),
        BigVarInt: _t=>Nt(_t),
        BigUint: _t=>Kt(_t),
        Uint: _t=>Wt(_t),
        BigVarUint: _t=>zt(_t),
        Bool: ()=>ir(),
        Address: ()=>or(),
        Cell: ()=>tr(),
        Buffer: _t=>Ht(_t),
        BitString: _t=>Mt(_t),
        Dictionary: (_t,gt)=>wr(_t, gt)
    };
    function pt() {
        return {
            bits: 267,
            serialize: _t=>{
                if (!r.Address.isAddress(_t))
                    throw Error("Key is not an address");
                return (0,
                d.beginCell)().storeAddress(_t).endCell().beginParse().preloadUintBig(267)
            }
            ,
            parse: _t=>(0,
            d.beginCell)().storeUint(_t, 267).endCell().beginParse().loadAddress()
        }
    }
    function bt(_t) {
        return {
            bits: _t,
            serialize: gt=>{
                if (typeof gt != "bigint")
                    throw Error("Key is not a bigint");
                return (0,
                d.beginCell)().storeInt(gt, _t).endCell().beginParse().loadUintBig(_t)
            }
            ,
            parse: gt=>(0,
            d.beginCell)().storeUint(gt, _t).endCell().beginParse().loadIntBig(_t)
        }
    }
    function wt(_t) {
        return {
            bits: _t,
            serialize: gt=>{
                if (typeof gt != "number")
                    throw Error("Key is not a number");
                if (!Number.isSafeInteger(gt))
                    throw Error("Key is not a safe integer: " + gt);
                return (0,
                d.beginCell)().storeInt(gt, _t).endCell().beginParse().loadUintBig(_t)
            }
            ,
            parse: gt=>(0,
            d.beginCell)().storeUint(gt, _t).endCell().beginParse().loadInt(_t)
        }
    }
    function xt(_t) {
        return {
            bits: _t,
            serialize: gt=>{
                if (typeof gt != "bigint")
                    throw Error("Key is not a bigint");
                if (gt < 0)
                    throw Error("Key is negative: " + gt);
                return (0,
                d.beginCell)().storeUint(gt, _t).endCell().beginParse().loadUintBig(_t)
            }
            ,
            parse: gt=>(0,
            d.beginCell)().storeUint(gt, _t).endCell().beginParse().loadUintBig(_t)
        }
    }
    function At(_t) {
        return {
            bits: _t,
            serialize: gt=>{
                if (typeof gt != "number")
                    throw Error("Key is not a number");
                if (!Number.isSafeInteger(gt))
                    throw Error("Key is not a safe integer: " + gt);
                if (gt < 0)
                    throw Error("Key is negative: " + gt);
                return (0,
                d.beginCell)().storeUint(gt, _t).endCell().beginParse().loadUintBig(_t)
            }
            ,
            parse: gt=>Number((0,
            d.beginCell)().storeUint(gt, _t).endCell().beginParse().loadUint(_t))
        }
    }
    function Ct(_t) {
        return {
            bits: _t * 8,
            serialize: gt=>{
                if (!Buffer.isBuffer(gt))
                    throw Error("Key is not a buffer");
                return (0,
                d.beginCell)().storeBuffer(gt).endCell().beginParse().loadUintBig(_t * 8)
            }
            ,
            parse: gt=>(0,
            d.beginCell)().storeUint(gt, _t * 8).endCell().beginParse().loadBuffer(_t)
        }
    }
    function Pt(_t) {
        return {
            bits: _t,
            serialize: gt=>{
                if (!m.BitString.isBitString(gt))
                    throw Error("Key is not a BitString");
                return (0,
                d.beginCell)().storeBits(gt).endCell().beginParse().loadUintBig(_t)
            }
            ,
            parse: gt=>(0,
            d.beginCell)().storeUint(gt, _t).endCell().beginParse().loadBits(_t)
        }
    }
    function $t(_t) {
        return {
            serialize: (gt,vt)=>{
                vt.storeInt(gt, _t)
            }
            ,
            parse: gt=>gt.loadInt(_t)
        }
    }
    function Ot(_t) {
        return {
            serialize: (gt,vt)=>{
                vt.storeInt(gt, _t)
            }
            ,
            parse: gt=>gt.loadIntBig(_t)
        }
    }
    function Nt(_t) {
        return {
            serialize: (gt,vt)=>{
                vt.storeVarInt(gt, _t)
            }
            ,
            parse: gt=>gt.loadVarIntBig(_t)
        }
    }
    function zt(_t) {
        return {
            serialize: (gt,vt)=>{
                vt.storeVarUint(gt, _t)
            }
            ,
            parse: gt=>gt.loadVarUintBig(_t)
        }
    }
    function Wt(_t) {
        return {
            serialize: (gt,vt)=>{
                vt.storeUint(gt, _t)
            }
            ,
            parse: gt=>gt.loadUint(_t)
        }
    }
    function Kt(_t) {
        return {
            serialize: (gt,vt)=>{
                vt.storeUint(gt, _t)
            }
            ,
            parse: gt=>gt.loadUintBig(_t)
        }
    }
    function ir() {
        return {
            serialize: (_t,gt)=>{
                gt.storeBit(_t)
            }
            ,
            parse: _t=>_t.loadBit()
        }
    }
    function or() {
        return {
            serialize: (_t,gt)=>{
                gt.storeAddress(_t)
            }
            ,
            parse: _t=>_t.loadAddress()
        }
    }
    function tr() {
        return {
            serialize: (_t,gt)=>{
                gt.storeRef(_t)
            }
            ,
            parse: _t=>_t.loadRef()
        }
    }
    function wr(_t, gt) {
        return {
            serialize: (vt,Et)=>{
                vt.store(Et)
            }
            ,
            parse: vt=>yt.load(_t, gt, vt)
        }
    }
    function Ht(_t) {
        return {
            serialize: (gt,vt)=>{
                if (gt.length !== _t)
                    throw Error("Invalid buffer size");
                vt.storeBuffer(gt)
            }
            ,
            parse: gt=>gt.loadBuffer(_t)
        }
    }
    function Mt(_t) {
        return {
            serialize: (gt,vt)=>{
                if (gt.length !== _t)
                    throw Error("Invalid BitString size");
                vt.storeBits(gt)
            }
            ,
            parse: gt=>gt.loadBits(_t)
        }
    }
    return Dictionary
}
var strings = {}, hasRequiredStrings;
function requireStrings() {
    if (hasRequiredStrings)
        return strings;
    hasRequiredStrings = 1,
    Object.defineProperty(strings, "__esModule", {
        value: !0
    }),
    strings.writeString = strings.stringToCell = strings.readString = void 0;
    const r = requireBuilder();
    function d(ee) {
        if (ee.remainingBits % 8 !== 0)
            throw new Error(`Invalid string length: ${ee.remainingBits}`);
        if (ee.remainingRefs !== 0 && ee.remainingRefs !== 1)
            throw new Error(`invalid number of refs: ${ee.remainingRefs}`);
        let dt;
        return ee.remainingBits === 0 ? dt = Buffer.alloc(0) : dt = ee.loadBuffer(ee.remainingBits / 8),
        ee.remainingRefs === 1 && (dt = Buffer.concat([dt, d(ee.loadRef().beginParse())])),
        dt
    }
    function f(ee) {
        return d(ee).toString()
    }
    strings.readString = f;
    function m(ee, dt) {
        if (ee.length > 0) {
            let mt = Math.floor(dt.availableBits / 8);
            if (ee.length > mt) {
                let yt = ee.subarray(0, mt)
                  , pt = ee.subarray(mt);
                dt = dt.storeBuffer(yt);
                let bt = (0,
                r.beginCell)();
                m(pt, bt),
                dt = dt.storeRef(bt.endCell())
            } else
                dt = dt.storeBuffer(ee)
        }
    }
    function k(ee) {
        let dt = (0,
        r.beginCell)();
        return m(Buffer.from(ee), dt),
        dt.endCell()
    }
    strings.stringToCell = k;
    function y(ee, dt) {
        m(Buffer.from(ee), dt)
    }
    return strings.writeString = y,
    strings
}
var hasRequiredSlice;
function requireSlice() {
    if (hasRequiredSlice)
        return Slice;
    hasRequiredSlice = 1;
    var r = commonjsGlobal && commonjsGlobal.__importDefault || function(dt) {
        return dt && dt.__esModule ? dt : {
            default: dt
        }
    }
    , d;
    Object.defineProperty(Slice, "__esModule", {
        value: !0
    }),
    Slice.Slice = void 0;
    const f = r(symbol_inspect)
      , m = requireDictionary()
      , k = requireBuilder()
      , y = requireStrings();
    let ee = class Zn {
        constructor(mt, yt) {
            this[d] = ()=>this.toString(),
            this._reader = mt.clone(),
            this._refs = [...yt],
            this._refsOffset = 0
        }
        get remainingBits() {
            return this._reader.remaining
        }
        get offsetBits() {
            return this._reader.offset
        }
        get remainingRefs() {
            return this._refs.length - this._refsOffset
        }
        get offsetRefs() {
            return this._refsOffset
        }
        skip(mt) {
            return this._reader.skip(mt),
            this
        }
        loadBit() {
            return this._reader.loadBit()
        }
        preloadBit() {
            return this._reader.preloadBit()
        }
        loadBoolean() {
            return this.loadBit()
        }
        loadMaybeBoolean() {
            return this.loadBit() ? this.loadBoolean() : null
        }
        loadBits(mt) {
            return this._reader.loadBits(mt)
        }
        preloadBits(mt) {
            return this._reader.preloadBits(mt)
        }
        loadUint(mt) {
            return this._reader.loadUint(mt)
        }
        loadUintBig(mt) {
            return this._reader.loadUintBig(mt)
        }
        preloadUint(mt) {
            return this._reader.preloadUint(mt)
        }
        preloadUintBig(mt) {
            return this._reader.preloadUintBig(mt)
        }
        loadMaybeUint(mt) {
            return this.loadBit() ? this.loadUint(mt) : null
        }
        loadMaybeUintBig(mt) {
            return this.loadBit() ? this.loadUintBig(mt) : null
        }
        loadInt(mt) {
            return this._reader.loadInt(mt)
        }
        loadIntBig(mt) {
            return this._reader.loadIntBig(mt)
        }
        preloadInt(mt) {
            return this._reader.preloadInt(mt)
        }
        preloadIntBig(mt) {
            return this._reader.preloadIntBig(mt)
        }
        loadMaybeInt(mt) {
            return this.loadBit() ? this.loadInt(mt) : null
        }
        loadMaybeIntBig(mt) {
            return this.loadBit() ? this.loadIntBig(mt) : null
        }
        loadVarUint(mt) {
            return this._reader.loadVarUint(mt)
        }
        loadVarUintBig(mt) {
            return this._reader.loadVarUintBig(mt)
        }
        preloadVarUint(mt) {
            return this._reader.preloadVarUint(mt)
        }
        preloadVarUintBig(mt) {
            return this._reader.preloadVarUintBig(mt)
        }
        loadVarInt(mt) {
            return this._reader.loadVarInt(mt)
        }
        loadVarIntBig(mt) {
            return this._reader.loadVarIntBig(mt)
        }
        preloadVarInt(mt) {
            return this._reader.preloadVarInt(mt)
        }
        preloadVarIntBig(mt) {
            return this._reader.preloadVarIntBig(mt)
        }
        loadCoins() {
            return this._reader.loadCoins()
        }
        preloadCoins() {
            return this._reader.preloadCoins()
        }
        loadMaybeCoins() {
            return this._reader.loadBit() ? this._reader.loadCoins() : null
        }
        loadAddress() {
            return this._reader.loadAddress()
        }
        loadMaybeAddress() {
            return this._reader.loadMaybeAddress()
        }
        loadExternalAddress() {
            return this._reader.loadExternalAddress()
        }
        loadMaybeExternalAddress() {
            return this._reader.loadMaybeExternalAddress()
        }
        loadAddressAny() {
            return this._reader.loadAddressAny()
        }
        loadRef() {
            if (this._refsOffset >= this._refs.length)
                throw new Error("No more references");
            return this._refs[this._refsOffset++]
        }
        preloadRef() {
            if (this._refsOffset >= this._refs.length)
                throw new Error("No more references");
            return this._refs[this._refsOffset]
        }
        loadMaybeRef() {
            return this.loadBit() ? this.loadRef() : null
        }
        preloadMaybeRef() {
            return this.preloadBit() ? this.preloadRef() : null
        }
        loadBuffer(mt) {
            return this._reader.loadBuffer(mt)
        }
        preloadBuffer(mt) {
            return this._reader.preloadBuffer(mt)
        }
        loadStringTail() {
            return (0,
            y.readString)(this)
        }
        loadMaybeStringTail() {
            return this.loadBit() ? (0,
            y.readString)(this) : null
        }
        loadStringRefTail() {
            return (0,
            y.readString)(this.loadRef().beginParse())
        }
        loadMaybeStringRefTail() {
            const mt = this.loadMaybeRef();
            return mt ? (0,
            y.readString)(mt.beginParse()) : null
        }
        loadDict(mt, yt) {
            return m.Dictionary.load(mt, yt, this)
        }
        loadDictDirect(mt, yt) {
            return m.Dictionary.loadDirect(mt, yt, this)
        }
        endParse() {
            if (this.remainingBits > 0 || this.remainingRefs > 0)
                throw new Error("Slice is not empty")
        }
        asCell() {
            return (0,
            k.beginCell)().storeSlice(this).endCell()
        }
        asBuilder() {
            return (0,
            k.beginCell)().storeSlice(this)
        }
        clone(mt=!1) {
            if (mt) {
                let yt = this._reader.clone();
                return yt.reset(),
                new Zn(yt,this._refs)
            } else {
                let yt = new Zn(this._reader,this._refs);
                return yt._refsOffset = this._refsOffset,
                yt
            }
        }
        toString() {
            return this.asCell().toString()
        }
    }
    ;
    return Slice.Slice = ee,
    d = f.default,
    Slice
}
var resolveExotic$1 = {}
  , BitReader$1 = {};
Object.defineProperty(BitReader$1, "__esModule", {
    value: !0
});
BitReader$1.BitReader = void 0;
const Address_1$3 = Address$1
  , ExternalAddress_1 = ExternalAddress$1;
class BitReader {
    constructor(d, f=0) {
        this._checkpoints = [],
        this._bits = d,
        this._offset = f
    }
    get offset() {
        return this._offset
    }
    get remaining() {
        return this._bits.length - this._offset
    }
    skip(d) {
        if (d < 0 || this._offset + d > this._bits.length)
            throw new Error(`Index ${this._offset + d} is out of bounds`);
        this._offset += d
    }
    reset() {
        this._checkpoints.length > 0 ? this._offset = this._checkpoints.pop() : this._offset = 0
    }
    save() {
        this._checkpoints.push(this._offset)
    }
    loadBit() {
        let d = this._bits.at(this._offset);
        return this._offset++,
        d
    }
    preloadBit() {
        return this._bits.at(this._offset)
    }
    loadBits(d) {
        let f = this._bits.substring(this._offset, d);
        return this._offset += d,
        f
    }
    preloadBits(d) {
        return this._bits.substring(this._offset, d)
    }
    loadBuffer(d) {
        let f = this._preloadBuffer(d, this._offset);
        return this._offset += d * 8,
        f
    }
    preloadBuffer(d) {
        return this._preloadBuffer(d, this._offset)
    }
    loadUint(d) {
        return Number(this.loadUintBig(d))
    }
    loadUintBig(d) {
        let f = this.preloadUintBig(d);
        return this._offset += d,
        f
    }
    preloadUint(d) {
        return Number(this._preloadUint(d, this._offset))
    }
    preloadUintBig(d) {
        return this._preloadUint(d, this._offset)
    }
    loadInt(d) {
        let f = this._preloadInt(d, this._offset);
        return this._offset += d,
        Number(f)
    }
    loadIntBig(d) {
        let f = this._preloadInt(d, this._offset);
        return this._offset += d,
        f
    }
    preloadInt(d) {
        return Number(this._preloadInt(d, this._offset))
    }
    preloadIntBig(d) {
        return this._preloadInt(d, this._offset)
    }
    loadVarUint(d) {
        let f = Number(this.loadUint(d));
        return Number(this.loadUintBig(f * 8))
    }
    loadVarUintBig(d) {
        let f = Number(this.loadUint(d));
        return this.loadUintBig(f * 8)
    }
    preloadVarUint(d) {
        let f = Number(this._preloadUint(d, this._offset));
        return Number(this._preloadUint(f * 8, this._offset + d))
    }
    preloadVarUintBig(d) {
        let f = Number(this._preloadUint(d, this._offset));
        return this._preloadUint(f * 8, this._offset + d)
    }
    loadVarInt(d) {
        let f = Number(this.loadUint(d));
        return Number(this.loadIntBig(f * 8))
    }
    loadVarIntBig(d) {
        let f = Number(this.loadUint(d));
        return this.loadIntBig(f * 8)
    }
    preloadVarInt(d) {
        let f = Number(this._preloadUint(d, this._offset));
        return Number(this._preloadInt(f * 8, this._offset + d))
    }
    preloadVarIntBig(d) {
        let f = Number(this._preloadUint(d, this._offset));
        return this._preloadInt(f * 8, this._offset + d)
    }
    loadCoins() {
        return this.loadVarUintBig(4)
    }
    preloadCoins() {
        return this.preloadVarUintBig(4)
    }
    loadAddress() {
        let d = Number(this._preloadUint(2, this._offset));
        if (d === 2)
            return this._loadInternalAddress();
        throw new Error("Invalid address: " + d)
    }
    loadMaybeAddress() {
        let d = Number(this._preloadUint(2, this._offset));
        if (d === 0)
            return this._offset += 2,
            null;
        if (d === 2)
            return this._loadInternalAddress();
        throw new Error("Invalid address")
    }
    loadExternalAddress() {
        if (Number(this._preloadUint(2, this._offset)) === 1)
            return this._loadExternalAddress();
        throw new Error("Invalid address")
    }
    loadMaybeExternalAddress() {
        let d = Number(this._preloadUint(2, this._offset));
        if (d === 0)
            return this._offset += 2,
            null;
        if (d === 1)
            return this._loadExternalAddress();
        throw new Error("Invalid address")
    }
    loadAddressAny() {
        let d = Number(this._preloadUint(2, this._offset));
        if (d === 0)
            return this._offset += 2,
            null;
        if (d === 2)
            return this._loadInternalAddress();
        if (d === 1)
            return this._loadExternalAddress();
        throw Error(d === 3 ? "Unsupported" : "Unreachable")
    }
    loadPaddedBits(d) {
        if (d % 8 !== 0)
            throw new Error("Invalid number of bits");
        let f = d;
        for (; ; )
            if (this._bits.at(this._offset + f - 1)) {
                f--;
                break
            } else
                f--;
        let m = this._bits.substring(this._offset, f);
        return this._offset += d,
        m
    }
    clone() {
        return new BitReader(this._bits,this._offset)
    }
    _preloadInt(d, f) {
        if (d == 0)
            return 0n;
        let m = this._bits.at(f)
          , k = 0n;
        for (let y = 0; y < d - 1; y++)
            this._bits.at(f + 1 + y) && (k += 1n << BigInt(d - y - 1 - 1));
        return m && (k = k - (1n << BigInt(d - 1))),
        k
    }
    _preloadUint(d, f) {
        if (d == 0)
            return 0n;
        let m = 0n;
        for (let k = 0; k < d; k++)
            this._bits.at(f + k) && (m += 1n << BigInt(d - k - 1));
        return m
    }
    _preloadBuffer(d, f) {
        let m = this._bits.subbuffer(f, d * 8);
        if (m)
            return m;
        let k = Buffer.alloc(d);
        for (let y = 0; y < d; y++)
            k[y] = Number(this._preloadUint(8, f + y * 8));
        return k
    }
    _loadInternalAddress() {
        if (Number(this._preloadUint(2, this._offset)) !== 2 || this._preloadUint(1, this._offset + 2) !== 0n)
            throw Error("Invalid address");
        let f = Number(this._preloadInt(8, this._offset + 3))
          , m = this._preloadBuffer(32, this._offset + 11);
        return this._offset += 267,
        new Address_1$3.Address(f,m)
    }
    _loadExternalAddress() {
        if (Number(this._preloadUint(2, this._offset)) !== 1)
            throw Error("Invalid address");
        let f = Number(this._preloadUint(9, this._offset + 2))
          , m = this._preloadUint(f, this._offset + 11);
        return this._offset += 11 + f,
        new ExternalAddress_1.ExternalAddress(m,f)
    }
}
BitReader$1.BitReader = BitReader;
var exoticLibrary$1 = {};
Object.defineProperty(exoticLibrary$1, "__esModule", {
    value: !0
});
exoticLibrary$1.exoticLibrary = void 0;
const BitReader_1$4 = BitReader$1;
function exoticLibrary(r, d) {
    const f = new BitReader_1$4.BitReader(r);
    if (r.length !== 264)
        throw new Error(`Library cell must have exactly (8 + 256) bits, got "${r.length}"`);
    let k = f.loadUint(8);
    if (k !== 2)
        throw new Error(`Library cell must have type 2, got "${k}"`);
    return {}
}
exoticLibrary$1.exoticLibrary = exoticLibrary;
var exoticMerkleProof$1 = {};
Object.defineProperty(exoticMerkleProof$1, "__esModule", {
    value: !0
});
exoticMerkleProof$1.exoticMerkleProof = void 0;
const BitReader_1$3 = BitReader$1;
function exoticMerkleProof(r, d) {
    const f = new BitReader_1$3.BitReader(r);
    if (r.length !== 280)
        throw new Error(`Merkle Proof cell must have exactly (8 + 256 + 16) bits, got "${r.length}"`);
    if (d.length !== 1)
        throw new Error(`Merkle Proof cell must have exactly 1 ref, got "${d.length}"`);
    let k = f.loadUint(8);
    if (k !== 3)
        throw new Error(`Merkle Proof cell must have type 3, got "${k}"`);
    const y = f.loadBuffer(32)
      , ee = f.loadUint(16)
      , dt = d[0].hash(0)
      , mt = d[0].depth(0);
    if (ee !== mt)
        throw new Error(`Merkle Proof cell ref depth must be exactly "${ee}", got "${mt}"`);
    if (!y.equals(dt))
        throw new Error(`Merkle Proof cell ref hash must be exactly "${y.toString("hex")}", got "${dt.toString("hex")}"`);
    return {
        proofDepth: ee,
        proofHash: y
    }
}
exoticMerkleProof$1.exoticMerkleProof = exoticMerkleProof;
var exoticMerkleUpdate$1 = {};
Object.defineProperty(exoticMerkleUpdate$1, "__esModule", {
    value: !0
});
exoticMerkleUpdate$1.exoticMerkleUpdate = void 0;
const BitReader_1$2 = BitReader$1;
function exoticMerkleUpdate(r, d) {
    const f = new BitReader_1$2.BitReader(r)
      , m = 8 + 2 * 272;
    if (r.length !== m)
        throw new Error(`Merkle Update cell must have exactly (8 + (2 * (256 + 16))) bits, got "${r.length}"`);
    if (d.length !== 2)
        throw new Error(`Merkle Update cell must have exactly 2 refs, got "${d.length}"`);
    let k = f.loadUint(8);
    if (k !== 4)
        throw new Error(`Merkle Update cell type must be exactly 4, got "${k}"`);
    const y = f.loadBuffer(32)
      , ee = f.loadBuffer(32)
      , dt = f.loadUint(16)
      , mt = f.loadUint(16);
    if (dt !== d[0].depth(0))
        throw new Error(`Merkle Update cell ref depth must be exactly "${dt}", got "${d[0].depth(0)}"`);
    if (!y.equals(d[0].hash(0)))
        throw new Error(`Merkle Update cell ref hash must be exactly "${y.toString("hex")}", got "${d[0].hash(0).toString("hex")}"`);
    if (mt !== d[1].depth(0))
        throw new Error(`Merkle Update cell ref depth must be exactly "${mt}", got "${d[1].depth(0)}"`);
    if (!ee.equals(d[1].hash(0)))
        throw new Error(`Merkle Update cell ref hash must be exactly "${ee.toString("hex")}", got "${d[1].hash(0).toString("hex")}"`);
    return {
        proofDepth1: dt,
        proofDepth2: mt,
        proofHash1: y,
        proofHash2: ee
    }
}
exoticMerkleUpdate$1.exoticMerkleUpdate = exoticMerkleUpdate;
var exoticPruned$1 = {}
  , LevelMask$1 = {};
Object.defineProperty(LevelMask$1, "__esModule", {
    value: !0
});
LevelMask$1.LevelMask = void 0;
class LevelMask {
    constructor(d=0) {
        this._mask = 0,
        this._mask = d,
        this._hashIndex = countSetBits(this._mask),
        this._hashCount = this._hashIndex + 1
    }
    get value() {
        return this._mask
    }
    get level() {
        return 32 - Math.clz32(this._mask)
    }
    get hashIndex() {
        return this._hashIndex
    }
    get hashCount() {
        return this._hashCount
    }
    apply(d) {
        return new LevelMask(this._mask & (1 << d) - 1)
    }
    isSignificant(d) {
        return d === 0 || (this._mask >> d - 1) % 2 !== 0
    }
}
LevelMask$1.LevelMask = LevelMask;
function countSetBits(r) {
    return r = r - (r >> 1 & 1431655765),
    r = (r & 858993459) + (r >> 2 & 858993459),
    (r + (r >> 4) & 252645135) * 16843009 >> 24
}
Object.defineProperty(exoticPruned$1, "__esModule", {
    value: !0
});
exoticPruned$1.exoticPruned = void 0;
const BitReader_1$1 = BitReader$1
  , LevelMask_1$2 = LevelMask$1;
function exoticPruned(r, d) {
    let f = new BitReader_1$1.BitReader(r)
      , m = f.loadUint(8);
    if (m !== 1)
        throw new Error(`Pruned branch cell must have type 1, got "${m}"`);
    if (d.length !== 0)
        throw new Error(`Pruned Branch cell can't has refs, got "${d.length}"`);
    let k;
    if (r.length === 280)
        k = new LevelMask_1$2.LevelMask(1);
    else {
        if (k = new LevelMask_1$2.LevelMask(f.loadUint(8)),
        k.level < 1 || k.level > 3)
            throw new Error(`Pruned Branch cell level must be >= 1 and <= 3, got "${k.level}/${k.value}"`);
        const mt = 16 + k.apply(k.level - 1).hashCount * 272;
        if (r.length !== mt)
            throw new Error(`Pruned branch cell must have exactly ${mt} bits, got "${r.length}"`)
    }
    let y = []
      , ee = []
      , dt = [];
    for (let mt = 0; mt < k.level; mt++)
        ee.push(f.loadBuffer(32));
    for (let mt = 0; mt < k.level; mt++)
        dt.push(f.loadUint(16));
    for (let mt = 0; mt < k.level; mt++)
        y.push({
            depth: dt[mt],
            hash: ee[mt]
        });
    return {
        mask: k.value,
        pruned: y
    }
}
exoticPruned$1.exoticPruned = exoticPruned;
Object.defineProperty(resolveExotic$1, "__esModule", {
    value: !0
});
resolveExotic$1.resolveExotic = void 0;
const BitReader_1 = BitReader$1
  , CellType_1$2 = CellType$1
  , exoticLibrary_1$1 = exoticLibrary$1
  , exoticMerkleProof_1$1 = exoticMerkleProof$1
  , exoticMerkleUpdate_1$1 = exoticMerkleUpdate$1
  , exoticPruned_1$1 = exoticPruned$1
  , LevelMask_1$1 = LevelMask$1;
function resolvePruned(r, d) {
    let f = (0,
    exoticPruned_1$1.exoticPruned)(r, d)
      , m = []
      , k = []
      , y = new LevelMask_1$1.LevelMask(f.mask);
    for (let ee = 0; ee < f.pruned.length; ee++)
        m.push(f.pruned[ee].depth),
        k.push(f.pruned[ee].hash);
    return {
        type: CellType_1$2.CellType.PrunedBranch,
        depths: m,
        hashes: k,
        mask: y
    }
}
function resolveLibrary(r, d) {
    (0,
    exoticLibrary_1$1.exoticLibrary)(r, d);
    let f = []
      , m = []
      , k = new LevelMask_1$1.LevelMask;
    return {
        type: CellType_1$2.CellType.Library,
        depths: f,
        hashes: m,
        mask: k
    }
}
function resolveMerkleProof(r, d) {
    (0,
    exoticMerkleProof_1$1.exoticMerkleProof)(r, d);
    let f = []
      , m = []
      , k = new LevelMask_1$1.LevelMask(d[0].level() >> 1);
    return {
        type: CellType_1$2.CellType.MerkleProof,
        depths: f,
        hashes: m,
        mask: k
    }
}
function resolveMerkleUpdate(r, d) {
    (0,
    exoticMerkleUpdate_1$1.exoticMerkleUpdate)(r, d);
    let f = []
      , m = []
      , k = new LevelMask_1$1.LevelMask((d[0].level() | d[1].level()) >> 1);
    return {
        type: CellType_1$2.CellType.MerkleUpdate,
        depths: f,
        hashes: m,
        mask: k
    }
}
function resolveExotic(r, d) {
    let m = new BitReader_1.BitReader(r).preloadUint(8);
    if (m === 1)
        return resolvePruned(r, d);
    if (m === 2)
        return resolveLibrary(r, d);
    if (m === 3)
        return resolveMerkleProof(r, d);
    if (m === 4)
        return resolveMerkleUpdate(r, d);
    throw Error("Invalid exotic cell type: " + m)
}
resolveExotic$1.resolveExotic = resolveExotic;
var wonderCalculator$1 = {}
  , descriptor = {};
Object.defineProperty(descriptor, "__esModule", {
    value: !0
});
descriptor.getRepr = descriptor.getBitsDescriptor = descriptor.getRefsDescriptor = void 0;
const CellType_1$1 = CellType$1
  , paddedBits_1 = requirePaddedBits();
function getRefsDescriptor(r, d, f) {
    return r.length + (f !== CellType_1$1.CellType.Ordinary ? 1 : 0) * 8 + d * 32
}
descriptor.getRefsDescriptor = getRefsDescriptor;
function getBitsDescriptor(r) {
    let d = r.length;
    return Math.ceil(d / 8) + Math.floor(d / 8)
}
descriptor.getBitsDescriptor = getBitsDescriptor;
function getRepr(r, d, f, m, k, y) {
    const ee = Math.ceil(d.length / 8)
      , dt = Buffer.alloc(2 + ee + 34 * f.length);
    let mt = 0;
    dt[mt++] = getRefsDescriptor(f, k, y),
    dt[mt++] = getBitsDescriptor(r),
    (0,
    paddedBits_1.bitsToPaddedBuffer)(d).copy(dt, mt),
    mt += ee;
    for (const yt of f) {
        let pt;
        y == CellType_1$1.CellType.MerkleProof || y == CellType_1$1.CellType.MerkleUpdate ? pt = yt.depth(m + 1) : pt = yt.depth(m),
        dt[mt++] = Math.floor(pt / 256),
        dt[mt++] = pt % 256
    }
    for (const yt of f) {
        let pt;
        y == CellType_1$1.CellType.MerkleProof || y == CellType_1$1.CellType.MerkleUpdate ? pt = yt.hash(m + 1) : pt = yt.hash(m),
        pt.copy(dt, mt),
        mt += 32
    }
    return dt
}
descriptor.getRepr = getRepr;
var dist = {}
  , sha256$3 = {}
  , sha = {
    exports: {}
};
(function(r, d) {
    (function(f, m) {
        r.exports = m()
    }
    )(commonjsGlobal, function() {
        var f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        function m(vr, ar, hr, _r) {
            var Ar, Ft, Ut, Dt = ar || [0], er = (hr = hr || 0) >>> 3, br = _r === -1 ? 3 : 0;
            for (Ar = 0; Ar < vr.length; Ar += 1)
                Ft = (Ut = Ar + er) >>> 2,
                Dt.length <= Ft && Dt.push(0),
                Dt[Ft] |= vr[Ar] << 8 * (br + _r * (Ut % 4));
            return {
                value: Dt,
                binLen: 8 * vr.length + hr
            }
        }
        function k(vr, ar, hr) {
            switch (ar) {
            case "UTF8":
            case "UTF16BE":
            case "UTF16LE":
                break;
            default:
                throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE")
            }
            switch (vr) {
            case "HEX":
                return function(_r, Ar, Ft) {
                    return function(Ut, Dt, er, br) {
                        var Cr, xr, Lr, Ur;
                        if (Ut.length % 2 != 0)
                            throw new Error("String of HEX type must be in byte increments");
                        var Ir = Dt || [0]
                          , Jr = (er = er || 0) >>> 3
                          , Wr = br === -1 ? 3 : 0;
                        for (Cr = 0; Cr < Ut.length; Cr += 2) {
                            if (xr = parseInt(Ut.substr(Cr, 2), 16),
                            isNaN(xr))
                                throw new Error("String of HEX type contains invalid characters");
                            for (Lr = (Ur = (Cr >>> 1) + Jr) >>> 2; Ir.length <= Lr; )
                                Ir.push(0);
                            Ir[Lr] |= xr << 8 * (Wr + br * (Ur % 4))
                        }
                        return {
                            value: Ir,
                            binLen: 4 * Ut.length + er
                        }
                    }(_r, Ar, Ft, hr)
                }
                ;
            case "TEXT":
                return function(_r, Ar, Ft) {
                    return function(Ut, Dt, er, br, Cr) {
                        var xr, Lr, Ur, Ir, Jr, Wr, Yr, Sn, pn = 0, tn = er || [0], Bn = (br = br || 0) >>> 3;
                        if (Dt === "UTF8")
                            for (Yr = Cr === -1 ? 3 : 0,
                            Ur = 0; Ur < Ut.length; Ur += 1)
                                for (Lr = [],
                                128 > (xr = Ut.charCodeAt(Ur)) ? Lr.push(xr) : 2048 > xr ? (Lr.push(192 | xr >>> 6),
                                Lr.push(128 | 63 & xr)) : 55296 > xr || 57344 <= xr ? Lr.push(224 | xr >>> 12, 128 | xr >>> 6 & 63, 128 | 63 & xr) : (Ur += 1,
                                xr = 65536 + ((1023 & xr) << 10 | 1023 & Ut.charCodeAt(Ur)),
                                Lr.push(240 | xr >>> 18, 128 | xr >>> 12 & 63, 128 | xr >>> 6 & 63, 128 | 63 & xr)),
                                Ir = 0; Ir < Lr.length; Ir += 1) {
                                    for (Jr = (Wr = pn + Bn) >>> 2; tn.length <= Jr; )
                                        tn.push(0);
                                    tn[Jr] |= Lr[Ir] << 8 * (Yr + Cr * (Wr % 4)),
                                    pn += 1
                                }
                        else
                            for (Yr = Cr === -1 ? 2 : 0,
                            Sn = Dt === "UTF16LE" && Cr !== 1 || Dt !== "UTF16LE" && Cr === 1,
                            Ur = 0; Ur < Ut.length; Ur += 1) {
                                for (xr = Ut.charCodeAt(Ur),
                                Sn === !0 && (xr = (Ir = 255 & xr) << 8 | xr >>> 8),
                                Jr = (Wr = pn + Bn) >>> 2; tn.length <= Jr; )
                                    tn.push(0);
                                tn[Jr] |= xr << 8 * (Yr + Cr * (Wr % 4)),
                                pn += 2
                            }
                        return {
                            value: tn,
                            binLen: 8 * pn + br
                        }
                    }(_r, ar, Ar, Ft, hr)
                }
                ;
            case "B64":
                return function(_r, Ar, Ft) {
                    return function(Ut, Dt, er, br) {
                        var Cr, xr, Lr, Ur, Ir, Jr, Wr = 0, Yr = Dt || [0], Sn = (er = er || 0) >>> 3, pn = br === -1 ? 3 : 0, tn = Ut.indexOf("=");
                        if (Ut.search(/^[a-zA-Z0-9=+/]+$/) === -1)
                            throw new Error("Invalid character in base-64 string");
                        if (Ut = Ut.replace(/=/g, ""),
                        tn !== -1 && tn < Ut.length)
                            throw new Error("Invalid '=' found in base-64 string");
                        for (Cr = 0; Cr < Ut.length; Cr += 4) {
                            for (Ur = Ut.substr(Cr, 4),
                            Lr = 0,
                            xr = 0; xr < Ur.length; xr += 1)
                                Lr |= f.indexOf(Ur.charAt(xr)) << 18 - 6 * xr;
                            for (xr = 0; xr < Ur.length - 1; xr += 1) {
                                for (Ir = (Jr = Wr + Sn) >>> 2; Yr.length <= Ir; )
                                    Yr.push(0);
                                Yr[Ir] |= (Lr >>> 16 - 8 * xr & 255) << 8 * (pn + br * (Jr % 4)),
                                Wr += 1
                            }
                        }
                        return {
                            value: Yr,
                            binLen: 8 * Wr + er
                        }
                    }(_r, Ar, Ft, hr)
                }
                ;
            case "BYTES":
                return function(_r, Ar, Ft) {
                    return function(Ut, Dt, er, br) {
                        var Cr, xr, Lr, Ur, Ir = Dt || [0], Jr = (er = er || 0) >>> 3, Wr = br === -1 ? 3 : 0;
                        for (xr = 0; xr < Ut.length; xr += 1)
                            Cr = Ut.charCodeAt(xr),
                            Lr = (Ur = xr + Jr) >>> 2,
                            Ir.length <= Lr && Ir.push(0),
                            Ir[Lr] |= Cr << 8 * (Wr + br * (Ur % 4));
                        return {
                            value: Ir,
                            binLen: 8 * Ut.length + er
                        }
                    }(_r, Ar, Ft, hr)
                }
                ;
            case "ARRAYBUFFER":
                try {
                    new ArrayBuffer(0)
                } catch {
                    throw new Error("ARRAYBUFFER not supported by this environment")
                }
                return function(_r, Ar, Ft) {
                    return function(Ut, Dt, er, br) {
                        return m(new Uint8Array(Ut), Dt, er, br)
                    }(_r, Ar, Ft, hr)
                }
                ;
            case "UINT8ARRAY":
                try {
                    new Uint8Array(0)
                } catch {
                    throw new Error("UINT8ARRAY not supported by this environment")
                }
                return function(_r, Ar, Ft) {
                    return m(_r, Ar, Ft, hr)
                }
                ;
            default:
                throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY")
            }
        }
        function y(vr, ar, hr, _r) {
            switch (vr) {
            case "HEX":
                return function(Ar) {
                    return function(Ft, Ut, Dt, er) {
                        var br, Cr, xr = "", Lr = Ut / 8, Ur = Dt === -1 ? 3 : 0;
                        for (br = 0; br < Lr; br += 1)
                            Cr = Ft[br >>> 2] >>> 8 * (Ur + Dt * (br % 4)),
                            xr += "0123456789abcdef".charAt(Cr >>> 4 & 15) + "0123456789abcdef".charAt(15 & Cr);
                        return er.outputUpper ? xr.toUpperCase() : xr
                    }(Ar, ar, hr, _r)
                }
                ;
            case "B64":
                return function(Ar) {
                    return function(Ft, Ut, Dt, er) {
                        var br, Cr, xr, Lr, Ur, Ir = "", Jr = Ut / 8, Wr = Dt === -1 ? 3 : 0;
                        for (br = 0; br < Jr; br += 3)
                            for (Lr = br + 1 < Jr ? Ft[br + 1 >>> 2] : 0,
                            Ur = br + 2 < Jr ? Ft[br + 2 >>> 2] : 0,
                            xr = (Ft[br >>> 2] >>> 8 * (Wr + Dt * (br % 4)) & 255) << 16 | (Lr >>> 8 * (Wr + Dt * ((br + 1) % 4)) & 255) << 8 | Ur >>> 8 * (Wr + Dt * ((br + 2) % 4)) & 255,
                            Cr = 0; Cr < 4; Cr += 1)
                                Ir += 8 * br + 6 * Cr <= Ut ? f.charAt(xr >>> 6 * (3 - Cr) & 63) : er.b64Pad;
                        return Ir
                    }(Ar, ar, hr, _r)
                }
                ;
            case "BYTES":
                return function(Ar) {
                    return function(Ft, Ut, Dt) {
                        var er, br, Cr = "", xr = Ut / 8, Lr = Dt === -1 ? 3 : 0;
                        for (er = 0; er < xr; er += 1)
                            br = Ft[er >>> 2] >>> 8 * (Lr + Dt * (er % 4)) & 255,
                            Cr += String.fromCharCode(br);
                        return Cr
                    }(Ar, ar, hr)
                }
                ;
            case "ARRAYBUFFER":
                try {
                    new ArrayBuffer(0)
                } catch {
                    throw new Error("ARRAYBUFFER not supported by this environment")
                }
                return function(Ar) {
                    return function(Ft, Ut, Dt) {
                        var er, br = Ut / 8, Cr = new ArrayBuffer(br), xr = new Uint8Array(Cr), Lr = Dt === -1 ? 3 : 0;
                        for (er = 0; er < br; er += 1)
                            xr[er] = Ft[er >>> 2] >>> 8 * (Lr + Dt * (er % 4)) & 255;
                        return Cr
                    }(Ar, ar, hr)
                }
                ;
            case "UINT8ARRAY":
                try {
                    new Uint8Array(0)
                } catch {
                    throw new Error("UINT8ARRAY not supported by this environment")
                }
                return function(Ar) {
                    return function(Ft, Ut, Dt) {
                        var er, br = Ut / 8, Cr = Dt === -1 ? 3 : 0, xr = new Uint8Array(br);
                        for (er = 0; er < br; er += 1)
                            xr[er] = Ft[er >>> 2] >>> 8 * (Cr + Dt * (er % 4)) & 255;
                        return xr
                    }(Ar, ar, hr)
                }
                ;
            default:
                throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY")
            }
        }
        var ee = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]
          , dt = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
          , mt = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]
          , yt = "Chosen SHA variant is not supported";
        function pt(vr, ar) {
            var hr, _r, Ar = vr.binLen >>> 3, Ft = ar.binLen >>> 3, Ut = Ar << 3, Dt = 4 - Ar << 3;
            if (Ar % 4 != 0) {
                for (hr = 0; hr < Ft; hr += 4)
                    _r = Ar + hr >>> 2,
                    vr.value[_r] |= ar.value[hr >>> 2] << Ut,
                    vr.value.push(0),
                    vr.value[_r + 1] |= ar.value[hr >>> 2] >>> Dt;
                return (vr.value.length << 2) - 4 >= Ft + Ar && vr.value.pop(),
                {
                    value: vr.value,
                    binLen: vr.binLen + ar.binLen
                }
            }
            return {
                value: vr.value.concat(ar.value),
                binLen: vr.binLen + ar.binLen
            }
        }
        function bt(vr) {
            var ar = {
                outputUpper: !1,
                b64Pad: "=",
                outputLen: -1
            }
              , hr = vr || {}
              , _r = "Output length must be a multiple of 8";
            if (ar.outputUpper = hr.outputUpper || !1,
            hr.b64Pad && (ar.b64Pad = hr.b64Pad),
            hr.outputLen) {
                if (hr.outputLen % 8 != 0)
                    throw new Error(_r);
                ar.outputLen = hr.outputLen
            } else if (hr.shakeLen) {
                if (hr.shakeLen % 8 != 0)
                    throw new Error(_r);
                ar.outputLen = hr.shakeLen
            }
            if (typeof ar.outputUpper != "boolean")
                throw new Error("Invalid outputUpper formatting option");
            if (typeof ar.b64Pad != "string")
                throw new Error("Invalid b64Pad formatting option");
            return ar
        }
        function wt(vr, ar, hr, _r) {
            var Ar = vr + " must include a value and format";
            if (!ar) {
                if (!_r)
                    throw new Error(Ar);
                return _r
            }
            if (ar.value === void 0 || !ar.format)
                throw new Error(Ar);
            return k(ar.format, ar.encoding || "UTF8", hr)(ar.value)
        }
        var xt = function() {
            function vr(ar, hr, _r) {
                var Ar = _r || {};
                if (this.t = hr,
                this.i = Ar.encoding || "UTF8",
                this.numRounds = Ar.numRounds || 1,
                isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds)
                    throw new Error("numRounds must a integer >= 1");
                this.o = ar,
                this.u = [],
                this.s = 0,
                this.h = !1,
                this.v = 0,
                this.A = !1,
                this.l = [],
                this.H = []
            }
            return vr.prototype.update = function(ar) {
                var hr, _r = 0, Ar = this.S >>> 5, Ft = this.p(ar, this.u, this.s), Ut = Ft.binLen, Dt = Ft.value, er = Ut >>> 5;
                for (hr = 0; hr < er; hr += Ar)
                    _r + this.S <= Ut && (this.m = this.R(Dt.slice(hr, hr + Ar), this.m),
                    _r += this.S);
                this.v += _r,
                this.u = Dt.slice(_r >>> 5),
                this.s = Ut % this.S,
                this.h = !0
            }
            ,
            vr.prototype.getHash = function(ar, hr) {
                var _r, Ar, Ft = this.U, Ut = bt(hr);
                if (this.T) {
                    if (Ut.outputLen === -1)
                        throw new Error("Output length must be specified in options");
                    Ft = Ut.outputLen
                }
                var Dt = y(ar, Ft, this.C, Ut);
                if (this.A && this.F)
                    return Dt(this.F(Ut));
                for (Ar = this.K(this.u.slice(), this.s, this.v, this.B(this.m), Ft),
                _r = 1; _r < this.numRounds; _r += 1)
                    this.T && Ft % 32 != 0 && (Ar[Ar.length - 1] &= 16777215 >>> 24 - Ft % 32),
                    Ar = this.K(Ar, Ft, 0, this.L(this.o), Ft);
                return Dt(Ar)
            }
            ,
            vr.prototype.setHMACKey = function(ar, hr, _r) {
                if (!this.g)
                    throw new Error("Variant does not support HMAC");
                if (this.h)
                    throw new Error("Cannot set MAC key after calling update");
                var Ar = k(hr, (_r || {}).encoding || "UTF8", this.C);
                this.k(Ar(ar))
            }
            ,
            vr.prototype.k = function(ar) {
                var hr, _r = this.S >>> 3, Ar = _r / 4 - 1;
                if (this.numRounds !== 1)
                    throw new Error("Cannot set numRounds with MAC");
                if (this.A)
                    throw new Error("MAC key already set");
                for (_r < ar.binLen / 8 && (ar.value = this.K(ar.value, ar.binLen, 0, this.L(this.o), this.U)); ar.value.length <= Ar; )
                    ar.value.push(0);
                for (hr = 0; hr <= Ar; hr += 1)
                    this.l[hr] = 909522486 ^ ar.value[hr],
                    this.H[hr] = 1549556828 ^ ar.value[hr];
                this.m = this.R(this.l, this.m),
                this.v = this.S,
                this.A = !0
            }
            ,
            vr.prototype.getHMAC = function(ar, hr) {
                var _r = bt(hr);
                return y(ar, this.U, this.C, _r)(this.Y())
            }
            ,
            vr.prototype.Y = function() {
                var ar;
                if (!this.A)
                    throw new Error("Cannot call getHMAC without first setting MAC key");
                var hr = this.K(this.u.slice(), this.s, this.v, this.B(this.m), this.U);
                return ar = this.R(this.H, this.L(this.o)),
                ar = this.K(hr, this.U, this.S, ar, this.U)
            }
            ,
            vr
        }()
          , At = function(vr, ar) {
            return (At = Object.setPrototypeOf || {
                __proto__: []
            }instanceof Array && function(hr, _r) {
                hr.__proto__ = _r
            }
            || function(hr, _r) {
                for (var Ar in _r)
                    Object.prototype.hasOwnProperty.call(_r, Ar) && (hr[Ar] = _r[Ar])
            }
            )(vr, ar)
        };
        function Ct(vr, ar) {
            function hr() {
                this.constructor = vr
            }
            At(vr, ar),
            vr.prototype = ar === null ? Object.create(ar) : (hr.prototype = ar.prototype,
            new hr)
        }
        function Pt(vr, ar) {
            return vr << ar | vr >>> 32 - ar
        }
        function $t(vr, ar) {
            return vr >>> ar | vr << 32 - ar
        }
        function Ot(vr, ar) {
            return vr >>> ar
        }
        function Nt(vr, ar, hr) {
            return vr ^ ar ^ hr
        }
        function zt(vr, ar, hr) {
            return vr & ar ^ ~vr & hr
        }
        function Wt(vr, ar, hr) {
            return vr & ar ^ vr & hr ^ ar & hr
        }
        function Kt(vr) {
            return $t(vr, 2) ^ $t(vr, 13) ^ $t(vr, 22)
        }
        function ir(vr, ar) {
            var hr = (65535 & vr) + (65535 & ar);
            return (65535 & (vr >>> 16) + (ar >>> 16) + (hr >>> 16)) << 16 | 65535 & hr
        }
        function or(vr, ar, hr, _r) {
            var Ar = (65535 & vr) + (65535 & ar) + (65535 & hr) + (65535 & _r);
            return (65535 & (vr >>> 16) + (ar >>> 16) + (hr >>> 16) + (_r >>> 16) + (Ar >>> 16)) << 16 | 65535 & Ar
        }
        function tr(vr, ar, hr, _r, Ar) {
            var Ft = (65535 & vr) + (65535 & ar) + (65535 & hr) + (65535 & _r) + (65535 & Ar);
            return (65535 & (vr >>> 16) + (ar >>> 16) + (hr >>> 16) + (_r >>> 16) + (Ar >>> 16) + (Ft >>> 16)) << 16 | 65535 & Ft
        }
        function wr(vr) {
            return $t(vr, 7) ^ $t(vr, 18) ^ Ot(vr, 3)
        }
        function Ht(vr) {
            return $t(vr, 6) ^ $t(vr, 11) ^ $t(vr, 25)
        }
        function Mt(vr) {
            return [1732584193, 4023233417, 2562383102, 271733878, 3285377520]
        }
        function _t(vr, ar) {
            var hr, _r, Ar, Ft, Ut, Dt, er, br = [];
            for (hr = ar[0],
            _r = ar[1],
            Ar = ar[2],
            Ft = ar[3],
            Ut = ar[4],
            er = 0; er < 80; er += 1)
                br[er] = er < 16 ? vr[er] : Pt(br[er - 3] ^ br[er - 8] ^ br[er - 14] ^ br[er - 16], 1),
                Dt = er < 20 ? tr(Pt(hr, 5), zt(_r, Ar, Ft), Ut, 1518500249, br[er]) : er < 40 ? tr(Pt(hr, 5), Nt(_r, Ar, Ft), Ut, 1859775393, br[er]) : er < 60 ? tr(Pt(hr, 5), Wt(_r, Ar, Ft), Ut, 2400959708, br[er]) : tr(Pt(hr, 5), Nt(_r, Ar, Ft), Ut, 3395469782, br[er]),
                Ut = Ft,
                Ft = Ar,
                Ar = Pt(_r, 30),
                _r = hr,
                hr = Dt;
            return ar[0] = ir(hr, ar[0]),
            ar[1] = ir(_r, ar[1]),
            ar[2] = ir(Ar, ar[2]),
            ar[3] = ir(Ft, ar[3]),
            ar[4] = ir(Ut, ar[4]),
            ar
        }
        function gt(vr, ar, hr, _r) {
            for (var Ar, Ft = 15 + (ar + 65 >>> 9 << 4), Ut = ar + hr; vr.length <= Ft; )
                vr.push(0);
            for (vr[ar >>> 5] |= 128 << 24 - ar % 32,
            vr[Ft] = 4294967295 & Ut,
            vr[Ft - 1] = Ut / 4294967296 | 0,
            Ar = 0; Ar < vr.length; Ar += 16)
                _r = _t(vr.slice(Ar, Ar + 16), _r);
            return _r
        }
        var vt = function(vr) {
            function ar(hr, _r, Ar) {
                var Ft = this;
                if (hr !== "SHA-1")
                    throw new Error(yt);
                var Ut = Ar || {};
                return (Ft = vr.call(this, hr, _r, Ar) || this).g = !0,
                Ft.F = Ft.Y,
                Ft.C = -1,
                Ft.p = k(Ft.t, Ft.i, Ft.C),
                Ft.R = _t,
                Ft.B = function(Dt) {
                    return Dt.slice()
                }
                ,
                Ft.L = Mt,
                Ft.K = gt,
                Ft.m = [1732584193, 4023233417, 2562383102, 271733878, 3285377520],
                Ft.S = 512,
                Ft.U = 160,
                Ft.T = !1,
                Ut.hmacKey && Ft.k(wt("hmacKey", Ut.hmacKey, Ft.C)),
                Ft
            }
            return Ct(ar, vr),
            ar
        }(xt);
        function Et(vr) {
            return vr == "SHA-224" ? dt.slice() : mt.slice()
        }
        function Bt(vr, ar) {
            var hr, _r, Ar, Ft, Ut, Dt, er, br, Cr, xr, Lr, Ur, Ir = [];
            for (hr = ar[0],
            _r = ar[1],
            Ar = ar[2],
            Ft = ar[3],
            Ut = ar[4],
            Dt = ar[5],
            er = ar[6],
            br = ar[7],
            Lr = 0; Lr < 64; Lr += 1)
                Ir[Lr] = Lr < 16 ? vr[Lr] : or($t(Ur = Ir[Lr - 2], 17) ^ $t(Ur, 19) ^ Ot(Ur, 10), Ir[Lr - 7], wr(Ir[Lr - 15]), Ir[Lr - 16]),
                Cr = tr(br, Ht(Ut), zt(Ut, Dt, er), ee[Lr], Ir[Lr]),
                xr = ir(Kt(hr), Wt(hr, _r, Ar)),
                br = er,
                er = Dt,
                Dt = Ut,
                Ut = ir(Ft, Cr),
                Ft = Ar,
                Ar = _r,
                _r = hr,
                hr = ir(Cr, xr);
            return ar[0] = ir(hr, ar[0]),
            ar[1] = ir(_r, ar[1]),
            ar[2] = ir(Ar, ar[2]),
            ar[3] = ir(Ft, ar[3]),
            ar[4] = ir(Ut, ar[4]),
            ar[5] = ir(Dt, ar[5]),
            ar[6] = ir(er, ar[6]),
            ar[7] = ir(br, ar[7]),
            ar
        }
        var Rt = function(vr) {
            function ar(hr, _r, Ar) {
                var Ft = this;
                if (hr !== "SHA-224" && hr !== "SHA-256")
                    throw new Error(yt);
                var Ut = Ar || {};
                return (Ft = vr.call(this, hr, _r, Ar) || this).F = Ft.Y,
                Ft.g = !0,
                Ft.C = -1,
                Ft.p = k(Ft.t, Ft.i, Ft.C),
                Ft.R = Bt,
                Ft.B = function(Dt) {
                    return Dt.slice()
                }
                ,
                Ft.L = Et,
                Ft.K = function(Dt, er, br, Cr) {
                    return function(xr, Lr, Ur, Ir, Jr) {
                        for (var Wr, Yr = 15 + (Lr + 65 >>> 9 << 4), Sn = Lr + Ur; xr.length <= Yr; )
                            xr.push(0);
                        for (xr[Lr >>> 5] |= 128 << 24 - Lr % 32,
                        xr[Yr] = 4294967295 & Sn,
                        xr[Yr - 1] = Sn / 4294967296 | 0,
                        Wr = 0; Wr < xr.length; Wr += 16)
                            Ir = Bt(xr.slice(Wr, Wr + 16), Ir);
                        return Jr === "SHA-224" ? [Ir[0], Ir[1], Ir[2], Ir[3], Ir[4], Ir[5], Ir[6]] : Ir
                    }(Dt, er, br, Cr, hr)
                }
                ,
                Ft.m = Et(hr),
                Ft.S = 512,
                Ft.U = hr === "SHA-224" ? 224 : 256,
                Ft.T = !1,
                Ut.hmacKey && Ft.k(wt("hmacKey", Ut.hmacKey, Ft.C)),
                Ft
            }
            return Ct(ar, vr),
            ar
        }(xt)
          , kt = function(vr, ar) {
            this.N = vr,
            this.I = ar
        };
        function Tt(vr, ar) {
            var hr;
            return ar > 32 ? (hr = 64 - ar,
            new kt(vr.I << ar | vr.N >>> hr,vr.N << ar | vr.I >>> hr)) : ar !== 0 ? (hr = 32 - ar,
            new kt(vr.N << ar | vr.I >>> hr,vr.I << ar | vr.N >>> hr)) : vr
        }
        function It(vr, ar) {
            var hr;
            return ar < 32 ? (hr = 32 - ar,
            new kt(vr.N >>> ar | vr.I << hr,vr.I >>> ar | vr.N << hr)) : (hr = 64 - ar,
            new kt(vr.I >>> ar | vr.N << hr,vr.N >>> ar | vr.I << hr))
        }
        function St(vr, ar) {
            return new kt(vr.N >>> ar,vr.I >>> ar | vr.N << 32 - ar)
        }
        function qt(vr, ar, hr) {
            return new kt(vr.N & ar.N ^ ~vr.N & hr.N,vr.I & ar.I ^ ~vr.I & hr.I)
        }
        function ur(vr, ar, hr) {
            return new kt(vr.N & ar.N ^ vr.N & hr.N ^ ar.N & hr.N,vr.I & ar.I ^ vr.I & hr.I ^ ar.I & hr.I)
        }
        function gr(vr) {
            var ar = It(vr, 28)
              , hr = It(vr, 34)
              , _r = It(vr, 39);
            return new kt(ar.N ^ hr.N ^ _r.N,ar.I ^ hr.I ^ _r.I)
        }
        function lr(vr, ar) {
            var hr, _r;
            hr = (65535 & vr.I) + (65535 & ar.I);
            var Ar = (65535 & (_r = (vr.I >>> 16) + (ar.I >>> 16) + (hr >>> 16))) << 16 | 65535 & hr;
            return hr = (65535 & vr.N) + (65535 & ar.N) + (_r >>> 16),
            _r = (vr.N >>> 16) + (ar.N >>> 16) + (hr >>> 16),
            new kt((65535 & _r) << 16 | 65535 & hr,Ar)
        }
        function Zt(vr, ar, hr, _r) {
            var Ar, Ft;
            Ar = (65535 & vr.I) + (65535 & ar.I) + (65535 & hr.I) + (65535 & _r.I);
            var Ut = (65535 & (Ft = (vr.I >>> 16) + (ar.I >>> 16) + (hr.I >>> 16) + (_r.I >>> 16) + (Ar >>> 16))) << 16 | 65535 & Ar;
            return Ar = (65535 & vr.N) + (65535 & ar.N) + (65535 & hr.N) + (65535 & _r.N) + (Ft >>> 16),
            Ft = (vr.N >>> 16) + (ar.N >>> 16) + (hr.N >>> 16) + (_r.N >>> 16) + (Ar >>> 16),
            new kt((65535 & Ft) << 16 | 65535 & Ar,Ut)
        }
        function Vt(vr, ar, hr, _r, Ar) {
            var Ft, Ut;
            Ft = (65535 & vr.I) + (65535 & ar.I) + (65535 & hr.I) + (65535 & _r.I) + (65535 & Ar.I);
            var Dt = (65535 & (Ut = (vr.I >>> 16) + (ar.I >>> 16) + (hr.I >>> 16) + (_r.I >>> 16) + (Ar.I >>> 16) + (Ft >>> 16))) << 16 | 65535 & Ft;
            return Ft = (65535 & vr.N) + (65535 & ar.N) + (65535 & hr.N) + (65535 & _r.N) + (65535 & Ar.N) + (Ut >>> 16),
            Ut = (vr.N >>> 16) + (ar.N >>> 16) + (hr.N >>> 16) + (_r.N >>> 16) + (Ar.N >>> 16) + (Ft >>> 16),
            new kt((65535 & Ut) << 16 | 65535 & Ft,Dt)
        }
        function rr(vr, ar) {
            return new kt(vr.N ^ ar.N,vr.I ^ ar.I)
        }
        function fr(vr) {
            var ar = It(vr, 1)
              , hr = It(vr, 8)
              , _r = St(vr, 7);
            return new kt(ar.N ^ hr.N ^ _r.N,ar.I ^ hr.I ^ _r.I)
        }
        function Yt(vr) {
            var ar = It(vr, 14)
              , hr = It(vr, 18)
              , _r = It(vr, 41);
            return new kt(ar.N ^ hr.N ^ _r.N,ar.I ^ hr.I ^ _r.I)
        }
        var Xt = [new kt(ee[0],3609767458), new kt(ee[1],602891725), new kt(ee[2],3964484399), new kt(ee[3],2173295548), new kt(ee[4],4081628472), new kt(ee[5],3053834265), new kt(ee[6],2937671579), new kt(ee[7],3664609560), new kt(ee[8],2734883394), new kt(ee[9],1164996542), new kt(ee[10],1323610764), new kt(ee[11],3590304994), new kt(ee[12],4068182383), new kt(ee[13],991336113), new kt(ee[14],633803317), new kt(ee[15],3479774868), new kt(ee[16],2666613458), new kt(ee[17],944711139), new kt(ee[18],2341262773), new kt(ee[19],2007800933), new kt(ee[20],1495990901), new kt(ee[21],1856431235), new kt(ee[22],3175218132), new kt(ee[23],2198950837), new kt(ee[24],3999719339), new kt(ee[25],766784016), new kt(ee[26],2566594879), new kt(ee[27],3203337956), new kt(ee[28],1034457026), new kt(ee[29],2466948901), new kt(ee[30],3758326383), new kt(ee[31],168717936), new kt(ee[32],1188179964), new kt(ee[33],1546045734), new kt(ee[34],1522805485), new kt(ee[35],2643833823), new kt(ee[36],2343527390), new kt(ee[37],1014477480), new kt(ee[38],1206759142), new kt(ee[39],344077627), new kt(ee[40],1290863460), new kt(ee[41],3158454273), new kt(ee[42],3505952657), new kt(ee[43],106217008), new kt(ee[44],3606008344), new kt(ee[45],1432725776), new kt(ee[46],1467031594), new kt(ee[47],851169720), new kt(ee[48],3100823752), new kt(ee[49],1363258195), new kt(ee[50],3750685593), new kt(ee[51],3785050280), new kt(ee[52],3318307427), new kt(ee[53],3812723403), new kt(ee[54],2003034995), new kt(ee[55],3602036899), new kt(ee[56],1575990012), new kt(ee[57],1125592928), new kt(ee[58],2716904306), new kt(ee[59],442776044), new kt(ee[60],593698344), new kt(ee[61],3733110249), new kt(ee[62],2999351573), new kt(ee[63],3815920427), new kt(3391569614,3928383900), new kt(3515267271,566280711), new kt(3940187606,3454069534), new kt(4118630271,4000239992), new kt(116418474,1914138554), new kt(174292421,2731055270), new kt(289380356,3203993006), new kt(460393269,320620315), new kt(685471733,587496836), new kt(852142971,1086792851), new kt(1017036298,365543100), new kt(1126000580,2618297676), new kt(1288033470,3409855158), new kt(1501505948,4234509866), new kt(1607167915,987167468), new kt(1816402316,1246189591)];
        function Sr(vr) {
            return vr === "SHA-384" ? [new kt(3418070365,dt[0]), new kt(1654270250,dt[1]), new kt(2438529370,dt[2]), new kt(355462360,dt[3]), new kt(1731405415,dt[4]), new kt(41048885895,dt[5]), new kt(3675008525,dt[6]), new kt(1203062813,dt[7])] : [new kt(mt[0],4089235720), new kt(mt[1],2227873595), new kt(mt[2],4271175723), new kt(mt[3],1595750129), new kt(mt[4],2917565137), new kt(mt[5],725511199), new kt(mt[6],4215389547), new kt(mt[7],327033209)]
        }
        function Rr(vr, ar) {
            var hr, _r, Ar, Ft, Ut, Dt, er, br, Cr, xr, Lr, Ur, Ir, Jr, Wr, Yr, Sn = [];
            for (hr = ar[0],
            _r = ar[1],
            Ar = ar[2],
            Ft = ar[3],
            Ut = ar[4],
            Dt = ar[5],
            er = ar[6],
            br = ar[7],
            Lr = 0; Lr < 80; Lr += 1)
                Lr < 16 ? (Ur = 2 * Lr,
                Sn[Lr] = new kt(vr[Ur],vr[Ur + 1])) : Sn[Lr] = Zt((Ir = Sn[Lr - 2],
                Jr = void 0,
                Wr = void 0,
                Yr = void 0,
                Jr = It(Ir, 19),
                Wr = It(Ir, 61),
                Yr = St(Ir, 6),
                new kt(Jr.N ^ Wr.N ^ Yr.N,Jr.I ^ Wr.I ^ Yr.I)), Sn[Lr - 7], fr(Sn[Lr - 15]), Sn[Lr - 16]),
                Cr = Vt(br, Yt(Ut), qt(Ut, Dt, er), Xt[Lr], Sn[Lr]),
                xr = lr(gr(hr), ur(hr, _r, Ar)),
                br = er,
                er = Dt,
                Dt = Ut,
                Ut = lr(Ft, Cr),
                Ft = Ar,
                Ar = _r,
                _r = hr,
                hr = lr(Cr, xr);
            return ar[0] = lr(hr, ar[0]),
            ar[1] = lr(_r, ar[1]),
            ar[2] = lr(Ar, ar[2]),
            ar[3] = lr(Ft, ar[3]),
            ar[4] = lr(Ut, ar[4]),
            ar[5] = lr(Dt, ar[5]),
            ar[6] = lr(er, ar[6]),
            ar[7] = lr(br, ar[7]),
            ar
        }
        var qr = function(vr) {
            function ar(hr, _r, Ar) {
                var Ft = this;
                if (hr !== "SHA-384" && hr !== "SHA-512")
                    throw new Error(yt);
                var Ut = Ar || {};
                return (Ft = vr.call(this, hr, _r, Ar) || this).F = Ft.Y,
                Ft.g = !0,
                Ft.C = -1,
                Ft.p = k(Ft.t, Ft.i, Ft.C),
                Ft.R = Rr,
                Ft.B = function(Dt) {
                    return Dt.slice()
                }
                ,
                Ft.L = Sr,
                Ft.K = function(Dt, er, br, Cr) {
                    return function(xr, Lr, Ur, Ir, Jr) {
                        for (var Wr, Yr = 31 + (Lr + 129 >>> 10 << 5), Sn = Lr + Ur; xr.length <= Yr; )
                            xr.push(0);
                        for (xr[Lr >>> 5] |= 128 << 24 - Lr % 32,
                        xr[Yr] = 4294967295 & Sn,
                        xr[Yr - 1] = Sn / 4294967296 | 0,
                        Wr = 0; Wr < xr.length; Wr += 32)
                            Ir = Rr(xr.slice(Wr, Wr + 32), Ir);
                        return Jr === "SHA-384" ? [(Ir = Ir)[0].N, Ir[0].I, Ir[1].N, Ir[1].I, Ir[2].N, Ir[2].I, Ir[3].N, Ir[3].I, Ir[4].N, Ir[4].I, Ir[5].N, Ir[5].I] : [Ir[0].N, Ir[0].I, Ir[1].N, Ir[1].I, Ir[2].N, Ir[2].I, Ir[3].N, Ir[3].I, Ir[4].N, Ir[4].I, Ir[5].N, Ir[5].I, Ir[6].N, Ir[6].I, Ir[7].N, Ir[7].I]
                    }(Dt, er, br, Cr, hr)
                }
                ,
                Ft.m = Sr(hr),
                Ft.S = 1024,
                Ft.U = hr === "SHA-384" ? 384 : 512,
                Ft.T = !1,
                Ut.hmacKey && Ft.k(wt("hmacKey", Ut.hmacKey, Ft.C)),
                Ft
            }
            return Ct(ar, vr),
            ar
        }(xt)
          , Nr = [new kt(0,1), new kt(0,32898), new kt(2147483648,32906), new kt(2147483648,2147516416), new kt(0,32907), new kt(0,2147483649), new kt(2147483648,2147516545), new kt(2147483648,32777), new kt(0,138), new kt(0,136), new kt(0,2147516425), new kt(0,2147483658), new kt(0,2147516555), new kt(2147483648,139), new kt(2147483648,32905), new kt(2147483648,32771), new kt(2147483648,32770), new kt(2147483648,128), new kt(0,32778), new kt(2147483648,2147483658), new kt(2147483648,2147516545), new kt(2147483648,32896), new kt(0,2147483649), new kt(2147483648,2147516424)]
          , Dr = [[0, 36, 3, 41, 18], [1, 44, 10, 45, 2], [62, 6, 43, 15, 61], [28, 55, 25, 21, 56], [27, 20, 39, 8, 14]];
        function Or(vr) {
            var ar, hr = [];
            for (ar = 0; ar < 5; ar += 1)
                hr[ar] = [new kt(0,0), new kt(0,0), new kt(0,0), new kt(0,0), new kt(0,0)];
            return hr
        }
        function $r(vr) {
            var ar, hr = [];
            for (ar = 0; ar < 5; ar += 1)
                hr[ar] = vr[ar].slice();
            return hr
        }
        function Zr(vr, ar) {
            var hr, _r, Ar, Ft, Ut, Dt, er, br, Cr, xr = [], Lr = [];
            if (vr !== null)
                for (_r = 0; _r < vr.length; _r += 2)
                    ar[(_r >>> 1) % 5][(_r >>> 1) / 5 | 0] = rr(ar[(_r >>> 1) % 5][(_r >>> 1) / 5 | 0], new kt(vr[_r + 1],vr[_r]));
            for (hr = 0; hr < 24; hr += 1) {
                for (Ft = Or(),
                _r = 0; _r < 5; _r += 1)
                    xr[_r] = (Ut = ar[_r][0],
                    Dt = ar[_r][1],
                    er = ar[_r][2],
                    br = ar[_r][3],
                    Cr = ar[_r][4],
                    new kt(Ut.N ^ Dt.N ^ er.N ^ br.N ^ Cr.N,Ut.I ^ Dt.I ^ er.I ^ br.I ^ Cr.I));
                for (_r = 0; _r < 5; _r += 1)
                    Lr[_r] = rr(xr[(_r + 4) % 5], Tt(xr[(_r + 1) % 5], 1));
                for (_r = 0; _r < 5; _r += 1)
                    for (Ar = 0; Ar < 5; Ar += 1)
                        ar[_r][Ar] = rr(ar[_r][Ar], Lr[_r]);
                for (_r = 0; _r < 5; _r += 1)
                    for (Ar = 0; Ar < 5; Ar += 1)
                        Ft[Ar][(2 * _r + 3 * Ar) % 5] = Tt(ar[_r][Ar], Dr[_r][Ar]);
                for (_r = 0; _r < 5; _r += 1)
                    for (Ar = 0; Ar < 5; Ar += 1)
                        ar[_r][Ar] = rr(Ft[_r][Ar], new kt(~Ft[(_r + 1) % 5][Ar].N & Ft[(_r + 2) % 5][Ar].N,~Ft[(_r + 1) % 5][Ar].I & Ft[(_r + 2) % 5][Ar].I));
                ar[0][0] = rr(ar[0][0], Nr[hr])
            }
            return ar
        }
        function Hr(vr) {
            var ar, hr, _r = 0, Ar = [0, 0], Ft = [4294967295 & vr, vr / 4294967296 & 2097151];
            for (ar = 6; ar >= 0; ar--)
                (hr = Ft[ar >> 2] >>> 8 * ar & 255) === 0 && _r === 0 || (Ar[_r + 1 >> 2] |= hr << 8 * (_r + 1),
                _r += 1);
            return _r = _r !== 0 ? _r : 1,
            Ar[0] |= _r,
            {
                value: _r + 1 > 4 ? Ar : [Ar[0]],
                binLen: 8 + 8 * _r
            }
        }
        function un(vr) {
            return pt(Hr(vr.binLen), vr)
        }
        function Qr(vr, ar) {
            var hr, _r = Hr(ar), Ar = ar >>> 2, Ft = (Ar - (_r = pt(_r, vr)).value.length % Ar) % Ar;
            for (hr = 0; hr < Ft; hr++)
                _r.value.push(0);
            return _r.value
        }
        var Gr = function(vr) {
            function ar(hr, _r, Ar) {
                var Ft = this
                  , Ut = 6
                  , Dt = 0
                  , er = Ar || {};
                if ((Ft = vr.call(this, hr, _r, Ar) || this).numRounds !== 1) {
                    if (er.kmacKey || er.hmacKey)
                        throw new Error("Cannot set numRounds with MAC");
                    if (Ft.o === "CSHAKE128" || Ft.o === "CSHAKE256")
                        throw new Error("Cannot set numRounds for CSHAKE variants")
                }
                switch (Ft.C = 1,
                Ft.p = k(Ft.t, Ft.i, Ft.C),
                Ft.R = Zr,
                Ft.B = $r,
                Ft.L = Or,
                Ft.m = Or(),
                Ft.T = !1,
                hr) {
                case "SHA3-224":
                    Ft.S = Dt = 1152,
                    Ft.U = 224,
                    Ft.g = !0,
                    Ft.F = Ft.Y;
                    break;
                case "SHA3-256":
                    Ft.S = Dt = 1088,
                    Ft.U = 256,
                    Ft.g = !0,
                    Ft.F = Ft.Y;
                    break;
                case "SHA3-384":
                    Ft.S = Dt = 832,
                    Ft.U = 384,
                    Ft.g = !0,
                    Ft.F = Ft.Y;
                    break;
                case "SHA3-512":
                    Ft.S = Dt = 576,
                    Ft.U = 512,
                    Ft.g = !0,
                    Ft.F = Ft.Y;
                    break;
                case "SHAKE128":
                    Ut = 31,
                    Ft.S = Dt = 1344,
                    Ft.U = -1,
                    Ft.T = !0,
                    Ft.g = !1,
                    Ft.F = null;
                    break;
                case "SHAKE256":
                    Ut = 31,
                    Ft.S = Dt = 1088,
                    Ft.U = -1,
                    Ft.T = !0,
                    Ft.g = !1,
                    Ft.F = null;
                    break;
                case "KMAC128":
                    Ut = 4,
                    Ft.S = Dt = 1344,
                    Ft.M(Ar),
                    Ft.U = -1,
                    Ft.T = !0,
                    Ft.g = !1,
                    Ft.F = Ft.X;
                    break;
                case "KMAC256":
                    Ut = 4,
                    Ft.S = Dt = 1088,
                    Ft.M(Ar),
                    Ft.U = -1,
                    Ft.T = !0,
                    Ft.g = !1,
                    Ft.F = Ft.X;
                    break;
                case "CSHAKE128":
                    Ft.S = Dt = 1344,
                    Ut = Ft.O(Ar),
                    Ft.U = -1,
                    Ft.T = !0,
                    Ft.g = !1,
                    Ft.F = null;
                    break;
                case "CSHAKE256":
                    Ft.S = Dt = 1088,
                    Ut = Ft.O(Ar),
                    Ft.U = -1,
                    Ft.T = !0,
                    Ft.g = !1,
                    Ft.F = null;
                    break;
                default:
                    throw new Error(yt)
                }
                return Ft.K = function(br, Cr, xr, Lr, Ur) {
                    return function(Ir, Jr, Wr, Yr, Sn, pn, tn) {
                        var Bn, An, dn = 0, Rn = [], En = Sn >>> 5, an = Jr >>> 5;
                        for (Bn = 0; Bn < an && Jr >= Sn; Bn += En)
                            Yr = Zr(Ir.slice(Bn, Bn + En), Yr),
                            Jr -= Sn;
                        for (Ir = Ir.slice(Bn),
                        Jr %= Sn; Ir.length < En; )
                            Ir.push(0);
                        for (Ir[(Bn = Jr >>> 3) >> 2] ^= pn << Bn % 4 * 8,
                        Ir[En - 1] ^= 2147483648,
                        Yr = Zr(Ir, Yr); 32 * Rn.length < tn && (An = Yr[dn % 5][dn / 5 | 0],
                        Rn.push(An.I),
                        !(32 * Rn.length >= tn)); )
                            Rn.push(An.N),
                            64 * (dn += 1) % Sn == 0 && (Zr(null, Yr),
                            dn = 0);
                        return Rn
                    }(br, Cr, 0, Lr, Dt, Ut, Ur)
                }
                ,
                er.hmacKey && Ft.k(wt("hmacKey", er.hmacKey, Ft.C)),
                Ft
            }
            return Ct(ar, vr),
            ar.prototype.O = function(hr, _r) {
                var Ar = function(er) {
                    var br = er || {};
                    return {
                        funcName: wt("funcName", br.funcName, 1, {
                            value: [],
                            binLen: 0
                        }),
                        customization: wt("Customization", br.customization, 1, {
                            value: [],
                            binLen: 0
                        })
                    }
                }(hr || {});
                _r && (Ar.funcName = _r);
                var Ft = pt(un(Ar.funcName), un(Ar.customization));
                if (Ar.customization.binLen !== 0 || Ar.funcName.binLen !== 0) {
                    for (var Ut = Qr(Ft, this.S >>> 3), Dt = 0; Dt < Ut.length; Dt += this.S >>> 5)
                        this.m = this.R(Ut.slice(Dt, Dt + (this.S >>> 5)), this.m),
                        this.v += this.S;
                    return 4
                }
                return 31
            }
            ,
            ar.prototype.M = function(hr) {
                var _r = function(Ut) {
                    var Dt = Ut || {};
                    return {
                        kmacKey: wt("kmacKey", Dt.kmacKey, 1),
                        funcName: {
                            value: [1128353099],
                            binLen: 32
                        },
                        customization: wt("Customization", Dt.customization, 1, {
                            value: [],
                            binLen: 0
                        })
                    }
                }(hr || {});
                this.O(hr, _r.funcName);
                for (var Ar = Qr(un(_r.kmacKey), this.S >>> 3), Ft = 0; Ft < Ar.length; Ft += this.S >>> 5)
                    this.m = this.R(Ar.slice(Ft, Ft + (this.S >>> 5)), this.m),
                    this.v += this.S;
                this.A = !0
            }
            ,
            ar.prototype.X = function(hr) {
                var _r = pt({
                    value: this.u.slice(),
                    binLen: this.s
                }, function(Ar) {
                    var Ft, Ut, Dt = 0, er = [0, 0], br = [4294967295 & Ar, Ar / 4294967296 & 2097151];
                    for (Ft = 6; Ft >= 0; Ft--)
                        (Ut = br[Ft >> 2] >>> 8 * Ft & 255) == 0 && Dt === 0 || (er[Dt >> 2] |= Ut << 8 * Dt,
                        Dt += 1);
                    return er[(Dt = Dt !== 0 ? Dt : 1) >> 2] |= Dt << 8 * Dt,
                    {
                        value: Dt + 1 > 4 ? er : [er[0]],
                        binLen: 8 + 8 * Dt
                    }
                }(hr.outputLen));
                return this.K(_r.value, _r.binLen, this.v, this.B(this.m), hr.outputLen)
            }
            ,
            ar
        }(xt);
        return function() {
            function vr(ar, hr, _r) {
                if (ar == "SHA-1")
                    this.j = new vt(ar,hr,_r);
                else if (ar == "SHA-224" || ar == "SHA-256")
                    this.j = new Rt(ar,hr,_r);
                else if (ar == "SHA-384" || ar == "SHA-512")
                    this.j = new qr(ar,hr,_r);
                else {
                    if (ar != "SHA3-224" && ar != "SHA3-256" && ar != "SHA3-384" && ar != "SHA3-512" && ar != "SHAKE128" && ar != "SHAKE256" && ar != "CSHAKE128" && ar != "CSHAKE256" && ar != "KMAC128" && ar != "KMAC256")
                        throw new Error(yt);
                    this.j = new Gr(ar,hr,_r)
                }
            }
            return vr.prototype.update = function(ar) {
                this.j.update(ar)
            }
            ,
            vr.prototype.getHash = function(ar, hr) {
                return this.j.getHash(ar, hr)
            }
            ,
            vr.prototype.setHMACKey = function(ar, hr, _r) {
                this.j.setHMACKey(ar, hr, _r)
            }
            ,
            vr.prototype.getHMAC = function(ar, hr) {
                return this.j.getHMAC(ar, hr)
            }
            ,
            vr
        }()
    })
}
)(sha);
var shaExports = sha.exports
  , browser = {}
  , getSecureRandom$1 = {};
Object.defineProperty(getSecureRandom$1, "__esModule", {
    value: !0
});
getSecureRandom$1.getSecureRandomWords = getSecureRandom$1.getSecureRandomBytes = void 0;
function getSecureRandomBytes$1(r) {
    return Buffer.from(window.crypto.getRandomValues(new Uint8Array(r)))
}
getSecureRandom$1.getSecureRandomBytes = getSecureRandomBytes$1;
function getSecureRandomWords$1(r) {
    return window.crypto.getRandomValues(new Uint16Array(r))
}
getSecureRandom$1.getSecureRandomWords = getSecureRandomWords$1;
var hmac_sha512$3 = {};
Object.defineProperty(hmac_sha512$3, "__esModule", {
    value: !0
});
hmac_sha512$3.hmac_sha512 = void 0;
async function hmac_sha512$2(r, d) {
    let f = typeof r == "string" ? Buffer.from(r, "utf-8") : r
      , m = typeof d == "string" ? Buffer.from(d, "utf-8") : d;
    const k = {
        name: "HMAC",
        hash: "SHA-512"
    }
      , y = await window.crypto.subtle.importKey("raw", f, k, !1, ["sign"]);
    return Buffer.from(await crypto.subtle.sign(k, y, m))
}
hmac_sha512$3.hmac_sha512 = hmac_sha512$2;
var pbkdf2_sha512$3 = {};
Object.defineProperty(pbkdf2_sha512$3, "__esModule", {
    value: !0
});
pbkdf2_sha512$3.pbkdf2_sha512 = void 0;
async function pbkdf2_sha512$2(r, d, f, m) {
    const k = typeof r == "string" ? Buffer.from(r, "utf-8") : r
      , y = typeof d == "string" ? Buffer.from(d, "utf-8") : d
      , ee = await window.crypto.subtle.importKey("raw", k, {
        name: "PBKDF2"
    }, !1, ["deriveBits"])
      , dt = await window.crypto.subtle.deriveBits({
        name: "PBKDF2",
        hash: "SHA-512",
        salt: y,
        iterations: f
    }, ee, m * 8);
    return Buffer.from(dt)
}
pbkdf2_sha512$3.pbkdf2_sha512 = pbkdf2_sha512$2;
var sha256$2 = {};
Object.defineProperty(sha256$2, "__esModule", {
    value: !0
});
sha256$2.sha256 = void 0;
async function sha256$1(r) {
    return typeof r == "string" ? Buffer.from(await crypto.subtle.digest("SHA-256", Buffer.from(r, "utf-8"))) : Buffer.from(await crypto.subtle.digest("SHA-256", r))
}
sha256$2.sha256 = sha256$1;
var sha512$3 = {};
Object.defineProperty(sha512$3, "__esModule", {
    value: !0
});
sha512$3.sha512 = void 0;
async function sha512$2(r) {
    return typeof r == "string" ? Buffer.from(await crypto.subtle.digest("SHA-512", Buffer.from(r, "utf-8"))) : Buffer.from(await crypto.subtle.digest("SHA-512", r))
}
sha512$3.sha512 = sha512$2;
(function(r) {
    Object.defineProperty(r, "__esModule", {
        value: !0
    }),
    r.sha512 = r.sha256 = r.pbkdf2_sha512 = r.hmac_sha512 = r.getSecureRandomWords = r.getSecureRandomBytes = void 0;
    var d = getSecureRandom$1;
    Object.defineProperty(r, "getSecureRandomBytes", {
        enumerable: !0,
        get: function() {
            return d.getSecureRandomBytes
        }
    }),
    Object.defineProperty(r, "getSecureRandomWords", {
        enumerable: !0,
        get: function() {
            return d.getSecureRandomWords
        }
    });
    var f = hmac_sha512$3;
    Object.defineProperty(r, "hmac_sha512", {
        enumerable: !0,
        get: function() {
            return f.hmac_sha512
        }
    });
    var m = pbkdf2_sha512$3;
    Object.defineProperty(r, "pbkdf2_sha512", {
        enumerable: !0,
        get: function() {
            return m.pbkdf2_sha512
        }
    });
    var k = sha256$2;
    Object.defineProperty(r, "sha256", {
        enumerable: !0,
        get: function() {
            return k.sha256
        }
    });
    var y = sha512$3;
    Object.defineProperty(r, "sha512", {
        enumerable: !0,
        get: function() {
            return y.sha512
        }
    })
}
)(browser);
var __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(r) {
    return r && r.__esModule ? r : {
        default: r
    }
}
;
Object.defineProperty(sha256$3, "__esModule", {
    value: !0
});
sha256$3.sha256 = sha256$3.sha256_fallback = sha256$3.sha256_sync = void 0;
const jssha_1$2 = __importDefault$7(shaExports)
  , crypto_primitives_1$4 = browser;
function sha256_sync(r) {
    let d;
    typeof r == "string" ? d = Buffer.from(r, "utf-8").toString("hex") : d = r.toString("hex");
    let f = new jssha_1$2.default("SHA-256","HEX");
    f.update(d);
    let m = f.getHash("HEX");
    return Buffer.from(m, "hex")
}
sha256$3.sha256_sync = sha256_sync;
async function sha256_fallback(r) {
    return sha256_sync(r)
}
sha256$3.sha256_fallback = sha256_fallback;
function sha256(r) {
    return (0,
    crypto_primitives_1$4.sha256)(r)
}
sha256$3.sha256 = sha256;
var sha512$1 = {}
  , __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(r) {
    return r && r.__esModule ? r : {
        default: r
    }
}
;
Object.defineProperty(sha512$1, "__esModule", {
    value: !0
});
sha512$1.sha512 = sha512$1.sha512_fallback = sha512$1.sha512_sync = void 0;
const jssha_1$1 = __importDefault$6(shaExports)
  , crypto_primitives_1$3 = browser;
function sha512_sync(r) {
    let d;
    typeof r == "string" ? d = Buffer.from(r, "utf-8").toString("hex") : d = r.toString("hex");
    let f = new jssha_1$1.default("SHA-512","HEX");
    f.update(d);
    let m = f.getHash("HEX");
    return Buffer.from(m, "hex")
}
sha512$1.sha512_sync = sha512_sync;
async function sha512_fallback(r) {
    return sha512_sync(r)
}
sha512$1.sha512_fallback = sha512_fallback;
async function sha512(r) {
    return (0,
    crypto_primitives_1$3.sha512)(r)
}
sha512$1.sha512 = sha512;
var pbkdf2_sha512$1 = {};
Object.defineProperty(pbkdf2_sha512$1, "__esModule", {
    value: !0
});
pbkdf2_sha512$1.pbkdf2_sha512 = void 0;
const crypto_primitives_1$2 = browser;
function pbkdf2_sha512(r, d, f, m) {
    return (0,
    crypto_primitives_1$2.pbkdf2_sha512)(r, d, f, m)
}
pbkdf2_sha512$1.pbkdf2_sha512 = pbkdf2_sha512;
var hmac_sha512$1 = {}
  , __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(r) {
    return r && r.__esModule ? r : {
        default: r
    }
}
;
Object.defineProperty(hmac_sha512$1, "__esModule", {
    value: !0
});
hmac_sha512$1.hmac_sha512 = hmac_sha512$1.hmac_sha512_fallback = void 0;
const jssha_1 = __importDefault$5(shaExports)
  , crypto_primitives_1$1 = browser;
async function hmac_sha512_fallback(r, d) {
    let f = typeof r == "string" ? Buffer.from(r, "utf-8") : r
      , m = typeof d == "string" ? Buffer.from(d, "utf-8") : d;
    const k = new jssha_1.default("SHA-512","HEX",{
        hmacKey: {
            value: f.toString("hex"),
            format: "HEX"
        }
    });
    k.update(m.toString("hex"));
    const y = k.getHash("HEX");
    return Buffer.from(y, "hex")
}
hmac_sha512$1.hmac_sha512_fallback = hmac_sha512_fallback;
function hmac_sha512(r, d) {
    return (0,
    crypto_primitives_1$1.hmac_sha512)(r, d)
}
hmac_sha512$1.hmac_sha512 = hmac_sha512;
var getSecureRandom = {};
Object.defineProperty(getSecureRandom, "__esModule", {
    value: !0
});
getSecureRandom.getSecureRandomNumber = getSecureRandom.getSecureRandomWords = getSecureRandom.getSecureRandomBytes = void 0;
const crypto_primitives_1 = browser;
async function getSecureRandomBytes(r) {
    return (0,
    crypto_primitives_1.getSecureRandomBytes)(r)
}
getSecureRandom.getSecureRandomBytes = getSecureRandomBytes;
async function getSecureRandomWords(r) {
    return getSecureRandomWords()
}
getSecureRandom.getSecureRandomWords = getSecureRandomWords;
async function getSecureRandomNumber(r, d) {
    let f = d - r;
    var m = Math.ceil(Math.log2(f));
    if (m > 53)
        throw new Error("Range is too large");
    for (var k = Math.ceil(m / 8), y = Math.pow(2, m) - 1; ; ) {
        let dt = await getSecureRandomBytes(m)
          , mt = (k - 1) * 8
          , yt = 0;
        for (var ee = 0; ee < k; ee++)
            yt += dt[ee] * Math.pow(2, mt),
            mt -= 8;
        if (yt = yt & y,
        !(yt >= f))
            return r + yt
    }
}
getSecureRandom.getSecureRandomNumber = getSecureRandomNumber;
var newSecureWords$1 = {}
  , wordlist$1 = {};
Object.defineProperty(wordlist$1, "__esModule", {
    value: !0
});
wordlist$1.wordlist = void 0;
wordlist$1.wordlist = ["abacus", "abdomen", "abdominal", "abide", "abiding", "ability", "ablaze", "able", "abnormal", "abrasion", "abrasive", "abreast", "abridge", "abroad", "abruptly", "absence", "absentee", "absently", "absinthe", "absolute", "absolve", "abstain", "abstract", "absurd", "accent", "acclaim", "acclimate", "accompany", "account", "accuracy", "accurate", "accustom", "acetone", "achiness", "aching", "acid", "acorn", "acquaint", "acquire", "acre", "acrobat", "acronym", "acting", "action", "activate", "activator", "active", "activism", "activist", "activity", "actress", "acts", "acutely", "acuteness", "aeration", "aerobics", "aerosol", "aerospace", "afar", "affair", "affected", "affecting", "affection", "affidavit", "affiliate", "affirm", "affix", "afflicted", "affluent", "afford", "affront", "aflame", "afloat", "aflutter", "afoot", "afraid", "afterglow", "afterlife", "aftermath", "aftermost", "afternoon", "aged", "ageless", "agency", "agenda", "agent", "aggregate", "aghast", "agile", "agility", "aging", "agnostic", "agonize", "agonizing", "agony", "agreeable", "agreeably", "agreed", "agreeing", "agreement", "aground", "ahead", "ahoy", "aide", "aids", "aim", "ajar", "alabaster", "alarm", "albatross", "album", "alfalfa", "algebra", "algorithm", "alias", "alibi", "alienable", "alienate", "aliens", "alike", "alive", "alkaline", "alkalize", "almanac", "almighty", "almost", "aloe", "aloft", "aloha", "alone", "alongside", "aloof", "alphabet", "alright", "although", "altitude", "alto", "aluminum", "alumni", "always", "amaretto", "amaze", "amazingly", "amber", "ambiance", "ambiguity", "ambiguous", "ambition", "ambitious", "ambulance", "ambush", "amendable", "amendment", "amends", "amenity", "amiable", "amicably", "amid", "amigo", "amino", "amiss", "ammonia", "ammonium", "amnesty", "amniotic", "among", "amount", "amperage", "ample", "amplifier", "amplify", "amply", "amuck", "amulet", "amusable", "amused", "amusement", "amuser", "amusing", "anaconda", "anaerobic", "anagram", "anatomist", "anatomy", "anchor", "anchovy", "ancient", "android", "anemia", "anemic", "aneurism", "anew", "angelfish", "angelic", "anger", "angled", "angler", "angles", "angling", "angrily", "angriness", "anguished", "angular", "animal", "animate", "animating", "animation", "animator", "anime", "animosity", "ankle", "annex", "annotate", "announcer", "annoying", "annually", "annuity", "anointer", "another", "answering", "antacid", "antarctic", "anteater", "antelope", "antennae", "anthem", "anthill", "anthology", "antibody", "antics", "antidote", "antihero", "antiquely", "antiques", "antiquity", "antirust", "antitoxic", "antitrust", "antiviral", "antivirus", "antler", "antonym", "antsy", "anvil", "anybody", "anyhow", "anymore", "anyone", "anyplace", "anything", "anytime", "anyway", "anywhere", "aorta", "apache", "apostle", "appealing", "appear", "appease", "appeasing", "appendage", "appendix", "appetite", "appetizer", "applaud", "applause", "apple", "appliance", "applicant", "applied", "apply", "appointee", "appraisal", "appraiser", "apprehend", "approach", "approval", "approve", "apricot", "april", "apron", "aptitude", "aptly", "aqua", "aqueduct", "arbitrary", "arbitrate", "ardently", "area", "arena", "arguable", "arguably", "argue", "arise", "armadillo", "armband", "armchair", "armed", "armful", "armhole", "arming", "armless", "armoire", "armored", "armory", "armrest", "army", "aroma", "arose", "around", "arousal", "arrange", "array", "arrest", "arrival", "arrive", "arrogance", "arrogant", "arson", "art", "ascend", "ascension", "ascent", "ascertain", "ashamed", "ashen", "ashes", "ashy", "aside", "askew", "asleep", "asparagus", "aspect", "aspirate", "aspire", "aspirin", "astonish", "astound", "astride", "astrology", "astronaut", "astronomy", "astute", "atlantic", "atlas", "atom", "atonable", "atop", "atrium", "atrocious", "atrophy", "attach", "attain", "attempt", "attendant", "attendee", "attention", "attentive", "attest", "attic", "attire", "attitude", "attractor", "attribute", "atypical", "auction", "audacious", "audacity", "audible", "audibly", "audience", "audio", "audition", "augmented", "august", "authentic", "author", "autism", "autistic", "autograph", "automaker", "automated", "automatic", "autopilot", "available", "avalanche", "avatar", "avenge", "avenging", "avenue", "average", "aversion", "avert", "aviation", "aviator", "avid", "avoid", "await", "awaken", "award", "aware", "awhile", "awkward", "awning", "awoke", "awry", "axis", "babble", "babbling", "babied", "baboon", "backache", "backboard", "backboned", "backdrop", "backed", "backer", "backfield", "backfire", "backhand", "backing", "backlands", "backlash", "backless", "backlight", "backlit", "backlog", "backpack", "backpedal", "backrest", "backroom", "backshift", "backside", "backslid", "backspace", "backspin", "backstab", "backstage", "backtalk", "backtrack", "backup", "backward", "backwash", "backwater", "backyard", "bacon", "bacteria", "bacterium", "badass", "badge", "badland", "badly", "badness", "baffle", "baffling", "bagel", "bagful", "baggage", "bagged", "baggie", "bagginess", "bagging", "baggy", "bagpipe", "baguette", "baked", "bakery", "bakeshop", "baking", "balance", "balancing", "balcony", "balmy", "balsamic", "bamboo", "banana", "banish", "banister", "banjo", "bankable", "bankbook", "banked", "banker", "banking", "banknote", "bankroll", "banner", "bannister", "banshee", "banter", "barbecue", "barbed", "barbell", "barber", "barcode", "barge", "bargraph", "barista", "baritone", "barley", "barmaid", "barman", "barn", "barometer", "barrack", "barracuda", "barrel", "barrette", "barricade", "barrier", "barstool", "bartender", "barterer", "bash", "basically", "basics", "basil", "basin", "basis", "basket", "batboy", "batch", "bath", "baton", "bats", "battalion", "battered", "battering", "battery", "batting", "battle", "bauble", "bazooka", "blabber", "bladder", "blade", "blah", "blame", "blaming", "blanching", "blandness", "blank", "blaspheme", "blasphemy", "blast", "blatancy", "blatantly", "blazer", "blazing", "bleach", "bleak", "bleep", "blemish", "blend", "bless", "blighted", "blimp", "bling", "blinked", "blinker", "blinking", "blinks", "blip", "blissful", "blitz", "blizzard", "bloated", "bloating", "blob", "blog", "bloomers", "blooming", "blooper", "blot", "blouse", "blubber", "bluff", "bluish", "blunderer", "blunt", "blurb", "blurred", "blurry", "blurt", "blush", "blustery", "boaster", "boastful", "boasting", "boat", "bobbed", "bobbing", "bobble", "bobcat", "bobsled", "bobtail", "bodacious", "body", "bogged", "boggle", "bogus", "boil", "bok", "bolster", "bolt", "bonanza", "bonded", "bonding", "bondless", "boned", "bonehead", "boneless", "bonelike", "boney", "bonfire", "bonnet", "bonsai", "bonus", "bony", "boogeyman", "boogieman", "book", "boondocks", "booted", "booth", "bootie", "booting", "bootlace", "bootleg", "boots", "boozy", "borax", "boring", "borough", "borrower", "borrowing", "boss", "botanical", "botanist", "botany", "botch", "both", "bottle", "bottling", "bottom", "bounce", "bouncing", "bouncy", "bounding", "boundless", "bountiful", "bovine", "boxcar", "boxer", "boxing", "boxlike", "boxy", "breach", "breath", "breeches", "breeching", "breeder", "breeding", "breeze", "breezy", "brethren", "brewery", "brewing", "briar", "bribe", "brick", "bride", "bridged", "brigade", "bright", "brilliant", "brim", "bring", "brink", "brisket", "briskly", "briskness", "bristle", "brittle", "broadband", "broadcast", "broaden", "broadly", "broadness", "broadside", "broadways", "broiler", "broiling", "broken", "broker", "bronchial", "bronco", "bronze", "bronzing", "brook", "broom", "brought", "browbeat", "brownnose", "browse", "browsing", "bruising", "brunch", "brunette", "brunt", "brush", "brussels", "brute", "brutishly", "bubble", "bubbling", "bubbly", "buccaneer", "bucked", "bucket", "buckle", "buckshot", "buckskin", "bucktooth", "buckwheat", "buddhism", "buddhist", "budding", "buddy", "budget", "buffalo", "buffed", "buffer", "buffing", "buffoon", "buggy", "bulb", "bulge", "bulginess", "bulgur", "bulk", "bulldog", "bulldozer", "bullfight", "bullfrog", "bullhorn", "bullion", "bullish", "bullpen", "bullring", "bullseye", "bullwhip", "bully", "bunch", "bundle", "bungee", "bunion", "bunkbed", "bunkhouse", "bunkmate", "bunny", "bunt", "busboy", "bush", "busily", "busload", "bust", "busybody", "buzz", "cabana", "cabbage", "cabbie", "cabdriver", "cable", "caboose", "cache", "cackle", "cacti", "cactus", "caddie", "caddy", "cadet", "cadillac", "cadmium", "cage", "cahoots", "cake", "calamari", "calamity", "calcium", "calculate", "calculus", "caliber", "calibrate", "calm", "caloric", "calorie", "calzone", "camcorder", "cameo", "camera", "camisole", "camper", "campfire", "camping", "campsite", "campus", "canal", "canary", "cancel", "candied", "candle", "candy", "cane", "canine", "canister", "cannabis", "canned", "canning", "cannon", "cannot", "canola", "canon", "canopener", "canopy", "canteen", "canyon", "capable", "capably", "capacity", "cape", "capillary", "capital", "capitol", "capped", "capricorn", "capsize", "capsule", "caption", "captivate", "captive", "captivity", "capture", "caramel", "carat", "caravan", "carbon", "cardboard", "carded", "cardiac", "cardigan", "cardinal", "cardstock", "carefully", "caregiver", "careless", "caress", "caretaker", "cargo", "caring", "carless", "carload", "carmaker", "carnage", "carnation", "carnival", "carnivore", "carol", "carpenter", "carpentry", "carpool", "carport", "carried", "carrot", "carrousel", "carry", "cartel", "cartload", "carton", "cartoon", "cartridge", "cartwheel", "carve", "carving", "carwash", "cascade", "case", "cash", "casing", "casino", "casket", "cassette", "casually", "casualty", "catacomb", "catalog", "catalyst", "catalyze", "catapult", "cataract", "catatonic", "catcall", "catchable", "catcher", "catching", "catchy", "caterer", "catering", "catfight", "catfish", "cathedral", "cathouse", "catlike", "catnap", "catnip", "catsup", "cattail", "cattishly", "cattle", "catty", "catwalk", "caucasian", "caucus", "causal", "causation", "cause", "causing", "cauterize", "caution", "cautious", "cavalier", "cavalry", "caviar", "cavity", "cedar", "celery", "celestial", "celibacy", "celibate", "celtic", "cement", "census", "ceramics", "ceremony", "certainly", "certainty", "certified", "certify", "cesarean", "cesspool", "chafe", "chaffing", "chain", "chair", "chalice", "challenge", "chamber", "chamomile", "champion", "chance", "change", "channel", "chant", "chaos", "chaperone", "chaplain", "chapped", "chaps", "chapter", "character", "charbroil", "charcoal", "charger", "charging", "chariot", "charity", "charm", "charred", "charter", "charting", "chase", "chasing", "chaste", "chastise", "chastity", "chatroom", "chatter", "chatting", "chatty", "cheating", "cheddar", "cheek", "cheer", "cheese", "cheesy", "chef", "chemicals", "chemist", "chemo", "cherisher", "cherub", "chess", "chest", "chevron", "chevy", "chewable", "chewer", "chewing", "chewy", "chief", "chihuahua", "childcare", "childhood", "childish", "childless", "childlike", "chili", "chill", "chimp", "chip", "chirping", "chirpy", "chitchat", "chivalry", "chive", "chloride", "chlorine", "choice", "chokehold", "choking", "chomp", "chooser", "choosing", "choosy", "chop", "chosen", "chowder", "chowtime", "chrome", "chubby", "chuck", "chug", "chummy", "chump", "chunk", "churn", "chute", "cider", "cilantro", "cinch", "cinema", "cinnamon", "circle", "circling", "circular", "circulate", "circus", "citable", "citadel", "citation", "citizen", "citric", "citrus", "city", "civic", "civil", "clad", "claim", "clambake", "clammy", "clamor", "clamp", "clamshell", "clang", "clanking", "clapped", "clapper", "clapping", "clarify", "clarinet", "clarity", "clash", "clasp", "class", "clatter", "clause", "clavicle", "claw", "clay", "clean", "clear", "cleat", "cleaver", "cleft", "clench", "clergyman", "clerical", "clerk", "clever", "clicker", "client", "climate", "climatic", "cling", "clinic", "clinking", "clip", "clique", "cloak", "clobber", "clock", "clone", "cloning", "closable", "closure", "clothes", "clothing", "cloud", "clover", "clubbed", "clubbing", "clubhouse", "clump", "clumsily", "clumsy", "clunky", "clustered", "clutch", "clutter", "coach", "coagulant", "coastal", "coaster", "coasting", "coastland", "coastline", "coat", "coauthor", "cobalt", "cobbler", "cobweb", "cocoa", "coconut", "cod", "coeditor", "coerce", "coexist", "coffee", "cofounder", "cognition", "cognitive", "cogwheel", "coherence", "coherent", "cohesive", "coil", "coke", "cola", "cold", "coleslaw", "coliseum", "collage", "collapse", "collar", "collected", "collector", "collide", "collie", "collision", "colonial", "colonist", "colonize", "colony", "colossal", "colt", "coma", "come", "comfort", "comfy", "comic", "coming", "comma", "commence", "commend", "comment", "commerce", "commode", "commodity", "commodore", "common", "commotion", "commute", "commuting", "compacted", "compacter", "compactly", "compactor", "companion", "company", "compare", "compel", "compile", "comply", "component", "composed", "composer", "composite", "compost", "composure", "compound", "compress", "comprised", "computer", "computing", "comrade", "concave", "conceal", "conceded", "concept", "concerned", "concert", "conch", "concierge", "concise", "conclude", "concrete", "concur", "condense", "condiment", "condition", "condone", "conducive", "conductor", "conduit", "cone", "confess", "confetti", "confidant", "confident", "confider", "confiding", "configure", "confined", "confining", "confirm", "conflict", "conform", "confound", "confront", "confused", "confusing", "confusion", "congenial", "congested", "congrats", "congress", "conical", "conjoined", "conjure", "conjuror", "connected", "connector", "consensus", "consent", "console", "consoling", "consonant", "constable", "constant", "constrain", "constrict", "construct", "consult", "consumer", "consuming", "contact", "container", "contempt", "contend", "contented", "contently", "contents", "contest", "context", "contort", "contour", "contrite", "control", "contusion", "convene", "convent", "copartner", "cope", "copied", "copier", "copilot", "coping", "copious", "copper", "copy", "coral", "cork", "cornball", "cornbread", "corncob", "cornea", "corned", "corner", "cornfield", "cornflake", "cornhusk", "cornmeal", "cornstalk", "corny", "coronary", "coroner", "corporal", "corporate", "corral", "correct", "corridor", "corrode", "corroding", "corrosive", "corsage", "corset", "cortex", "cosigner", "cosmetics", "cosmic", "cosmos", "cosponsor", "cost", "cottage", "cotton", "couch", "cough", "could", "countable", "countdown", "counting", "countless", "country", "county", "courier", "covenant", "cover", "coveted", "coveting", "coyness", "cozily", "coziness", "cozy", "crabbing", "crabgrass", "crablike", "crabmeat", "cradle", "cradling", "crafter", "craftily", "craftsman", "craftwork", "crafty", "cramp", "cranberry", "crane", "cranial", "cranium", "crank", "crate", "crave", "craving", "crawfish", "crawlers", "crawling", "crayfish", "crayon", "crazed", "crazily", "craziness", "crazy", "creamed", "creamer", "creamlike", "crease", "creasing", "creatable", "create", "creation", "creative", "creature", "credible", "credibly", "credit", "creed", "creme", "creole", "crepe", "crept", "crescent", "crested", "cresting", "crestless", "crevice", "crewless", "crewman", "crewmate", "crib", "cricket", "cried", "crier", "crimp", "crimson", "cringe", "cringing", "crinkle", "crinkly", "crisped", "crisping", "crisply", "crispness", "crispy", "criteria", "critter", "croak", "crock", "crook", "croon", "crop", "cross", "crouch", "crouton", "crowbar", "crowd", "crown", "crucial", "crudely", "crudeness", "cruelly", "cruelness", "cruelty", "crumb", "crummiest", "crummy", "crumpet", "crumpled", "cruncher", "crunching", "crunchy", "crusader", "crushable", "crushed", "crusher", "crushing", "crust", "crux", "crying", "cryptic", "crystal", "cubbyhole", "cube", "cubical", "cubicle", "cucumber", "cuddle", "cuddly", "cufflink", "culinary", "culminate", "culpable", "culprit", "cultivate", "cultural", "culture", "cupbearer", "cupcake", "cupid", "cupped", "cupping", "curable", "curator", "curdle", "cure", "curfew", "curing", "curled", "curler", "curliness", "curling", "curly", "curry", "curse", "cursive", "cursor", "curtain", "curtly", "curtsy", "curvature", "curve", "curvy", "cushy", "cusp", "cussed", "custard", "custodian", "custody", "customary", "customer", "customize", "customs", "cut", "cycle", "cyclic", "cycling", "cyclist", "cylinder", "cymbal", "cytoplasm", "cytoplast", "dab", "dad", "daffodil", "dagger", "daily", "daintily", "dainty", "dairy", "daisy", "dallying", "dance", "dancing", "dandelion", "dander", "dandruff", "dandy", "danger", "dangle", "dangling", "daredevil", "dares", "daringly", "darkened", "darkening", "darkish", "darkness", "darkroom", "darling", "darn", "dart", "darwinism", "dash", "dastardly", "data", "datebook", "dating", "daughter", "daunting", "dawdler", "dawn", "daybed", "daybreak", "daycare", "daydream", "daylight", "daylong", "dayroom", "daytime", "dazzler", "dazzling", "deacon", "deafening", "deafness", "dealer", "dealing", "dealmaker", "dealt", "dean", "debatable", "debate", "debating", "debit", "debrief", "debtless", "debtor", "debug", "debunk", "decade", "decaf", "decal", "decathlon", "decay", "deceased", "deceit", "deceiver", "deceiving", "december", "decency", "decent", "deception", "deceptive", "decibel", "decidable", "decimal", "decimeter", "decipher", "deck", "declared", "decline", "decode", "decompose", "decorated", "decorator", "decoy", "decrease", "decree", "dedicate", "dedicator", "deduce", "deduct", "deed", "deem", "deepen", "deeply", "deepness", "deface", "defacing", "defame", "default", "defeat", "defection", "defective", "defendant", "defender", "defense", "defensive", "deferral", "deferred", "defiance", "defiant", "defile", "defiling", "define", "definite", "deflate", "deflation", "deflator", "deflected", "deflector", "defog", "deforest", "defraud", "defrost", "deftly", "defuse", "defy", "degraded", "degrading", "degrease", "degree", "dehydrate", "deity", "dejected", "delay", "delegate", "delegator", "delete", "deletion", "delicacy", "delicate", "delicious", "delighted", "delirious", "delirium", "deliverer", "delivery", "delouse", "delta", "deluge", "delusion", "deluxe", "demanding", "demeaning", "demeanor", "demise", "democracy", "democrat", "demote", "demotion", "demystify", "denatured", "deniable", "denial", "denim", "denote", "dense", "density", "dental", "dentist", "denture", "deny", "deodorant", "deodorize", "departed", "departure", "depict", "deplete", "depletion", "deplored", "deploy", "deport", "depose", "depraved", "depravity", "deprecate", "depress", "deprive", "depth", "deputize", "deputy", "derail", "deranged", "derby", "derived", "desecrate", "deserve", "deserving", "designate", "designed", "designer", "designing", "deskbound", "desktop", "deskwork", "desolate", "despair", "despise", "despite", "destiny", "destitute", "destruct", "detached", "detail", "detection", "detective", "detector", "detention", "detergent", "detest", "detonate", "detonator", "detoxify", "detract", "deuce", "devalue", "deviancy", "deviant", "deviate", "deviation", "deviator", "device", "devious", "devotedly", "devotee", "devotion", "devourer", "devouring", "devoutly", "dexterity", "dexterous", "diabetes", "diabetic", "diabolic", "diagnoses", "diagnosis", "diagram", "dial", "diameter", "diaper", "diaphragm", "diary", "dice", "dicing", "dictate", "dictation", "dictator", "difficult", "diffused", "diffuser", "diffusion", "diffusive", "dig", "dilation", "diligence", "diligent", "dill", "dilute", "dime", "diminish", "dimly", "dimmed", "dimmer", "dimness", "dimple", "diner", "dingbat", "dinghy", "dinginess", "dingo", "dingy", "dining", "dinner", "diocese", "dioxide", "diploma", "dipped", "dipper", "dipping", "directed", "direction", "directive", "directly", "directory", "direness", "dirtiness", "disabled", "disagree", "disallow", "disarm", "disarray", "disaster", "disband", "disbelief", "disburse", "discard", "discern", "discharge", "disclose", "discolor", "discount", "discourse", "discover", "discuss", "disdain", "disengage", "disfigure", "disgrace", "dish", "disinfect", "disjoin", "disk", "dislike", "disliking", "dislocate", "dislodge", "disloyal", "dismantle", "dismay", "dismiss", "dismount", "disobey", "disorder", "disown", "disparate", "disparity", "dispatch", "dispense", "dispersal", "dispersed", "disperser", "displace", "display", "displease", "disposal", "dispose", "disprove", "dispute", "disregard", "disrupt", "dissuade", "distance", "distant", "distaste", "distill", "distinct", "distort", "distract", "distress", "district", "distrust", "ditch", "ditto", "ditzy", "dividable", "divided", "dividend", "dividers", "dividing", "divinely", "diving", "divinity", "divisible", "divisibly", "division", "divisive", "divorcee", "dizziness", "dizzy", "doable", "docile", "dock", "doctrine", "document", "dodge", "dodgy", "doily", "doing", "dole", "dollar", "dollhouse", "dollop", "dolly", "dolphin", "domain", "domelike", "domestic", "dominion", "dominoes", "donated", "donation", "donator", "donor", "donut", "doodle", "doorbell", "doorframe", "doorknob", "doorman", "doormat", "doornail", "doorpost", "doorstep", "doorstop", "doorway", "doozy", "dork", "dormitory", "dorsal", "dosage", "dose", "dotted", "doubling", "douche", "dove", "down", "dowry", "doze", "drab", "dragging", "dragonfly", "dragonish", "dragster", "drainable", "drainage", "drained", "drainer", "drainpipe", "dramatic", "dramatize", "drank", "drapery", "drastic", "draw", "dreaded", "dreadful", "dreadlock", "dreamboat", "dreamily", "dreamland", "dreamless", "dreamlike", "dreamt", "dreamy", "drearily", "dreary", "drench", "dress", "drew", "dribble", "dried", "drier", "drift", "driller", "drilling", "drinkable", "drinking", "dripping", "drippy", "drivable", "driven", "driver", "driveway", "driving", "drizzle", "drizzly", "drone", "drool", "droop", "drop-down", "dropbox", "dropkick", "droplet", "dropout", "dropper", "drove", "drown", "drowsily", "drudge", "drum", "dry", "dubbed", "dubiously", "duchess", "duckbill", "ducking", "duckling", "ducktail", "ducky", "duct", "dude", "duffel", "dugout", "duh", "duke", "duller", "dullness", "duly", "dumping", "dumpling", "dumpster", "duo", "dupe", "duplex", "duplicate", "duplicity", "durable", "durably", "duration", "duress", "during", "dusk", "dust", "dutiful", "duty", "duvet", "dwarf", "dweeb", "dwelled", "dweller", "dwelling", "dwindle", "dwindling", "dynamic", "dynamite", "dynasty", "dyslexia", "dyslexic", "each", "eagle", "earache", "eardrum", "earflap", "earful", "earlobe", "early", "earmark", "earmuff", "earphone", "earpiece", "earplugs", "earring", "earshot", "earthen", "earthlike", "earthling", "earthly", "earthworm", "earthy", "earwig", "easeful", "easel", "easiest", "easily", "easiness", "easing", "eastbound", "eastcoast", "easter", "eastward", "eatable", "eaten", "eatery", "eating", "eats", "ebay", "ebony", "ebook", "ecard", "eccentric", "echo", "eclair", "eclipse", "ecologist", "ecology", "economic", "economist", "economy", "ecosphere", "ecosystem", "edge", "edginess", "edging", "edgy", "edition", "editor", "educated", "education", "educator", "eel", "effective", "effects", "efficient", "effort", "eggbeater", "egging", "eggnog", "eggplant", "eggshell", "egomaniac", "egotism", "egotistic", "either", "eject", "elaborate", "elastic", "elated", "elbow", "eldercare", "elderly", "eldest", "electable", "election", "elective", "elephant", "elevate", "elevating", "elevation", "elevator", "eleven", "elf", "eligible", "eligibly", "eliminate", "elite", "elitism", "elixir", "elk", "ellipse", "elliptic", "elm", "elongated", "elope", "eloquence", "eloquent", "elsewhere", "elude", "elusive", "elves", "email", "embargo", "embark", "embassy", "embattled", "embellish", "ember", "embezzle", "emblaze", "emblem", "embody", "embolism", "emboss", "embroider", "emcee", "emerald", "emergency", "emission", "emit", "emote", "emoticon", "emotion", "empathic", "empathy", "emperor", "emphases", "emphasis", "emphasize", "emphatic", "empirical", "employed", "employee", "employer", "emporium", "empower", "emptier", "emptiness", "empty", "emu", "enable", "enactment", "enamel", "enchanted", "enchilada", "encircle", "enclose", "enclosure", "encode", "encore", "encounter", "encourage", "encroach", "encrust", "encrypt", "endanger", "endeared", "endearing", "ended", "ending", "endless", "endnote", "endocrine", "endorphin", "endorse", "endowment", "endpoint", "endurable", "endurance", "enduring", "energetic", "energize", "energy", "enforced", "enforcer", "engaged", "engaging", "engine", "engorge", "engraved", "engraver", "engraving", "engross", "engulf", "enhance", "enigmatic", "enjoyable", "enjoyably", "enjoyer", "enjoying", "enjoyment", "enlarged", "enlarging", "enlighten", "enlisted", "enquirer", "enrage", "enrich", "enroll", "enslave", "ensnare", "ensure", "entail", "entangled", "entering", "entertain", "enticing", "entire", "entitle", "entity", "entomb", "entourage", "entrap", "entree", "entrench", "entrust", "entryway", "entwine", "enunciate", "envelope", "enviable", "enviably", "envious", "envision", "envoy", "envy", "enzyme", "epic", "epidemic", "epidermal", "epidermis", "epidural", "epilepsy", "epileptic", "epilogue", "epiphany", "episode", "equal", "equate", "equation", "equator", "equinox", "equipment", "equity", "equivocal", "eradicate", "erasable", "erased", "eraser", "erasure", "ergonomic", "errand", "errant", "erratic", "error", "erupt", "escalate", "escalator", "escapable", "escapade", "escapist", "escargot", "eskimo", "esophagus", "espionage", "espresso", "esquire", "essay", "essence", "essential", "establish", "estate", "esteemed", "estimate", "estimator", "estranged", "estrogen", "etching", "eternal", "eternity", "ethanol", "ether", "ethically", "ethics", "euphemism", "evacuate", "evacuee", "evade", "evaluate", "evaluator", "evaporate", "evasion", "evasive", "even", "everglade", "evergreen", "everybody", "everyday", "everyone", "evict", "evidence", "evident", "evil", "evoke", "evolution", "evolve", "exact", "exalted", "example", "excavate", "excavator", "exceeding", "exception", "excess", "exchange", "excitable", "exciting", "exclaim", "exclude", "excluding", "exclusion", "exclusive", "excretion", "excretory", "excursion", "excusable", "excusably", "excuse", "exemplary", "exemplify", "exemption", "exerciser", "exert", "exes", "exfoliate", "exhale", "exhaust", "exhume", "exile", "existing", "exit", "exodus", "exonerate", "exorcism", "exorcist", "expand", "expanse", "expansion", "expansive", "expectant", "expedited", "expediter", "expel", "expend", "expenses", "expensive", "expert", "expire", "expiring", "explain", "expletive", "explicit", "explode", "exploit", "explore", "exploring", "exponent", "exporter", "exposable", "expose", "exposure", "express", "expulsion", "exquisite", "extended", "extending", "extent", "extenuate", "exterior", "external", "extinct", "extortion", "extradite", "extras", "extrovert", "extrude", "extruding", "exuberant", "fable", "fabric", "fabulous", "facebook", "facecloth", "facedown", "faceless", "facelift", "faceplate", "faceted", "facial", "facility", "facing", "facsimile", "faction", "factoid", "factor", "factsheet", "factual", "faculty", "fade", "fading", "failing", "falcon", "fall", "false", "falsify", "fame", "familiar", "family", "famine", "famished", "fanatic", "fancied", "fanciness", "fancy", "fanfare", "fang", "fanning", "fantasize", "fantastic", "fantasy", "fascism", "fastball", "faster", "fasting", "fastness", "faucet", "favorable", "favorably", "favored", "favoring", "favorite", "fax", "feast", "federal", "fedora", "feeble", "feed", "feel", "feisty", "feline", "felt-tip", "feminine", "feminism", "feminist", "feminize", "femur", "fence", "fencing", "fender", "ferment", "fernlike", "ferocious", "ferocity", "ferret", "ferris", "ferry", "fervor", "fester", "festival", "festive", "festivity", "fetal", "fetch", "fever", "fiber", "fiction", "fiddle", "fiddling", "fidelity", "fidgeting", "fidgety", "fifteen", "fifth", "fiftieth", "fifty", "figment", "figure", "figurine", "filing", "filled", "filler", "filling", "film", "filter", "filth", "filtrate", "finale", "finalist", "finalize", "finally", "finance", "financial", "finch", "fineness", "finer", "finicky", "finished", "finisher", "finishing", "finite", "finless", "finlike", "fiscally", "fit", "five", "flaccid", "flagman", "flagpole", "flagship", "flagstick", "flagstone", "flail", "flakily", "flaky", "flame", "flammable", "flanked", "flanking", "flannels", "flap", "flaring", "flashback", "flashbulb", "flashcard", "flashily", "flashing", "flashy", "flask", "flatbed", "flatfoot", "flatly", "flatness", "flatten", "flattered", "flatterer", "flattery", "flattop", "flatware", "flatworm", "flavored", "flavorful", "flavoring", "flaxseed", "fled", "fleshed", "fleshy", "flick", "flier", "flight", "flinch", "fling", "flint", "flip", "flirt", "float", "flock", "flogging", "flop", "floral", "florist", "floss", "flounder", "flyable", "flyaway", "flyer", "flying", "flyover", "flypaper", "foam", "foe", "fog", "foil", "folic", "folk", "follicle", "follow", "fondling", "fondly", "fondness", "fondue", "font", "food", "fool", "footage", "football", "footbath", "footboard", "footer", "footgear", "foothill", "foothold", "footing", "footless", "footman", "footnote", "footpad", "footpath", "footprint", "footrest", "footsie", "footsore", "footwear", "footwork", "fossil", "foster", "founder", "founding", "fountain", "fox", "foyer", "fraction", "fracture", "fragile", "fragility", "fragment", "fragrance", "fragrant", "frail", "frame", "framing", "frantic", "fraternal", "frayed", "fraying", "frays", "freckled", "freckles", "freebase", "freebee", "freebie", "freedom", "freefall", "freehand", "freeing", "freeload", "freely", "freemason", "freeness", "freestyle", "freeware", "freeway", "freewill", "freezable", "freezing", "freight", "french", "frenzied", "frenzy", "frequency", "frequent", "fresh", "fretful", "fretted", "friction", "friday", "fridge", "fried", "friend", "frighten", "frightful", "frigidity", "frigidly", "frill", "fringe", "frisbee", "frisk", "fritter", "frivolous", "frolic", "from", "front", "frostbite", "frosted", "frostily", "frosting", "frostlike", "frosty", "froth", "frown", "frozen", "fructose", "frugality", "frugally", "fruit", "frustrate", "frying", "gab", "gaffe", "gag", "gainfully", "gaining", "gains", "gala", "gallantly", "galleria", "gallery", "galley", "gallon", "gallows", "gallstone", "galore", "galvanize", "gambling", "game", "gaming", "gamma", "gander", "gangly", "gangrene", "gangway", "gap", "garage", "garbage", "garden", "gargle", "garland", "garlic", "garment", "garnet", "garnish", "garter", "gas", "gatherer", "gathering", "gating", "gauging", "gauntlet", "gauze", "gave", "gawk", "gazing", "gear", "gecko", "geek", "geiger", "gem", "gender", "generic", "generous", "genetics", "genre", "gentile", "gentleman", "gently", "gents", "geography", "geologic", "geologist", "geology", "geometric", "geometry", "geranium", "gerbil", "geriatric", "germicide", "germinate", "germless", "germproof", "gestate", "gestation", "gesture", "getaway", "getting", "getup", "giant", "gibberish", "giblet", "giddily", "giddiness", "giddy", "gift", "gigabyte", "gigahertz", "gigantic", "giggle", "giggling", "giggly", "gigolo", "gilled", "gills", "gimmick", "girdle", "giveaway", "given", "giver", "giving", "gizmo", "gizzard", "glacial", "glacier", "glade", "gladiator", "gladly", "glamorous", "glamour", "glance", "glancing", "glandular", "glare", "glaring", "glass", "glaucoma", "glazing", "gleaming", "gleeful", "glider", "gliding", "glimmer", "glimpse", "glisten", "glitch", "glitter", "glitzy", "gloater", "gloating", "gloomily", "gloomy", "glorified", "glorifier", "glorify", "glorious", "glory", "gloss", "glove", "glowing", "glowworm", "glucose", "glue", "gluten", "glutinous", "glutton", "gnarly", "gnat", "goal", "goatskin", "goes", "goggles", "going", "goldfish", "goldmine", "goldsmith", "golf", "goliath", "gonad", "gondola", "gone", "gong", "good", "gooey", "goofball", "goofiness", "goofy", "google", "goon", "gopher", "gore", "gorged", "gorgeous", "gory", "gosling", "gossip", "gothic", "gotten", "gout", "gown", "grab", "graceful", "graceless", "gracious", "gradation", "graded", "grader", "gradient", "grading", "gradually", "graduate", "graffiti", "grafted", "grafting", "grain", "granddad", "grandkid", "grandly", "grandma", "grandpa", "grandson", "granite", "granny", "granola", "grant", "granular", "grape", "graph", "grapple", "grappling", "grasp", "grass", "gratified", "gratify", "grating", "gratitude", "gratuity", "gravel", "graveness", "graves", "graveyard", "gravitate", "gravity", "gravy", "gray", "grazing", "greasily", "greedily", "greedless", "greedy", "green", "greeter", "greeting", "grew", "greyhound", "grid", "grief", "grievance", "grieving", "grievous", "grill", "grimace", "grimacing", "grime", "griminess", "grimy", "grinch", "grinning", "grip", "gristle", "grit", "groggily", "groggy", "groin", "groom", "groove", "grooving", "groovy", "grope", "ground", "grouped", "grout", "grove", "grower", "growing", "growl", "grub", "grudge", "grudging", "grueling", "gruffly", "grumble", "grumbling", "grumbly", "grumpily", "grunge", "grunt", "guacamole", "guidable", "guidance", "guide", "guiding", "guileless", "guise", "gulf", "gullible", "gully", "gulp", "gumball", "gumdrop", "gumminess", "gumming", "gummy", "gurgle", "gurgling", "guru", "gush", "gusto", "gusty", "gutless", "guts", "gutter", "guy", "guzzler", "gyration", "habitable", "habitant", "habitat", "habitual", "hacked", "hacker", "hacking", "hacksaw", "had", "haggler", "haiku", "half", "halogen", "halt", "halved", "halves", "hamburger", "hamlet", "hammock", "hamper", "hamster", "hamstring", "handbag", "handball", "handbook", "handbrake", "handcart", "handclap", "handclasp", "handcraft", "handcuff", "handed", "handful", "handgrip", "handgun", "handheld", "handiness", "handiwork", "handlebar", "handled", "handler", "handling", "handmade", "handoff", "handpick", "handprint", "handrail", "handsaw", "handset", "handsfree", "handshake", "handstand", "handwash", "handwork", "handwoven", "handwrite", "handyman", "hangnail", "hangout", "hangover", "hangup", "hankering", "hankie", "hanky", "haphazard", "happening", "happier", "happiest", "happily", "happiness", "happy", "harbor", "hardcopy", "hardcore", "hardcover", "harddisk", "hardened", "hardener", "hardening", "hardhat", "hardhead", "hardiness", "hardly", "hardness", "hardship", "hardware", "hardwired", "hardwood", "hardy", "harmful", "harmless", "harmonica", "harmonics", "harmonize", "harmony", "harness", "harpist", "harsh", "harvest", "hash", "hassle", "haste", "hastily", "hastiness", "hasty", "hatbox", "hatchback", "hatchery", "hatchet", "hatching", "hatchling", "hate", "hatless", "hatred", "haunt", "haven", "hazard", "hazelnut", "hazily", "haziness", "hazing", "hazy", "headache", "headband", "headboard", "headcount", "headdress", "headed", "header", "headfirst", "headgear", "heading", "headlamp", "headless", "headlock", "headphone", "headpiece", "headrest", "headroom", "headscarf", "headset", "headsman", "headstand", "headstone", "headway", "headwear", "heap", "heat", "heave", "heavily", "heaviness", "heaving", "hedge", "hedging", "heftiness", "hefty", "helium", "helmet", "helper", "helpful", "helping", "helpless", "helpline", "hemlock", "hemstitch", "hence", "henchman", "henna", "herald", "herbal", "herbicide", "herbs", "heritage", "hermit", "heroics", "heroism", "herring", "herself", "hertz", "hesitancy", "hesitant", "hesitate", "hexagon", "hexagram", "hubcap", "huddle", "huddling", "huff", "hug", "hula", "hulk", "hull", "human", "humble", "humbling", "humbly", "humid", "humiliate", "humility", "humming", "hummus", "humongous", "humorist", "humorless", "humorous", "humpback", "humped", "humvee", "hunchback", "hundredth", "hunger", "hungrily", "hungry", "hunk", "hunter", "hunting", "huntress", "huntsman", "hurdle", "hurled", "hurler", "hurling", "hurray", "hurricane", "hurried", "hurry", "hurt", "husband", "hush", "husked", "huskiness", "hut", "hybrid", "hydrant", "hydrated", "hydration", "hydrogen", "hydroxide", "hyperlink", "hypertext", "hyphen", "hypnoses", "hypnosis", "hypnotic", "hypnotism", "hypnotist", "hypnotize", "hypocrisy", "hypocrite", "ibuprofen", "ice", "iciness", "icing", "icky", "icon", "icy", "idealism", "idealist", "idealize", "ideally", "idealness", "identical", "identify", "identity", "ideology", "idiocy", "idiom", "idly", "igloo", "ignition", "ignore", "iguana", "illicitly", "illusion", "illusive", "image", "imaginary", "imagines", "imaging", "imbecile", "imitate", "imitation", "immature", "immerse", "immersion", "imminent", "immobile", "immodest", "immorally", "immortal", "immovable", "immovably", "immunity", "immunize", "impaired", "impale", "impart", "impatient", "impeach", "impeding", "impending", "imperfect", "imperial", "impish", "implant", "implement", "implicate", "implicit", "implode", "implosion", "implosive", "imply", "impolite", "important", "importer", "impose", "imposing", "impotence", "impotency", "impotent", "impound", "imprecise", "imprint", "imprison", "impromptu", "improper", "improve", "improving", "improvise", "imprudent", "impulse", "impulsive", "impure", "impurity", "iodine", "iodize", "ion", "ipad", "iphone", "ipod", "irate", "irk", "iron", "irregular", "irrigate", "irritable", "irritably", "irritant", "irritate", "islamic", "islamist", "isolated", "isolating", "isolation", "isotope", "issue", "issuing", "italicize", "italics", "item", "itinerary", "itunes", "ivory", "ivy", "jab", "jackal", "jacket", "jackknife", "jackpot", "jailbird", "jailbreak", "jailer", "jailhouse", "jalapeno", "jam", "janitor", "january", "jargon", "jarring", "jasmine", "jaundice", "jaunt", "java", "jawed", "jawless", "jawline", "jaws", "jaybird", "jaywalker", "jazz", "jeep", "jeeringly", "jellied", "jelly", "jersey", "jester", "jet", "jiffy", "jigsaw", "jimmy", "jingle", "jingling", "jinx", "jitters", "jittery", "job", "jockey", "jockstrap", "jogger", "jogging", "john", "joining", "jokester", "jokingly", "jolliness", "jolly", "jolt", "jot", "jovial", "joyfully", "joylessly", "joyous", "joyride", "joystick", "jubilance", "jubilant", "judge", "judgingly", "judicial", "judiciary", "judo", "juggle", "juggling", "jugular", "juice", "juiciness", "juicy", "jujitsu", "jukebox", "july", "jumble", "jumbo", "jump", "junction", "juncture", "june", "junior", "juniper", "junkie", "junkman", "junkyard", "jurist", "juror", "jury", "justice", "justifier", "justify", "justly", "justness", "juvenile", "kabob", "kangaroo", "karaoke", "karate", "karma", "kebab", "keenly", "keenness", "keep", "keg", "kelp", "kennel", "kept", "kerchief", "kerosene", "kettle", "kick", "kiln", "kilobyte", "kilogram", "kilometer", "kilowatt", "kilt", "kimono", "kindle", "kindling", "kindly", "kindness", "kindred", "kinetic", "kinfolk", "king", "kinship", "kinsman", "kinswoman", "kissable", "kisser", "kissing", "kitchen", "kite", "kitten", "kitty", "kiwi", "kleenex", "knapsack", "knee", "knelt", "knickers", "knoll", "koala", "kooky", "kosher", "krypton", "kudos", "kung", "labored", "laborer", "laboring", "laborious", "labrador", "ladder", "ladies", "ladle", "ladybug", "ladylike", "lagged", "lagging", "lagoon", "lair", "lake", "lance", "landed", "landfall", "landfill", "landing", "landlady", "landless", "landline", "landlord", "landmark", "landmass", "landmine", "landowner", "landscape", "landside", "landslide", "language", "lankiness", "lanky", "lantern", "lapdog", "lapel", "lapped", "lapping", "laptop", "lard", "large", "lark", "lash", "lasso", "last", "latch", "late", "lather", "latitude", "latrine", "latter", "latticed", "launch", "launder", "laundry", "laurel", "lavender", "lavish", "laxative", "lazily", "laziness", "lazy", "lecturer", "left", "legacy", "legal", "legend", "legged", "leggings", "legible", "legibly", "legislate", "lego", "legroom", "legume", "legwarmer", "legwork", "lemon", "lend", "length", "lens", "lent", "leotard", "lesser", "letdown", "lethargic", "lethargy", "letter", "lettuce", "level", "leverage", "levers", "levitate", "levitator", "liability", "liable", "liberty", "librarian", "library", "licking", "licorice", "lid", "life", "lifter", "lifting", "liftoff", "ligament", "likely", "likeness", "likewise", "liking", "lilac", "lilly", "lily", "limb", "limeade", "limelight", "limes", "limit", "limping", "limpness", "line", "lingo", "linguini", "linguist", "lining", "linked", "linoleum", "linseed", "lint", "lion", "lip", "liquefy", "liqueur", "liquid", "lisp", "list", "litigate", "litigator", "litmus", "litter", "little", "livable", "lived", "lively", "liver", "livestock", "lividly", "living", "lizard", "lubricant", "lubricate", "lucid", "luckily", "luckiness", "luckless", "lucrative", "ludicrous", "lugged", "lukewarm", "lullaby", "lumber", "luminance", "luminous", "lumpiness", "lumping", "lumpish", "lunacy", "lunar", "lunchbox", "luncheon", "lunchroom", "lunchtime", "lung", "lurch", "lure", "luridness", "lurk", "lushly", "lushness", "luster", "lustfully", "lustily", "lustiness", "lustrous", "lusty", "luxurious", "luxury", "lying", "lyrically", "lyricism", "lyricist", "lyrics", "macarena", "macaroni", "macaw", "mace", "machine", "machinist", "magazine", "magenta", "maggot", "magical", "magician", "magma", "magnesium", "magnetic", "magnetism", "magnetize", "magnifier", "magnify", "magnitude", "magnolia", "mahogany", "maimed", "majestic", "majesty", "majorette", "majority", "makeover", "maker", "makeshift", "making", "malformed", "malt", "mama", "mammal", "mammary", "mammogram", "manager", "managing", "manatee", "mandarin", "mandate", "mandatory", "mandolin", "manger", "mangle", "mango", "mangy", "manhandle", "manhole", "manhood", "manhunt", "manicotti", "manicure", "manifesto", "manila", "mankind", "manlike", "manliness", "manly", "manmade", "manned", "mannish", "manor", "manpower", "mantis", "mantra", "manual", "many", "map", "marathon", "marauding", "marbled", "marbles", "marbling", "march", "mardi", "margarine", "margarita", "margin", "marigold", "marina", "marine", "marital", "maritime", "marlin", "marmalade", "maroon", "married", "marrow", "marry", "marshland", "marshy", "marsupial", "marvelous", "marxism", "mascot", "masculine", "mashed", "mashing", "massager", "masses", "massive", "mastiff", "matador", "matchbook", "matchbox", "matcher", "matching", "matchless", "material", "maternal", "maternity", "math", "mating", "matriarch", "matrimony", "matrix", "matron", "matted", "matter", "maturely", "maturing", "maturity", "mauve", "maverick", "maximize", "maximum", "maybe", "mayday", "mayflower", "moaner", "moaning", "mobile", "mobility", "mobilize", "mobster", "mocha", "mocker", "mockup", "modified", "modify", "modular", "modulator", "module", "moisten", "moistness", "moisture", "molar", "molasses", "mold", "molecular", "molecule", "molehill", "mollusk", "mom", "monastery", "monday", "monetary", "monetize", "moneybags", "moneyless", "moneywise", "mongoose", "mongrel", "monitor", "monkhood", "monogamy", "monogram", "monologue", "monopoly", "monorail", "monotone", "monotype", "monoxide", "monsieur", "monsoon", "monstrous", "monthly", "monument", "moocher", "moodiness", "moody", "mooing", "moonbeam", "mooned", "moonlight", "moonlike", "moonlit", "moonrise", "moonscape", "moonshine", "moonstone", "moonwalk", "mop", "morale", "morality", "morally", "morbidity", "morbidly", "morphine", "morphing", "morse", "mortality", "mortally", "mortician", "mortified", "mortify", "mortuary", "mosaic", "mossy", "most", "mothball", "mothproof", "motion", "motivate", "motivator", "motive", "motocross", "motor", "motto", "mountable", "mountain", "mounted", "mounting", "mourner", "mournful", "mouse", "mousiness", "moustache", "mousy", "mouth", "movable", "move", "movie", "moving", "mower", "mowing", "much", "muck", "mud", "mug", "mulberry", "mulch", "mule", "mulled", "mullets", "multiple", "multiply", "multitask", "multitude", "mumble", "mumbling", "mumbo", "mummified", "mummify", "mummy", "mumps", "munchkin", "mundane", "municipal", "muppet", "mural", "murkiness", "murky", "murmuring", "muscular", "museum", "mushily", "mushiness", "mushroom", "mushy", "music", "musket", "muskiness", "musky", "mustang", "mustard", "muster", "mustiness", "musty", "mutable", "mutate", "mutation", "mute", "mutilated", "mutilator", "mutiny", "mutt", "mutual", "muzzle", "myself", "myspace", "mystified", "mystify", "myth", "nacho", "nag", "nail", "name", "naming", "nanny", "nanometer", "nape", "napkin", "napped", "napping", "nappy", "narrow", "nastily", "nastiness", "national", "native", "nativity", "natural", "nature", "naturist", "nautical", "navigate", "navigator", "navy", "nearby", "nearest", "nearly", "nearness", "neatly", "neatness", "nebula", "nebulizer", "nectar", "negate", "negation", "negative", "neglector", "negligee", "negligent", "negotiate", "nemeses", "nemesis", "neon", "nephew", "nerd", "nervous", "nervy", "nest", "net", "neurology", "neuron", "neurosis", "neurotic", "neuter", "neutron", "never", "next", "nibble", "nickname", "nicotine", "niece", "nifty", "nimble", "nimbly", "nineteen", "ninetieth", "ninja", "nintendo", "ninth", "nuclear", "nuclei", "nucleus", "nugget", "nullify", "number", "numbing", "numbly", "numbness", "numeral", "numerate", "numerator", "numeric", "numerous", "nuptials", "nursery", "nursing", "nurture", "nutcase", "nutlike", "nutmeg", "nutrient", "nutshell", "nuttiness", "nutty", "nuzzle", "nylon", "oaf", "oak", "oasis", "oat", "obedience", "obedient", "obituary", "object", "obligate", "obliged", "oblivion", "oblivious", "oblong", "obnoxious", "oboe", "obscure", "obscurity", "observant", "observer", "observing", "obsessed", "obsession", "obsessive", "obsolete", "obstacle", "obstinate", "obstruct", "obtain", "obtrusive", "obtuse", "obvious", "occultist", "occupancy", "occupant", "occupier", "occupy", "ocean", "ocelot", "octagon", "octane", "october", "octopus", "ogle", "oil", "oink", "ointment", "okay", "old", "olive", "olympics", "omega", "omen", "ominous", "omission", "omit", "omnivore", "onboard", "oncoming", "ongoing", "onion", "online", "onlooker", "only", "onscreen", "onset", "onshore", "onslaught", "onstage", "onto", "onward", "onyx", "oops", "ooze", "oozy", "opacity", "opal", "open", "operable", "operate", "operating", "operation", "operative", "operator", "opium", "opossum", "opponent", "oppose", "opposing", "opposite", "oppressed", "oppressor", "opt", "opulently", "osmosis", "other", "otter", "ouch", "ought", "ounce", "outage", "outback", "outbid", "outboard", "outbound", "outbreak", "outburst", "outcast", "outclass", "outcome", "outdated", "outdoors", "outer", "outfield", "outfit", "outflank", "outgoing", "outgrow", "outhouse", "outing", "outlast", "outlet", "outline", "outlook", "outlying", "outmatch", "outmost", "outnumber", "outplayed", "outpost", "outpour", "output", "outrage", "outrank", "outreach", "outright", "outscore", "outsell", "outshine", "outshoot", "outsider", "outskirts", "outsmart", "outsource", "outspoken", "outtakes", "outthink", "outward", "outweigh", "outwit", "oval", "ovary", "oven", "overact", "overall", "overarch", "overbid", "overbill", "overbite", "overblown", "overboard", "overbook", "overbuilt", "overcast", "overcoat", "overcome", "overcook", "overcrowd", "overdraft", "overdrawn", "overdress", "overdrive", "overdue", "overeager", "overeater", "overexert", "overfed", "overfeed", "overfill", "overflow", "overfull", "overgrown", "overhand", "overhang", "overhaul", "overhead", "overhear", "overheat", "overhung", "overjoyed", "overkill", "overlabor", "overlaid", "overlap", "overlay", "overload", "overlook", "overlord", "overlying", "overnight", "overpass", "overpay", "overplant", "overplay", "overpower", "overprice", "overrate", "overreach", "overreact", "override", "overripe", "overrule", "overrun", "overshoot", "overshot", "oversight", "oversized", "oversleep", "oversold", "overspend", "overstate", "overstay", "overstep", "overstock", "overstuff", "oversweet", "overtake", "overthrow", "overtime", "overtly", "overtone", "overture", "overturn", "overuse", "overvalue", "overview", "overwrite", "owl", "oxford", "oxidant", "oxidation", "oxidize", "oxidizing", "oxygen", "oxymoron", "oyster", "ozone", "paced", "pacemaker", "pacific", "pacifier", "pacifism", "pacifist", "pacify", "padded", "padding", "paddle", "paddling", "padlock", "pagan", "pager", "paging", "pajamas", "palace", "palatable", "palm", "palpable", "palpitate", "paltry", "pampered", "pamperer", "pampers", "pamphlet", "panama", "pancake", "pancreas", "panda", "pandemic", "pang", "panhandle", "panic", "panning", "panorama", "panoramic", "panther", "pantomime", "pantry", "pants", "pantyhose", "paparazzi", "papaya", "paper", "paprika", "papyrus", "parabola", "parachute", "parade", "paradox", "paragraph", "parakeet", "paralegal", "paralyses", "paralysis", "paralyze", "paramedic", "parameter", "paramount", "parasail", "parasite", "parasitic", "parcel", "parched", "parchment", "pardon", "parish", "parka", "parking", "parkway", "parlor", "parmesan", "parole", "parrot", "parsley", "parsnip", "partake", "parted", "parting", "partition", "partly", "partner", "partridge", "party", "passable", "passably", "passage", "passcode", "passenger", "passerby", "passing", "passion", "passive", "passivism", "passover", "passport", "password", "pasta", "pasted", "pastel", "pastime", "pastor", "pastrami", "pasture", "pasty", "patchwork", "patchy", "paternal", "paternity", "path", "patience", "patient", "patio", "patriarch", "patriot", "patrol", "patronage", "patronize", "pauper", "pavement", "paver", "pavestone", "pavilion", "paving", "pawing", "payable", "payback", "paycheck", "payday", "payee", "payer", "paying", "payment", "payphone", "payroll", "pebble", "pebbly", "pecan", "pectin", "peculiar", "peddling", "pediatric", "pedicure", "pedigree", "pedometer", "pegboard", "pelican", "pellet", "pelt", "pelvis", "penalize", "penalty", "pencil", "pendant", "pending", "penholder", "penknife", "pennant", "penniless", "penny", "penpal", "pension", "pentagon", "pentagram", "pep", "perceive", "percent", "perch", "percolate", "perennial", "perfected", "perfectly", "perfume", "periscope", "perish", "perjurer", "perjury", "perkiness", "perky", "perm", "peroxide", "perpetual", "perplexed", "persecute", "persevere", "persuaded", "persuader", "pesky", "peso", "pessimism", "pessimist", "pester", "pesticide", "petal", "petite", "petition", "petri", "petroleum", "petted", "petticoat", "pettiness", "petty", "petunia", "phantom", "phobia", "phoenix", "phonebook", "phoney", "phonics", "phoniness", "phony", "phosphate", "photo", "phrase", "phrasing", "placard", "placate", "placidly", "plank", "planner", "plant", "plasma", "plaster", "plastic", "plated", "platform", "plating", "platinum", "platonic", "platter", "platypus", "plausible", "plausibly", "playable", "playback", "player", "playful", "playgroup", "playhouse", "playing", "playlist", "playmaker", "playmate", "playoff", "playpen", "playroom", "playset", "plaything", "playtime", "plaza", "pleading", "pleat", "pledge", "plentiful", "plenty", "plethora", "plexiglas", "pliable", "plod", "plop", "plot", "plow", "ploy", "pluck", "plug", "plunder", "plunging", "plural", "plus", "plutonium", "plywood", "poach", "pod", "poem", "poet", "pogo", "pointed", "pointer", "pointing", "pointless", "pointy", "poise", "poison", "poker", "poking", "polar", "police", "policy", "polio", "polish", "politely", "polka", "polo", "polyester", "polygon", "polygraph", "polymer", "poncho", "pond", "pony", "popcorn", "pope", "poplar", "popper", "poppy", "popsicle", "populace", "popular", "populate", "porcupine", "pork", "porous", "porridge", "portable", "portal", "portfolio", "porthole", "portion", "portly", "portside", "poser", "posh", "posing", "possible", "possibly", "possum", "postage", "postal", "postbox", "postcard", "posted", "poster", "posting", "postnasal", "posture", "postwar", "pouch", "pounce", "pouncing", "pound", "pouring", "pout", "powdered", "powdering", "powdery", "power", "powwow", "pox", "praising", "prance", "prancing", "pranker", "prankish", "prankster", "prayer", "praying", "preacher", "preaching", "preachy", "preamble", "precinct", "precise", "precision", "precook", "precut", "predator", "predefine", "predict", "preface", "prefix", "preflight", "preformed", "pregame", "pregnancy", "pregnant", "preheated", "prelaunch", "prelaw", "prelude", "premiere", "premises", "premium", "prenatal", "preoccupy", "preorder", "prepaid", "prepay", "preplan", "preppy", "preschool", "prescribe", "preseason", "preset", "preshow", "president", "presoak", "press", "presume", "presuming", "preteen", "pretended", "pretender", "pretense", "pretext", "pretty", "pretzel", "prevail", "prevalent", "prevent", "preview", "previous", "prewar", "prewashed", "prideful", "pried", "primal", "primarily", "primary", "primate", "primer", "primp", "princess", "print", "prior", "prism", "prison", "prissy", "pristine", "privacy", "private", "privatize", "prize", "proactive", "probable", "probably", "probation", "probe", "probing", "probiotic", "problem", "procedure", "process", "proclaim", "procreate", "procurer", "prodigal", "prodigy", "produce", "product", "profane", "profanity", "professed", "professor", "profile", "profound", "profusely", "progeny", "prognosis", "program", "progress", "projector", "prologue", "prolonged", "promenade", "prominent", "promoter", "promotion", "prompter", "promptly", "prone", "prong", "pronounce", "pronto", "proofing", "proofread", "proofs", "propeller", "properly", "property", "proponent", "proposal", "propose", "props", "prorate", "protector", "protegee", "proton", "prototype", "protozoan", "protract", "protrude", "proud", "provable", "proved", "proven", "provided", "provider", "providing", "province", "proving", "provoke", "provoking", "provolone", "prowess", "prowler", "prowling", "proximity", "proxy", "prozac", "prude", "prudishly", "prune", "pruning", "pry", "psychic", "public", "publisher", "pucker", "pueblo", "pug", "pull", "pulmonary", "pulp", "pulsate", "pulse", "pulverize", "puma", "pumice", "pummel", "punch", "punctual", "punctuate", "punctured", "pungent", "punisher", "punk", "pupil", "puppet", "puppy", "purchase", "pureblood", "purebred", "purely", "pureness", "purgatory", "purge", "purging", "purifier", "purify", "purist", "puritan", "purity", "purple", "purplish", "purposely", "purr", "purse", "pursuable", "pursuant", "pursuit", "purveyor", "pushcart", "pushchair", "pusher", "pushiness", "pushing", "pushover", "pushpin", "pushup", "pushy", "putdown", "putt", "puzzle", "puzzling", "pyramid", "pyromania", "python", "quack", "quadrant", "quail", "quaintly", "quake", "quaking", "qualified", "qualifier", "qualify", "quality", "qualm", "quantum", "quarrel", "quarry", "quartered", "quarterly", "quarters", "quartet", "quench", "query", "quicken", "quickly", "quickness", "quicksand", "quickstep", "quiet", "quill", "quilt", "quintet", "quintuple", "quirk", "quit", "quiver", "quizzical", "quotable", "quotation", "quote", "rabid", "race", "racing", "racism", "rack", "racoon", "radar", "radial", "radiance", "radiantly", "radiated", "radiation", "radiator", "radio", "radish", "raffle", "raft", "rage", "ragged", "raging", "ragweed", "raider", "railcar", "railing", "railroad", "railway", "raisin", "rake", "raking", "rally", "ramble", "rambling", "ramp", "ramrod", "ranch", "rancidity", "random", "ranged", "ranger", "ranging", "ranked", "ranking", "ransack", "ranting", "rants", "rare", "rarity", "rascal", "rash", "rasping", "ravage", "raven", "ravine", "raving", "ravioli", "ravishing", "reabsorb", "reach", "reacquire", "reaction", "reactive", "reactor", "reaffirm", "ream", "reanalyze", "reappear", "reapply", "reappoint", "reapprove", "rearrange", "rearview", "reason", "reassign", "reassure", "reattach", "reawake", "rebalance", "rebate", "rebel", "rebirth", "reboot", "reborn", "rebound", "rebuff", "rebuild", "rebuilt", "reburial", "rebuttal", "recall", "recant", "recapture", "recast", "recede", "recent", "recess", "recharger", "recipient", "recital", "recite", "reckless", "reclaim", "recliner", "reclining", "recluse", "reclusive", "recognize", "recoil", "recollect", "recolor", "reconcile", "reconfirm", "reconvene", "recopy", "record", "recount", "recoup", "recovery", "recreate", "rectal", "rectangle", "rectified", "rectify", "recycled", "recycler", "recycling", "reemerge", "reenact", "reenter", "reentry", "reexamine", "referable", "referee", "reference", "refill", "refinance", "refined", "refinery", "refining", "refinish", "reflected", "reflector", "reflex", "reflux", "refocus", "refold", "reforest", "reformat", "reformed", "reformer", "reformist", "refract", "refrain", "refreeze", "refresh", "refried", "refueling", "refund", "refurbish", "refurnish", "refusal", "refuse", "refusing", "refutable", "refute", "regain", "regalia", "regally", "reggae", "regime", "region", "register", "registrar", "registry", "regress", "regretful", "regroup", "regular", "regulate", "regulator", "rehab", "reheat", "rehire", "rehydrate", "reimburse", "reissue", "reiterate", "rejoice", "rejoicing", "rejoin", "rekindle", "relapse", "relapsing", "relatable", "related", "relation", "relative", "relax", "relay", "relearn", "release", "relenting", "reliable", "reliably", "reliance", "reliant", "relic", "relieve", "relieving", "relight", "relish", "relive", "reload", "relocate", "relock", "reluctant", "rely", "remake", "remark", "remarry", "rematch", "remedial", "remedy", "remember", "reminder", "remindful", "remission", "remix", "remnant", "remodeler", "remold", "remorse", "remote", "removable", "removal", "removed", "remover", "removing", "rename", "renderer", "rendering", "rendition", "renegade", "renewable", "renewably", "renewal", "renewed", "renounce", "renovate", "renovator", "rentable", "rental", "rented", "renter", "reoccupy", "reoccur", "reopen", "reorder", "repackage", "repacking", "repaint", "repair", "repave", "repaying", "repayment", "repeal", "repeated", "repeater", "repent", "rephrase", "replace", "replay", "replica", "reply", "reporter", "repose", "repossess", "repost", "repressed", "reprimand", "reprint", "reprise", "reproach", "reprocess", "reproduce", "reprogram", "reps", "reptile", "reptilian", "repugnant", "repulsion", "repulsive", "repurpose", "reputable", "reputably", "request", "require", "requisite", "reroute", "rerun", "resale", "resample", "rescuer", "reseal", "research", "reselect", "reseller", "resemble", "resend", "resent", "reset", "reshape", "reshoot", "reshuffle", "residence", "residency", "resident", "residual", "residue", "resigned", "resilient", "resistant", "resisting", "resize", "resolute", "resolved", "resonant", "resonate", "resort", "resource", "respect", "resubmit", "result", "resume", "resupply", "resurface", "resurrect", "retail", "retainer", "retaining", "retake", "retaliate", "retention", "rethink", "retinal", "retired", "retiree", "retiring", "retold", "retool", "retorted", "retouch", "retrace", "retract", "retrain", "retread", "retreat", "retrial", "retrieval", "retriever", "retry", "return", "retying", "retype", "reunion", "reunite", "reusable", "reuse", "reveal", "reveler", "revenge", "revenue", "reverb", "revered", "reverence", "reverend", "reversal", "reverse", "reversing", "reversion", "revert", "revisable", "revise", "revision", "revisit", "revivable", "revival", "reviver", "reviving", "revocable", "revoke", "revolt", "revolver", "revolving", "reward", "rewash", "rewind", "rewire", "reword", "rework", "rewrap", "rewrite", "rhyme", "ribbon", "ribcage", "rice", "riches", "richly", "richness", "rickety", "ricotta", "riddance", "ridden", "ride", "riding", "rifling", "rift", "rigging", "rigid", "rigor", "rimless", "rimmed", "rind", "rink", "rinse", "rinsing", "riot", "ripcord", "ripeness", "ripening", "ripping", "ripple", "rippling", "riptide", "rise", "rising", "risk", "risotto", "ritalin", "ritzy", "rival", "riverbank", "riverbed", "riverboat", "riverside", "riveter", "riveting", "roamer", "roaming", "roast", "robbing", "robe", "robin", "robotics", "robust", "rockband", "rocker", "rocket", "rockfish", "rockiness", "rocking", "rocklike", "rockslide", "rockstar", "rocky", "rogue", "roman", "romp", "rope", "roping", "roster", "rosy", "rotten", "rotting", "rotunda", "roulette", "rounding", "roundish", "roundness", "roundup", "roundworm", "routine", "routing", "rover", "roving", "royal", "rubbed", "rubber", "rubbing", "rubble", "rubdown", "ruby", "ruckus", "rudder", "rug", "ruined", "rule", "rumble", "rumbling", "rummage", "rumor", "runaround", "rundown", "runner", "running", "runny", "runt", "runway", "rupture", "rural", "ruse", "rush", "rust", "rut", "sabbath", "sabotage", "sacrament", "sacred", "sacrifice", "sadden", "saddlebag", "saddled", "saddling", "sadly", "sadness", "safari", "safeguard", "safehouse", "safely", "safeness", "saffron", "saga", "sage", "sagging", "saggy", "said", "saint", "sake", "salad", "salami", "salaried", "salary", "saline", "salon", "saloon", "salsa", "salt", "salutary", "salute", "salvage", "salvaging", "salvation", "same", "sample", "sampling", "sanction", "sanctity", "sanctuary", "sandal", "sandbag", "sandbank", "sandbar", "sandblast", "sandbox", "sanded", "sandfish", "sanding", "sandlot", "sandpaper", "sandpit", "sandstone", "sandstorm", "sandworm", "sandy", "sanitary", "sanitizer", "sank", "santa", "sapling", "sappiness", "sappy", "sarcasm", "sarcastic", "sardine", "sash", "sasquatch", "sassy", "satchel", "satiable", "satin", "satirical", "satisfied", "satisfy", "saturate", "saturday", "sauciness", "saucy", "sauna", "savage", "savanna", "saved", "savings", "savior", "savor", "saxophone", "say", "scabbed", "scabby", "scalded", "scalding", "scale", "scaling", "scallion", "scallop", "scalping", "scam", "scandal", "scanner", "scanning", "scant", "scapegoat", "scarce", "scarcity", "scarecrow", "scared", "scarf", "scarily", "scariness", "scarring", "scary", "scavenger", "scenic", "schedule", "schematic", "scheme", "scheming", "schilling", "schnapps", "scholar", "science", "scientist", "scion", "scoff", "scolding", "scone", "scoop", "scooter", "scope", "scorch", "scorebook", "scorecard", "scored", "scoreless", "scorer", "scoring", "scorn", "scorpion", "scotch", "scoundrel", "scoured", "scouring", "scouting", "scouts", "scowling", "scrabble", "scraggly", "scrambled", "scrambler", "scrap", "scratch", "scrawny", "screen", "scribble", "scribe", "scribing", "scrimmage", "script", "scroll", "scrooge", "scrounger", "scrubbed", "scrubber", "scruffy", "scrunch", "scrutiny", "scuba", "scuff", "sculptor", "sculpture", "scurvy", "scuttle", "secluded", "secluding", "seclusion", "second", "secrecy", "secret", "sectional", "sector", "secular", "securely", "security", "sedan", "sedate", "sedation", "sedative", "sediment", "seduce", "seducing", "segment", "seismic", "seizing", "seldom", "selected", "selection", "selective", "selector", "self", "seltzer", "semantic", "semester", "semicolon", "semifinal", "seminar", "semisoft", "semisweet", "senate", "senator", "send", "senior", "senorita", "sensation", "sensitive", "sensitize", "sensually", "sensuous", "sepia", "september", "septic", "septum", "sequel", "sequence", "sequester", "series", "sermon", "serotonin", "serpent", "serrated", "serve", "service", "serving", "sesame", "sessions", "setback", "setting", "settle", "settling", "setup", "sevenfold", "seventeen", "seventh", "seventy", "severity", "shabby", "shack", "shaded", "shadily", "shadiness", "shading", "shadow", "shady", "shaft", "shakable", "shakily", "shakiness", "shaking", "shaky", "shale", "shallot", "shallow", "shame", "shampoo", "shamrock", "shank", "shanty", "shape", "shaping", "share", "sharpener", "sharper", "sharpie", "sharply", "sharpness", "shawl", "sheath", "shed", "sheep", "sheet", "shelf", "shell", "shelter", "shelve", "shelving", "sherry", "shield", "shifter", "shifting", "shiftless", "shifty", "shimmer", "shimmy", "shindig", "shine", "shingle", "shininess", "shining", "shiny", "ship", "shirt", "shivering", "shock", "shone", "shoplift", "shopper", "shopping", "shoptalk", "shore", "shortage", "shortcake", "shortcut", "shorten", "shorter", "shorthand", "shortlist", "shortly", "shortness", "shorts", "shortwave", "shorty", "shout", "shove", "showbiz", "showcase", "showdown", "shower", "showgirl", "showing", "showman", "shown", "showoff", "showpiece", "showplace", "showroom", "showy", "shrank", "shrapnel", "shredder", "shredding", "shrewdly", "shriek", "shrill", "shrimp", "shrine", "shrink", "shrivel", "shrouded", "shrubbery", "shrubs", "shrug", "shrunk", "shucking", "shudder", "shuffle", "shuffling", "shun", "shush", "shut", "shy", "siamese", "siberian", "sibling", "siding", "sierra", "siesta", "sift", "sighing", "silenced", "silencer", "silent", "silica", "silicon", "silk", "silliness", "silly", "silo", "silt", "silver", "similarly", "simile", "simmering", "simple", "simplify", "simply", "sincere", "sincerity", "singer", "singing", "single", "singular", "sinister", "sinless", "sinner", "sinuous", "sip", "siren", "sister", "sitcom", "sitter", "sitting", "situated", "situation", "sixfold", "sixteen", "sixth", "sixties", "sixtieth", "sixtyfold", "sizable", "sizably", "size", "sizing", "sizzle", "sizzling", "skater", "skating", "skedaddle", "skeletal", "skeleton", "skeptic", "sketch", "skewed", "skewer", "skid", "skied", "skier", "skies", "skiing", "skilled", "skillet", "skillful", "skimmed", "skimmer", "skimming", "skimpily", "skincare", "skinhead", "skinless", "skinning", "skinny", "skintight", "skipper", "skipping", "skirmish", "skirt", "skittle", "skydiver", "skylight", "skyline", "skype", "skyrocket", "skyward", "slab", "slacked", "slacker", "slacking", "slackness", "slacks", "slain", "slam", "slander", "slang", "slapping", "slapstick", "slashed", "slashing", "slate", "slather", "slaw", "sled", "sleek", "sleep", "sleet", "sleeve", "slept", "sliceable", "sliced", "slicer", "slicing", "slick", "slider", "slideshow", "sliding", "slighted", "slighting", "slightly", "slimness", "slimy", "slinging", "slingshot", "slinky", "slip", "slit", "sliver", "slobbery", "slogan", "sloped", "sloping", "sloppily", "sloppy", "slot", "slouching", "slouchy", "sludge", "slug", "slum", "slurp", "slush", "sly", "small", "smartly", "smartness", "smasher", "smashing", "smashup", "smell", "smelting", "smile", "smilingly", "smirk", "smite", "smith", "smitten", "smock", "smog", "smoked", "smokeless", "smokiness", "smoking", "smoky", "smolder", "smooth", "smother", "smudge", "smudgy", "smuggler", "smuggling", "smugly", "smugness", "snack", "snagged", "snaking", "snap", "snare", "snarl", "snazzy", "sneak", "sneer", "sneeze", "sneezing", "snide", "sniff", "snippet", "snipping", "snitch", "snooper", "snooze", "snore", "snoring", "snorkel", "snort", "snout", "snowbird", "snowboard", "snowbound", "snowcap", "snowdrift", "snowdrop", "snowfall", "snowfield", "snowflake", "snowiness", "snowless", "snowman", "snowplow", "snowshoe", "snowstorm", "snowsuit", "snowy", "snub", "snuff", "snuggle", "snugly", "snugness", "speak", "spearfish", "spearhead", "spearman", "spearmint", "species", "specimen", "specked", "speckled", "specks", "spectacle", "spectator", "spectrum", "speculate", "speech", "speed", "spellbind", "speller", "spelling", "spendable", "spender", "spending", "spent", "spew", "sphere", "spherical", "sphinx", "spider", "spied", "spiffy", "spill", "spilt", "spinach", "spinal", "spindle", "spinner", "spinning", "spinout", "spinster", "spiny", "spiral", "spirited", "spiritism", "spirits", "spiritual", "splashed", "splashing", "splashy", "splatter", "spleen", "splendid", "splendor", "splice", "splicing", "splinter", "splotchy", "splurge", "spoilage", "spoiled", "spoiler", "spoiling", "spoils", "spoken", "spokesman", "sponge", "spongy", "sponsor", "spoof", "spookily", "spooky", "spool", "spoon", "spore", "sporting", "sports", "sporty", "spotless", "spotlight", "spotted", "spotter", "spotting", "spotty", "spousal", "spouse", "spout", "sprain", "sprang", "sprawl", "spray", "spree", "sprig", "spring", "sprinkled", "sprinkler", "sprint", "sprite", "sprout", "spruce", "sprung", "spry", "spud", "spur", "sputter", "spyglass", "squabble", "squad", "squall", "squander", "squash", "squatted", "squatter", "squatting", "squeak", "squealer", "squealing", "squeamish", "squeegee", "squeeze", "squeezing", "squid", "squiggle", "squiggly", "squint", "squire", "squirt", "squishier", "squishy", "stability", "stabilize", "stable", "stack", "stadium", "staff", "stage", "staging", "stagnant", "stagnate", "stainable", "stained", "staining", "stainless", "stalemate", "staleness", "stalling", "stallion", "stamina", "stammer", "stamp", "stand", "stank", "staple", "stapling", "starboard", "starch", "stardom", "stardust", "starfish", "stargazer", "staring", "stark", "starless", "starlet", "starlight", "starlit", "starring", "starry", "starship", "starter", "starting", "startle", "startling", "startup", "starved", "starving", "stash", "state", "static", "statistic", "statue", "stature", "status", "statute", "statutory", "staunch", "stays", "steadfast", "steadier", "steadily", "steadying", "steam", "steed", "steep", "steerable", "steering", "steersman", "stegosaur", "stellar", "stem", "stench", "stencil", "step", "stereo", "sterile", "sterility", "sterilize", "sterling", "sternness", "sternum", "stew", "stick", "stiffen", "stiffly", "stiffness", "stifle", "stifling", "stillness", "stilt", "stimulant", "stimulate", "stimuli", "stimulus", "stinger", "stingily", "stinging", "stingray", "stingy", "stinking", "stinky", "stipend", "stipulate", "stir", "stitch", "stock", "stoic", "stoke", "stole", "stomp", "stonewall", "stoneware", "stonework", "stoning", "stony", "stood", "stooge", "stool", "stoop", "stoplight", "stoppable", "stoppage", "stopped", "stopper", "stopping", "stopwatch", "storable", "storage", "storeroom", "storewide", "storm", "stout", "stove", "stowaway", "stowing", "straddle", "straggler", "strained", "strainer", "straining", "strangely", "stranger", "strangle", "strategic", "strategy", "stratus", "straw", "stray", "streak", "stream", "street", "strength", "strenuous", "strep", "stress", "stretch", "strewn", "stricken", "strict", "stride", "strife", "strike", "striking", "strive", "striving", "strobe", "strode", "stroller", "strongbox", "strongly", "strongman", "struck", "structure", "strudel", "struggle", "strum", "strung", "strut", "stubbed", "stubble", "stubbly", "stubborn", "stucco", "stuck", "student", "studied", "studio", "study", "stuffed", "stuffing", "stuffy", "stumble", "stumbling", "stump", "stung", "stunned", "stunner", "stunning", "stunt", "stupor", "sturdily", "sturdy", "styling", "stylishly", "stylist", "stylized", "stylus", "suave", "subarctic", "subatomic", "subdivide", "subdued", "subduing", "subfloor", "subgroup", "subheader", "subject", "sublease", "sublet", "sublevel", "sublime", "submarine", "submerge", "submersed", "submitter", "subpanel", "subpar", "subplot", "subprime", "subscribe", "subscript", "subsector", "subside", "subsiding", "subsidize", "subsidy", "subsoil", "subsonic", "substance", "subsystem", "subtext", "subtitle", "subtly", "subtotal", "subtract", "subtype", "suburb", "subway", "subwoofer", "subzero", "succulent", "such", "suction", "sudden", "sudoku", "suds", "sufferer", "suffering", "suffice", "suffix", "suffocate", "suffrage", "sugar", "suggest", "suing", "suitable", "suitably", "suitcase", "suitor", "sulfate", "sulfide", "sulfite", "sulfur", "sulk", "sullen", "sulphate", "sulphuric", "sultry", "superbowl", "superglue", "superhero", "superior", "superjet", "superman", "supermom", "supernova", "supervise", "supper", "supplier", "supply", "support", "supremacy", "supreme", "surcharge", "surely", "sureness", "surface", "surfacing", "surfboard", "surfer", "surgery", "surgical", "surging", "surname", "surpass", "surplus", "surprise", "surreal", "surrender", "surrogate", "surround", "survey", "survival", "survive", "surviving", "survivor", "sushi", "suspect", "suspend", "suspense", "sustained", "sustainer", "swab", "swaddling", "swagger", "swampland", "swan", "swapping", "swarm", "sway", "swear", "sweat", "sweep", "swell", "swept", "swerve", "swifter", "swiftly", "swiftness", "swimmable", "swimmer", "swimming", "swimsuit", "swimwear", "swinger", "swinging", "swipe", "swirl", "switch", "swivel", "swizzle", "swooned", "swoop", "swoosh", "swore", "sworn", "swung", "sycamore", "sympathy", "symphonic", "symphony", "symptom", "synapse", "syndrome", "synergy", "synopses", "synopsis", "synthesis", "synthetic", "syrup", "system", "t-shirt", "tabasco", "tabby", "tableful", "tables", "tablet", "tableware", "tabloid", "tackiness", "tacking", "tackle", "tackling", "tacky", "taco", "tactful", "tactical", "tactics", "tactile", "tactless", "tadpole", "taekwondo", "tag", "tainted", "take", "taking", "talcum", "talisman", "tall", "talon", "tamale", "tameness", "tamer", "tamper", "tank", "tanned", "tannery", "tanning", "tantrum", "tapeless", "tapered", "tapering", "tapestry", "tapioca", "tapping", "taps", "tarantula", "target", "tarmac", "tarnish", "tarot", "tartar", "tartly", "tartness", "task", "tassel", "taste", "tastiness", "tasting", "tasty", "tattered", "tattle", "tattling", "tattoo", "taunt", "tavern", "thank", "that", "thaw", "theater", "theatrics", "thee", "theft", "theme", "theology", "theorize", "thermal", "thermos", "thesaurus", "these", "thesis", "thespian", "thicken", "thicket", "thickness", "thieving", "thievish", "thigh", "thimble", "thing", "think", "thinly", "thinner", "thinness", "thinning", "thirstily", "thirsting", "thirsty", "thirteen", "thirty", "thong", "thorn", "those", "thousand", "thrash", "thread", "threaten", "threefold", "thrift", "thrill", "thrive", "thriving", "throat", "throbbing", "throng", "throttle", "throwaway", "throwback", "thrower", "throwing", "thud", "thumb", "thumping", "thursday", "thus", "thwarting", "thyself", "tiara", "tibia", "tidal", "tidbit", "tidiness", "tidings", "tidy", "tiger", "tighten", "tightly", "tightness", "tightrope", "tightwad", "tigress", "tile", "tiling", "till", "tilt", "timid", "timing", "timothy", "tinderbox", "tinfoil", "tingle", "tingling", "tingly", "tinker", "tinkling", "tinsel", "tinsmith", "tint", "tinwork", "tiny", "tipoff", "tipped", "tipper", "tipping", "tiptoeing", "tiptop", "tiring", "tissue", "trace", "tracing", "track", "traction", "tractor", "trade", "trading", "tradition", "traffic", "tragedy", "trailing", "trailside", "train", "traitor", "trance", "tranquil", "transfer", "transform", "translate", "transpire", "transport", "transpose", "trapdoor", "trapeze", "trapezoid", "trapped", "trapper", "trapping", "traps", "trash", "travel", "traverse", "travesty", "tray", "treachery", "treading", "treadmill", "treason", "treat", "treble", "tree", "trekker", "tremble", "trembling", "tremor", "trench", "trend", "trespass", "triage", "trial", "triangle", "tribesman", "tribunal", "tribune", "tributary", "tribute", "triceps", "trickery", "trickily", "tricking", "trickle", "trickster", "tricky", "tricolor", "tricycle", "trident", "tried", "trifle", "trifocals", "trillion", "trilogy", "trimester", "trimmer", "trimming", "trimness", "trinity", "trio", "tripod", "tripping", "triumph", "trivial", "trodden", "trolling", "trombone", "trophy", "tropical", "tropics", "trouble", "troubling", "trough", "trousers", "trout", "trowel", "truce", "truck", "truffle", "trump", "trunks", "trustable", "trustee", "trustful", "trusting", "trustless", "truth", "try", "tubby", "tubeless", "tubular", "tucking", "tuesday", "tug", "tuition", "tulip", "tumble", "tumbling", "tummy", "turban", "turbine", "turbofan", "turbojet", "turbulent", "turf", "turkey", "turmoil", "turret", "turtle", "tusk", "tutor", "tutu", "tux", "tweak", "tweed", "tweet", "tweezers", "twelve", "twentieth", "twenty", "twerp", "twice", "twiddle", "twiddling", "twig", "twilight", "twine", "twins", "twirl", "twistable", "twisted", "twister", "twisting", "twisty", "twitch", "twitter", "tycoon", "tying", "tyke", "udder", "ultimate", "ultimatum", "ultra", "umbilical", "umbrella", "umpire", "unabashed", "unable", "unadorned", "unadvised", "unafraid", "unaired", "unaligned", "unaltered", "unarmored", "unashamed", "unaudited", "unawake", "unaware", "unbaked", "unbalance", "unbeaten", "unbend", "unbent", "unbiased", "unbitten", "unblended", "unblessed", "unblock", "unbolted", "unbounded", "unboxed", "unbraided", "unbridle", "unbroken", "unbuckled", "unbundle", "unburned", "unbutton", "uncanny", "uncapped", "uncaring", "uncertain", "unchain", "unchanged", "uncharted", "uncheck", "uncivil", "unclad", "unclaimed", "unclamped", "unclasp", "uncle", "unclip", "uncloak", "unclog", "unclothed", "uncoated", "uncoiled", "uncolored", "uncombed", "uncommon", "uncooked", "uncork", "uncorrupt", "uncounted", "uncouple", "uncouth", "uncover", "uncross", "uncrown", "uncrushed", "uncured", "uncurious", "uncurled", "uncut", "undamaged", "undated", "undaunted", "undead", "undecided", "undefined", "underage", "underarm", "undercoat", "undercook", "undercut", "underdog", "underdone", "underfed", "underfeed", "underfoot", "undergo", "undergrad", "underhand", "underline", "underling", "undermine", "undermost", "underpaid", "underpass", "underpay", "underrate", "undertake", "undertone", "undertook", "undertow", "underuse", "underwear", "underwent", "underwire", "undesired", "undiluted", "undivided", "undocked", "undoing", "undone", "undrafted", "undress", "undrilled", "undusted", "undying", "unearned", "unearth", "unease", "uneasily", "uneasy", "uneatable", "uneaten", "unedited", "unelected", "unending", "unengaged", "unenvied", "unequal", "unethical", "uneven", "unexpired", "unexposed", "unfailing", "unfair", "unfasten", "unfazed", "unfeeling", "unfiled", "unfilled", "unfitted", "unfitting", "unfixable", "unfixed", "unflawed", "unfocused", "unfold", "unfounded", "unframed", "unfreeze", "unfrosted", "unfrozen", "unfunded", "unglazed", "ungloved", "unglue", "ungodly", "ungraded", "ungreased", "unguarded", "unguided", "unhappily", "unhappy", "unharmed", "unhealthy", "unheard", "unhearing", "unheated", "unhelpful", "unhidden", "unhinge", "unhitched", "unholy", "unhook", "unicorn", "unicycle", "unified", "unifier", "uniformed", "uniformly", "unify", "unimpeded", "uninjured", "uninstall", "uninsured", "uninvited", "union", "uniquely", "unisexual", "unison", "unissued", "unit", "universal", "universe", "unjustly", "unkempt", "unkind", "unknotted", "unknowing", "unknown", "unlaced", "unlatch", "unlawful", "unleaded", "unlearned", "unleash", "unless", "unleveled", "unlighted", "unlikable", "unlimited", "unlined", "unlinked", "unlisted", "unlit", "unlivable", "unloaded", "unloader", "unlocked", "unlocking", "unlovable", "unloved", "unlovely", "unloving", "unluckily", "unlucky", "unmade", "unmanaged", "unmanned", "unmapped", "unmarked", "unmasked", "unmasking", "unmatched", "unmindful", "unmixable", "unmixed", "unmolded", "unmoral", "unmovable", "unmoved", "unmoving", "unnamable", "unnamed", "unnatural", "unneeded", "unnerve", "unnerving", "unnoticed", "unopened", "unopposed", "unpack", "unpadded", "unpaid", "unpainted", "unpaired", "unpaved", "unpeeled", "unpicked", "unpiloted", "unpinned", "unplanned", "unplanted", "unpleased", "unpledged", "unplowed", "unplug", "unpopular", "unproven", "unquote", "unranked", "unrated", "unraveled", "unreached", "unread", "unreal", "unreeling", "unrefined", "unrelated", "unrented", "unrest", "unretired", "unrevised", "unrigged", "unripe", "unrivaled", "unroasted", "unrobed", "unroll", "unruffled", "unruly", "unrushed", "unsaddle", "unsafe", "unsaid", "unsalted", "unsaved", "unsavory", "unscathed", "unscented", "unscrew", "unsealed", "unseated", "unsecured", "unseeing", "unseemly", "unseen", "unselect", "unselfish", "unsent", "unsettled", "unshackle", "unshaken", "unshaved", "unshaven", "unsheathe", "unshipped", "unsightly", "unsigned", "unskilled", "unsliced", "unsmooth", "unsnap", "unsocial", "unsoiled", "unsold", "unsolved", "unsorted", "unspoiled", "unspoken", "unstable", "unstaffed", "unstamped", "unsteady", "unsterile", "unstirred", "unstitch", "unstopped", "unstuck", "unstuffed", "unstylish", "unsubtle", "unsubtly", "unsuited", "unsure", "unsworn", "untagged", "untainted", "untaken", "untamed", "untangled", "untapped", "untaxed", "unthawed", "unthread", "untidy", "untie", "until", "untimed", "untimely", "untitled", "untoasted", "untold", "untouched", "untracked", "untrained", "untreated", "untried", "untrimmed", "untrue", "untruth", "unturned", "untwist", "untying", "unusable", "unused", "unusual", "unvalued", "unvaried", "unvarying", "unveiled", "unveiling", "unvented", "unviable", "unvisited", "unvocal", "unwanted", "unwarlike", "unwary", "unwashed", "unwatched", "unweave", "unwed", "unwelcome", "unwell", "unwieldy", "unwilling", "unwind", "unwired", "unwitting", "unwomanly", "unworldly", "unworn", "unworried", "unworthy", "unwound", "unwoven", "unwrapped", "unwritten", "unzip", "upbeat", "upchuck", "upcoming", "upcountry", "update", "upfront", "upgrade", "upheaval", "upheld", "uphill", "uphold", "uplifted", "uplifting", "upload", "upon", "upper", "upright", "uprising", "upriver", "uproar", "uproot", "upscale", "upside", "upstage", "upstairs", "upstart", "upstate", "upstream", "upstroke", "upswing", "uptake", "uptight", "uptown", "upturned", "upward", "upwind", "uranium", "urban", "urchin", "urethane", "urgency", "urgent", "urging", "urologist", "urology", "usable", "usage", "useable", "used", "uselessly", "user", "usher", "usual", "utensil", "utility", "utilize", "utmost", "utopia", "utter", "vacancy", "vacant", "vacate", "vacation", "vagabond", "vagrancy", "vagrantly", "vaguely", "vagueness", "valiant", "valid", "valium", "valley", "valuables", "value", "vanilla", "vanish", "vanity", "vanquish", "vantage", "vaporizer", "variable", "variably", "varied", "variety", "various", "varmint", "varnish", "varsity", "varying", "vascular", "vaseline", "vastly", "vastness", "veal", "vegan", "veggie", "vehicular", "velcro", "velocity", "velvet", "vendetta", "vending", "vendor", "veneering", "vengeful", "venomous", "ventricle", "venture", "venue", "venus", "verbalize", "verbally", "verbose", "verdict", "verify", "verse", "version", "versus", "vertebrae", "vertical", "vertigo", "very", "vessel", "vest", "veteran", "veto", "vexingly", "viability", "viable", "vibes", "vice", "vicinity", "victory", "video", "viewable", "viewer", "viewing", "viewless", "viewpoint", "vigorous", "village", "villain", "vindicate", "vineyard", "vintage", "violate", "violation", "violator", "violet", "violin", "viper", "viral", "virtual", "virtuous", "virus", "visa", "viscosity", "viscous", "viselike", "visible", "visibly", "vision", "visiting", "visitor", "visor", "vista", "vitality", "vitalize", "vitally", "vitamins", "vivacious", "vividly", "vividness", "vixen", "vocalist", "vocalize", "vocally", "vocation", "voice", "voicing", "void", "volatile", "volley", "voltage", "volumes", "voter", "voting", "voucher", "vowed", "vowel", "voyage", "wackiness", "wad", "wafer", "waffle", "waged", "wager", "wages", "waggle", "wagon", "wake", "waking", "walk", "walmart", "walnut", "walrus", "waltz", "wand", "wannabe", "wanted", "wanting", "wasabi", "washable", "washbasin", "washboard", "washbowl", "washcloth", "washday", "washed", "washer", "washhouse", "washing", "washout", "washroom", "washstand", "washtub", "wasp", "wasting", "watch", "water", "waviness", "waving", "wavy", "whacking", "whacky", "wham", "wharf", "wheat", "whenever", "whiff", "whimsical", "whinny", "whiny", "whisking", "whoever", "whole", "whomever", "whoopee", "whooping", "whoops", "why", "wick", "widely", "widen", "widget", "widow", "width", "wieldable", "wielder", "wife", "wifi", "wikipedia", "wildcard", "wildcat", "wilder", "wildfire", "wildfowl", "wildland", "wildlife", "wildly", "wildness", "willed", "willfully", "willing", "willow", "willpower", "wilt", "wimp", "wince", "wincing", "wind", "wing", "winking", "winner", "winnings", "winter", "wipe", "wired", "wireless", "wiring", "wiry", "wisdom", "wise", "wish", "wisplike", "wispy", "wistful", "wizard", "wobble", "wobbling", "wobbly", "wok", "wolf", "wolverine", "womanhood", "womankind", "womanless", "womanlike", "womanly", "womb", "woof", "wooing", "wool", "woozy", "word", "work", "worried", "worrier", "worrisome", "worry", "worsening", "worshiper", "worst", "wound", "woven", "wow", "wrangle", "wrath", "wreath", "wreckage", "wrecker", "wrecking", "wrench", "wriggle", "wriggly", "wrinkle", "wrinkly", "wrist", "writing", "written", "wrongdoer", "wronged", "wrongful", "wrongly", "wrongness", "wrought", "xbox", "xerox", "yahoo", "yam", "yanking", "yapping", "yard", "yarn", "yeah", "yearbook", "yearling", "yearly", "yearning", "yeast", "yelling", "yelp", "yen", "yesterday", "yiddish", "yield", "yin", "yippee", "yo-yo", "yodel", "yoga", "yogurt", "yonder", "yoyo", "yummy", "zap", "zealous", "zebra", "zen", "zeppelin", "zero", "zestfully", "zesty", "zigzagged", "zipfile", "zipping", "zippy", "zips", "zit", "zodiac", "zombie", "zone", "zoning", "zookeeper", "zoologist", "zoology", "zoom"];
Object.defineProperty(newSecureWords$1, "__esModule", {
    value: !0
});
newSecureWords$1.newSecureWords = void 0;
const getSecureRandom_1$1 = getSecureRandom
  , wordlist_1$1 = wordlist$1;
async function newSecureWords(r=6) {
    let d = [];
    for (let f = 0; f < r; f++)
        d.push(wordlist_1$1.wordlist[await (0,
        getSecureRandom_1$1.getSecureRandomNumber)(0, wordlist_1$1.wordlist.length)]);
    return d
}
newSecureWords$1.newSecureWords = newSecureWords;
var newSecurePassphrase = {}, hasRequiredNewSecurePassphrase;
function requireNewSecurePassphrase() {
    if (hasRequiredNewSecurePassphrase)
        return newSecurePassphrase;
    hasRequiredNewSecurePassphrase = 1,
    Object.defineProperty(newSecurePassphrase, "__esModule", {
        value: !0
    }),
    newSecurePassphrase.newSecurePassphrase = void 0;
    const r = requireDist();
    async function d(f=6) {
        return (await (0,
        r.newSecureWords)(f)).join("-")
    }
    return newSecurePassphrase.newSecurePassphrase = d,
    newSecurePassphrase
}
var mnemonic = {}
  , binary = {};
Object.defineProperty(binary, "__esModule", {
    value: !0
});
binary.bitsToBytes = binary.bytesToBits = binary.lpad = void 0;
function lpad(r, d, f) {
    for (; r.length < f; )
        r = d + r;
    return r
}
binary.lpad = lpad;
function bytesToBits(r) {
    let d = "";
    for (let f = 0; f < r.length; f++) {
        let m = r.at(f);
        d += lpad(m.toString(2), "0", 8)
    }
    return d
}
binary.bytesToBits = bytesToBits;
function bitsToBytes(r) {
    if (r.length % 8 !== 0)
        throw Error("Uneven bits");
    let d = [];
    for (; r.length > 0; )
        d.push(parseInt(r.slice(0, 8), 2)),
        r = r.slice(8);
    return Buffer.from(d)
}
binary.bitsToBytes = bitsToBytes;
var wordlist = {};
Object.defineProperty(wordlist, "__esModule", {
    value: !0
});
wordlist.wordlist = void 0;
const EN = ["abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent", "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger", "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique", "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction", "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become", "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body", "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb", "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy", "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry", "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century", "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase", "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child", "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close", "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut", "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control", "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle", "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial", "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad", "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal", "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense", "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance", "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain", "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo", "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough", "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip", "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate", "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit", "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since", "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"];
wordlist.wordlist = EN;
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(r) {
    return r && r.__esModule ? r : {
        default: r
    }
}
;
Object.defineProperty(mnemonic, "__esModule", {
    value: !0
});
mnemonic.mnemonicFromRandomSeed = mnemonic.mnemonicIndexesToBytes = mnemonic.bytesToMnemonics = mnemonic.bytesToMnemonicIndexes = mnemonic.mnemonicNew = mnemonic.mnemonicValidate = mnemonic.mnemonicToHDSeed = mnemonic.mnemonicToWalletKey = mnemonic.mnemonicToPrivateKey = mnemonic.mnemonicToSeed = mnemonic.mnemonicToEntropy = void 0;
const tweetnacl_1$1 = __importDefault$4(naclFastExports)
  , getSecureRandom_1 = getSecureRandom
  , hmac_sha512_1$3 = hmac_sha512$1
  , pbkdf2_sha512_1 = pbkdf2_sha512$1
  , binary_1 = binary
  , wordlist_1 = wordlist
  , PBKDF_ITERATIONS = 1e5;
async function isPasswordNeeded(r) {
    const d = await mnemonicToEntropy(r);
    return await isPasswordSeed(d) && !await isBasicSeed(d)
}
function normalizeMnemonic(r) {
    return r.map(d=>d.toLowerCase().trim())
}
async function isBasicSeed(r) {
    return (await (0,
    pbkdf2_sha512_1.pbkdf2_sha512)(r, "TON seed version", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), 64))[0] == 0
}
async function isPasswordSeed(r) {
    return (await (0,
    pbkdf2_sha512_1.pbkdf2_sha512)(r, "TON fast seed version", 1, 64))[0] == 1
}
async function mnemonicToEntropy(r, d) {
    return await (0,
    hmac_sha512_1$3.hmac_sha512)(r.join(" "), d && d.length > 0 ? d : "")
}
mnemonic.mnemonicToEntropy = mnemonicToEntropy;
async function mnemonicToSeed(r, d, f) {
    const m = await mnemonicToEntropy(r, f);
    return await (0,
    pbkdf2_sha512_1.pbkdf2_sha512)(m, d, PBKDF_ITERATIONS, 64)
}
mnemonic.mnemonicToSeed = mnemonicToSeed;
async function mnemonicToPrivateKey(r, d) {
    r = normalizeMnemonic(r);
    const f = await mnemonicToSeed(r, "TON default seed", d);
    let m = tweetnacl_1$1.default.sign.keyPair.fromSeed(f.slice(0, 32));
    return {
        publicKey: Buffer.from(m.publicKey),
        secretKey: Buffer.from(m.secretKey)
    }
}
mnemonic.mnemonicToPrivateKey = mnemonicToPrivateKey;
async function mnemonicToWalletKey(r, d) {
    let m = (await mnemonicToPrivateKey(r, d)).secretKey.slice(0, 32);
    const k = tweetnacl_1$1.default.sign.keyPair.fromSeed(m);
    return {
        publicKey: Buffer.from(k.publicKey),
        secretKey: Buffer.from(k.secretKey)
    }
}
mnemonic.mnemonicToWalletKey = mnemonicToWalletKey;
async function mnemonicToHDSeed(r, d) {
    return r = normalizeMnemonic(r),
    await mnemonicToSeed(r, "TON HD Keys seed", d)
}
mnemonic.mnemonicToHDSeed = mnemonicToHDSeed;
async function mnemonicValidate(r, d) {
    r = normalizeMnemonic(r);
    for (let f of r)
        if (wordlist_1.wordlist.indexOf(f) < 0)
            return !1;
    return d && d.length > 0 && !await isPasswordNeeded(r) ? !1 : await isBasicSeed(await mnemonicToEntropy(r, d))
}
mnemonic.mnemonicValidate = mnemonicValidate;
async function mnemonicNew(r=24, d) {
    let f = [];
    for (; ; ) {
        f = [];
        for (let m = 0; m < r; m++) {
            let k = await (0,
            getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length);
            f.push(wordlist_1.wordlist[k])
        }
        if (!(d && d.length > 0 && !await isPasswordNeeded(f)) && await isBasicSeed(await mnemonicToEntropy(f, d)))
            break
    }
    return f
}
mnemonic.mnemonicNew = mnemonicNew;
function bytesToMnemonicIndexes(r, d) {
    let f = (0,
    binary_1.bytesToBits)(r)
      , m = [];
    for (let k = 0; k < d; k++) {
        let y = f.slice(k * 11, k * 11 + 11);
        m.push(parseInt(y, 2))
    }
    return m
}
mnemonic.bytesToMnemonicIndexes = bytesToMnemonicIndexes;
function bytesToMnemonics(r, d) {
    let f = bytesToMnemonicIndexes(r, d)
      , m = [];
    for (let k of f)
        m.push(wordlist_1.wordlist[k]);
    return m
}
mnemonic.bytesToMnemonics = bytesToMnemonics;
function mnemonicIndexesToBytes(r) {
    let d = "";
    for (let f of r) {
        if (!Number.isSafeInteger(f) || f < 0 || f >= 2028)
            throw Error("Invalid input");
        d += (0,
        binary_1.lpad)(f.toString(2), "0", 11)
    }
    for (; d.length % 8 !== 0; )
        d = d + "0";
    return (0,
    binary_1.bitsToBytes)(d)
}
mnemonic.mnemonicIndexesToBytes = mnemonicIndexesToBytes;
async function mnemonicFromRandomSeed(r, d=24, f) {
    const m = Math.ceil(d * 11 / 8);
    let k = r;
    for (; ; ) {
        let y = await (0,
        pbkdf2_sha512_1.pbkdf2_sha512)(k, "TON mnemonic seed", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), m)
          , ee = bytesToMnemonics(y, d);
        if (await mnemonicValidate(ee, f))
            return ee;
        k = y
    }
}
mnemonic.mnemonicFromRandomSeed = mnemonicFromRandomSeed;
var nacl = {}
  , __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(r) {
    return r && r.__esModule ? r : {
        default: r
    }
}
;
Object.defineProperty(nacl, "__esModule", {
    value: !0
});
nacl.openBox = nacl.sealBox = nacl.signVerify = nacl.sign = nacl.keyPairFromSeed = nacl.keyPairFromSecretKey = void 0;
const tweetnacl_1 = __importDefault$3(naclFastExports);
function keyPairFromSecretKey(r) {
    let d = tweetnacl_1.default.sign.keyPair.fromSecretKey(new Uint8Array(r));
    return {
        publicKey: Buffer.from(d.publicKey),
        secretKey: Buffer.from(d.secretKey)
    }
}
nacl.keyPairFromSecretKey = keyPairFromSecretKey;
function keyPairFromSeed(r) {
    let d = tweetnacl_1.default.sign.keyPair.fromSeed(new Uint8Array(r));
    return {
        publicKey: Buffer.from(d.publicKey),
        secretKey: Buffer.from(d.secretKey)
    }
}
nacl.keyPairFromSeed = keyPairFromSeed;
function sign(r, d) {
    return Buffer.from(tweetnacl_1.default.sign.detached(new Uint8Array(r), new Uint8Array(d)))
}
nacl.sign = sign;
function signVerify(r, d, f) {
    return tweetnacl_1.default.sign.detached.verify(new Uint8Array(r), new Uint8Array(d), new Uint8Array(f))
}
nacl.signVerify = signVerify;
function sealBox(r, d, f) {
    return Buffer.from(tweetnacl_1.default.secretbox(r, d, f))
}
nacl.sealBox = sealBox;
function openBox(r, d, f) {
    let m = tweetnacl_1.default.secretbox.open(r, d, f);
    return m ? Buffer.from(m) : null
}
nacl.openBox = openBox;
var ed25519 = {};
Object.defineProperty(ed25519, "__esModule", {
    value: !0
});
ed25519.deriveEd25519Path = ed25519.deriveED25519HardenedKey = ed25519.getED25519MasterKeyFromSeed = void 0;
const hmac_sha512_1$2 = hmac_sha512$1
  , ED25519_CURVE = "ed25519 seed"
  , HARDENED_OFFSET$1 = 2147483648;
async function getED25519MasterKeyFromSeed(r) {
    const d = await (0,
    hmac_sha512_1$2.hmac_sha512)(ED25519_CURVE, r)
      , f = d.slice(0, 32)
      , m = d.slice(32);
    return {
        key: f,
        chainCode: m
    }
}
ed25519.getED25519MasterKeyFromSeed = getED25519MasterKeyFromSeed;
async function deriveED25519HardenedKey(r, d) {
    if (d >= HARDENED_OFFSET$1)
        throw Error("Key index must be less than offset");
    const f = Buffer.alloc(4);
    f.writeUInt32BE(d + HARDENED_OFFSET$1, 0);
    const m = Buffer.concat([Buffer.alloc(1, 0), r.key, f])
      , k = await (0,
    hmac_sha512_1$2.hmac_sha512)(r.chainCode, m)
      , y = k.slice(0, 32)
      , ee = k.slice(32);
    return {
        key: y,
        chainCode: ee
    }
}
ed25519.deriveED25519HardenedKey = deriveED25519HardenedKey;
async function deriveEd25519Path(r, d) {
    let f = await getED25519MasterKeyFromSeed(r)
      , m = [...d];
    for (; m.length > 0; ) {
        let k = m[0];
        m = m.slice(1),
        f = await deriveED25519HardenedKey(f, k)
    }
    return f.key
}
ed25519.deriveEd25519Path = deriveEd25519Path;
var symmetric = {};
Object.defineProperty(symmetric, "__esModule", {
    value: !0
});
symmetric.deriveSymmetricPath = symmetric.deriveSymmetricHardenedKey = symmetric.getSymmetricMasterKeyFromSeed = void 0;
const hmac_sha512_1$1 = hmac_sha512$1
  , SYMMETRIC_SEED = "Symmetric key seed";
async function getSymmetricMasterKeyFromSeed(r) {
    const d = await (0,
    hmac_sha512_1$1.hmac_sha512)(SYMMETRIC_SEED, r)
      , f = d.slice(32)
      , m = d.slice(0, 32);
    return {
        key: f,
        chainCode: m
    }
}
symmetric.getSymmetricMasterKeyFromSeed = getSymmetricMasterKeyFromSeed;
async function deriveSymmetricHardenedKey(r, d) {
    const f = Buffer.concat([Buffer.alloc(1, 0), Buffer.from(d)])
      , m = await (0,
    hmac_sha512_1$1.hmac_sha512)(r.chainCode, f)
      , k = m.slice(32)
      , y = m.slice(0, 32);
    return {
        key: k,
        chainCode: y
    }
}
symmetric.deriveSymmetricHardenedKey = deriveSymmetricHardenedKey;
async function deriveSymmetricPath(r, d) {
    let f = await getSymmetricMasterKeyFromSeed(r)
      , m = [...d];
    for (; m.length > 0; ) {
        let k = m[0];
        m = m.slice(1),
        f = await deriveSymmetricHardenedKey(f, k)
    }
    return f.key
}
symmetric.deriveSymmetricPath = deriveSymmetricPath;
var mnemonics = {};
Object.defineProperty(mnemonics, "__esModule", {
    value: !0
});
mnemonics.deriveMnemonicsPath = mnemonics.deriveMnemonicHardenedKey = mnemonics.getMnemonicsMasterKeyFromSeed = void 0;
const mnemonic_1 = mnemonic
  , hmac_sha512_1 = hmac_sha512$1
  , HARDENED_OFFSET = 2147483648
  , MNEMONICS_SEED = "TON Mnemonics HD seed";
async function getMnemonicsMasterKeyFromSeed(r) {
    const d = await (0,
    hmac_sha512_1.hmac_sha512)(MNEMONICS_SEED, r)
      , f = d.slice(0, 32)
      , m = d.slice(32);
    return {
        key: f,
        chainCode: m
    }
}
mnemonics.getMnemonicsMasterKeyFromSeed = getMnemonicsMasterKeyFromSeed;
async function deriveMnemonicHardenedKey(r, d) {
    if (d >= HARDENED_OFFSET)
        throw Error("Key index must be less than offset");
    const f = Buffer.alloc(4);
    f.writeUInt32BE(d + HARDENED_OFFSET, 0);
    const m = Buffer.concat([Buffer.alloc(1, 0), r.key, f])
      , k = await (0,
    hmac_sha512_1.hmac_sha512)(r.chainCode, m)
      , y = k.slice(0, 32)
      , ee = k.slice(32);
    return {
        key: y,
        chainCode: ee
    }
}
mnemonics.deriveMnemonicHardenedKey = deriveMnemonicHardenedKey;
async function deriveMnemonicsPath(r, d, f=24, m) {
    let k = await getMnemonicsMasterKeyFromSeed(r)
      , y = [...d];
    for (; y.length > 0; ) {
        let ee = y[0];
        y = y.slice(1),
        k = await deriveMnemonicHardenedKey(k, ee)
    }
    return await (0,
    mnemonic_1.mnemonicFromRandomSeed)(k.key, f, m)
}
mnemonics.deriveMnemonicsPath = deriveMnemonicsPath;
var hasRequiredDist;
function requireDist() {
    return hasRequiredDist || (hasRequiredDist = 1,
    function(r) {
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.getMnemonicsMasterKeyFromSeed = r.deriveMnemonicHardenedKey = r.deriveMnemonicsPath = r.deriveSymmetricPath = r.deriveSymmetricHardenedKey = r.getSymmetricMasterKeyFromSeed = r.deriveEd25519Path = r.deriveED25519HardenedKey = r.getED25519MasterKeyFromSeed = r.signVerify = r.sign = r.keyPairFromSecretKey = r.keyPairFromSeed = r.openBox = r.sealBox = r.mnemonicWordList = r.mnemonicToHDSeed = r.mnemonicToSeed = r.mnemonicToWalletKey = r.mnemonicToPrivateKey = r.mnemonicValidate = r.mnemonicNew = r.newSecurePassphrase = r.newSecureWords = r.getSecureRandomNumber = r.getSecureRandomWords = r.getSecureRandomBytes = r.hmac_sha512 = r.pbkdf2_sha512 = r.sha512_sync = r.sha512 = r.sha256_sync = r.sha256 = void 0;
        var d = sha256$3;
        Object.defineProperty(r, "sha256", {
            enumerable: !0,
            get: function() {
                return d.sha256
            }
        }),
        Object.defineProperty(r, "sha256_sync", {
            enumerable: !0,
            get: function() {
                return d.sha256_sync
            }
        });
        var f = sha512$1;
        Object.defineProperty(r, "sha512", {
            enumerable: !0,
            get: function() {
                return f.sha512
            }
        }),
        Object.defineProperty(r, "sha512_sync", {
            enumerable: !0,
            get: function() {
                return f.sha512_sync
            }
        });
        var m = pbkdf2_sha512$1;
        Object.defineProperty(r, "pbkdf2_sha512", {
            enumerable: !0,
            get: function() {
                return m.pbkdf2_sha512
            }
        });
        var k = hmac_sha512$1;
        Object.defineProperty(r, "hmac_sha512", {
            enumerable: !0,
            get: function() {
                return k.hmac_sha512
            }
        });
        var y = getSecureRandom;
        Object.defineProperty(r, "getSecureRandomBytes", {
            enumerable: !0,
            get: function() {
                return y.getSecureRandomBytes
            }
        }),
        Object.defineProperty(r, "getSecureRandomWords", {
            enumerable: !0,
            get: function() {
                return y.getSecureRandomWords
            }
        }),
        Object.defineProperty(r, "getSecureRandomNumber", {
            enumerable: !0,
            get: function() {
                return y.getSecureRandomNumber
            }
        });
        var ee = newSecureWords$1;
        Object.defineProperty(r, "newSecureWords", {
            enumerable: !0,
            get: function() {
                return ee.newSecureWords
            }
        });
        var dt = requireNewSecurePassphrase();
        Object.defineProperty(r, "newSecurePassphrase", {
            enumerable: !0,
            get: function() {
                return dt.newSecurePassphrase
            }
        });
        var mt = mnemonic;
        Object.defineProperty(r, "mnemonicNew", {
            enumerable: !0,
            get: function() {
                return mt.mnemonicNew
            }
        }),
        Object.defineProperty(r, "mnemonicValidate", {
            enumerable: !0,
            get: function() {
                return mt.mnemonicValidate
            }
        }),
        Object.defineProperty(r, "mnemonicToPrivateKey", {
            enumerable: !0,
            get: function() {
                return mt.mnemonicToPrivateKey
            }
        }),
        Object.defineProperty(r, "mnemonicToWalletKey", {
            enumerable: !0,
            get: function() {
                return mt.mnemonicToWalletKey
            }
        }),
        Object.defineProperty(r, "mnemonicToSeed", {
            enumerable: !0,
            get: function() {
                return mt.mnemonicToSeed
            }
        }),
        Object.defineProperty(r, "mnemonicToHDSeed", {
            enumerable: !0,
            get: function() {
                return mt.mnemonicToHDSeed
            }
        });
        var yt = wordlist;
        Object.defineProperty(r, "mnemonicWordList", {
            enumerable: !0,
            get: function() {
                return yt.wordlist
            }
        });
        var pt = nacl;
        Object.defineProperty(r, "sealBox", {
            enumerable: !0,
            get: function() {
                return pt.sealBox
            }
        }),
        Object.defineProperty(r, "openBox", {
            enumerable: !0,
            get: function() {
                return pt.openBox
            }
        });
        var bt = nacl;
        Object.defineProperty(r, "keyPairFromSeed", {
            enumerable: !0,
            get: function() {
                return bt.keyPairFromSeed
            }
        }),
        Object.defineProperty(r, "keyPairFromSecretKey", {
            enumerable: !0,
            get: function() {
                return bt.keyPairFromSecretKey
            }
        }),
        Object.defineProperty(r, "sign", {
            enumerable: !0,
            get: function() {
                return bt.sign
            }
        }),
        Object.defineProperty(r, "signVerify", {
            enumerable: !0,
            get: function() {
                return bt.signVerify
            }
        });
        var wt = ed25519;
        Object.defineProperty(r, "getED25519MasterKeyFromSeed", {
            enumerable: !0,
            get: function() {
                return wt.getED25519MasterKeyFromSeed
            }
        }),
        Object.defineProperty(r, "deriveED25519HardenedKey", {
            enumerable: !0,
            get: function() {
                return wt.deriveED25519HardenedKey
            }
        }),
        Object.defineProperty(r, "deriveEd25519Path", {
            enumerable: !0,
            get: function() {
                return wt.deriveEd25519Path
            }
        });
        var xt = symmetric;
        Object.defineProperty(r, "getSymmetricMasterKeyFromSeed", {
            enumerable: !0,
            get: function() {
                return xt.getSymmetricMasterKeyFromSeed
            }
        }),
        Object.defineProperty(r, "deriveSymmetricHardenedKey", {
            enumerable: !0,
            get: function() {
                return xt.deriveSymmetricHardenedKey
            }
        }),
        Object.defineProperty(r, "deriveSymmetricPath", {
            enumerable: !0,
            get: function() {
                return xt.deriveSymmetricPath
            }
        });
        var At = mnemonics;
        Object.defineProperty(r, "deriveMnemonicsPath", {
            enumerable: !0,
            get: function() {
                return At.deriveMnemonicsPath
            }
        }),
        Object.defineProperty(r, "deriveMnemonicHardenedKey", {
            enumerable: !0,
            get: function() {
                return At.deriveMnemonicHardenedKey
            }
        }),
        Object.defineProperty(r, "getMnemonicsMasterKeyFromSeed", {
            enumerable: !0,
            get: function() {
                return At.getMnemonicsMasterKeyFromSeed
            }
        })
    }(dist)),
    dist
}
Object.defineProperty(wonderCalculator$1, "__esModule", {
    value: !0
});
wonderCalculator$1.wonderCalculator = void 0;
const BitString_1 = requireBitString()
  , CellType_1 = CellType$1
  , LevelMask_1 = LevelMask$1
  , exoticPruned_1 = exoticPruned$1
  , exoticMerkleProof_1 = exoticMerkleProof$1
  , descriptor_1 = descriptor
  , crypto_1$4 = requireDist()
  , exoticMerkleUpdate_1 = exoticMerkleUpdate$1
  , exoticLibrary_1 = exoticLibrary$1;
function wonderCalculator(r, d, f) {
    let m, k = null;
    if (r === CellType_1.CellType.Ordinary) {
        let wt = 0;
        for (let xt of f)
            wt = wt | xt.mask.value;
        m = new LevelMask_1.LevelMask(wt)
    } else if (r === CellType_1.CellType.PrunedBranch)
        k = (0,
        exoticPruned_1.exoticPruned)(d, f),
        m = new LevelMask_1.LevelMask(k.mask);
    else if (r === CellType_1.CellType.MerkleProof)
        (0,
        exoticMerkleProof_1.exoticMerkleProof)(d, f),
        m = new LevelMask_1.LevelMask(f[0].mask.value >> 1);
    else if (r === CellType_1.CellType.MerkleUpdate)
        (0,
        exoticMerkleUpdate_1.exoticMerkleUpdate)(d, f),
        m = new LevelMask_1.LevelMask((f[0].mask.value | f[1].mask.value) >> 1);
    else if (r === CellType_1.CellType.Library)
        (0,
        exoticLibrary_1.exoticLibrary)(d, f),
        m = new LevelMask_1.LevelMask;
    else
        throw new Error("Unsupported exotic type");
    let y = []
      , ee = []
      , dt = r === CellType_1.CellType.PrunedBranch ? 1 : m.hashCount
      , yt = m.hashCount - dt;
    for (let wt = 0, xt = 0; wt <= m.level; wt++) {
        if (!m.isSignificant(wt))
            continue;
        if (xt < yt) {
            xt++;
            continue
        }
        let At;
        if (xt === yt) {
            if (!(wt === 0 || r === CellType_1.CellType.PrunedBranch))
                throw Error("Invalid");
            At = d
        } else {
            if (!(wt !== 0 && r !== CellType_1.CellType.PrunedBranch))
                throw Error("Invalid: " + wt + ", " + r);
            At = new BitString_1.BitString(ee[xt - yt - 1],0,256)
        }
        let Ct = 0;
        for (let Nt of f) {
            let zt;
            r == CellType_1.CellType.MerkleProof || r == CellType_1.CellType.MerkleUpdate ? zt = Nt.depth(wt + 1) : zt = Nt.depth(wt),
            Ct = Math.max(Ct, zt)
        }
        f.length > 0 && Ct++;
        let Pt = (0,
        descriptor_1.getRepr)(d, At, f, wt, m.apply(wt).value, r)
          , $t = (0,
        crypto_1$4.sha256_sync)(Pt)
          , Ot = xt - yt;
        y[Ot] = Ct,
        ee[Ot] = $t,
        xt++
    }
    let pt = []
      , bt = [];
    if (k)
        for (let wt = 0; wt < 4; wt++) {
            const {hashIndex: xt} = m.apply(wt)
              , {hashIndex: At} = m;
            xt !== At ? (pt.push(k.pruned[xt].hash),
            bt.push(k.pruned[xt].depth)) : (pt.push(ee[0]),
            bt.push(y[0]))
        }
    else
        for (let wt = 0; wt < 4; wt++)
            pt.push(ee[m.apply(wt).hashIndex]),
            bt.push(y[m.apply(wt).hashIndex]);
    return {
        mask: m,
        hashes: pt,
        depths: bt
    }
}
wonderCalculator$1.wonderCalculator = wonderCalculator;
var serialization = {}
  , topologicalSort$1 = {};
Object.defineProperty(topologicalSort$1, "__esModule", {
    value: !0
});
topologicalSort$1.topologicalSort = void 0;
function topologicalSort(r) {
    let d = [r]
      , f = new Map
      , m = new Set
      , k = [];
    for (; d.length > 0; ) {
        const yt = [...d];
        d = [];
        for (let pt of yt) {
            const bt = pt.hash().toString("hex");
            if (!f.has(bt)) {
                m.add(bt),
                f.set(bt, {
                    cell: pt,
                    refs: pt.refs.map(wt=>wt.hash().toString("hex"))
                });
                for (let wt of pt.refs)
                    d.push(wt)
            }
        }
    }
    let y = new Set;
    function ee(yt) {
        if (!m.has(yt))
            return;
        if (y.has(yt))
            throw Error("Not a DAG");
        y.add(yt);
        let pt = f.get(yt).refs;
        for (let bt = pt.length - 1; bt >= 0; bt--)
            ee(pt[bt]);
        k.push(yt),
        y.delete(yt),
        m.delete(yt)
    }
    for (; m.size > 0; ) {
        const yt = Array.from(m)[0];
        ee(yt)
    }
    let dt = new Map;
    for (let yt = 0; yt < k.length; yt++)
        dt.set(k[k.length - yt - 1], yt);
    let mt = [];
    for (let yt = k.length - 1; yt >= 0; yt--) {
        let pt = k[yt];
        const bt = f.get(pt);
        mt.push({
            cell: bt.cell,
            refs: bt.refs.map(wt=>dt.get(wt))
        })
    }
    return mt
}
topologicalSort$1.topologicalSort = topologicalSort;
var bitsForNumber$1 = {};
Object.defineProperty(bitsForNumber$1, "__esModule", {
    value: !0
});
bitsForNumber$1.bitsForNumber = void 0;
function bitsForNumber(r, d) {
    let f = BigInt(r);
    if (d === "int")
        return f === 0n || f === -1n ? 1 : (f > 0 ? f : -f).toString(2).length + 1;
    if (d === "uint") {
        if (f < 0)
            throw Error(`value is negative. Got ${r}`);
        return f.toString(2).length
    } else
        throw Error(`invalid mode. Got ${d}`)
}
bitsForNumber$1.bitsForNumber = bitsForNumber;
var crc32c$1 = {};
Object.defineProperty(crc32c$1, "__esModule", {
    value: !0
});
crc32c$1.crc32c = void 0;
const POLY = 2197175160;
function crc32c(r) {
    let d = -1;
    for (let m = 0; m < r.length; m++)
        d ^= r[m],
        d = d & 1 ? d >>> 1 ^ POLY : d >>> 1,
        d = d & 1 ? d >>> 1 ^ POLY : d >>> 1,
        d = d & 1 ? d >>> 1 ^ POLY : d >>> 1,
        d = d & 1 ? d >>> 1 ^ POLY : d >>> 1,
        d = d & 1 ? d >>> 1 ^ POLY : d >>> 1,
        d = d & 1 ? d >>> 1 ^ POLY : d >>> 1,
        d = d & 1 ? d >>> 1 ^ POLY : d >>> 1,
        d = d & 1 ? d >>> 1 ^ POLY : d >>> 1;
    d = d ^ 4294967295;
    let f = Buffer.alloc(4);
    return f.writeInt32LE(d),
    f
}
crc32c$1.crc32c = crc32c;
var hasRequiredSerialization;
function requireSerialization() {
    if (hasRequiredSerialization)
        return serialization;
    hasRequiredSerialization = 1,
    Object.defineProperty(serialization, "__esModule", {
        value: !0
    }),
    serialization.serializeBoc = serialization.deserializeBoc = serialization.parseBoc = void 0;
    const r = BitReader$1
      , d = requireBitString()
      , f = requireCell()
      , m = topologicalSort$1
      , k = bitsForNumber$1
      , y = requireBitBuilder()
      , ee = descriptor
      , dt = requirePaddedBits()
      , mt = crc32c$1;
    function yt($t) {
        return pt($t & 7)
    }
    function pt($t) {
        let Ot = 0;
        for (let Nt = 0; Nt < 3; Nt++)
            Ot += $t & 1,
            $t = $t >> 1;
        return Ot + 1
    }
    function bt($t, Ot) {
        const Nt = $t.loadUint(8)
          , zt = Nt % 8
          , Wt = !!(Nt & 8)
          , Kt = $t.loadUint(8)
          , ir = Math.ceil(Kt / 2)
          , or = !!(Kt % 2)
          , tr = Nt >> 5
          , wr = (Nt & 16) != 0
          , Mt = wr ? yt(tr) * 32 : 0
          , _t = wr ? yt(tr) * 2 : 0;
        $t.skip(Mt * 8),
        $t.skip(_t * 8);
        let gt = d.BitString.EMPTY;
        ir > 0 && (or ? gt = $t.loadPaddedBits(ir * 8) : gt = $t.loadBits(ir * 8));
        let vt = [];
        for (let Et = 0; Et < zt; Et++)
            vt.push($t.loadUint(Ot * 8));
        return {
            bits: gt,
            refs: vt,
            exotic: Wt
        }
    }
    function wt($t, Ot) {
        return 2 + Math.ceil($t.bits.length / 8) + $t.refs.length * Ot
    }
    function xt($t) {
        let Ot = new r.BitReader(new d.BitString($t,0,$t.length * 8))
          , Nt = Ot.loadUint(32);
        if (Nt === 1761568243) {
            let zt = Ot.loadUint(8)
              , Wt = Ot.loadUint(8)
              , Kt = Ot.loadUint(zt * 8)
              , ir = Ot.loadUint(zt * 8)
              , or = Ot.loadUint(zt * 8)
              , tr = Ot.loadUint(Wt * 8)
              , wr = Ot.loadBuffer(Kt * Wt)
              , Ht = Ot.loadBuffer(tr);
            return {
                size: zt,
                offBytes: Wt,
                cells: Kt,
                roots: ir,
                absent: or,
                totalCellSize: tr,
                index: wr,
                cellData: Ht,
                root: [0]
            }
        } else if (Nt === 2898503464) {
            let zt = Ot.loadUint(8)
              , Wt = Ot.loadUint(8)
              , Kt = Ot.loadUint(zt * 8)
              , ir = Ot.loadUint(zt * 8)
              , or = Ot.loadUint(zt * 8)
              , tr = Ot.loadUint(Wt * 8)
              , wr = Ot.loadBuffer(Kt * Wt)
              , Ht = Ot.loadBuffer(tr)
              , Mt = Ot.loadBuffer(4);
            if (!(0,
            mt.crc32c)($t.subarray(0, $t.length - 4)).equals(Mt))
                throw Error("Invalid CRC32C");
            return {
                size: zt,
                offBytes: Wt,
                cells: Kt,
                roots: ir,
                absent: or,
                totalCellSize: tr,
                index: wr,
                cellData: Ht,
                root: [0]
            }
        } else if (Nt === 3052313714) {
            let zt = Ot.loadUint(1)
              , Wt = Ot.loadUint(1);
            Ot.loadUint(1),
            Ot.loadUint(2);
            let Kt = Ot.loadUint(3)
              , ir = Ot.loadUint(8)
              , or = Ot.loadUint(Kt * 8)
              , tr = Ot.loadUint(Kt * 8)
              , wr = Ot.loadUint(Kt * 8)
              , Ht = Ot.loadUint(ir * 8)
              , Mt = [];
            for (let vt = 0; vt < tr; vt++)
                Mt.push(Ot.loadUint(Kt * 8));
            let _t = null;
            zt && (_t = Ot.loadBuffer(or * ir));
            let gt = Ot.loadBuffer(Ht);
            if (Wt) {
                let vt = Ot.loadBuffer(4);
                if (!(0,
                mt.crc32c)($t.subarray(0, $t.length - 4)).equals(vt))
                    throw Error("Invalid CRC32C")
            }
            return {
                size: Kt,
                offBytes: ir,
                cells: or,
                roots: tr,
                absent: wr,
                totalCellSize: Ht,
                index: _t,
                cellData: gt,
                root: Mt
            }
        } else
            throw Error("Invalid magic")
    }
    serialization.parseBoc = xt;
    function At($t) {
        let Ot = xt($t)
          , Nt = new r.BitReader(new d.BitString(Ot.cellData,0,Ot.cellData.length * 8))
          , zt = [];
        for (let Kt = 0; Kt < Ot.cells; Kt++) {
            let ir = bt(Nt, Ot.size);
            zt.push({
                ...ir,
                result: null
            })
        }
        for (let Kt = zt.length - 1; Kt >= 0; Kt--) {
            if (zt[Kt].result)
                throw Error("Impossible");
            let ir = [];
            for (let or of zt[Kt].refs) {
                if (!zt[or].result)
                    throw Error("Invalid BOC file");
                ir.push(zt[or].result)
            }
            zt[Kt].result = new f.Cell({
                bits: zt[Kt].bits,
                refs: ir,
                exotic: zt[Kt].exotic
            })
        }
        let Wt = [];
        for (let Kt = 0; Kt < Ot.root.length; Kt++)
            Wt.push(zt[Ot.root[Kt]].result);
        return Wt
    }
    serialization.deserializeBoc = At;
    function Ct($t, Ot, Nt, zt) {
        let Wt = (0,
        ee.getRefsDescriptor)($t.refs, $t.mask.value, $t.type)
          , Kt = (0,
        ee.getBitsDescriptor)($t.bits);
        zt.writeUint(Wt, 8),
        zt.writeUint(Kt, 8),
        zt.writeBuffer((0,
        dt.bitsToPaddedBuffer)($t.bits));
        for (let ir of Ot)
            zt.writeUint(ir, Nt * 8)
    }
    function Pt($t, Ot) {
        let Nt = (0,
        m.topologicalSort)($t)
          , zt = Nt.length
          , Wt = Ot.idx
          , Kt = Ot.crc32
          , ir = !1
          , or = 0
          , tr = Math.max(Math.ceil((0,
        k.bitsForNumber)(zt, "uint") / 8), 1)
          , wr = 0
          , Ht = [];
        for (let Et of Nt) {
            let Bt = wt(Et.cell, tr);
            wr += Bt,
            Ht.push(wr)
        }
        let Mt = Math.max(Math.ceil((0,
        k.bitsForNumber)(wr, "uint") / 8), 1)
          , _t = (6 + 3 * tr + Mt + 1 * tr + (Wt ? zt * Mt : 0) + wr + (Kt ? 4 : 0)) * 8
          , gt = new y.BitBuilder(_t);
        if (gt.writeUint(3052313714, 32),
        gt.writeBit(Wt),
        gt.writeBit(Kt),
        gt.writeBit(ir),
        gt.writeUint(or, 2),
        gt.writeUint(tr, 3),
        gt.writeUint(Mt, 8),
        gt.writeUint(zt, tr * 8),
        gt.writeUint(1, tr * 8),
        gt.writeUint(0, tr * 8),
        gt.writeUint(wr, Mt * 8),
        gt.writeUint(0, tr * 8),
        Wt)
            for (let Et = 0; Et < zt; Et++)
                gt.writeUint(Ht[Et], Mt * 8);
        for (let Et = 0; Et < zt; Et++)
            Ct(Nt[Et].cell, Nt[Et].refs, tr, gt);
        if (Kt) {
            let Et = (0,
            mt.crc32c)(gt.buffer());
            gt.writeBuffer(Et)
        }
        let vt = gt.buffer();
        if (vt.length !== _t / 8)
            throw Error("Internal error");
        return vt
    }
    return serialization.serializeBoc = Pt,
    serialization
}
var hasRequiredCell;
function requireCell() {
    if (hasRequiredCell)
        return Cell;
    hasRequiredCell = 1;
    var r = commonjsGlobal && commonjsGlobal.__importDefault || function(wt) {
        return wt && wt.__esModule ? wt : {
            default: wt
        }
    }
    , d;
    Object.defineProperty(Cell, "__esModule", {
        value: !0
    }),
    Cell.Cell = void 0;
    const f = r(symbol_inspect)
      , m = requireBitString()
      , k = CellType$1
      , y = requireSlice()
      , ee = resolveExotic$1
      , dt = wonderCalculator$1
      , mt = requireSerialization()
      , yt = BitReader$1
      , pt = requireBuilder();
    let bt = class Jn {
        static fromBoc(xt) {
            return (0,
            mt.deserializeBoc)(xt)
        }
        static fromBase64(xt) {
            let At = Jn.fromBoc(Buffer.from(xt, "base64"));
            if (At.length !== 1)
                throw new Error("Deserialized more than one cell");
            return At[0]
        }
        constructor(xt) {
            this._hashes = [],
            this._depths = [],
            this.beginParse = (zt=!1)=>{
                if (this.isExotic && !zt)
                    throw new Error("Exotic cells cannot be parsed");
                return new y.Slice(new yt.BitReader(this.bits),this.refs)
            }
            ,
            this.hash = (zt=3)=>this._hashes[Math.min(this._hashes.length - 1, zt)],
            this.depth = (zt=3)=>this._depths[Math.min(this._depths.length - 1, zt)],
            this.level = ()=>this.mask.level,
            this.equals = zt=>this.hash().equals(zt.hash()),
            this[d] = ()=>this.toString();
            let At = m.BitString.EMPTY;
            xt && xt.bits && (At = xt.bits);
            let Ct = [];
            xt && xt.refs && (Ct = [...xt.refs]);
            let Pt, $t, Ot, Nt = k.CellType.Ordinary;
            if (xt && xt.exotic) {
                let zt = (0,
                ee.resolveExotic)(At, Ct)
                  , Wt = (0,
                dt.wonderCalculator)(zt.type, At, Ct);
                Ot = Wt.mask,
                $t = Wt.depths,
                Pt = Wt.hashes,
                Nt = zt.type
            } else {
                if (Ct.length > 4)
                    throw new Error("Invalid number of references");
                if (At.length > 1023)
                    throw new Error(`Bits overflow: ${At.length} > 1023`);
                let zt = (0,
                dt.wonderCalculator)(k.CellType.Ordinary, At, Ct);
                Ot = zt.mask,
                $t = zt.depths,
                Pt = zt.hashes,
                Nt = k.CellType.Ordinary
            }
            this.type = Nt,
            this.bits = At,
            this.refs = Ct,
            this.mask = Ot,
            this._depths = $t,
            this._hashes = Pt,
            Object.freeze(this),
            Object.freeze(this.refs),
            Object.freeze(this.bits),
            Object.freeze(this.mask),
            Object.freeze(this._depths),
            Object.freeze(this._hashes)
        }
        get isExotic() {
            return this.type !== k.CellType.Ordinary
        }
        toBoc(xt) {
            let At = xt && xt.idx !== null && xt.idx !== void 0 ? xt.idx : !1
              , Ct = xt && xt.crc32 !== null && xt.crc32 !== void 0 ? xt.crc32 : !0;
            return (0,
            mt.serializeBoc)(this, {
                idx: At,
                crc32: Ct
            })
        }
        toString(xt) {
            let At = xt || ""
              , Ct = "x";
            this.isExotic && (this.type === k.CellType.MerkleProof ? Ct = "p" : this.type === k.CellType.MerkleUpdate ? Ct = "u" : this.type === k.CellType.PrunedBranch && (Ct = "p"));
            let Pt = At + (this.isExotic ? Ct : "x") + "{" + this.bits.toString() + "}";
            for (let $t in this.refs) {
                const Ot = this.refs[$t];
                Pt += `
` + Ot.toString(At + " ")
            }
            return Pt
        }
        asSlice() {
            return this.beginParse()
        }
        asBuilder() {
            return (0,
            pt.beginCell)().storeSlice(this.asSlice())
        }
    }
    ;
    return Cell.Cell = bt,
    d = f.default,
    bt.EMPTY = new bt,
    Cell
}
var hasRequiredBuilder;
function requireBuilder() {
    if (hasRequiredBuilder)
        return Builder;
    hasRequiredBuilder = 1,
    Object.defineProperty(Builder, "__esModule", {
        value: !0
    }),
    Builder.Builder = Builder.beginCell = void 0;
    const r = requireBitBuilder()
      , d = requireCell()
      , f = requireStrings();
    function m() {
        return new k
    }
    Builder.beginCell = m;
    let k = class Xn {
        constructor() {
            this._bits = new r.BitBuilder,
            this._refs = []
        }
        get bits() {
            return this._bits.length
        }
        get refs() {
            return this._refs.length
        }
        get availableBits() {
            return 1023 - this.bits
        }
        get availableRefs() {
            return 4 - this.refs
        }
        storeBit(ee) {
            return this._bits.writeBit(ee),
            this
        }
        storeBits(ee) {
            return this._bits.writeBits(ee),
            this
        }
        storeBuffer(ee, dt) {
            if (dt != null && ee.length !== dt)
                throw Error(`Buffer length ${ee.length} is not equal to ${dt}`);
            return this._bits.writeBuffer(ee),
            this
        }
        storeMaybeBuffer(ee, dt) {
            return ee !== null ? (this.storeBit(1),
            this.storeBuffer(ee, dt)) : this.storeBit(0),
            this
        }
        storeUint(ee, dt) {
            return this._bits.writeUint(ee, dt),
            this
        }
        storeMaybeUint(ee, dt) {
            return ee != null ? (this.storeBit(1),
            this.storeUint(ee, dt)) : this.storeBit(0),
            this
        }
        storeInt(ee, dt) {
            return this._bits.writeInt(ee, dt),
            this
        }
        storeMaybeInt(ee, dt) {
            return ee != null ? (this.storeBit(1),
            this.storeInt(ee, dt)) : this.storeBit(0),
            this
        }
        storeVarUint(ee, dt) {
            return this._bits.writeVarUint(ee, dt),
            this
        }
        storeMaybeVarUint(ee, dt) {
            return ee != null ? (this.storeBit(1),
            this.storeVarUint(ee, dt)) : this.storeBit(0),
            this
        }
        storeVarInt(ee, dt) {
            return this._bits.writeVarInt(ee, dt),
            this
        }
        storeMaybeVarInt(ee, dt) {
            return ee != null ? (this.storeBit(1),
            this.storeVarInt(ee, dt)) : this.storeBit(0),
            this
        }
        storeCoins(ee) {
            return this._bits.writeCoins(ee),
            this
        }
        storeMaybeCoins(ee) {
            return ee != null ? (this.storeBit(1),
            this.storeCoins(ee)) : this.storeBit(0),
            this
        }
        storeAddress(ee) {
            return this._bits.writeAddress(ee),
            this
        }
        storeRef(ee) {
            if (this._refs.length >= 4)
                throw new Error("Too many references");
            if (ee instanceof d.Cell)
                this._refs.push(ee);
            else if (ee instanceof Xn)
                this._refs.push(ee.endCell());
            else
                throw new Error("Invalid argument");
            return this
        }
        storeMaybeRef(ee) {
            return ee ? (this.storeBit(1),
            this.storeRef(ee)) : this.storeBit(0),
            this
        }
        storeSlice(ee) {
            let dt = ee.clone();
            for (dt.remainingBits > 0 && this.storeBits(dt.loadBits(dt.remainingBits)); dt.remainingRefs > 0; )
                this.storeRef(dt.loadRef());
            return this
        }
        storeMaybeSlice(ee) {
            return ee ? (this.storeBit(1),
            this.storeSlice(ee)) : this.storeBit(0),
            this
        }
        storeBuilder(ee) {
            return this.storeSlice(ee.endCell().beginParse())
        }
        storeMaybeBuilder(ee) {
            return ee ? (this.storeBit(1),
            this.storeBuilder(ee)) : this.storeBit(0),
            this
        }
        storeWritable(ee) {
            return typeof ee == "object" ? ee.writeTo(this) : ee(this),
            this
        }
        storeMaybeWritable(ee) {
            return ee ? (this.storeBit(1),
            this.storeWritable(ee)) : this.storeBit(0),
            this
        }
        store(ee) {
            return this.storeWritable(ee),
            this
        }
        storeStringTail(ee) {
            return (0,
            f.writeString)(ee, this),
            this
        }
        storeMaybeStringTail(ee) {
            return ee != null ? (this.storeBit(1),
            (0,
            f.writeString)(ee, this)) : this.storeBit(0),
            this
        }
        storeStringRefTail(ee) {
            return this.storeRef(m().storeStringTail(ee)),
            this
        }
        storeMaybeStringRefTail(ee) {
            return ee != null ? (this.storeBit(1),
            this.storeStringRefTail(ee)) : this.storeBit(0),
            this
        }
        storeDict(ee, dt, mt) {
            return ee ? ee.store(this, dt, mt) : this.storeBit(0),
            this
        }
        storeDictDirect(ee, dt, mt) {
            return ee.storeDirect(this, dt, mt),
            this
        }
        endCell(ee) {
            return new d.Cell({
                bits: this._bits.build(),
                refs: this._refs,
                exotic: ee == null ? void 0 : ee.exotic
            })
        }
        asCell() {
            return this.endCell()
        }
        asSlice() {
            return this.endCell().beginParse()
        }
    }
    ;
    return Builder.Builder = k,
    Builder
}
var StateInit = {}
  , SimpleLibrary = {};
Object.defineProperty(SimpleLibrary, "__esModule", {
    value: !0
});
SimpleLibrary.SimpleLibraryValue = SimpleLibrary.storeSimpleLibrary = SimpleLibrary.loadSimpleLibrary = void 0;
function loadSimpleLibrary(r) {
    return {
        public: r.loadBit(),
        root: r.loadRef()
    }
}
SimpleLibrary.loadSimpleLibrary = loadSimpleLibrary;
function storeSimpleLibrary(r) {
    return d=>{
        d.storeBit(r.public),
        d.storeRef(r.root)
    }
}
SimpleLibrary.storeSimpleLibrary = storeSimpleLibrary;
SimpleLibrary.SimpleLibraryValue = {
    serialize(r, d) {
        storeSimpleLibrary(r)(d)
    },
    parse(r) {
        return loadSimpleLibrary(r)
    }
};
var TickTock = {};
Object.defineProperty(TickTock, "__esModule", {
    value: !0
});
TickTock.storeTickTock = TickTock.loadTickTock = void 0;
function loadTickTock(r) {
    return {
        tick: r.loadBit(),
        tock: r.loadBit()
    }
}
TickTock.loadTickTock = loadTickTock;
function storeTickTock(r) {
    return d=>{
        d.storeBit(r.tick),
        d.storeBit(r.tock)
    }
}
TickTock.storeTickTock = storeTickTock;
Object.defineProperty(StateInit, "__esModule", {
    value: !0
});
StateInit.storeStateInit = StateInit.loadStateInit = void 0;
const Dictionary_1$2 = requireDictionary()
  , SimpleLibrary_1 = SimpleLibrary
  , TickTock_1 = TickTock;
function loadStateInit(r) {
    let d;
    r.loadBit() && (d = r.loadUint(5));
    let f;
    r.loadBit() && (f = (0,
    TickTock_1.loadTickTock)(r));
    let m = r.loadMaybeRef()
      , k = r.loadMaybeRef()
      , y = r.loadDict(Dictionary_1$2.Dictionary.Keys.BigUint(256), SimpleLibrary_1.SimpleLibraryValue);
    return y.size === 0 && (y = void 0),
    {
        splitDepth: d,
        special: f,
        code: m,
        data: k,
        libraries: y
    }
}
StateInit.loadStateInit = loadStateInit;
function storeStateInit(r) {
    return d=>{
        r.splitDepth !== null && r.splitDepth !== void 0 ? (d.storeBit(!0),
        d.storeUint(r.splitDepth, 5)) : d.storeBit(!1),
        r.special !== null && r.special !== void 0 ? (d.storeBit(!0),
        d.store((0,
        TickTock_1.storeTickTock)(r.special))) : d.storeBit(!1),
        d.storeMaybeRef(r.code),
        d.storeMaybeRef(r.data),
        d.storeDict(r.libraries)
    }
}
StateInit.storeStateInit = storeStateInit;
Object.defineProperty(contractAddress$1, "__esModule", {
    value: !0
});
contractAddress$1.contractAddress = void 0;
const Builder_1$8 = requireBuilder()
  , StateInit_1$3 = StateInit
  , Address_1$2 = Address$1;
function contractAddress(r, d) {
    let f = (0,
    Builder_1$8.beginCell)().store((0,
    StateInit_1$3.storeStateInit)(d)).endCell().hash();
    return new Address_1$2.Address(r,f)
}
contractAddress$1.contractAddress = contractAddress;
var tuple = {};
Object.defineProperty(tuple, "__esModule", {
    value: !0
});
tuple.parseTuple = tuple.serializeTuple = void 0;
const Builder_1$7 = requireBuilder()
  , INT64_MIN = BigInt("-9223372036854775808")
  , INT64_MAX = BigInt("9223372036854775807");
function serializeTupleItem(r, d) {
    if (r.type === "null")
        d.storeUint(0, 8);
    else if (r.type === "int")
        r.value <= INT64_MAX && r.value >= INT64_MIN ? (d.storeUint(1, 8),
        d.storeInt(r.value, 64)) : (d.storeUint(256, 15),
        d.storeInt(r.value, 257));
    else if (r.type === "nan")
        d.storeInt(767, 16);
    else if (r.type === "cell")
        d.storeUint(3, 8),
        d.storeRef(r.cell);
    else if (r.type === "slice")
        d.storeUint(4, 8),
        d.storeUint(0, 10),
        d.storeUint(r.cell.bits.length, 10),
        d.storeUint(0, 3),
        d.storeUint(r.cell.refs.length, 3),
        d.storeRef(r.cell);
    else if (r.type === "builder")
        d.storeUint(5, 8),
        d.storeRef(r.cell);
    else if (r.type === "tuple") {
        let f = null
          , m = null;
        for (let k = 0; k < r.items.length; k++) {
            let y = f;
            f = m,
            m = y,
            k > 1 && (f = (0,
            Builder_1$7.beginCell)().storeRef(m).storeRef(f).endCell());
            let ee = (0,
            Builder_1$7.beginCell)();
            serializeTupleItem(r.items[k], ee),
            m = ee.endCell()
        }
        d.storeUint(7, 8),
        d.storeUint(r.items.length, 16),
        f && d.storeRef(f),
        m && d.storeRef(m)
    } else
        throw Error("Invalid value")
}
function parseStackItem$1(r) {
    let d = r.loadUint(8);
    if (d === 0)
        return {
            type: "null"
        };
    if (d === 1)
        return {
            type: "int",
            value: r.loadIntBig(64)
        };
    if (d === 2)
        return r.loadUint(7) === 0 ? {
            type: "int",
            value: r.loadIntBig(257)
        } : (r.loadBit(),
        {
            type: "nan"
        });
    if (d === 3)
        return {
            type: "cell",
            cell: r.loadRef()
        };
    if (d === 4) {
        let f = r.loadUint(10)
          , m = r.loadUint(10)
          , k = r.loadUint(3)
          , y = r.loadUint(3)
          , ee = r.loadRef().beginParse();
        ee.skip(f);
        let dt = ee.loadBits(m - f)
          , mt = (0,
        Builder_1$7.beginCell)().storeBits(dt);
        if (k < y) {
            for (let yt = 0; yt < k; yt++)
                ee.loadRef();
            for (let yt = 0; yt < y - k; yt++)
                mt.storeRef(ee.loadRef())
        }
        return {
            type: "slice",
            cell: mt.endCell()
        }
    } else {
        if (d === 5)
            return {
                type: "builder",
                cell: r.loadRef()
            };
        if (d === 7) {
            let f = r.loadUint(16)
              , m = [];
            if (f > 1) {
                let k = r.loadRef().beginParse()
                  , y = r.loadRef().beginParse();
                m.unshift(parseStackItem$1(y));
                for (let ee = 0; ee < f - 2; ee++) {
                    let dt = k;
                    k = dt.loadRef().beginParse(),
                    y = dt.loadRef().beginParse(),
                    m.unshift(parseStackItem$1(y))
                }
                m.unshift(parseStackItem$1(k))
            } else
                f === 1 && m.push(parseStackItem$1(r.loadRef().beginParse()));
            return {
                type: "tuple",
                items: m
            }
        } else
            throw Error("Unsupported stack item")
    }
}
function serializeTupleTail(r, d) {
    if (r.length > 0) {
        let f = (0,
        Builder_1$7.beginCell)();
        serializeTupleTail(r.slice(0, r.length - 1), f),
        d.storeRef(f.endCell()),
        serializeTupleItem(r[r.length - 1], d)
    }
}
function serializeTuple(r) {
    let d = (0,
    Builder_1$7.beginCell)();
    d.storeUint(r.length, 24);
    let f = [...r];
    return serializeTupleTail(f, d),
    d.endCell()
}
tuple.serializeTuple = serializeTuple;
function parseTuple(r) {
    let d = []
      , f = r.beginParse()
      , m = f.loadUint(24);
    for (let k = 0; k < m; k++) {
        let y = f.loadRef();
        d.unshift(parseStackItem$1(f)),
        f = y.beginParse()
    }
    return d
}
tuple.parseTuple = parseTuple;
var reader = {};
Object.defineProperty(reader, "__esModule", {
    value: !0
});
reader.TupleReader = void 0;
class TupleReader {
    constructor(d) {
        this.items = [...d]
    }
    get remaining() {
        return this.items.length
    }
    peek() {
        if (this.items.length === 0)
            throw Error("EOF");
        return this.items[0]
    }
    pop() {
        if (this.items.length === 0)
            throw Error("EOF");
        let d = this.items[0];
        return this.items.splice(0, 1),
        d
    }
    skip(d=1) {
        for (let f = 0; f < d; f++)
            this.pop();
        return this
    }
    readBigNumber() {
        let d = this.pop();
        if (d.type !== "int")
            throw Error("Not a number");
        return d.value
    }
    readBigNumberOpt() {
        let d = this.pop();
        if (d.type === "null")
            return null;
        if (d.type !== "int")
            throw Error("Not a number");
        return d.value
    }
    readNumber() {
        return Number(this.readBigNumber())
    }
    readNumberOpt() {
        let d = this.readBigNumberOpt();
        return d !== null ? Number(d) : null
    }
    readBoolean() {
        return this.readNumber() !== 0
    }
    readBooleanOpt() {
        let d = this.readNumberOpt();
        return d !== null ? d !== 0 : null
    }
    readAddress() {
        let d = this.readCell().beginParse().loadAddress();
        if (d !== null)
            return d;
        throw Error("Not an address")
    }
    readAddressOpt() {
        let d = this.readCellOpt();
        return d !== null ? d.beginParse().loadMaybeAddress() : null
    }
    readCell() {
        let d = this.pop();
        if (d.type !== "cell" && d.type !== "slice" && d.type !== "builder")
            throw Error("Not a cell: " + d.type);
        return d.cell
    }
    readCellOpt() {
        let d = this.pop();
        if (d.type === "null")
            return null;
        if (d.type !== "cell" && d.type !== "slice" && d.type !== "builder")
            throw Error("Not a cell");
        return d.cell
    }
    readTuple() {
        let d = this.pop();
        if (d.type !== "tuple")
            throw Error("Not a tuple");
        return new TupleReader(d.items)
    }
    readTupleOpt() {
        let d = this.pop();
        if (d.type === "null")
            return null;
        if (d.type !== "tuple")
            throw Error("Not a tuple");
        return new TupleReader(d.items)
    }
    static readLispList(d) {
        const f = [];
        let m = d;
        for (; m !== null; ) {
            var k = m.pop();
            if (m.items.length === 0 || m.items[0].type !== "tuple" && m.items[0].type !== "null")
                throw Error("Lisp list consists only from (any, tuple) elements and ends with null");
            m = m.readTupleOpt(),
            f.push(k)
        }
        return f
    }
    readLispListDirect() {
        return this.items.length === 1 && this.items[0].type === "null" ? [] : TupleReader.readLispList(this)
    }
    readLispList() {
        return TupleReader.readLispList(this.readTupleOpt())
    }
    readBuffer() {
        let d = this.readCell().beginParse();
        if (d.remainingRefs !== 0 || d.remainingBits % 8 !== 0)
            throw Error("Not a buffer");
        return d.loadBuffer(d.remainingBits / 8)
    }
    readBufferOpt() {
        if (this.peek().type === "null")
            return null;
        let f = this.readCell().beginParse();
        if (f.remainingRefs !== 0 || f.remainingBits % 8 !== 0)
            throw Error("Not a buffer");
        return f.loadBuffer(f.remainingBits / 8)
    }
    readString() {
        return this.readCell().beginParse().loadStringTail()
    }
    readStringOpt() {
        return this.peek().type === "null" ? null : this.readCell().beginParse().loadStringTail()
    }
}
reader.TupleReader = TupleReader;
var builder = {};
Object.defineProperty(builder, "__esModule", {
    value: !0
});
builder.TupleBuilder = void 0;
const Builder_1$6 = requireBuilder()
  , Cell_1$2 = requireCell()
  , Slice_1 = requireSlice();
class TupleBuilder {
    constructor() {
        this._tuple = []
    }
    writeNumber(d) {
        d == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "int",
            value: BigInt(d)
        })
    }
    writeBoolean(d) {
        d == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "int",
            value: d ? -1n : 0n
        })
    }
    writeBuffer(d) {
        d == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "slice",
            cell: (0,
            Builder_1$6.beginCell)().storeBuffer(d).endCell()
        })
    }
    writeString(d) {
        d == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "slice",
            cell: (0,
            Builder_1$6.beginCell)().storeStringTail(d).endCell()
        })
    }
    writeCell(d) {
        d == null ? this._tuple.push({
            type: "null"
        }) : d instanceof Cell_1$2.Cell ? this._tuple.push({
            type: "cell",
            cell: d
        }) : d instanceof Slice_1.Slice && this._tuple.push({
            type: "cell",
            cell: d.asCell()
        })
    }
    writeSlice(d) {
        d == null ? this._tuple.push({
            type: "null"
        }) : d instanceof Cell_1$2.Cell ? this._tuple.push({
            type: "slice",
            cell: d
        }) : d instanceof Slice_1.Slice && this._tuple.push({
            type: "slice",
            cell: d.asCell()
        })
    }
    writeBuilder(d) {
        d == null ? this._tuple.push({
            type: "null"
        }) : d instanceof Cell_1$2.Cell ? this._tuple.push({
            type: "builder",
            cell: d
        }) : d instanceof Slice_1.Slice && this._tuple.push({
            type: "builder",
            cell: d.asCell()
        })
    }
    writeTuple(d) {
        d == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "tuple",
            items: d
        })
    }
    writeAddress(d) {
        d == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "slice",
            cell: (0,
            Builder_1$6.beginCell)().storeAddress(d).endCell()
        })
    }
    build() {
        return [...this._tuple]
    }
}
builder.TupleBuilder = TupleBuilder;
var _export = {}
  , _helpers = {}
  , convert = {};
Object.defineProperty(convert, "__esModule", {
    value: !0
});
convert.fromNano = convert.toNano = void 0;
function toNano(r) {
    if (typeof r == "bigint")
        return r * 1000000000n;
    {
        if (typeof r == "number") {
            if (!Number.isFinite(r))
                throw Error("Invalid number");
            if (Math.log10(r) <= 6)
                r = r.toLocaleString("en", {
                    minimumFractionDigits: 9,
                    useGrouping: !1
                });
            else if (r - Math.trunc(r) === 0)
                r = r.toLocaleString("en", {
                    maximumFractionDigits: 0,
                    useGrouping: !1
                });
            else
                throw Error("Not enough precision for a number value. Use string value instead")
        }
        let d = !1;
        for (; r.startsWith("-"); )
            d = !d,
            r = r.slice(1);
        if (r === ".")
            throw Error("Invalid number");
        let f = r.split(".");
        if (f.length > 2)
            throw Error("Invalid number");
        let m = f[0]
          , k = f[1];
        if (m || (m = "0"),
        k || (k = "0"),
        k.length > 9)
            throw Error("Invalid number");
        for (; k.length < 9; )
            k += "0";
        let y = BigInt(m) * 1000000000n + BigInt(k);
        return d && (y = -y),
        y
    }
}
convert.toNano = toNano;
function fromNano(r) {
    let d = BigInt(r)
      , f = !1;
    d < 0 && (f = !0,
    d = -d);
    let k = (d % 1000000000n).toString();
    for (; k.length < 9; )
        k = "0" + k;
    k = k.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    let dt = `${(d / 1000000000n).toString()}${k === "0" ? "" : `.${k}`}`;
    return f && (dt = "-" + dt),
    dt
}
convert.fromNano = fromNano;
Object.defineProperty(_helpers, "__esModule", {
    value: !0
});
_helpers.comment = _helpers.external = _helpers.internal = void 0;
const Address_1$1 = Address$1
  , Cell_1$1 = requireCell()
  , Builder_1$5 = requireBuilder()
  , convert_1 = convert;
function internal(r) {
    let d = !0;
    r.bounce !== null && r.bounce !== void 0 && (d = r.bounce);
    let f;
    if (typeof r.to == "string")
        f = Address_1$1.Address.parse(r.to);
    else if (Address_1$1.Address.isAddress(r.to))
        f = r.to;
    else
        throw new Error(`Invalid address ${r.to}`);
    let m;
    typeof r.value == "string" ? m = (0,
    convert_1.toNano)(r.value) : m = r.value;
    let k = Cell_1$1.Cell.EMPTY;
    return typeof r.body == "string" ? k = (0,
    Builder_1$5.beginCell)().storeUint(0, 32).storeStringTail(r.body).endCell() : r.body && (k = r.body),
    {
        info: {
            type: "internal",
            dest: f,
            value: {
                coins: m
            },
            bounce: d,
            ihrDisabled: !0,
            bounced: !1,
            ihrFee: 0n,
            forwardFee: 0n,
            createdAt: 0,
            createdLt: 0n
        },
        init: r.init ?? void 0,
        body: k
    }
}
_helpers.internal = internal;
function external$1(r) {
    let d;
    if (typeof r.to == "string")
        d = Address_1$1.Address.parse(r.to);
    else if (Address_1$1.Address.isAddress(r.to))
        d = r.to;
    else
        throw new Error(`Invalid address ${r.to}`);
    return {
        info: {
            type: "external-in",
            dest: d,
            importFee: 0n
        },
        init: r.init ?? void 0,
        body: r.body || Cell_1$1.Cell.EMPTY
    }
}
_helpers.external = external$1;
function comment(r) {
    return (0,
    Builder_1$5.beginCell)().storeUint(0, 32).storeStringTail(r).endCell()
}
_helpers.comment = comment;
var Account = {}
  , AccountStorage = {}
  , AccountState = {};
Object.defineProperty(AccountState, "__esModule", {
    value: !0
});
AccountState.storeAccountState = AccountState.loadAccountState = void 0;
const StateInit_1$2 = StateInit;
function loadAccountState(r) {
    return r.loadBit() ? {
        type: "active",
        state: (0,
        StateInit_1$2.loadStateInit)(r)
    } : r.loadBit() ? {
        type: "frozen",
        stateHash: r.loadUintBig(256)
    } : {
        type: "uninit"
    }
}
AccountState.loadAccountState = loadAccountState;
function storeAccountState(r) {
    return d=>{
        r.type === "active" ? (d.storeBit(!0),
        d.store((0,
        StateInit_1$2.storeStateInit)(r.state))) : r.type === "frozen" ? (d.storeBit(!1),
        d.storeBit(!0),
        d.storeUint(r.stateHash, 256)) : r.type === "uninit" && (d.storeBit(!1),
        d.storeBit(!1))
    }
}
AccountState.storeAccountState = storeAccountState;
var CurrencyCollection = {};
Object.defineProperty(CurrencyCollection, "__esModule", {
    value: !0
});
CurrencyCollection.storeCurrencyCollection = CurrencyCollection.loadCurrencyCollection = void 0;
const Dictionary_1$1 = requireDictionary();
function loadCurrencyCollection(r) {
    const d = r.loadCoins()
      , f = r.loadDict(Dictionary_1$1.Dictionary.Keys.Uint(32), Dictionary_1$1.Dictionary.Values.BigVarUint(5));
    return f.size === 0 ? {
        coins: d
    } : {
        other: f,
        coins: d
    }
}
CurrencyCollection.loadCurrencyCollection = loadCurrencyCollection;
function storeCurrencyCollection(r) {
    return d=>{
        d.storeCoins(r.coins),
        r.other ? d.storeDict(r.other) : d.storeBit(0)
    }
}
CurrencyCollection.storeCurrencyCollection = storeCurrencyCollection;
Object.defineProperty(AccountStorage, "__esModule", {
    value: !0
});
AccountStorage.storeAccountStorage = AccountStorage.loadAccountStorage = void 0;
const AccountState_1 = AccountState
  , CurrencyCollection_1$5 = CurrencyCollection;
function loadAccountStorage(r) {
    return {
        lastTransLt: r.loadUintBig(64),
        balance: (0,
        CurrencyCollection_1$5.loadCurrencyCollection)(r),
        state: (0,
        AccountState_1.loadAccountState)(r)
    }
}
AccountStorage.loadAccountStorage = loadAccountStorage;
function storeAccountStorage(r) {
    return d=>{
        d.storeUint(r.lastTransLt, 64),
        d.store((0,
        CurrencyCollection_1$5.storeCurrencyCollection)(r.balance)),
        d.store((0,
        AccountState_1.storeAccountState)(r.state))
    }
}
AccountStorage.storeAccountStorage = storeAccountStorage;
var StorageInto = {}
  , StorageUsed = {};
Object.defineProperty(StorageUsed, "__esModule", {
    value: !0
});
StorageUsed.storeStorageUsed = StorageUsed.loadStorageUsed = void 0;
function loadStorageUsed(r) {
    return {
        cells: r.loadVarUintBig(3),
        bits: r.loadVarUintBig(3),
        publicCells: r.loadVarUintBig(3)
    }
}
StorageUsed.loadStorageUsed = loadStorageUsed;
function storeStorageUsed(r) {
    return d=>{
        d.storeVarUint(r.cells, 3),
        d.storeVarUint(r.bits, 3),
        d.storeVarUint(r.publicCells, 3)
    }
}
StorageUsed.storeStorageUsed = storeStorageUsed;
Object.defineProperty(StorageInto, "__esModule", {
    value: !0
});
StorageInto.storeStorageInfo = StorageInto.loadStorageInfo = void 0;
const StorageUsed_1 = StorageUsed;
function loadStorageInfo(r) {
    return {
        used: (0,
        StorageUsed_1.loadStorageUsed)(r),
        lastPaid: r.loadUint(32),
        duePayment: r.loadMaybeCoins()
    }
}
StorageInto.loadStorageInfo = loadStorageInfo;
function storeStorageInfo(r) {
    return d=>{
        d.store((0,
        StorageUsed_1.storeStorageUsed)(r.used)),
        d.storeUint(r.lastPaid, 32),
        d.storeMaybeCoins(r.duePayment)
    }
}
StorageInto.storeStorageInfo = storeStorageInfo;
Object.defineProperty(Account, "__esModule", {
    value: !0
});
Account.storeAccount = Account.loadAccount = void 0;
const AccountStorage_1 = AccountStorage
  , StorageInto_1 = StorageInto;
function loadAccount(r) {
    return {
        addr: r.loadAddress(),
        storageStats: (0,
        StorageInto_1.loadStorageInfo)(r),
        storage: (0,
        AccountStorage_1.loadAccountStorage)(r)
    }
}
Account.loadAccount = loadAccount;
function storeAccount(r) {
    return d=>{
        d.storeAddress(r.addr),
        d.store((0,
        StorageInto_1.storeStorageInfo)(r.storageStats)),
        d.store((0,
        AccountStorage_1.storeAccountStorage)(r.storage))
    }
}
Account.storeAccount = storeAccount;
var AccountStatus = {};
Object.defineProperty(AccountStatus, "__esModule", {
    value: !0
});
AccountStatus.storeAccountStatus = AccountStatus.loadAccountStatus = void 0;
function loadAccountStatus(r) {
    const d = r.loadUint(2);
    if (d === 0)
        return "uninitialized";
    if (d === 1)
        return "frozen";
    if (d === 2)
        return "active";
    if (d === 3)
        return "non-existing";
    throw Error("Invalid data")
}
AccountStatus.loadAccountStatus = loadAccountStatus;
function storeAccountStatus(r) {
    return d=>{
        if (r === "uninitialized")
            d.storeUint(0, 2);
        else if (r === "frozen")
            d.storeUint(1, 2);
        else if (r === "active")
            d.storeUint(2, 2);
        else if (r === "non-existing")
            d.storeUint(3, 2);
        else
            throw Error("Invalid data");
        return d
    }
}
AccountStatus.storeAccountStatus = storeAccountStatus;
var AccountStatusChange = {};
Object.defineProperty(AccountStatusChange, "__esModule", {
    value: !0
});
AccountStatusChange.storeAccountStatusChange = AccountStatusChange.loadAccountStatusChange = void 0;
function loadAccountStatusChange(r) {
    return r.loadBit() ? r.loadBit() ? "deleted" : "frozen" : "unchanged"
}
AccountStatusChange.loadAccountStatusChange = loadAccountStatusChange;
function storeAccountStatusChange(r) {
    return d=>{
        if (r == "unchanged")
            d.storeBit(0);
        else if (r === "frozen")
            d.storeBit(1),
            d.storeBit(0);
        else if (r === "deleted")
            d.storeBit(1),
            d.storeBit(1);
        else
            throw Error("Invalid account status change")
    }
}
AccountStatusChange.storeAccountStatusChange = storeAccountStatusChange;
var OutList = {}
  , MessageRelaxed = {}
  , CommonMessageInfoRelaxed = {};
Object.defineProperty(CommonMessageInfoRelaxed, "__esModule", {
    value: !0
});
CommonMessageInfoRelaxed.storeCommonMessageInfoRelaxed = CommonMessageInfoRelaxed.loadCommonMessageInfoRelaxed = void 0;
const CurrencyCollection_1$4 = CurrencyCollection;
function loadCommonMessageInfoRelaxed(r) {
    if (!r.loadBit()) {
        const y = r.loadBit()
          , ee = r.loadBit()
          , dt = r.loadBit()
          , mt = r.loadMaybeAddress()
          , yt = r.loadAddress()
          , pt = (0,
        CurrencyCollection_1$4.loadCurrencyCollection)(r)
          , bt = r.loadCoins()
          , wt = r.loadCoins()
          , xt = r.loadUintBig(64)
          , At = r.loadUint(32);
        return {
            type: "internal",
            ihrDisabled: y,
            bounce: ee,
            bounced: dt,
            src: mt,
            dest: yt,
            value: pt,
            ihrFee: bt,
            forwardFee: wt,
            createdLt: xt,
            createdAt: At
        }
    }
    if (!r.loadBit())
        throw Error("External In message is not possible for CommonMessageInfoRelaxed");
    const d = r.loadMaybeAddress()
      , f = r.loadMaybeExternalAddress()
      , m = r.loadUintBig(64)
      , k = r.loadUint(32);
    return {
        type: "external-out",
        src: d,
        dest: f,
        createdLt: m,
        createdAt: k
    }
}
CommonMessageInfoRelaxed.loadCommonMessageInfoRelaxed = loadCommonMessageInfoRelaxed;
function storeCommonMessageInfoRelaxed(r) {
    return d=>{
        if (r.type === "internal")
            d.storeBit(0),
            d.storeBit(r.ihrDisabled),
            d.storeBit(r.bounce),
            d.storeBit(r.bounced),
            d.storeAddress(r.src),
            d.storeAddress(r.dest),
            d.store((0,
            CurrencyCollection_1$4.storeCurrencyCollection)(r.value)),
            d.storeCoins(r.ihrFee),
            d.storeCoins(r.forwardFee),
            d.storeUint(r.createdLt, 64),
            d.storeUint(r.createdAt, 32);
        else if (r.type === "external-out")
            d.storeBit(1),
            d.storeBit(1),
            d.storeAddress(r.src),
            d.storeAddress(r.dest),
            d.storeUint(r.createdLt, 64),
            d.storeUint(r.createdAt, 32);
        else
            throw new Error("Unknown CommonMessageInfo type")
    }
}
CommonMessageInfoRelaxed.storeCommonMessageInfoRelaxed = storeCommonMessageInfoRelaxed;
Object.defineProperty(MessageRelaxed, "__esModule", {
    value: !0
});
MessageRelaxed.storeMessageRelaxed = MessageRelaxed.loadMessageRelaxed = void 0;
const Builder_1$4 = requireBuilder()
  , CommonMessageInfoRelaxed_1 = CommonMessageInfoRelaxed
  , StateInit_1$1 = StateInit;
function loadMessageRelaxed(r) {
    const d = (0,
    CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed)(r);
    let f = null;
    r.loadBit() && (r.loadBit() ? f = (0,
    StateInit_1$1.loadStateInit)(r.loadRef().beginParse()) : f = (0,
    StateInit_1$1.loadStateInit)(r));
    const m = r.loadBit() ? r.loadRef() : r.asCell();
    return {
        info: d,
        init: f,
        body: m
    }
}
MessageRelaxed.loadMessageRelaxed = loadMessageRelaxed;
function storeMessageRelaxed(r, d) {
    return f=>{
        if (f.store((0,
        CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed)(r.info)),
        r.init) {
            f.storeBit(!0);
            let k = (0,
            Builder_1$4.beginCell)().store((0,
            StateInit_1$1.storeStateInit)(r.init))
              , y = !1;
            d && d.forceRef ? y = !0 : f.availableBits - 2 >= k.bits ? y = !1 : y = !0,
            y ? (f.storeBit(!0),
            f.storeRef(k)) : (f.storeBit(!1),
            f.storeBuilder(k))
        } else
            f.storeBit(!1);
        let m = !1;
        d && d.forceRef ? m = !0 : f.availableBits - 1 >= r.body.bits.length && f.refs + r.body.refs.length <= 4 && !r.body.isExotic ? m = !1 : m = !0,
        m ? (f.storeBit(!0),
        f.storeRef(r.body)) : (f.storeBit(!1),
        f.storeBuilder(r.body.asBuilder()))
    }
}
MessageRelaxed.storeMessageRelaxed = storeMessageRelaxed;
Object.defineProperty(OutList, "__esModule", {
    value: !0
});
OutList.loadOutList = OutList.storeOutList = OutList.loadOutAction = OutList.storeOutAction = void 0;
const MessageRelaxed_1 = MessageRelaxed
  , Builder_1$3 = requireBuilder();
function storeOutAction(r) {
    switch (r.type) {
    case "sendMsg":
        return storeOutActionSendMsg(r);
    case "setCode":
        return storeOutActionSetCode(r);
    default:
        throw new Error(`Unknown action type ${r.type}`)
    }
}
OutList.storeOutAction = storeOutAction;
const outActionSendMsgTag = 247711853;
function storeOutActionSendMsg(r) {
    return d=>{
        d.storeUint(outActionSendMsgTag, 32).storeUint(r.mode, 8).storeRef((0,
        Builder_1$3.beginCell)().store((0,
        MessageRelaxed_1.storeMessageRelaxed)(r.outMsg)).endCell())
    }
}
const outActionSetCodeTag = 2907562126;
function storeOutActionSetCode(r) {
    return d=>{
        d.storeUint(outActionSetCodeTag, 32).storeRef(r.newCode)
    }
}
function loadOutAction(r) {
    const d = r.loadUint(32);
    if (d === outActionSendMsgTag) {
        const f = r.loadUint(8)
          , m = (0,
        MessageRelaxed_1.loadMessageRelaxed)(r.loadRef().beginParse());
        return {
            type: "sendMsg",
            mode: f,
            outMsg: m
        }
    }
    if (d === outActionSetCodeTag)
        return {
            type: "setCode",
            newCode: r.loadRef()
        };
    throw new Error(`Unknown out action tag 0x${d.toString(16)}`)
}
OutList.loadOutAction = loadOutAction;
function storeOutList(r) {
    const d = r.reduce((f,m)=>(0,
    Builder_1$3.beginCell)().storeRef(f).store(storeOutAction(m)).endCell(), (0,
    Builder_1$3.beginCell)().endCell());
    return f=>{
        f.storeSlice(d.beginParse())
    }
}
OutList.storeOutList = storeOutList;
function loadOutList(r) {
    const d = [];
    for (; r.remainingRefs; ) {
        const f = r.loadRef();
        d.push(loadOutAction(r)),
        r = f.beginParse()
    }
    return d.reverse()
}
OutList.loadOutList = loadOutList;
var CommonMessageInfo = {};
Object.defineProperty(CommonMessageInfo, "__esModule", {
    value: !0
});
CommonMessageInfo.storeCommonMessageInfo = CommonMessageInfo.loadCommonMessageInfo = void 0;
const CurrencyCollection_1$3 = CurrencyCollection;
function loadCommonMessageInfo(r) {
    if (!r.loadBit()) {
        const y = r.loadBit()
          , ee = r.loadBit()
          , dt = r.loadBit()
          , mt = r.loadAddress()
          , yt = r.loadAddress()
          , pt = (0,
        CurrencyCollection_1$3.loadCurrencyCollection)(r)
          , bt = r.loadCoins()
          , wt = r.loadCoins()
          , xt = r.loadUintBig(64)
          , At = r.loadUint(32);
        return {
            type: "internal",
            ihrDisabled: y,
            bounce: ee,
            bounced: dt,
            src: mt,
            dest: yt,
            value: pt,
            ihrFee: bt,
            forwardFee: wt,
            createdLt: xt,
            createdAt: At
        }
    }
    if (!r.loadBit()) {
        const y = r.loadMaybeExternalAddress()
          , ee = r.loadAddress()
          , dt = r.loadCoins();
        return {
            type: "external-in",
            src: y,
            dest: ee,
            importFee: dt
        }
    }
    const d = r.loadAddress()
      , f = r.loadMaybeExternalAddress()
      , m = r.loadUintBig(64)
      , k = r.loadUint(32);
    return {
        type: "external-out",
        src: d,
        dest: f,
        createdLt: m,
        createdAt: k
    }
}
CommonMessageInfo.loadCommonMessageInfo = loadCommonMessageInfo;
function storeCommonMessageInfo(r) {
    return d=>{
        if (r.type === "internal")
            d.storeBit(0),
            d.storeBit(r.ihrDisabled),
            d.storeBit(r.bounce),
            d.storeBit(r.bounced),
            d.storeAddress(r.src),
            d.storeAddress(r.dest),
            d.store((0,
            CurrencyCollection_1$3.storeCurrencyCollection)(r.value)),
            d.storeCoins(r.ihrFee),
            d.storeCoins(r.forwardFee),
            d.storeUint(r.createdLt, 64),
            d.storeUint(r.createdAt, 32);
        else if (r.type === "external-in")
            d.storeBit(1),
            d.storeBit(0),
            d.storeAddress(r.src),
            d.storeAddress(r.dest),
            d.storeCoins(r.importFee);
        else if (r.type === "external-out")
            d.storeBit(1),
            d.storeBit(1),
            d.storeAddress(r.src),
            d.storeAddress(r.dest),
            d.storeUint(r.createdLt, 64),
            d.storeUint(r.createdAt, 32);
        else
            throw new Error("Unknown CommonMessageInfo type")
    }
}
CommonMessageInfo.storeCommonMessageInfo = storeCommonMessageInfo;
var ComputeSkipReason = {};
Object.defineProperty(ComputeSkipReason, "__esModule", {
    value: !0
});
ComputeSkipReason.storeComputeSkipReason = ComputeSkipReason.loadComputeSkipReason = void 0;
function loadComputeSkipReason(r) {
    let d = r.loadUint(2);
    if (d === 0)
        return "no-state";
    if (d === 1)
        return "bad-state";
    if (d === 2)
        return "no-gas";
    throw new Error(`Unknown ComputeSkipReason: ${d}`)
}
ComputeSkipReason.loadComputeSkipReason = loadComputeSkipReason;
function storeComputeSkipReason(r) {
    return d=>{
        if (r === "no-state")
            d.storeUint(0, 2);
        else if (r === "bad-state")
            d.storeUint(1, 2);
        else if (r === "no-gas")
            d.storeUint(2, 2);
        else
            throw new Error(`Unknown ComputeSkipReason: ${r}`)
    }
}
ComputeSkipReason.storeComputeSkipReason = storeComputeSkipReason;
var DepthBalanceInfo = {};
Object.defineProperty(DepthBalanceInfo, "__esModule", {
    value: !0
});
DepthBalanceInfo.storeDepthBalanceInfo = DepthBalanceInfo.loadDepthBalanceInfo = void 0;
const CurrencyCollection_1$2 = CurrencyCollection;
function loadDepthBalanceInfo(r) {
    return {
        splitDepth: r.loadUint(5),
        balance: (0,
        CurrencyCollection_1$2.loadCurrencyCollection)(r)
    }
}
DepthBalanceInfo.loadDepthBalanceInfo = loadDepthBalanceInfo;
function storeDepthBalanceInfo(r) {
    return d=>{
        d.storeUint(r.splitDepth, 5),
        d.store((0,
        CurrencyCollection_1$2.storeCurrencyCollection)(r.balance))
    }
}
DepthBalanceInfo.storeDepthBalanceInfo = storeDepthBalanceInfo;
var HashUpdate = {};
Object.defineProperty(HashUpdate, "__esModule", {
    value: !0
});
HashUpdate.storeHashUpdate = HashUpdate.loadHashUpdate = void 0;
function loadHashUpdate(r) {
    if (r.loadUint(8) !== 114)
        throw Error("Invalid data");
    const d = r.loadBuffer(32)
      , f = r.loadBuffer(32);
    return {
        oldHash: d,
        newHash: f
    }
}
HashUpdate.loadHashUpdate = loadHashUpdate;
function storeHashUpdate(r) {
    return d=>{
        d.storeUint(114, 8),
        d.storeBuffer(r.oldHash),
        d.storeBuffer(r.newHash)
    }
}
HashUpdate.storeHashUpdate = storeHashUpdate;
var MasterchainStateExtra = {};
Object.defineProperty(MasterchainStateExtra, "__esModule", {
    value: !0
});
MasterchainStateExtra.loadMasterchainStateExtra = void 0;
const Dictionary_1 = requireDictionary()
  , CurrencyCollection_1$1 = CurrencyCollection;
function loadMasterchainStateExtra(r) {
    if (r.loadUint(16) !== 52262)
        throw Error("Invalid data");
    r.loadBit() && r.loadRef();
    let d = r.loadUintBig(256)
      , f = Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.Int(32), Dictionary_1.Dictionary.Values.Cell(), r);
    const m = (0,
    CurrencyCollection_1$1.loadCurrencyCollection)(r);
    return {
        config: f,
        configAddress: d,
        globalBalance: m
    }
}
MasterchainStateExtra.loadMasterchainStateExtra = loadMasterchainStateExtra;
var Message = {};
Object.defineProperty(Message, "__esModule", {
    value: !0
});
Message.MessageValue = Message.storeMessage = Message.loadMessage = void 0;
const Builder_1$2 = requireBuilder()
  , CommonMessageInfo_1 = CommonMessageInfo
  , StateInit_1 = StateInit;
function loadMessage(r) {
    const d = (0,
    CommonMessageInfo_1.loadCommonMessageInfo)(r);
    let f = null;
    r.loadBit() && (r.loadBit() ? f = (0,
    StateInit_1.loadStateInit)(r.loadRef().beginParse()) : f = (0,
    StateInit_1.loadStateInit)(r));
    const m = r.loadBit() ? r.loadRef() : r.asCell();
    return {
        info: d,
        init: f,
        body: m
    }
}
Message.loadMessage = loadMessage;
function storeMessage(r, d) {
    return f=>{
        if (f.store((0,
        CommonMessageInfo_1.storeCommonMessageInfo)(r.info)),
        r.init) {
            f.storeBit(!0);
            let k = (0,
            Builder_1$2.beginCell)().store((0,
            StateInit_1.storeStateInit)(r.init))
              , y = !1;
            d && d.forceRef ? y = !0 : y = f.availableBits - 2 < k.bits + r.body.bits.length,
            y ? (f.storeBit(!0),
            f.storeRef(k)) : (f.storeBit(!1),
            f.storeBuilder(k))
        } else
            f.storeBit(!1);
        let m = !1;
        d && d.forceRef ? m = !0 : m = f.availableBits - 1 < r.body.bits.length || f.refs + r.body.refs.length > 4,
        m ? (f.storeBit(!0),
        f.storeRef(r.body)) : (f.storeBit(!1),
        f.storeBuilder(r.body.asBuilder()))
    }
}
Message.storeMessage = storeMessage;
Message.MessageValue = {
    serialize(r, d) {
        d.storeRef((0,
        Builder_1$2.beginCell)().store(storeMessage(r)))
    },
    parse(r) {
        return loadMessage(r.loadRef().beginParse())
    }
};
var SendMode$1 = {};
Object.defineProperty(SendMode$1, "__esModule", {
    value: !0
});
SendMode$1.SendMode = void 0;
var SendMode;
(function(r) {
    r[r.CARRY_ALL_REMAINING_BALANCE = 128] = "CARRY_ALL_REMAINING_BALANCE",
    r[r.CARRY_ALL_REMAINING_INCOMING_VALUE = 64] = "CARRY_ALL_REMAINING_INCOMING_VALUE",
    r[r.DESTROY_ACCOUNT_IF_ZERO = 32] = "DESTROY_ACCOUNT_IF_ZERO",
    r[r.PAY_GAS_SEPARATELY = 1] = "PAY_GAS_SEPARATELY",
    r[r.IGNORE_ERRORS = 2] = "IGNORE_ERRORS",
    r[r.NONE = 0] = "NONE"
}
)(SendMode || (SendMode$1.SendMode = SendMode = {}));
var ShardAccount = {};
Object.defineProperty(ShardAccount, "__esModule", {
    value: !0
});
ShardAccount.storeShardAccount = ShardAccount.loadShardAccount = void 0;
const Builder_1$1 = requireBuilder()
  , Account_1 = Account;
function loadShardAccount(r) {
    let d = r.loadRef(), f;
    if (!d.isExotic) {
        let m = d.beginParse();
        m.loadBit() && (f = (0,
        Account_1.loadAccount)(m))
    }
    return {
        account: f,
        lastTransactionHash: r.loadUintBig(256),
        lastTransactionLt: r.loadUintBig(64)
    }
}
ShardAccount.loadShardAccount = loadShardAccount;
function storeShardAccount(r) {
    return d=>{
        r.account ? d.storeRef((0,
        Builder_1$1.beginCell)().storeBit(!0).store((0,
        Account_1.storeAccount)(r.account))) : d.storeRef((0,
        Builder_1$1.beginCell)().storeBit(!1)),
        d.storeUint(r.lastTransactionHash, 256),
        d.storeUint(r.lastTransactionLt, 64)
    }
}
ShardAccount.storeShardAccount = storeShardAccount;
var ShardAccounts = {};
(function(r) {
    Object.defineProperty(r, "__esModule", {
        value: !0
    }),
    r.storeShardAccounts = r.loadShardAccounts = r.ShardAccountRefValue = void 0;
    const d = requireDictionary()
      , f = DepthBalanceInfo
      , m = ShardAccount;
    r.ShardAccountRefValue = {
        parse: ee=>{
            let dt = (0,
            f.loadDepthBalanceInfo)(ee)
              , mt = (0,
            m.loadShardAccount)(ee);
            return {
                depthBalanceInfo: dt,
                shardAccount: mt
            }
        }
        ,
        serialize(ee, dt) {
            dt.store((0,
            f.storeDepthBalanceInfo)(ee.depthBalanceInfo)),
            dt.store((0,
            m.storeShardAccount)(ee.shardAccount))
        }
    };
    function k(ee) {
        return d.Dictionary.load(d.Dictionary.Keys.BigUint(256), r.ShardAccountRefValue, ee)
    }
    r.loadShardAccounts = k;
    function y(ee) {
        return dt=>{
            dt.storeDict(ee)
        }
    }
    r.storeShardAccounts = y
}
)(ShardAccounts);
var ShardIdent = {};
Object.defineProperty(ShardIdent, "__esModule", {
    value: !0
});
ShardIdent.storeShardIdent = ShardIdent.loadShardIdent = void 0;
function loadShardIdent(r) {
    if (r.loadUint(2) !== 0)
        throw Error("Invalid data");
    return {
        shardPrefixBits: r.loadUint(6),
        workchainId: r.loadInt(32),
        shardPrefix: r.loadUintBig(64)
    }
}
ShardIdent.loadShardIdent = loadShardIdent;
function storeShardIdent(r) {
    return d=>{
        d.storeUint(0, 2),
        d.storeUint(r.shardPrefixBits, 6),
        d.storeInt(r.workchainId, 32),
        d.storeUint(r.shardPrefix, 64)
    }
}
ShardIdent.storeShardIdent = storeShardIdent;
var ShardStateUnsplit = {};
Object.defineProperty(ShardStateUnsplit, "__esModule", {
    value: !0
});
ShardStateUnsplit.loadShardStateUnsplit = void 0;
const MasterchainStateExtra_1 = MasterchainStateExtra
  , ShardAccounts_1 = ShardAccounts
  , ShardIdent_1 = ShardIdent;
function loadShardStateUnsplit(r) {
    if (r.loadUint(32) !== 2418257890)
        throw Error("Invalid data");
    let d = r.loadInt(32)
      , f = (0,
    ShardIdent_1.loadShardIdent)(r)
      , m = r.loadUint(32)
      , k = r.loadUint(32)
      , y = r.loadUint(32)
      , ee = r.loadUintBig(64)
      , dt = r.loadUint(32);
    r.loadRef();
    let mt = r.loadBit(), yt = r.loadRef(), pt;
    yt.isExotic || (pt = (0,
    ShardAccounts_1.loadShardAccounts)(yt.beginParse())),
    r.loadRef();
    let bt = r.loadBit()
      , wt = null;
    if (bt) {
        let xt = r.loadRef();
        xt.isExotic || (wt = (0,
        MasterchainStateExtra_1.loadMasterchainStateExtra)(xt.beginParse()))
    }
    return {
        globalId: d,
        shardId: f,
        seqno: m,
        vertSeqNo: k,
        genUtime: y,
        genLt: ee,
        minRefMcSeqno: dt,
        beforeSplit: mt,
        accounts: pt,
        extras: wt
    }
}
ShardStateUnsplit.loadShardStateUnsplit = loadShardStateUnsplit;
var SplitMergeInfo = {};
Object.defineProperty(SplitMergeInfo, "__esModule", {
    value: !0
});
SplitMergeInfo.storeSplitMergeInfo = SplitMergeInfo.loadSplitMergeInfo = void 0;
function loadSplitMergeInfo(r) {
    let d = r.loadUint(6)
      , f = r.loadUint(6)
      , m = r.loadUintBig(256)
      , k = r.loadUintBig(256);
    return {
        currentShardPrefixLength: d,
        accountSplitDepth: f,
        thisAddress: m,
        siblingAddress: k
    }
}
SplitMergeInfo.loadSplitMergeInfo = loadSplitMergeInfo;
function storeSplitMergeInfo(r) {
    return d=>{
        d.storeUint(r.currentShardPrefixLength, 6),
        d.storeUint(r.accountSplitDepth, 6),
        d.storeUint(r.thisAddress, 256),
        d.storeUint(r.siblingAddress, 256)
    }
}
SplitMergeInfo.storeSplitMergeInfo = storeSplitMergeInfo;
var StorageUsedShort = {};
Object.defineProperty(StorageUsedShort, "__esModule", {
    value: !0
});
StorageUsedShort.storeStorageUsedShort = StorageUsedShort.loadStorageUsedShort = void 0;
function loadStorageUsedShort(r) {
    let d = r.loadVarUintBig(3)
      , f = r.loadVarUintBig(3);
    return {
        cells: d,
        bits: f
    }
}
StorageUsedShort.loadStorageUsedShort = loadStorageUsedShort;
function storeStorageUsedShort(r) {
    return d=>{
        d.storeVarUint(r.cells, 3),
        d.storeVarUint(r.bits, 3)
    }
}
StorageUsedShort.storeStorageUsedShort = storeStorageUsedShort;
var Transaction = {}
  , TransactionDescription = {}
  , TransactionActionPhase = {};
Object.defineProperty(TransactionActionPhase, "__esModule", {
    value: !0
});
TransactionActionPhase.storeTransactionActionPhase = TransactionActionPhase.loadTransactionActionPhase = void 0;
const AccountStatusChange_1$1 = AccountStatusChange
  , StorageUsedShort_1$1 = StorageUsedShort;
function loadTransactionActionPhase(r) {
    let d = r.loadBit()
      , f = r.loadBit()
      , m = r.loadBit()
      , k = (0,
    AccountStatusChange_1$1.loadAccountStatusChange)(r)
      , y = r.loadBit() ? r.loadCoins() : void 0
      , ee = r.loadBit() ? r.loadCoins() : void 0
      , dt = r.loadInt(32)
      , mt = r.loadBit() ? r.loadInt(32) : void 0
      , yt = r.loadUint(16)
      , pt = r.loadUint(16)
      , bt = r.loadUint(16)
      , wt = r.loadUint(16)
      , xt = r.loadUintBig(256)
      , At = (0,
    StorageUsedShort_1$1.loadStorageUsedShort)(r);
    return {
        success: d,
        valid: f,
        noFunds: m,
        statusChange: k,
        totalFwdFees: y,
        totalActionFees: ee,
        resultCode: dt,
        resultArg: mt,
        totalActions: yt,
        specActions: pt,
        skippedActions: bt,
        messagesCreated: wt,
        actionListHash: xt,
        totalMessageSize: At
    }
}
TransactionActionPhase.loadTransactionActionPhase = loadTransactionActionPhase;
function storeTransactionActionPhase(r) {
    return d=>{
        d.storeBit(r.success),
        d.storeBit(r.valid),
        d.storeBit(r.noFunds),
        d.store((0,
        AccountStatusChange_1$1.storeAccountStatusChange)(r.statusChange)),
        d.storeMaybeCoins(r.totalFwdFees),
        d.storeMaybeCoins(r.totalActionFees),
        d.storeInt(r.resultCode, 32),
        d.storeMaybeInt(r.resultArg, 32),
        d.storeUint(r.totalActions, 16),
        d.storeUint(r.specActions, 16),
        d.storeUint(r.skippedActions, 16),
        d.storeUint(r.messagesCreated, 16),
        d.storeUint(r.actionListHash, 256),
        d.store((0,
        StorageUsedShort_1$1.storeStorageUsedShort)(r.totalMessageSize))
    }
}
TransactionActionPhase.storeTransactionActionPhase = storeTransactionActionPhase;
var TransactionBouncePhase = {};
Object.defineProperty(TransactionBouncePhase, "__esModule", {
    value: !0
});
TransactionBouncePhase.storeTransactionBouncePhase = TransactionBouncePhase.loadTransactionBouncePhase = void 0;
const StorageUsedShort_1 = StorageUsedShort;
function loadTransactionBouncePhase(r) {
    if (r.loadBit()) {
        let d = (0,
        StorageUsedShort_1.loadStorageUsedShort)(r)
          , f = r.loadCoins()
          , m = r.loadCoins();
        return {
            type: "ok",
            messageSize: d,
            messageFees: f,
            forwardFees: m
        }
    }
    if (r.loadBit()) {
        let d = (0,
        StorageUsedShort_1.loadStorageUsedShort)(r)
          , f = r.loadCoins();
        return {
            type: "no-funds",
            messageSize: d,
            requiredForwardFees: f
        }
    }
    return {
        type: "negative-funds"
    }
}
TransactionBouncePhase.loadTransactionBouncePhase = loadTransactionBouncePhase;
function storeTransactionBouncePhase(r) {
    return d=>{
        if (r.type === "ok")
            d.storeBit(!0),
            d.store((0,
            StorageUsedShort_1.storeStorageUsedShort)(r.messageSize)),
            d.storeCoins(r.messageFees),
            d.storeCoins(r.forwardFees);
        else if (r.type === "negative-funds")
            d.storeBit(!1),
            d.storeBit(!1);
        else if (r.type === "no-funds")
            d.storeBit(!1),
            d.storeBit(!0),
            d.store((0,
            StorageUsedShort_1.storeStorageUsedShort)(r.messageSize)),
            d.storeCoins(r.requiredForwardFees);
        else
            throw new Error("Invalid TransactionBouncePhase type")
    }
}
TransactionBouncePhase.storeTransactionBouncePhase = storeTransactionBouncePhase;
var TransactionComputePhase = {};
Object.defineProperty(TransactionComputePhase, "__esModule", {
    value: !0
});
TransactionComputePhase.storeTransactionComputePhase = TransactionComputePhase.loadTransactionComputePhase = void 0;
const Builder_1 = requireBuilder()
  , ComputeSkipReason_1 = ComputeSkipReason;
function loadTransactionComputePhase(r) {
    if (!r.loadBit())
        return {
            type: "skipped",
            reason: (0,
            ComputeSkipReason_1.loadComputeSkipReason)(r)
        };
    let d = r.loadBit()
      , f = r.loadBit()
      , m = r.loadBit()
      , k = r.loadCoins();
    const y = r.loadRef().beginParse();
    let ee = y.loadVarUintBig(3)
      , dt = y.loadVarUintBig(3)
      , mt = y.loadBit() ? y.loadVarUintBig(2) : void 0
      , yt = y.loadUint(8)
      , pt = y.loadInt(32)
      , bt = y.loadBit() ? y.loadInt(32) : void 0
      , wt = y.loadUint(32)
      , xt = y.loadUintBig(256)
      , At = y.loadUintBig(256);
    return {
        type: "vm",
        success: d,
        messageStateUsed: f,
        accountActivated: m,
        gasFees: k,
        gasUsed: ee,
        gasLimit: dt,
        gasCredit: mt,
        mode: yt,
        exitCode: pt,
        exitArg: bt,
        vmSteps: wt,
        vmInitStateHash: xt,
        vmFinalStateHash: At
    }
}
TransactionComputePhase.loadTransactionComputePhase = loadTransactionComputePhase;
function storeTransactionComputePhase(r) {
    return d=>{
        if (r.type === "skipped") {
            d.storeBit(0),
            d.store((0,
            ComputeSkipReason_1.storeComputeSkipReason)(r.reason));
            return
        }
        d.storeBit(1),
        d.storeBit(r.success),
        d.storeBit(r.messageStateUsed),
        d.storeBit(r.accountActivated),
        d.storeCoins(r.gasFees),
        d.storeRef((0,
        Builder_1.beginCell)().storeVarUint(r.gasUsed, 3).storeVarUint(r.gasLimit, 3).store(f=>r.gasCredit !== void 0 && r.gasCredit !== null ? f.storeBit(1).storeVarUint(r.gasCredit, 2) : f.storeBit(0)).storeUint(r.mode, 8).storeInt(r.exitCode, 32).store(f=>r.exitArg !== void 0 && r.exitArg !== null ? f.storeBit(1).storeInt(r.exitArg, 32) : f.storeBit(0)).storeUint(r.vmSteps, 32).storeUint(r.vmInitStateHash, 256).storeUint(r.vmFinalStateHash, 256).endCell())
    }
}
TransactionComputePhase.storeTransactionComputePhase = storeTransactionComputePhase;
var TransactionCreditPhase = {};
Object.defineProperty(TransactionCreditPhase, "__esModule", {
    value: !0
});
TransactionCreditPhase.storeTransactionCreditPhase = TransactionCreditPhase.loadTransactionCreditPhase = void 0;
const CurrencyCollection_1 = CurrencyCollection;
function loadTransactionCreditPhase(r) {
    const d = r.loadBit() ? r.loadCoins() : void 0
      , f = (0,
    CurrencyCollection_1.loadCurrencyCollection)(r);
    return {
        dueFeesColelcted: d,
        credit: f
    }
}
TransactionCreditPhase.loadTransactionCreditPhase = loadTransactionCreditPhase;
function storeTransactionCreditPhase(r) {
    return d=>{
        r.dueFeesColelcted === null || r.dueFeesColelcted === void 0 ? d.storeBit(!1) : (d.storeBit(!0),
        d.storeCoins(r.dueFeesColelcted)),
        d.store((0,
        CurrencyCollection_1.storeCurrencyCollection)(r.credit))
    }
}
TransactionCreditPhase.storeTransactionCreditPhase = storeTransactionCreditPhase;
var TransactionStoragePhase = {};
Object.defineProperty(TransactionStoragePhase, "__esModule", {
    value: !0
});
TransactionStoragePhase.storeTransactionsStoragePhase = TransactionStoragePhase.loadTransactionStoragePhase = void 0;
const AccountStatusChange_1 = AccountStatusChange;
function loadTransactionStoragePhase(r) {
    const d = r.loadCoins();
    let f;
    r.loadBit() && (f = r.loadCoins());
    const m = (0,
    AccountStatusChange_1.loadAccountStatusChange)(r);
    return {
        storageFeesCollected: d,
        storageFeesDue: f,
        statusChange: m
    }
}
TransactionStoragePhase.loadTransactionStoragePhase = loadTransactionStoragePhase;
function storeTransactionsStoragePhase(r) {
    return d=>{
        d.storeCoins(r.storageFeesCollected),
        r.storageFeesDue === null || r.storageFeesDue === void 0 ? d.storeBit(!1) : (d.storeBit(!0),
        d.storeCoins(r.storageFeesDue)),
        d.store((0,
        AccountStatusChange_1.storeAccountStatusChange)(r.statusChange))
    }
}
TransactionStoragePhase.storeTransactionsStoragePhase = storeTransactionsStoragePhase;
var hasRequiredTransactionDescription;
function requireTransactionDescription() {
    if (hasRequiredTransactionDescription)
        return TransactionDescription;
    hasRequiredTransactionDescription = 1,
    Object.defineProperty(TransactionDescription, "__esModule", {
        value: !0
    }),
    TransactionDescription.storeTransactionDescription = TransactionDescription.loadTransactionDescription = void 0;
    const r = requireBuilder()
      , d = SplitMergeInfo
      , f = requireTransaction()
      , m = TransactionActionPhase
      , k = TransactionBouncePhase
      , y = TransactionComputePhase
      , ee = TransactionCreditPhase
      , dt = TransactionStoragePhase;
    function mt(pt) {
        let bt = pt.loadUint(4);
        if (bt === 0) {
            const wt = pt.loadBit();
            let xt;
            pt.loadBit() && (xt = (0,
            dt.loadTransactionStoragePhase)(pt));
            let At;
            pt.loadBit() && (At = (0,
            ee.loadTransactionCreditPhase)(pt));
            let Ct = (0,
            y.loadTransactionComputePhase)(pt), Pt;
            pt.loadBit() && (Pt = (0,
            m.loadTransactionActionPhase)(pt.loadRef().beginParse()));
            let $t = pt.loadBit(), Ot;
            pt.loadBit() && (Ot = (0,
            k.loadTransactionBouncePhase)(pt));
            const Nt = pt.loadBit();
            return {
                type: "generic",
                creditFirst: wt,
                storagePhase: xt,
                creditPhase: At,
                computePhase: Ct,
                actionPhase: Pt,
                bouncePhase: Ot,
                aborted: $t,
                destroyed: Nt
            }
        }
        if (bt === 1)
            return {
                type: "storage",
                storagePhase: (0,
                dt.loadTransactionStoragePhase)(pt)
            };
        if (bt === 2 || bt === 3) {
            const wt = bt === 3;
            let xt = (0,
            dt.loadTransactionStoragePhase)(pt), At = (0,
            y.loadTransactionComputePhase)(pt), Ct;
            pt.loadBit() && (Ct = (0,
            m.loadTransactionActionPhase)(pt.loadRef().beginParse()));
            const Pt = pt.loadBit()
              , $t = pt.loadBit();
            return {
                type: "tick-tock",
                isTock: wt,
                storagePhase: xt,
                computePhase: At,
                actionPhase: Ct,
                aborted: Pt,
                destroyed: $t
            }
        }
        if (bt === 4) {
            let wt = (0,
            d.loadSplitMergeInfo)(pt), xt;
            pt.loadBit() && (xt = (0,
            dt.loadTransactionStoragePhase)(pt));
            let At = (0,
            y.loadTransactionComputePhase)(pt), Ct;
            pt.loadBit() && (Ct = (0,
            m.loadTransactionActionPhase)(pt.loadRef().beginParse()));
            const Pt = pt.loadBit()
              , $t = pt.loadBit();
            return {
                type: "split-prepare",
                splitInfo: wt,
                storagePhase: xt,
                computePhase: At,
                actionPhase: Ct,
                aborted: Pt,
                destroyed: $t
            }
        }
        if (bt === 5) {
            let wt = (0,
            d.loadSplitMergeInfo)(pt)
              , xt = (0,
            f.loadTransaction)(pt.loadRef().beginParse());
            const At = pt.loadBit();
            return {
                type: "split-install",
                splitInfo: wt,
                prepareTransaction: xt,
                installed: At
            }
        }
        throw Error(`Unsupported transaction description type ${bt}`)
    }
    TransactionDescription.loadTransactionDescription = mt;
    function yt(pt) {
        return bt=>{
            if (pt.type === "generic")
                bt.storeUint(0, 4),
                bt.storeBit(pt.creditFirst),
                pt.storagePhase ? (bt.storeBit(!0),
                bt.store((0,
                dt.storeTransactionsStoragePhase)(pt.storagePhase))) : bt.storeBit(!1),
                pt.creditPhase ? (bt.storeBit(!0),
                bt.store((0,
                ee.storeTransactionCreditPhase)(pt.creditPhase))) : bt.storeBit(!1),
                bt.store((0,
                y.storeTransactionComputePhase)(pt.computePhase)),
                pt.actionPhase ? (bt.storeBit(!0),
                bt.storeRef((0,
                r.beginCell)().store((0,
                m.storeTransactionActionPhase)(pt.actionPhase)))) : bt.storeBit(!1),
                bt.storeBit(pt.aborted),
                pt.bouncePhase ? (bt.storeBit(!0),
                bt.store((0,
                k.storeTransactionBouncePhase)(pt.bouncePhase))) : bt.storeBit(!1),
                bt.storeBit(pt.destroyed);
            else if (pt.type === "storage")
                bt.storeUint(1, 4),
                bt.store((0,
                dt.storeTransactionsStoragePhase)(pt.storagePhase));
            else if (pt.type === "tick-tock")
                bt.storeUint(pt.isTock ? 3 : 2, 4),
                bt.store((0,
                dt.storeTransactionsStoragePhase)(pt.storagePhase)),
                bt.store((0,
                y.storeTransactionComputePhase)(pt.computePhase)),
                pt.actionPhase ? (bt.storeBit(!0),
                bt.storeRef((0,
                r.beginCell)().store((0,
                m.storeTransactionActionPhase)(pt.actionPhase)))) : bt.storeBit(!1),
                bt.storeBit(pt.aborted),
                bt.storeBit(pt.destroyed);
            else if (pt.type === "split-prepare")
                bt.storeUint(4, 4),
                bt.store((0,
                d.storeSplitMergeInfo)(pt.splitInfo)),
                pt.storagePhase ? (bt.storeBit(!0),
                bt.store((0,
                dt.storeTransactionsStoragePhase)(pt.storagePhase))) : bt.storeBit(!1),
                bt.store((0,
                y.storeTransactionComputePhase)(pt.computePhase)),
                pt.actionPhase ? (bt.storeBit(!0),
                bt.store((0,
                m.storeTransactionActionPhase)(pt.actionPhase))) : bt.storeBit(!1),
                bt.storeBit(pt.aborted),
                bt.storeBit(pt.destroyed);
            else if (pt.type === "split-install")
                bt.storeUint(5, 4),
                bt.store((0,
                d.storeSplitMergeInfo)(pt.splitInfo)),
                bt.storeRef((0,
                r.beginCell)().store((0,
                f.storeTransaction)(pt.prepareTransaction))),
                bt.storeBit(pt.installed);
            else
                throw Error(`Unsupported transaction description type ${pt.type}`)
        }
    }
    return TransactionDescription.storeTransactionDescription = yt,
    TransactionDescription
}
var hasRequiredTransaction;
function requireTransaction() {
    if (hasRequiredTransaction)
        return Transaction;
    hasRequiredTransaction = 1,
    Object.defineProperty(Transaction, "__esModule", {
        value: !0
    }),
    Transaction.storeTransaction = Transaction.loadTransaction = void 0;
    const r = requireBuilder()
      , d = requireDictionary()
      , f = AccountStatus
      , m = CurrencyCollection
      , k = HashUpdate
      , y = Message
      , ee = requireTransactionDescription();
    function dt(yt) {
        let pt = yt.asCell();
        if (yt.loadUint(4) !== 7)
            throw Error("Invalid data");
        let bt = yt.loadUintBig(256)
          , wt = yt.loadUintBig(64)
          , xt = yt.loadUintBig(256)
          , At = yt.loadUintBig(64)
          , Ct = yt.loadUint(32)
          , Pt = yt.loadUint(15)
          , $t = (0,
        f.loadAccountStatus)(yt)
          , Ot = (0,
        f.loadAccountStatus)(yt)
          , zt = yt.loadRef().beginParse()
          , Wt = zt.loadBit() ? (0,
        y.loadMessage)(zt.loadRef().beginParse()) : void 0
          , Kt = zt.loadDict(d.Dictionary.Keys.Uint(15), y.MessageValue);
        zt.endParse();
        let ir = (0,
        m.loadCurrencyCollection)(yt)
          , or = (0,
        k.loadHashUpdate)(yt.loadRef().beginParse())
          , tr = (0,
        ee.loadTransactionDescription)(yt.loadRef().beginParse());
        return {
            address: bt,
            lt: wt,
            prevTransactionHash: xt,
            prevTransactionLt: At,
            now: Ct,
            outMessagesCount: Pt,
            oldStatus: $t,
            endStatus: Ot,
            inMessage: Wt,
            outMessages: Kt,
            totalFees: ir,
            stateUpdate: or,
            description: tr,
            raw: pt,
            hash: ()=>pt.hash()
        }
    }
    Transaction.loadTransaction = dt;
    function mt(yt) {
        return pt=>{
            pt.storeUint(7, 4),
            pt.storeUint(yt.address, 256),
            pt.storeUint(yt.lt, 64),
            pt.storeUint(yt.prevTransactionHash, 256),
            pt.storeUint(yt.prevTransactionLt, 64),
            pt.storeUint(yt.now, 32),
            pt.storeUint(yt.outMessagesCount, 15),
            pt.store((0,
            f.storeAccountStatus)(yt.oldStatus)),
            pt.store((0,
            f.storeAccountStatus)(yt.endStatus));
            let bt = (0,
            r.beginCell)();
            yt.inMessage ? (bt.storeBit(!0),
            bt.storeRef((0,
            r.beginCell)().store((0,
            y.storeMessage)(yt.inMessage)))) : bt.storeBit(!1),
            bt.storeDict(yt.outMessages),
            pt.storeRef(bt),
            pt.store((0,
            m.storeCurrencyCollection)(yt.totalFees)),
            pt.storeRef((0,
            r.beginCell)().store((0,
            k.storeHashUpdate)(yt.stateUpdate))),
            pt.storeRef((0,
            r.beginCell)().store((0,
            ee.storeTransactionDescription)(yt.description)))
        }
    }
    return Transaction.storeTransaction = mt,
    Transaction
}
(function(r) {
    Object.defineProperty(r, "__esModule", {
        value: !0
    }),
    r.loadStorageInfo = r.storeStateInit = r.loadStateInit = r.storeSplitMergeInfo = r.loadSplitMergeInfo = r.storeSimpleLibrary = r.loadSimpleLibrary = r.loadShardStateUnsplit = r.storeShardIdent = r.loadShardIdent = r.storeShardAccounts = r.loadShardAccounts = r.ShardAccountRefValue = r.storeShardAccount = r.loadShardAccount = r.SendMode = r.storeMessageRelaxed = r.loadMessageRelaxed = r.storeMessage = r.loadMessage = r.loadMasterchainStateExtra = r.storeHashUpdate = r.loadHashUpdate = r.storeDepthBalanceInfo = r.loadDepthBalanceInfo = r.storeCurrencyCollection = r.loadCurrencyCollection = r.storeComputeSkipReason = r.loadComputeSkipReason = r.storeCommonMessageInfoRelaxed = r.loadCommonMessageInfoRelaxed = r.storeCommonMessageInfo = r.loadCommonMessageInfo = r.storeOutList = r.loadOutList = r.storeOutAction = r.loadOutAction = r.storeAccountStorage = r.loadAccountStorage = r.storeAccountStatusChange = r.loadAccountStatusChange = r.storeAccountStatus = r.loadAccountStatus = r.storeAccountState = r.loadAccountState = r.storeAccount = r.loadAccount = r.comment = r.external = r.internal = void 0,
    r.storeTransactionsStoragePhase = r.loadTransactionStoragePhase = r.storeTransactionDescription = r.loadTransactionDescription = r.storeTransactionCreditPhase = r.loadTransactionCreditPhase = r.storeTransactionComputePhase = r.loadTransactionComputePhase = r.storeTransactionBouncePhase = r.loadTransactionBouncePhase = r.storeTransactionActionPhase = r.loadTransactionActionPhase = r.storeTransaction = r.loadTransaction = r.storeTickTock = r.loadTickTock = r.storeStorageUsedShort = r.loadStorageUsedShort = r.storeStorageUsed = r.loadStorageUsed = r.storeStorageInfo = void 0;
    var d = _helpers;
    Object.defineProperty(r, "internal", {
        enumerable: !0,
        get: function() {
            return d.internal
        }
    }),
    Object.defineProperty(r, "external", {
        enumerable: !0,
        get: function() {
            return d.external
        }
    }),
    Object.defineProperty(r, "comment", {
        enumerable: !0,
        get: function() {
            return d.comment
        }
    });
    var f = Account;
    Object.defineProperty(r, "loadAccount", {
        enumerable: !0,
        get: function() {
            return f.loadAccount
        }
    }),
    Object.defineProperty(r, "storeAccount", {
        enumerable: !0,
        get: function() {
            return f.storeAccount
        }
    });
    var m = AccountState;
    Object.defineProperty(r, "loadAccountState", {
        enumerable: !0,
        get: function() {
            return m.loadAccountState
        }
    }),
    Object.defineProperty(r, "storeAccountState", {
        enumerable: !0,
        get: function() {
            return m.storeAccountState
        }
    });
    var k = AccountStatus;
    Object.defineProperty(r, "loadAccountStatus", {
        enumerable: !0,
        get: function() {
            return k.loadAccountStatus
        }
    }),
    Object.defineProperty(r, "storeAccountStatus", {
        enumerable: !0,
        get: function() {
            return k.storeAccountStatus
        }
    });
    var y = AccountStatusChange;
    Object.defineProperty(r, "loadAccountStatusChange", {
        enumerable: !0,
        get: function() {
            return y.loadAccountStatusChange
        }
    }),
    Object.defineProperty(r, "storeAccountStatusChange", {
        enumerable: !0,
        get: function() {
            return y.storeAccountStatusChange
        }
    });
    var ee = AccountStorage;
    Object.defineProperty(r, "loadAccountStorage", {
        enumerable: !0,
        get: function() {
            return ee.loadAccountStorage
        }
    }),
    Object.defineProperty(r, "storeAccountStorage", {
        enumerable: !0,
        get: function() {
            return ee.storeAccountStorage
        }
    });
    var dt = OutList;
    Object.defineProperty(r, "loadOutAction", {
        enumerable: !0,
        get: function() {
            return dt.loadOutAction
        }
    }),
    Object.defineProperty(r, "storeOutAction", {
        enumerable: !0,
        get: function() {
            return dt.storeOutAction
        }
    }),
    Object.defineProperty(r, "loadOutList", {
        enumerable: !0,
        get: function() {
            return dt.loadOutList
        }
    }),
    Object.defineProperty(r, "storeOutList", {
        enumerable: !0,
        get: function() {
            return dt.storeOutList
        }
    });
    var mt = CommonMessageInfo;
    Object.defineProperty(r, "loadCommonMessageInfo", {
        enumerable: !0,
        get: function() {
            return mt.loadCommonMessageInfo
        }
    }),
    Object.defineProperty(r, "storeCommonMessageInfo", {
        enumerable: !0,
        get: function() {
            return mt.storeCommonMessageInfo
        }
    });
    var yt = CommonMessageInfoRelaxed;
    Object.defineProperty(r, "loadCommonMessageInfoRelaxed", {
        enumerable: !0,
        get: function() {
            return yt.loadCommonMessageInfoRelaxed
        }
    }),
    Object.defineProperty(r, "storeCommonMessageInfoRelaxed", {
        enumerable: !0,
        get: function() {
            return yt.storeCommonMessageInfoRelaxed
        }
    });
    var pt = ComputeSkipReason;
    Object.defineProperty(r, "loadComputeSkipReason", {
        enumerable: !0,
        get: function() {
            return pt.loadComputeSkipReason
        }
    }),
    Object.defineProperty(r, "storeComputeSkipReason", {
        enumerable: !0,
        get: function() {
            return pt.storeComputeSkipReason
        }
    });
    var bt = CurrencyCollection;
    Object.defineProperty(r, "loadCurrencyCollection", {
        enumerable: !0,
        get: function() {
            return bt.loadCurrencyCollection
        }
    }),
    Object.defineProperty(r, "storeCurrencyCollection", {
        enumerable: !0,
        get: function() {
            return bt.storeCurrencyCollection
        }
    });
    var wt = DepthBalanceInfo;
    Object.defineProperty(r, "loadDepthBalanceInfo", {
        enumerable: !0,
        get: function() {
            return wt.loadDepthBalanceInfo
        }
    }),
    Object.defineProperty(r, "storeDepthBalanceInfo", {
        enumerable: !0,
        get: function() {
            return wt.storeDepthBalanceInfo
        }
    });
    var xt = HashUpdate;
    Object.defineProperty(r, "loadHashUpdate", {
        enumerable: !0,
        get: function() {
            return xt.loadHashUpdate
        }
    }),
    Object.defineProperty(r, "storeHashUpdate", {
        enumerable: !0,
        get: function() {
            return xt.storeHashUpdate
        }
    });
    var At = MasterchainStateExtra;
    Object.defineProperty(r, "loadMasterchainStateExtra", {
        enumerable: !0,
        get: function() {
            return At.loadMasterchainStateExtra
        }
    });
    var Ct = Message;
    Object.defineProperty(r, "loadMessage", {
        enumerable: !0,
        get: function() {
            return Ct.loadMessage
        }
    }),
    Object.defineProperty(r, "storeMessage", {
        enumerable: !0,
        get: function() {
            return Ct.storeMessage
        }
    });
    var Pt = MessageRelaxed;
    Object.defineProperty(r, "loadMessageRelaxed", {
        enumerable: !0,
        get: function() {
            return Pt.loadMessageRelaxed
        }
    }),
    Object.defineProperty(r, "storeMessageRelaxed", {
        enumerable: !0,
        get: function() {
            return Pt.storeMessageRelaxed
        }
    });
    var $t = SendMode$1;
    Object.defineProperty(r, "SendMode", {
        enumerable: !0,
        get: function() {
            return $t.SendMode
        }
    });
    var Ot = ShardAccount;
    Object.defineProperty(r, "loadShardAccount", {
        enumerable: !0,
        get: function() {
            return Ot.loadShardAccount
        }
    }),
    Object.defineProperty(r, "storeShardAccount", {
        enumerable: !0,
        get: function() {
            return Ot.storeShardAccount
        }
    });
    var Nt = ShardAccounts;
    Object.defineProperty(r, "ShardAccountRefValue", {
        enumerable: !0,
        get: function() {
            return Nt.ShardAccountRefValue
        }
    }),
    Object.defineProperty(r, "loadShardAccounts", {
        enumerable: !0,
        get: function() {
            return Nt.loadShardAccounts
        }
    }),
    Object.defineProperty(r, "storeShardAccounts", {
        enumerable: !0,
        get: function() {
            return Nt.storeShardAccounts
        }
    });
    var zt = ShardIdent;
    Object.defineProperty(r, "loadShardIdent", {
        enumerable: !0,
        get: function() {
            return zt.loadShardIdent
        }
    }),
    Object.defineProperty(r, "storeShardIdent", {
        enumerable: !0,
        get: function() {
            return zt.storeShardIdent
        }
    });
    var Wt = ShardStateUnsplit;
    Object.defineProperty(r, "loadShardStateUnsplit", {
        enumerable: !0,
        get: function() {
            return Wt.loadShardStateUnsplit
        }
    });
    var Kt = SimpleLibrary;
    Object.defineProperty(r, "loadSimpleLibrary", {
        enumerable: !0,
        get: function() {
            return Kt.loadSimpleLibrary
        }
    }),
    Object.defineProperty(r, "storeSimpleLibrary", {
        enumerable: !0,
        get: function() {
            return Kt.storeSimpleLibrary
        }
    });
    var ir = SplitMergeInfo;
    Object.defineProperty(r, "loadSplitMergeInfo", {
        enumerable: !0,
        get: function() {
            return ir.loadSplitMergeInfo
        }
    }),
    Object.defineProperty(r, "storeSplitMergeInfo", {
        enumerable: !0,
        get: function() {
            return ir.storeSplitMergeInfo
        }
    });
    var or = StateInit;
    Object.defineProperty(r, "loadStateInit", {
        enumerable: !0,
        get: function() {
            return or.loadStateInit
        }
    }),
    Object.defineProperty(r, "storeStateInit", {
        enumerable: !0,
        get: function() {
            return or.storeStateInit
        }
    });
    var tr = StorageInto;
    Object.defineProperty(r, "loadStorageInfo", {
        enumerable: !0,
        get: function() {
            return tr.loadStorageInfo
        }
    }),
    Object.defineProperty(r, "storeStorageInfo", {
        enumerable: !0,
        get: function() {
            return tr.storeStorageInfo
        }
    });
    var wr = StorageUsed;
    Object.defineProperty(r, "loadStorageUsed", {
        enumerable: !0,
        get: function() {
            return wr.loadStorageUsed
        }
    }),
    Object.defineProperty(r, "storeStorageUsed", {
        enumerable: !0,
        get: function() {
            return wr.storeStorageUsed
        }
    });
    var Ht = StorageUsedShort;
    Object.defineProperty(r, "loadStorageUsedShort", {
        enumerable: !0,
        get: function() {
            return Ht.loadStorageUsedShort
        }
    }),
    Object.defineProperty(r, "storeStorageUsedShort", {
        enumerable: !0,
        get: function() {
            return Ht.storeStorageUsedShort
        }
    });
    var Mt = TickTock;
    Object.defineProperty(r, "loadTickTock", {
        enumerable: !0,
        get: function() {
            return Mt.loadTickTock
        }
    }),
    Object.defineProperty(r, "storeTickTock", {
        enumerable: !0,
        get: function() {
            return Mt.storeTickTock
        }
    });
    var _t = requireTransaction();
    Object.defineProperty(r, "loadTransaction", {
        enumerable: !0,
        get: function() {
            return _t.loadTransaction
        }
    }),
    Object.defineProperty(r, "storeTransaction", {
        enumerable: !0,
        get: function() {
            return _t.storeTransaction
        }
    });
    var gt = TransactionActionPhase;
    Object.defineProperty(r, "loadTransactionActionPhase", {
        enumerable: !0,
        get: function() {
            return gt.loadTransactionActionPhase
        }
    }),
    Object.defineProperty(r, "storeTransactionActionPhase", {
        enumerable: !0,
        get: function() {
            return gt.storeTransactionActionPhase
        }
    });
    var vt = TransactionBouncePhase;
    Object.defineProperty(r, "loadTransactionBouncePhase", {
        enumerable: !0,
        get: function() {
            return vt.loadTransactionBouncePhase
        }
    }),
    Object.defineProperty(r, "storeTransactionBouncePhase", {
        enumerable: !0,
        get: function() {
            return vt.storeTransactionBouncePhase
        }
    });
    var Et = TransactionComputePhase;
    Object.defineProperty(r, "loadTransactionComputePhase", {
        enumerable: !0,
        get: function() {
            return Et.loadTransactionComputePhase
        }
    }),
    Object.defineProperty(r, "storeTransactionComputePhase", {
        enumerable: !0,
        get: function() {
            return Et.storeTransactionComputePhase
        }
    });
    var Bt = TransactionCreditPhase;
    Object.defineProperty(r, "loadTransactionCreditPhase", {
        enumerable: !0,
        get: function() {
            return Bt.loadTransactionCreditPhase
        }
    }),
    Object.defineProperty(r, "storeTransactionCreditPhase", {
        enumerable: !0,
        get: function() {
            return Bt.storeTransactionCreditPhase
        }
    });
    var Rt = requireTransactionDescription();
    Object.defineProperty(r, "loadTransactionDescription", {
        enumerable: !0,
        get: function() {
            return Rt.loadTransactionDescription
        }
    }),
    Object.defineProperty(r, "storeTransactionDescription", {
        enumerable: !0,
        get: function() {
            return Rt.storeTransactionDescription
        }
    });
    var kt = TransactionStoragePhase;
    Object.defineProperty(r, "loadTransactionStoragePhase", {
        enumerable: !0,
        get: function() {
            return kt.loadTransactionStoragePhase
        }
    }),
    Object.defineProperty(r, "storeTransactionsStoragePhase", {
        enumerable: !0,
        get: function() {
            return kt.storeTransactionsStoragePhase
        }
    })
}
)(_export);
var openContract$1 = {};
Object.defineProperty(openContract$1, "__esModule", {
    value: !0
});
openContract$1.openContract = void 0;
const Address_1 = Address$1
  , Cell_1 = requireCell();
function openContract(r, d) {
    let f, m = null;
    if (!Address_1.Address.isAddress(r.address))
        throw Error("Invalid address");
    if (f = r.address,
    r.init) {
        if (!(r.init.code instanceof Cell_1.Cell))
            throw Error("Invalid init.code");
        if (!(r.init.data instanceof Cell_1.Cell))
            throw Error("Invalid init.data");
        m = r.init
    }
    let k = d({
        address: f,
        init: m
    });
    return new Proxy(r,{
        get(y, ee) {
            const dt = y[ee];
            return typeof ee == "string" && (ee.startsWith("get") || ee.startsWith("send")) && typeof dt == "function" ? (...mt)=>dt.apply(y, [k, ...mt]) : dt
        }
    })
}
openContract$1.openContract = openContract;
var ComputeError$1 = {};
Object.defineProperty(ComputeError$1, "__esModule", {
    value: !0
});
ComputeError$1.ComputeError = void 0;
class ComputeError extends Error {
    constructor(d, f, m) {
        super(d),
        this.exitCode = f,
        this.debugLogs = m && m.debugLogs ? m.debugLogs : null,
        this.logs = m && m.logs ? m.logs : null,
        Object.setPrototypeOf(this, ComputeError.prototype)
    }
}
ComputeError$1.ComputeError = ComputeError;
var getMethodId$1 = {};
Object.defineProperty(getMethodId$1, "__esModule", {
    value: !0
});
getMethodId$1.getMethodId = void 0;
const TABLE = new Int16Array([0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290, 45419, 49548, 53677, 57806, 61935, 4657, 528, 12915, 8786, 21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205, 50076, 62463, 58334, 9314, 13379, 1056, 5121, 25830, 29895, 17572, 21637, 42346, 46411, 34088, 38153, 58862, 62927, 50604, 54669, 13907, 9842, 5649, 1584, 30423, 26358, 22165, 18100, 46939, 42874, 38681, 34616, 63455, 59390, 55197, 51132, 18628, 22757, 26758, 30887, 2112, 6241, 10242, 14371, 51660, 55789, 59790, 63919, 35144, 39273, 43274, 47403, 23285, 19156, 31415, 27286, 6769, 2640, 14899, 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802, 27814, 31879, 19684, 23749, 11298, 15363, 3168, 7233, 60846, 64911, 52716, 56781, 44330, 48395, 36200, 40265, 32407, 28342, 24277, 20212, 15891, 11826, 7761, 3696, 65439, 61374, 57309, 53244, 48923, 44858, 40793, 36728, 37256, 33193, 45514, 41451, 53516, 49453, 61774, 57711, 4224, 161, 12482, 8419, 20484, 16421, 28742, 24679, 33721, 37784, 41979, 46042, 49981, 54044, 58239, 62302, 689, 4752, 8947, 13010, 16949, 21012, 25207, 29270, 46570, 42443, 38312, 34185, 62830, 58703, 54572, 50445, 13538, 9411, 5280, 1153, 29798, 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231, 63358, 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941, 22068, 55628, 51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596, 18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093, 56156, 60223, 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254, 2801, 6864, 10931, 14994, 64814, 60687, 56684, 52557, 48554, 44427, 40424, 36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392, 3265, 61215, 65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183, 32310, 20053, 24180, 11923, 16050, 3793, 7920]);
function crc16(r) {
    r instanceof Buffer || (r = Buffer.from(r));
    let d = 0;
    for (let f = 0; f < r.length; f++) {
        const m = r[f];
        d = (TABLE[(d >> 8 ^ m) & 255] ^ d << 8) & 65535
    }
    return d
}
function getMethodId(r) {
    return crc16(r) & 65535 | 65536
}
getMethodId$1.getMethodId = getMethodId;
var safeSign$1 = {};
Object.defineProperty(safeSign$1, "__esModule", {
    value: !0
});
safeSign$1.safeSignVerify = safeSign$1.safeSign = void 0;
const crypto_1$3 = requireDist()
  , MIN_SEED_LENGTH = 8
  , MAX_SEED_LENGTH = 64;
function createSafeSignHash(r, d) {
    let f = Buffer.from(d);
    if (f.length > MAX_SEED_LENGTH)
        throw Error("Seed can	 be longer than 64 bytes");
    if (f.length < MIN_SEED_LENGTH)
        throw Error("Seed must be at least 8 bytes");
    return (0,
    crypto_1$3.sha256_sync)(Buffer.concat([Buffer.from([255, 255]), f, r.hash()]))
}
function safeSign(r, d, f="ton-safe-sign-magic") {
    return (0,
    crypto_1$3.sign)(createSafeSignHash(r, f), d)
}
safeSign$1.safeSign = safeSign;
function safeSignVerify(r, d, f, m="ton-safe-sign-magic") {
    return (0,
    crypto_1$3.signVerify)(createSafeSignHash(r, m), d, f)
}
safeSign$1.safeSignVerify = safeSignVerify;
(function(r) {
    var d = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(vt, Et, Bt, Rt) {
        Rt === void 0 && (Rt = Bt);
        var kt = Object.getOwnPropertyDescriptor(Et, Bt);
        (!kt || ("get"in kt ? !Et.__esModule : kt.writable || kt.configurable)) && (kt = {
            enumerable: !0,
            get: function() {
                return Et[Bt]
            }
        }),
        Object.defineProperty(vt, Rt, kt)
    }
    : function(vt, Et, Bt, Rt) {
        Rt === void 0 && (Rt = Bt),
        vt[Rt] = Et[Bt]
    }
    )
      , f = commonjsGlobal && commonjsGlobal.__exportStar || function(vt, Et) {
        for (var Bt in vt)
            Bt !== "default" && !Object.prototype.hasOwnProperty.call(Et, Bt) && d(Et, vt, Bt)
    }
    ;
    Object.defineProperty(r, "__esModule", {
        value: !0
    }),
    r.safeSignVerify = r.safeSign = r.getMethodId = r.base32Encode = r.base32Decode = r.crc32c = r.crc16 = r.fromNano = r.toNano = r.ComputeError = r.openContract = r.TupleBuilder = r.TupleReader = r.serializeTuple = r.parseTuple = r.generateMerkleUpdate = r.generateMerkleProof = r.exoticPruned = r.exoticMerkleUpdate = r.exoticMerkleProof = r.Dictionary = r.Cell = r.CellType = r.Slice = r.beginCell = r.Builder = r.BitBuilder = r.BitReader = r.BitString = r.contractAddress = r.ADNLAddress = r.ExternalAddress = r.address = r.Address = void 0;
    var m = Address$1;
    Object.defineProperty(r, "Address", {
        enumerable: !0,
        get: function() {
            return m.Address
        }
    }),
    Object.defineProperty(r, "address", {
        enumerable: !0,
        get: function() {
            return m.address
        }
    });
    var k = ExternalAddress$1;
    Object.defineProperty(r, "ExternalAddress", {
        enumerable: !0,
        get: function() {
            return k.ExternalAddress
        }
    });
    var y = ADNLAddress$1;
    Object.defineProperty(r, "ADNLAddress", {
        enumerable: !0,
        get: function() {
            return y.ADNLAddress
        }
    });
    var ee = contractAddress$1;
    Object.defineProperty(r, "contractAddress", {
        enumerable: !0,
        get: function() {
            return ee.contractAddress
        }
    });
    var dt = requireBitString();
    Object.defineProperty(r, "BitString", {
        enumerable: !0,
        get: function() {
            return dt.BitString
        }
    });
    var mt = BitReader$1;
    Object.defineProperty(r, "BitReader", {
        enumerable: !0,
        get: function() {
            return mt.BitReader
        }
    });
    var yt = requireBitBuilder();
    Object.defineProperty(r, "BitBuilder", {
        enumerable: !0,
        get: function() {
            return yt.BitBuilder
        }
    });
    var pt = requireBuilder();
    Object.defineProperty(r, "Builder", {
        enumerable: !0,
        get: function() {
            return pt.Builder
        }
    }),
    Object.defineProperty(r, "beginCell", {
        enumerable: !0,
        get: function() {
            return pt.beginCell
        }
    });
    var bt = requireSlice();
    Object.defineProperty(r, "Slice", {
        enumerable: !0,
        get: function() {
            return bt.Slice
        }
    });
    var wt = CellType$1;
    Object.defineProperty(r, "CellType", {
        enumerable: !0,
        get: function() {
            return wt.CellType
        }
    });
    var xt = requireCell();
    Object.defineProperty(r, "Cell", {
        enumerable: !0,
        get: function() {
            return xt.Cell
        }
    });
    var At = requireDictionary();
    Object.defineProperty(r, "Dictionary", {
        enumerable: !0,
        get: function() {
            return At.Dictionary
        }
    });
    var Ct = exoticMerkleProof$1;
    Object.defineProperty(r, "exoticMerkleProof", {
        enumerable: !0,
        get: function() {
            return Ct.exoticMerkleProof
        }
    });
    var Pt = exoticMerkleUpdate$1;
    Object.defineProperty(r, "exoticMerkleUpdate", {
        enumerable: !0,
        get: function() {
            return Pt.exoticMerkleUpdate
        }
    });
    var $t = exoticPruned$1;
    Object.defineProperty(r, "exoticPruned", {
        enumerable: !0,
        get: function() {
            return $t.exoticPruned
        }
    });
    var Ot = requireGenerateMerkleProof();
    Object.defineProperty(r, "generateMerkleProof", {
        enumerable: !0,
        get: function() {
            return Ot.generateMerkleProof
        }
    });
    var Nt = requireGenerateMerkleUpdate();
    Object.defineProperty(r, "generateMerkleUpdate", {
        enumerable: !0,
        get: function() {
            return Nt.generateMerkleUpdate
        }
    });
    var zt = tuple;
    Object.defineProperty(r, "parseTuple", {
        enumerable: !0,
        get: function() {
            return zt.parseTuple
        }
    }),
    Object.defineProperty(r, "serializeTuple", {
        enumerable: !0,
        get: function() {
            return zt.serializeTuple
        }
    });
    var Wt = reader;
    Object.defineProperty(r, "TupleReader", {
        enumerable: !0,
        get: function() {
            return Wt.TupleReader
        }
    });
    var Kt = builder;
    Object.defineProperty(r, "TupleBuilder", {
        enumerable: !0,
        get: function() {
            return Kt.TupleBuilder
        }
    }),
    f(_export, r);
    var ir = openContract$1;
    Object.defineProperty(r, "openContract", {
        enumerable: !0,
        get: function() {
            return ir.openContract
        }
    });
    var or = ComputeError$1;
    Object.defineProperty(r, "ComputeError", {
        enumerable: !0,
        get: function() {
            return or.ComputeError
        }
    });
    var tr = convert;
    Object.defineProperty(r, "toNano", {
        enumerable: !0,
        get: function() {
            return tr.toNano
        }
    }),
    Object.defineProperty(r, "fromNano", {
        enumerable: !0,
        get: function() {
            return tr.fromNano
        }
    });
    var wr = crc16$2;
    Object.defineProperty(r, "crc16", {
        enumerable: !0,
        get: function() {
            return wr.crc16
        }
    });
    var Ht = crc32c$1;
    Object.defineProperty(r, "crc32c", {
        enumerable: !0,
        get: function() {
            return Ht.crc32c
        }
    });
    var Mt = base32;
    Object.defineProperty(r, "base32Decode", {
        enumerable: !0,
        get: function() {
            return Mt.base32Decode
        }
    }),
    Object.defineProperty(r, "base32Encode", {
        enumerable: !0,
        get: function() {
            return Mt.base32Encode
        }
    });
    var _t = getMethodId$1;
    Object.defineProperty(r, "getMethodId", {
        enumerable: !0,
        get: function() {
            return _t.getMethodId
        }
    });
    var gt = safeSign$1;
    Object.defineProperty(r, "safeSign", {
        enumerable: !0,
        get: function() {
            return gt.safeSign
        }
    }),
    Object.defineProperty(r, "safeSignVerify", {
        enumerable: !0,
        get: function() {
            return gt.safeSignVerify
        }
    })
}
)(dist$1);
var HttpApi$1 = {}
  , TonCache = {};
Object.defineProperty(TonCache, "__esModule", {
    value: !0
});
TonCache.InMemoryCache = void 0;
class InMemoryCache {
    constructor() {
        this.cache = new Map,
        this.set = async(d,f,m)=>{
            m !== null ? this.cache.set(d + "$$" + f, m) : this.cache.delete(d + "$$" + f)
        }
        ,
        this.get = async(d,f)=>{
            let m = this.cache.get(d + "$$" + f);
            return m !== void 0 ? m : null
        }
    }
}
TonCache.InMemoryCache = InMemoryCache;
var DataLoader = function() {
    function r(f, m) {
        if (typeof f != "function")
            throw new TypeError("DataLoader must be constructed with a function which accepts " + ("Array<key> and returns Promise<Array<value>>, but got: " + f + "."));
        this._batchLoadFn = f,
        this._maxBatchSize = getValidMaxBatchSize(m),
        this._batchScheduleFn = getValidBatchScheduleFn(m),
        this._cacheKeyFn = getValidCacheKeyFn(m),
        this._cacheMap = getValidCacheMap(m),
        this._batch = null,
        this.name = getValidName(m)
    }
    var d = r.prototype;
    return d.load = function(m) {
        if (m == null)
            throw new TypeError("The loader.load() function must be called with a value, " + ("but got: " + String(m) + "."));
        var k = getCurrentBatch(this)
          , y = this._cacheMap
          , ee = this._cacheKeyFn(m);
        if (y) {
            var dt = y.get(ee);
            if (dt) {
                var mt = k.cacheHits || (k.cacheHits = []);
                return new Promise(function(pt) {
                    mt.push(function() {
                        pt(dt)
                    })
                }
                )
            }
        }
        k.keys.push(m);
        var yt = new Promise(function(pt, bt) {
            k.callbacks.push({
                resolve: pt,
                reject: bt
            })
        }
        );
        return y && y.set(ee, yt),
        yt
    }
    ,
    d.loadMany = function(m) {
        if (!isArrayLike(m))
            throw new TypeError("The loader.loadMany() function must be called with Array<key> " + ("but got: " + m + "."));
        for (var k = [], y = 0; y < m.length; y++)
            k.push(this.load(m[y]).catch(function(ee) {
                return ee
            }));
        return Promise.all(k)
    }
    ,
    d.clear = function(m) {
        var k = this._cacheMap;
        if (k) {
            var y = this._cacheKeyFn(m);
            k.delete(y)
        }
        return this
    }
    ,
    d.clearAll = function() {
        var m = this._cacheMap;
        return m && m.clear(),
        this
    }
    ,
    d.prime = function(m, k) {
        var y = this._cacheMap;
        if (y) {
            var ee = this._cacheKeyFn(m);
            if (y.get(ee) === void 0) {
                var dt;
                k instanceof Error ? (dt = Promise.reject(k),
                dt.catch(function() {})) : dt = Promise.resolve(k),
                y.set(ee, dt)
            }
        }
        return this
    }
    ,
    r
}(), enqueuePostPromiseJob = typeof process$1 == "object" && typeof process$1.nextTick == "function" ? function(r) {
    resolvedPromise || (resolvedPromise = Promise.resolve()),
    resolvedPromise.then(function() {
        process$1.nextTick(r)
    })
}
: typeof setImmediate == "function" ? function(r) {
    setImmediate(r)
}
: function(r) {
    setTimeout(r)
}
, resolvedPromise;
function getCurrentBatch(r) {
    var d = r._batch;
    if (d !== null && !d.hasDispatched && d.keys.length < r._maxBatchSize)
        return d;
    var f = {
        hasDispatched: !1,
        keys: [],
        callbacks: []
    };
    return r._batch = f,
    r._batchScheduleFn(function() {
        dispatchBatch(r, f)
    }),
    f
}
function dispatchBatch(r, d) {
    if (d.hasDispatched = !0,
    d.keys.length === 0) {
        resolveCacheHits(d);
        return
    }
    var f;
    try {
        f = r._batchLoadFn(d.keys)
    } catch (m) {
        return failedDispatch(r, d, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function " + ("errored synchronously: " + String(m) + ".")))
    }
    if (!f || typeof f.then != "function")
        return failedDispatch(r, d, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise: " + String(f) + ".")));
    f.then(function(m) {
        if (!isArrayLike(m))
            throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise of an Array: " + String(m) + "."));
        if (m.length !== d.keys.length)
            throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys." + (`

Keys:
` + String(d.keys)) + (`

Values:
` + String(m)));
        resolveCacheHits(d);
        for (var k = 0; k < d.callbacks.length; k++) {
            var y = m[k];
            y instanceof Error ? d.callbacks[k].reject(y) : d.callbacks[k].resolve(y)
        }
    }).catch(function(m) {
        failedDispatch(r, d, m)
    })
}
function failedDispatch(r, d, f) {
    resolveCacheHits(d);
    for (var m = 0; m < d.keys.length; m++)
        r.clear(d.keys[m]),
        d.callbacks[m].reject(f)
}
function resolveCacheHits(r) {
    if (r.cacheHits)
        for (var d = 0; d < r.cacheHits.length; d++)
            r.cacheHits[d]()
}
function getValidMaxBatchSize(r) {
    var d = !r || r.batch !== !1;
    if (!d)
        return 1;
    var f = r && r.maxBatchSize;
    if (f === void 0)
        return 1 / 0;
    if (typeof f != "number" || f < 1)
        throw new TypeError("maxBatchSize must be a positive number: " + f);
    return f
}
function getValidBatchScheduleFn(r) {
    var d = r && r.batchScheduleFn;
    if (d === void 0)
        return enqueuePostPromiseJob;
    if (typeof d != "function")
        throw new TypeError("batchScheduleFn must be a function: " + d);
    return d
}
function getValidCacheKeyFn(r) {
    var d = r && r.cacheKeyFn;
    if (d === void 0)
        return function(f) {
            return f
        }
        ;
    if (typeof d != "function")
        throw new TypeError("cacheKeyFn must be a function: " + d);
    return d
}
function getValidCacheMap(r) {
    var d = !r || r.cache !== !1;
    if (!d)
        return null;
    var f = r && r.cacheMap;
    if (f === void 0)
        return new Map;
    if (f !== null) {
        var m = ["get", "set", "delete", "clear"]
          , k = m.filter(function(y) {
            return f && typeof f[y] != "function"
        });
        if (k.length !== 0)
            throw new TypeError("Custom cacheMap missing methods: " + k.join(", "))
    }
    return f
}
function getValidName(r) {
    return r && r.name ? r.name : null
}
function isArrayLike(r) {
    return typeof r == "object" && r !== null && typeof r.length == "number" && (r.length === 0 || r.length > 0 && Object.prototype.hasOwnProperty.call(r, r.length - 1))
}
var dataloader = DataLoader;
function bind(r, d) {
    return function() {
        return r.apply(d, arguments)
    }
}
const {toString} = Object.prototype
  , {getPrototypeOf} = Object
  , kindOf = (r=>d=>{
    const f = toString.call(d);
    return r[f] || (r[f] = f.slice(8, -1).toLowerCase())
}
)(Object.create(null))
  , kindOfTest = r=>(r = r.toLowerCase(),
d=>kindOf(d) === r)
  , typeOfTest = r=>d=>typeof d === r
  , {isArray} = Array
  , isUndefined = typeOfTest("undefined");
function isBuffer(r) {
    return r !== null && !isUndefined(r) && r.constructor !== null && !isUndefined(r.constructor) && isFunction(r.constructor.isBuffer) && r.constructor.isBuffer(r)
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(r) {
    let d;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? d = ArrayBuffer.isView(r) : d = r && r.buffer && isArrayBuffer(r.buffer),
    d
}
const isString = typeOfTest("string")
  , isFunction = typeOfTest("function")
  , isNumber = typeOfTest("number")
  , isObject = r=>r !== null && typeof r == "object"
  , isBoolean = r=>r === !0 || r === !1
  , isPlainObject = r=>{
    if (kindOf(r) !== "object")
        return !1;
    const d = getPrototypeOf(r);
    return (d === null || d === Object.prototype || Object.getPrototypeOf(d) === null) && !(Symbol.toStringTag in r) && !(Symbol.iterator in r)
}
  , isDate = kindOfTest("Date")
  , isFile = kindOfTest("File")
  , isBlob = kindOfTest("Blob")
  , isFileList = kindOfTest("FileList")
  , isStream = r=>isObject(r) && isFunction(r.pipe)
  , isFormData = r=>{
    let d;
    return r && (typeof FormData == "function" && r instanceof FormData || isFunction(r.append) && ((d = kindOf(r)) === "formdata" || d === "object" && isFunction(r.toString) && r.toString() === "[object FormData]"))
}
  , isURLSearchParams = kindOfTest("URLSearchParams")
  , [isReadableStream,isRequest,isResponse,isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest)
  , trim = r=>r.trim ? r.trim() : r.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(r, d, {allOwnKeys: f=!1}={}) {
    if (r === null || typeof r > "u")
        return;
    let m, k;
    if (typeof r != "object" && (r = [r]),
    isArray(r))
        for (m = 0,
        k = r.length; m < k; m++)
            d.call(null, r[m], m, r);
    else {
        const y = f ? Object.getOwnPropertyNames(r) : Object.keys(r)
          , ee = y.length;
        let dt;
        for (m = 0; m < ee; m++)
            dt = y[m],
            d.call(null, r[dt], dt, r)
    }
}
function findKey(r, d) {
    d = d.toLowerCase();
    const f = Object.keys(r);
    let m = f.length, k;
    for (; m-- > 0; )
        if (k = f[m],
        d === k.toLowerCase())
            return k;
    return null
}
const _global = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : commonjsGlobal
  , isContextDefined = r=>!isUndefined(r) && r !== _global;
function merge() {
    const {caseless: r} = isContextDefined(this) && this || {}
      , d = {}
      , f = (m,k)=>{
        const y = r && findKey(d, k) || k;
        isPlainObject(d[y]) && isPlainObject(m) ? d[y] = merge(d[y], m) : isPlainObject(m) ? d[y] = merge({}, m) : isArray(m) ? d[y] = m.slice() : d[y] = m
    }
    ;
    for (let m = 0, k = arguments.length; m < k; m++)
        arguments[m] && forEach(arguments[m], f);
    return d
}
const extend = (r,d,f,{allOwnKeys: m}={})=>(forEach(d, (k,y)=>{
    f && isFunction(k) ? r[y] = bind(k, f) : r[y] = k
}
, {
    allOwnKeys: m
}),
r)
  , stripBOM = r=>(r.charCodeAt(0) === 65279 && (r = r.slice(1)),
r)
  , inherits = (r,d,f,m)=>{
    r.prototype = Object.create(d.prototype, m),
    r.prototype.constructor = r,
    Object.defineProperty(r, "super", {
        value: d.prototype
    }),
    f && Object.assign(r.prototype, f)
}
  , toFlatObject = (r,d,f,m)=>{
    let k, y, ee;
    const dt = {};
    if (d = d || {},
    r == null)
        return d;
    do {
        for (k = Object.getOwnPropertyNames(r),
        y = k.length; y-- > 0; )
            ee = k[y],
            (!m || m(ee, r, d)) && !dt[ee] && (d[ee] = r[ee],
            dt[ee] = !0);
        r = f !== !1 && getPrototypeOf(r)
    } while (r && (!f || f(r, d)) && r !== Object.prototype);
    return d
}
  , endsWith = (r,d,f)=>{
    r = String(r),
    (f === void 0 || f > r.length) && (f = r.length),
    f -= d.length;
    const m = r.indexOf(d, f);
    return m !== -1 && m === f
}
  , toArray = r=>{
    if (!r)
        return null;
    if (isArray(r))
        return r;
    let d = r.length;
    if (!isNumber(d))
        return null;
    const f = new Array(d);
    for (; d-- > 0; )
        f[d] = r[d];
    return f
}
  , isTypedArray = (r=>d=>r && d instanceof r)(typeof Uint8Array < "u" && getPrototypeOf(Uint8Array))
  , forEachEntry = (r,d)=>{
    const m = (r && r[Symbol.iterator]).call(r);
    let k;
    for (; (k = m.next()) && !k.done; ) {
        const y = k.value;
        d.call(r, y[0], y[1])
    }
}
  , matchAll = (r,d)=>{
    let f;
    const m = [];
    for (; (f = r.exec(d)) !== null; )
        m.push(f);
    return m
}
  , isHTMLForm = kindOfTest("HTMLFormElement")
  , toCamelCase = r=>r.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(f, m, k) {
    return m.toUpperCase() + k
})
  , hasOwnProperty = (({hasOwnProperty: r})=>(d,f)=>r.call(d, f))(Object.prototype)
  , isRegExp = kindOfTest("RegExp")
  , reduceDescriptors = (r,d)=>{
    const f = Object.getOwnPropertyDescriptors(r)
      , m = {};
    forEach(f, (k,y)=>{
        let ee;
        (ee = d(k, y, r)) !== !1 && (m[y] = ee || k)
    }
    ),
    Object.defineProperties(r, m)
}
  , freezeMethods = r=>{
    reduceDescriptors(r, (d,f)=>{
        if (isFunction(r) && ["arguments", "caller", "callee"].indexOf(f) !== -1)
            return !1;
        const m = r[f];
        if (isFunction(m)) {
            if (d.enumerable = !1,
            "writable"in d) {
                d.writable = !1;
                return
            }
            d.set || (d.set = ()=>{
                throw Error("Can not rewrite read-only method '" + f + "'")
            }
            )
        }
    }
    )
}
  , toObjectSet = (r,d)=>{
    const f = {}
      , m = k=>{
        k.forEach(y=>{
            f[y] = !0
        }
        )
    }
    ;
    return isArray(r) ? m(r) : m(String(r).split(d)),
    f
}
  , noop = ()=>{}
  , toFiniteNumber = (r,d)=>r != null && Number.isFinite(r = +r) ? r : d
  , ALPHA = "abcdefghijklmnopqrstuvwxyz"
  , DIGIT = "0123456789"
  , ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
}
  , generateString = (r=16,d=ALPHABET.ALPHA_DIGIT)=>{
    let f = "";
    const {length: m} = d;
    for (; r--; )
        f += d[Math.random() * m | 0];
    return f
}
;
function isSpecCompliantForm(r) {
    return !!(r && isFunction(r.append) && r[Symbol.toStringTag] === "FormData" && r[Symbol.iterator])
}
const toJSONObject = r=>{
    const d = new Array(10)
      , f = (m,k)=>{
        if (isObject(m)) {
            if (d.indexOf(m) >= 0)
                return;
            if (!("toJSON"in m)) {
                d[k] = m;
                const y = isArray(m) ? [] : {};
                return forEach(m, (ee,dt)=>{
                    const mt = f(ee, k + 1);
                    !isUndefined(mt) && (y[dt] = mt)
                }
                ),
                d[k] = void 0,
                y
            }
        }
        return m
    }
    ;
    return f(r, 0)
}
  , isAsyncFn = kindOfTest("AsyncFunction")
  , isThenable = r=>r && (isObject(r) || isFunction(r)) && isFunction(r.then) && isFunction(r.catch);
var utils$1 = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isReadableStream,
    isRequest,
    isResponse,
    isHeaders,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable
};
function AxiosError(r, d, f, m, k) {
    Error.call(this),
    Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack,
    this.message = r,
    this.name = "AxiosError",
    d && (this.code = d),
    f && (this.config = f),
    m && (this.request = m),
    k && (this.response = k)
}
utils$1.inherits(AxiosError, Error, {
    toJSON: function r() {
        return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: utils$1.toJSONObject(this.config),
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
        }
    }
});
const prototype$1 = AxiosError.prototype
  , descriptors = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(r=>{
    descriptors[r] = {
        value: r
    }
}
);
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", {
    value: !0
});
AxiosError.from = (r,d,f,m,k,y)=>{
    const ee = Object.create(prototype$1);
    return utils$1.toFlatObject(r, ee, function(mt) {
        return mt !== Error.prototype
    }, dt=>dt !== "isAxiosError"),
    AxiosError.call(ee, r.message, d, f, m, k),
    ee.cause = r,
    ee.name = r.name,
    y && Object.assign(ee, y),
    ee
}
;
var httpAdapter = null;
function isVisitable(r) {
    return utils$1.isPlainObject(r) || utils$1.isArray(r)
}
function removeBrackets(r) {
    return utils$1.endsWith(r, "[]") ? r.slice(0, -2) : r
}
function renderKey(r, d, f) {
    return r ? r.concat(d).map(function(k, y) {
        return k = removeBrackets(k),
        !f && y ? "[" + k + "]" : k
    }).join(f ? "." : "") : d
}
function isFlatArray(r) {
    return utils$1.isArray(r) && !r.some(isVisitable)
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function r(d) {
    return /^is[A-Z]/.test(d)
});
function toFormData(r, d, f) {
    if (!utils$1.isObject(r))
        throw new TypeError("target must be an object");
    d = d || new FormData,
    f = utils$1.toFlatObject(f, {
        metaTokens: !0,
        dots: !1,
        indexes: !1
    }, !1, function(Ct, Pt) {
        return !utils$1.isUndefined(Pt[Ct])
    });
    const m = f.metaTokens
      , k = f.visitor || pt
      , y = f.dots
      , ee = f.indexes
      , mt = (f.Blob || typeof Blob < "u" && Blob) && utils$1.isSpecCompliantForm(d);
    if (!utils$1.isFunction(k))
        throw new TypeError("visitor must be a function");
    function yt(At) {
        if (At === null)
            return "";
        if (utils$1.isDate(At))
            return At.toISOString();
        if (!mt && utils$1.isBlob(At))
            throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        return utils$1.isArrayBuffer(At) || utils$1.isTypedArray(At) ? mt && typeof Blob == "function" ? new Blob([At]) : Buffer.from(At) : At
    }
    function pt(At, Ct, Pt) {
        let $t = At;
        if (At && !Pt && typeof At == "object") {
            if (utils$1.endsWith(Ct, "{}"))
                Ct = m ? Ct : Ct.slice(0, -2),
                At = JSON.stringify(At);
            else if (utils$1.isArray(At) && isFlatArray(At) || (utils$1.isFileList(At) || utils$1.endsWith(Ct, "[]")) && ($t = utils$1.toArray(At)))
                return Ct = removeBrackets(Ct),
                $t.forEach(function(Nt, zt) {
                    !(utils$1.isUndefined(Nt) || Nt === null) && d.append(ee === !0 ? renderKey([Ct], zt, y) : ee === null ? Ct : Ct + "[]", yt(Nt))
                }),
                !1
        }
        return isVisitable(At) ? !0 : (d.append(renderKey(Pt, Ct, y), yt(At)),
        !1)
    }
    const bt = []
      , wt = Object.assign(predicates, {
        defaultVisitor: pt,
        convertValue: yt,
        isVisitable
    });
    function xt(At, Ct) {
        if (!utils$1.isUndefined(At)) {
            if (bt.indexOf(At) !== -1)
                throw Error("Circular reference detected in " + Ct.join("."));
            bt.push(At),
            utils$1.forEach(At, function($t, Ot) {
                (!(utils$1.isUndefined($t) || $t === null) && k.call(d, $t, utils$1.isString(Ot) ? Ot.trim() : Ot, Ct, wt)) === !0 && xt($t, Ct ? Ct.concat(Ot) : [Ot])
            }),
            bt.pop()
        }
    }
    if (!utils$1.isObject(r))
        throw new TypeError("data must be an object");
    return xt(r),
    d
}
function encode$1(r) {
    const d = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(r).replace(/[!'()~]|%20|%00/g, function(m) {
        return d[m]
    })
}
function AxiosURLSearchParams(r, d) {
    this._pairs = [],
    r && toFormData(r, this, d)
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function r(d, f) {
    this._pairs.push([d, f])
}
;
prototype.toString = function r(d) {
    const f = d ? function(m) {
        return d.call(this, m, encode$1)
    }
    : encode$1;
    return this._pairs.map(function(k) {
        return f(k[0]) + "=" + f(k[1])
    }, "").join("&")
}
;
function encode(r) {
    return encodeURIComponent(r).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}
function buildURL(r, d, f) {
    if (!d)
        return r;
    const m = f && f.encode || encode
      , k = f && f.serialize;
    let y;
    if (k ? y = k(d, f) : y = utils$1.isURLSearchParams(d) ? d.toString() : new AxiosURLSearchParams(d,f).toString(m),
    y) {
        const ee = r.indexOf("#");
        ee !== -1 && (r = r.slice(0, ee)),
        r += (r.indexOf("?") === -1 ? "?" : "&") + y
    }
    return r
}
class InterceptorManager {
    constructor() {
        this.handlers = []
    }
    use(d, f, m) {
        return this.handlers.push({
            fulfilled: d,
            rejected: f,
            synchronous: m ? m.synchronous : !1,
            runWhen: m ? m.runWhen : null
        }),
        this.handlers.length - 1
    }
    eject(d) {
        this.handlers[d] && (this.handlers[d] = null)
    }
    clear() {
        this.handlers && (this.handlers = [])
    }
    forEach(d) {
        utils$1.forEach(this.handlers, function(m) {
            m !== null && d(m)
        })
    }
}
var InterceptorManager$1 = InterceptorManager
  , transitionalDefaults = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
}
  , URLSearchParams$1 = typeof URLSearchParams < "u" ? URLSearchParams : AxiosURLSearchParams
  , FormData$1 = typeof FormData < "u" ? FormData : null
  , Blob$1 = typeof Blob < "u" ? Blob : null
  , platform$1 = {
    isBrowser: !0,
    classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window < "u" && typeof document < "u"
  , hasStandardBrowserEnv = (r=>hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(r) < 0)(typeof navigator < "u" && navigator.product)
  , hasStandardBrowserWebWorkerEnv = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function"
  , origin = hasBrowserEnv && window.location.href || "http://localhost";
var utils = Object.freeze({
    __proto__: null,
    hasBrowserEnv,
    hasStandardBrowserWebWorkerEnv,
    hasStandardBrowserEnv,
    origin
})
  , platform = {
    ...utils,
    ...platform$1
};
function toURLEncodedForm(r, d) {
    return toFormData(r, new platform.classes.URLSearchParams, Object.assign({
        visitor: function(f, m, k, y) {
            return platform.isNode && utils$1.isBuffer(f) ? (this.append(m, f.toString("base64")),
            !1) : y.defaultVisitor.apply(this, arguments)
        }
    }, d))
}
function parsePropPath(r) {
    return utils$1.matchAll(/\w+|\[(\w*)]/g, r).map(d=>d[0] === "[]" ? "" : d[1] || d[0])
}
function arrayToObject(r) {
    const d = {}
      , f = Object.keys(r);
    let m;
    const k = f.length;
    let y;
    for (m = 0; m < k; m++)
        y = f[m],
        d[y] = r[y];
    return d
}
function formDataToJSON(r) {
    function d(f, m, k, y) {
        let ee = f[y++];
        if (ee === "__proto__")
            return !0;
        const dt = Number.isFinite(+ee)
          , mt = y >= f.length;
        return ee = !ee && utils$1.isArray(k) ? k.length : ee,
        mt ? (utils$1.hasOwnProp(k, ee) ? k[ee] = [k[ee], m] : k[ee] = m,
        !dt) : ((!k[ee] || !utils$1.isObject(k[ee])) && (k[ee] = []),
        d(f, m, k[ee], y) && utils$1.isArray(k[ee]) && (k[ee] = arrayToObject(k[ee])),
        !dt)
    }
    if (utils$1.isFormData(r) && utils$1.isFunction(r.entries)) {
        const f = {};
        return utils$1.forEachEntry(r, (m,k)=>{
            d(parsePropPath(m), k, f, 0)
        }
        ),
        f
    }
    return null
}
function stringifySafely(r, d, f) {
    if (utils$1.isString(r))
        try {
            return (d || JSON.parse)(r),
            utils$1.trim(r)
        } catch (m) {
            if (m.name !== "SyntaxError")
                throw m
        }
    return (f || JSON.stringify)(r)
}
const defaults = {
    transitional: transitionalDefaults,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function r(d, f) {
        const m = f.getContentType() || ""
          , k = m.indexOf("application/json") > -1
          , y = utils$1.isObject(d);
        if (y && utils$1.isHTMLForm(d) && (d = new FormData(d)),
        utils$1.isFormData(d))
            return k ? JSON.stringify(formDataToJSON(d)) : d;
        if (utils$1.isArrayBuffer(d) || utils$1.isBuffer(d) || utils$1.isStream(d) || utils$1.isFile(d) || utils$1.isBlob(d) || utils$1.isReadableStream(d))
            return d;
        if (utils$1.isArrayBufferView(d))
            return d.buffer;
        if (utils$1.isURLSearchParams(d))
            return f.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
            d.toString();
        let dt;
        if (y) {
            if (m.indexOf("application/x-www-form-urlencoded") > -1)
                return toURLEncodedForm(d, this.formSerializer).toString();
            if ((dt = utils$1.isFileList(d)) || m.indexOf("multipart/form-data") > -1) {
                const mt = this.env && this.env.FormData;
                return toFormData(dt ? {
                    "files[]": d
                } : d, mt && new mt, this.formSerializer)
            }
        }
        return y || k ? (f.setContentType("application/json", !1),
        stringifySafely(d)) : d
    }
    ],
    transformResponse: [function r(d) {
        const f = this.transitional || defaults.transitional
          , m = f && f.forcedJSONParsing
          , k = this.responseType === "json";
        if (utils$1.isResponse(d) || utils$1.isReadableStream(d))
            return d;
        if (d && utils$1.isString(d) && (m && !this.responseType || k)) {
            const ee = !(f && f.silentJSONParsing) && k;
            try {
                return JSON.parse(d)
            } catch (dt) {
                if (ee)
                    throw dt.name === "SyntaxError" ? AxiosError.from(dt, AxiosError.ERR_BAD_RESPONSE, this, null, this.response) : dt
            }
        }
        return d
    }
    ],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
    },
    validateStatus: function r(d) {
        return d >= 200 && d < 300
    },
    headers: {
        common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": void 0
        }
    }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], r=>{
    defaults.headers[r] = {}
}
);
var defaults$1 = defaults;
const ignoreDuplicateOf = utils$1.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
var parseHeaders = r=>{
    const d = {};
    let f, m, k;
    return r && r.split(`
`).forEach(function(ee) {
        k = ee.indexOf(":"),
        f = ee.substring(0, k).trim().toLowerCase(),
        m = ee.substring(k + 1).trim(),
        !(!f || d[f] && ignoreDuplicateOf[f]) && (f === "set-cookie" ? d[f] ? d[f].push(m) : d[f] = [m] : d[f] = d[f] ? d[f] + ", " + m : m)
    }),
    d
}
;
const $internals = Symbol("internals");
function normalizeHeader(r) {
    return r && String(r).trim().toLowerCase()
}
function normalizeValue(r) {
    return r === !1 || r == null ? r : utils$1.isArray(r) ? r.map(normalizeValue) : String(r)
}
function parseTokens(r) {
    const d = Object.create(null)
      , f = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let m;
    for (; m = f.exec(r); )
        d[m[1]] = m[2];
    return d
}
const isValidHeaderName = r=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(r.trim());
function matchHeaderValue(r, d, f, m, k) {
    if (utils$1.isFunction(m))
        return m.call(this, d, f);
    if (k && (d = f),
    !!utils$1.isString(d)) {
        if (utils$1.isString(m))
            return d.indexOf(m) !== -1;
        if (utils$1.isRegExp(m))
            return m.test(d)
    }
}
function formatHeader(r) {
    return r.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (d,f,m)=>f.toUpperCase() + m)
}
function buildAccessors(r, d) {
    const f = utils$1.toCamelCase(" " + d);
    ["get", "set", "has"].forEach(m=>{
        Object.defineProperty(r, m + f, {
            value: function(k, y, ee) {
                return this[m].call(this, d, k, y, ee)
            },
            configurable: !0
        })
    }
    )
}
class AxiosHeaders {
    constructor(d) {
        d && this.set(d)
    }
    set(d, f, m) {
        const k = this;
        function y(dt, mt, yt) {
            const pt = normalizeHeader(mt);
            if (!pt)
                throw new Error("header name must be a non-empty string");
            const bt = utils$1.findKey(k, pt);
            (!bt || k[bt] === void 0 || yt === !0 || yt === void 0 && k[bt] !== !1) && (k[bt || mt] = normalizeValue(dt))
        }
        const ee = (dt,mt)=>utils$1.forEach(dt, (yt,pt)=>y(yt, pt, mt));
        if (utils$1.isPlainObject(d) || d instanceof this.constructor)
            ee(d, f);
        else if (utils$1.isString(d) && (d = d.trim()) && !isValidHeaderName(d))
            ee(parseHeaders(d), f);
        else if (utils$1.isHeaders(d))
            for (const [dt,mt] of d.entries())
                y(mt, dt, m);
        else
            d != null && y(f, d, m);
        return this
    }
    get(d, f) {
        if (d = normalizeHeader(d),
        d) {
            const m = utils$1.findKey(this, d);
            if (m) {
                const k = this[m];
                if (!f)
                    return k;
                if (f === !0)
                    return parseTokens(k);
                if (utils$1.isFunction(f))
                    return f.call(this, k, m);
                if (utils$1.isRegExp(f))
                    return f.exec(k);
                throw new TypeError("parser must be boolean|regexp|function")
            }
        }
    }
    has(d, f) {
        if (d = normalizeHeader(d),
        d) {
            const m = utils$1.findKey(this, d);
            return !!(m && this[m] !== void 0 && (!f || matchHeaderValue(this, this[m], m, f)))
        }
        return !1
    }
    delete(d, f) {
        const m = this;
        let k = !1;
        function y(ee) {
            if (ee = normalizeHeader(ee),
            ee) {
                const dt = utils$1.findKey(m, ee);
                dt && (!f || matchHeaderValue(m, m[dt], dt, f)) && (delete m[dt],
                k = !0)
            }
        }
        return utils$1.isArray(d) ? d.forEach(y) : y(d),
        k
    }
    clear(d) {
        const f = Object.keys(this);
        let m = f.length
          , k = !1;
        for (; m--; ) {
            const y = f[m];
            (!d || matchHeaderValue(this, this[y], y, d, !0)) && (delete this[y],
            k = !0)
        }
        return k
    }
    normalize(d) {
        const f = this
          , m = {};
        return utils$1.forEach(this, (k,y)=>{
            const ee = utils$1.findKey(m, y);
            if (ee) {
                f[ee] = normalizeValue(k),
                delete f[y];
                return
            }
            const dt = d ? formatHeader(y) : String(y).trim();
            dt !== y && delete f[y],
            f[dt] = normalizeValue(k),
            m[dt] = !0
        }
        ),
        this
    }
    concat(...d) {
        return this.constructor.concat(this, ...d)
    }
    toJSON(d) {
        const f = Object.create(null);
        return utils$1.forEach(this, (m,k)=>{
            m != null && m !== !1 && (f[k] = d && utils$1.isArray(m) ? m.join(", ") : m)
        }
        ),
        f
    }
    [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]()
    }
    toString() {
        return Object.entries(this.toJSON()).map(([d,f])=>d + ": " + f).join(`
`)
    }
    get[Symbol.toStringTag]() {
        return "AxiosHeaders"
    }
    static from(d) {
        return d instanceof this ? d : new this(d)
    }
    static concat(d, ...f) {
        const m = new this(d);
        return f.forEach(k=>m.set(k)),
        m
    }
    static accessor(d) {
        const m = (this[$internals] = this[$internals] = {
            accessors: {}
        }).accessors
          , k = this.prototype;
        function y(ee) {
            const dt = normalizeHeader(ee);
            m[dt] || (buildAccessors(k, ee),
            m[dt] = !0)
        }
        return utils$1.isArray(d) ? d.forEach(y) : y(d),
        this
    }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({value: r},d)=>{
    let f = d[0].toUpperCase() + d.slice(1);
    return {
        get: ()=>r,
        set(m) {
            this[f] = m
        }
    }
}
);
utils$1.freezeMethods(AxiosHeaders);
var AxiosHeaders$1 = AxiosHeaders;
function transformData(r, d) {
    const f = this || defaults$1
      , m = d || f
      , k = AxiosHeaders$1.from(m.headers);
    let y = m.data;
    return utils$1.forEach(r, function(dt) {
        y = dt.call(f, y, k.normalize(), d ? d.status : void 0)
    }),
    k.normalize(),
    y
}
function isCancel(r) {
    return !!(r && r.__CANCEL__)
}
function CanceledError(r, d, f) {
    AxiosError.call(this, r ?? "canceled", AxiosError.ERR_CANCELED, d, f),
    this.name = "CanceledError"
}
utils$1.inherits(CanceledError, AxiosError, {
    __CANCEL__: !0
});
function settle(r, d, f) {
    const m = f.config.validateStatus;
    !f.status || !m || m(f.status) ? r(f) : d(new AxiosError("Request failed with status code " + f.status,[AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(f.status / 100) - 4],f.config,f.request,f))
}
function parseProtocol(r) {
    const d = /^([-+\w]{1,25})(:?\/\/|:)/.exec(r);
    return d && d[1] || ""
}
function speedometer(r, d) {
    r = r || 10;
    const f = new Array(r)
      , m = new Array(r);
    let k = 0, y = 0, ee;
    return d = d !== void 0 ? d : 1e3,
    function(mt) {
        const yt = Date.now()
          , pt = m[y];
        ee || (ee = yt),
        f[k] = mt,
        m[k] = yt;
        let bt = y
          , wt = 0;
        for (; bt !== k; )
            wt += f[bt++],
            bt = bt % r;
        if (k = (k + 1) % r,
        k === y && (y = (y + 1) % r),
        yt - ee < d)
            return;
        const xt = pt && yt - pt;
        return xt ? Math.round(wt * 1e3 / xt) : void 0
    }
}
function throttle(r, d) {
    let f = 0;
    const m = 1e3 / d;
    let k = null;
    return function() {
        const ee = this === !0
          , dt = Date.now();
        if (ee || dt - f > m)
            return k && (clearTimeout(k),
            k = null),
            f = dt,
            r.apply(null, arguments);
        k || (k = setTimeout(()=>(k = null,
        f = Date.now(),
        r.apply(null, arguments)), m - (dt - f)))
    }
}
var progressEventReducer = (r,d,f=3)=>{
    let m = 0;
    const k = speedometer(50, 250);
    return throttle(y=>{
        const ee = y.loaded
          , dt = y.lengthComputable ? y.total : void 0
          , mt = ee - m
          , yt = k(mt)
          , pt = ee <= dt;
        m = ee;
        const bt = {
            loaded: ee,
            total: dt,
            progress: dt ? ee / dt : void 0,
            bytes: mt,
            rate: yt || void 0,
            estimated: yt && dt && pt ? (dt - ee) / yt : void 0,
            event: y,
            lengthComputable: dt != null
        };
        bt[d ? "download" : "upload"] = !0,
        r(bt)
    }
    , f)
}
  , isURLSameOrigin = platform.hasStandardBrowserEnv ? function r() {
    const d = /(msie|trident)/i.test(navigator.userAgent)
      , f = document.createElement("a");
    let m;
    function k(y) {
        let ee = y;
        return d && (f.setAttribute("href", ee),
        ee = f.href),
        f.setAttribute("href", ee),
        {
            href: f.href,
            protocol: f.protocol ? f.protocol.replace(/:$/, "") : "",
            host: f.host,
            search: f.search ? f.search.replace(/^\?/, "") : "",
            hash: f.hash ? f.hash.replace(/^#/, "") : "",
            hostname: f.hostname,
            port: f.port,
            pathname: f.pathname.charAt(0) === "/" ? f.pathname : "/" + f.pathname
        }
    }
    return m = k(window.location.href),
    function(ee) {
        const dt = utils$1.isString(ee) ? k(ee) : ee;
        return dt.protocol === m.protocol && dt.host === m.host
    }
}() : function r() {
    return function() {
        return !0
    }
}()
  , cookies = platform.hasStandardBrowserEnv ? {
    write(r, d, f, m, k, y) {
        const ee = [r + "=" + encodeURIComponent(d)];
        utils$1.isNumber(f) && ee.push("expires=" + new Date(f).toGMTString()),
        utils$1.isString(m) && ee.push("path=" + m),
        utils$1.isString(k) && ee.push("domain=" + k),
        y === !0 && ee.push("secure"),
        document.cookie = ee.join("; ")
    },
    read(r) {
        const d = document.cookie.match(new RegExp("(^|;\\s*)(" + r + ")=([^;]*)"));
        return d ? decodeURIComponent(d[3]) : null
    },
    remove(r) {
        this.write(r, "", Date.now() - 864e5)
    }
} : {
    write() {},
    read() {
        return null
    },
    remove() {}
};
function isAbsoluteURL(r) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(r)
}
function combineURLs(r, d) {
    return d ? r.replace(/\/?\/$/, "") + "/" + d.replace(/^\/+/, "") : r
}
function buildFullPath(r, d) {
    return r && !isAbsoluteURL(d) ? combineURLs(r, d) : d
}
const headersToObject = r=>r instanceof AxiosHeaders$1 ? {
    ...r
} : r;
function mergeConfig(r, d) {
    d = d || {};
    const f = {};
    function m(yt, pt, bt) {
        return utils$1.isPlainObject(yt) && utils$1.isPlainObject(pt) ? utils$1.merge.call({
            caseless: bt
        }, yt, pt) : utils$1.isPlainObject(pt) ? utils$1.merge({}, pt) : utils$1.isArray(pt) ? pt.slice() : pt
    }
    function k(yt, pt, bt) {
        if (utils$1.isUndefined(pt)) {
            if (!utils$1.isUndefined(yt))
                return m(void 0, yt, bt)
        } else
            return m(yt, pt, bt)
    }
    function y(yt, pt) {
        if (!utils$1.isUndefined(pt))
            return m(void 0, pt)
    }
    function ee(yt, pt) {
        if (utils$1.isUndefined(pt)) {
            if (!utils$1.isUndefined(yt))
                return m(void 0, yt)
        } else
            return m(void 0, pt)
    }
    function dt(yt, pt, bt) {
        if (bt in d)
            return m(yt, pt);
        if (bt in r)
            return m(void 0, yt)
    }
    const mt = {
        url: y,
        method: y,
        data: y,
        baseURL: ee,
        transformRequest: ee,
        transformResponse: ee,
        paramsSerializer: ee,
        timeout: ee,
        timeoutMessage: ee,
        withCredentials: ee,
        withXSRFToken: ee,
        adapter: ee,
        responseType: ee,
        xsrfCookieName: ee,
        xsrfHeaderName: ee,
        onUploadProgress: ee,
        onDownloadProgress: ee,
        decompress: ee,
        maxContentLength: ee,
        maxBodyLength: ee,
        beforeRedirect: ee,
        transport: ee,
        httpAgent: ee,
        httpsAgent: ee,
        cancelToken: ee,
        socketPath: ee,
        responseEncoding: ee,
        validateStatus: dt,
        headers: (yt,pt)=>k(headersToObject(yt), headersToObject(pt), !0)
    };
    return utils$1.forEach(Object.keys(Object.assign({}, r, d)), function(pt) {
        const bt = mt[pt] || k
          , wt = bt(r[pt], d[pt], pt);
        utils$1.isUndefined(wt) && bt !== dt || (f[pt] = wt)
    }),
    f
}
var resolveConfig = r=>{
    const d = mergeConfig({}, r);
    let {data: f, withXSRFToken: m, xsrfHeaderName: k, xsrfCookieName: y, headers: ee, auth: dt} = d;
    d.headers = ee = AxiosHeaders$1.from(ee),
    d.url = buildURL(buildFullPath(d.baseURL, d.url), r.params, r.paramsSerializer),
    dt && ee.set("Authorization", "Basic " + btoa((dt.username || "") + ":" + (dt.password ? unescape(encodeURIComponent(dt.password)) : "")));
    let mt;
    if (utils$1.isFormData(f)) {
        if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv)
            ee.setContentType(void 0);
        else if ((mt = ee.getContentType()) !== !1) {
            const [yt,...pt] = mt ? mt.split(";").map(bt=>bt.trim()).filter(Boolean) : [];
            ee.setContentType([yt || "multipart/form-data", ...pt].join("; "))
        }
    }
    if (platform.hasStandardBrowserEnv && (m && utils$1.isFunction(m) && (m = m(d)),
    m || m !== !1 && isURLSameOrigin(d.url))) {
        const yt = k && y && cookies.read(y);
        yt && ee.set(k, yt)
    }
    return d
}
;
const isXHRAdapterSupported = typeof XMLHttpRequest < "u";
var xhrAdapter = isXHRAdapterSupported && function(r) {
    return new Promise(function(f, m) {
        const k = resolveConfig(r);
        let y = k.data;
        const ee = AxiosHeaders$1.from(k.headers).normalize();
        let {responseType: dt} = k, mt;
        function yt() {
            k.cancelToken && k.cancelToken.unsubscribe(mt),
            k.signal && k.signal.removeEventListener("abort", mt)
        }
        let pt = new XMLHttpRequest;
        pt.open(k.method.toUpperCase(), k.url, !0),
        pt.timeout = k.timeout;
        function bt() {
            if (!pt)
                return;
            const xt = AxiosHeaders$1.from("getAllResponseHeaders"in pt && pt.getAllResponseHeaders())
              , Ct = {
                data: !dt || dt === "text" || dt === "json" ? pt.responseText : pt.response,
                status: pt.status,
                statusText: pt.statusText,
                headers: xt,
                config: r,
                request: pt
            };
            settle(function($t) {
                f($t),
                yt()
            }, function($t) {
                m($t),
                yt()
            }, Ct),
            pt = null
        }
        "onloadend"in pt ? pt.onloadend = bt : pt.onreadystatechange = function() {
            !pt || pt.readyState !== 4 || pt.status === 0 && !(pt.responseURL && pt.responseURL.indexOf("file:") === 0) || setTimeout(bt)
        }
        ,
        pt.onabort = function() {
            pt && (m(new AxiosError("Request aborted",AxiosError.ECONNABORTED,k,pt)),
            pt = null)
        }
        ,
        pt.onerror = function() {
            m(new AxiosError("Network Error",AxiosError.ERR_NETWORK,k,pt)),
            pt = null
        }
        ,
        pt.ontimeout = function() {
            let At = k.timeout ? "timeout of " + k.timeout + "ms exceeded" : "timeout exceeded";
            const Ct = k.transitional || transitionalDefaults;
            k.timeoutErrorMessage && (At = k.timeoutErrorMessage),
            m(new AxiosError(At,Ct.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,k,pt)),
            pt = null
        }
        ,
        y === void 0 && ee.setContentType(null),
        "setRequestHeader"in pt && utils$1.forEach(ee.toJSON(), function(At, Ct) {
            pt.setRequestHeader(Ct, At)
        }),
        utils$1.isUndefined(k.withCredentials) || (pt.withCredentials = !!k.withCredentials),
        dt && dt !== "json" && (pt.responseType = k.responseType),
        typeof k.onDownloadProgress == "function" && pt.addEventListener("progress", progressEventReducer(k.onDownloadProgress, !0)),
        typeof k.onUploadProgress == "function" && pt.upload && pt.upload.addEventListener("progress", progressEventReducer(k.onUploadProgress)),
        (k.cancelToken || k.signal) && (mt = xt=>{
            pt && (m(!xt || xt.type ? new CanceledError(null,r,pt) : xt),
            pt.abort(),
            pt = null)
        }
        ,
        k.cancelToken && k.cancelToken.subscribe(mt),
        k.signal && (k.signal.aborted ? mt() : k.signal.addEventListener("abort", mt)));
        const wt = parseProtocol(k.url);
        if (wt && platform.protocols.indexOf(wt) === -1) {
            m(new AxiosError("Unsupported protocol " + wt + ":",AxiosError.ERR_BAD_REQUEST,r));
            return
        }
        pt.send(y || null)
    }
    )
}
;
const composeSignals = (r,d)=>{
    let f = new AbortController, m;
    const k = function(mt) {
        if (!m) {
            m = !0,
            ee();
            const yt = mt instanceof Error ? mt : this.reason;
            f.abort(yt instanceof AxiosError ? yt : new CanceledError(yt instanceof Error ? yt.message : yt))
        }
    };
    let y = d && setTimeout(()=>{
        k(new AxiosError(`timeout ${d} of ms exceeded`,AxiosError.ETIMEDOUT))
    }
    , d);
    const ee = ()=>{
        r && (y && clearTimeout(y),
        y = null,
        r.forEach(mt=>{
            mt && (mt.removeEventListener ? mt.removeEventListener("abort", k) : mt.unsubscribe(k))
        }
        ),
        r = null)
    }
    ;
    r.forEach(mt=>mt && mt.addEventListener && mt.addEventListener("abort", k));
    const {signal: dt} = f;
    return dt.unsubscribe = ee,
    [dt, ()=>{
        y && clearTimeout(y),
        y = null
    }
    ]
}
;
var composeSignals$1 = composeSignals;
const streamChunk = function*(r, d) {
    let f = r.byteLength;
    if (!d || f < d) {
        yield r;
        return
    }
    let m = 0, k;
    for (; m < f; )
        k = m + d,
        yield r.slice(m, k),
        m = k
}
  , readBytes = async function*(r, d, f) {
    for await(const m of r)
        yield*streamChunk(ArrayBuffer.isView(m) ? m : await f(String(m)), d)
}
  , trackStream = (r,d,f,m,k)=>{
    const y = readBytes(r, d, k);
    let ee = 0;
    return new ReadableStream({
        type: "bytes",
        async pull(dt) {
            const {done: mt, value: yt} = await y.next();
            if (mt) {
                dt.close(),
                m();
                return
            }
            let pt = yt.byteLength;
            f && f(ee += pt),
            dt.enqueue(new Uint8Array(yt))
        },
        cancel(dt) {
            return m(dt),
            y.return()
        }
    },{
        highWaterMark: 2
    })
}
  , fetchProgressDecorator = (r,d)=>{
    const f = r != null;
    return m=>setTimeout(()=>d({
        lengthComputable: f,
        total: r,
        loaded: m
    }))
}
  , isFetchSupported = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function"
  , isReadableStreamSupported = isFetchSupported && typeof ReadableStream == "function"
  , encodeText = isFetchSupported && (typeof TextEncoder == "function" ? (r=>d=>r.encode(d))(new TextEncoder) : async r=>new Uint8Array(await new Response(r).arrayBuffer()))
  , supportsRequestStream = isReadableStreamSupported && (()=>{
    let r = !1;
    const d = new Request(platform.origin,{
        body: new ReadableStream,
        method: "POST",
        get duplex() {
            return r = !0,
            "half"
        }
    }).headers.has("Content-Type");
    return r && !d
}
)()
  , DEFAULT_CHUNK_SIZE = 64 * 1024
  , supportsResponseStream = isReadableStreamSupported && !!(()=>{
    try {
        return utils$1.isReadableStream(new Response("").body)
    } catch {}
}
)()
  , resolvers = {
    stream: supportsResponseStream && (r=>r.body)
};
isFetchSupported && (r=>{
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(d=>{
        !resolvers[d] && (resolvers[d] = utils$1.isFunction(r[d]) ? f=>f[d]() : (f,m)=>{
            throw new AxiosError(`Response type '${d}' is not supported`,AxiosError.ERR_NOT_SUPPORT,m)
        }
        )
    }
    )
}
)(new Response);
const getBodyLength = async r=>{
    if (r == null)
        return 0;
    if (utils$1.isBlob(r))
        return r.size;
    if (utils$1.isSpecCompliantForm(r))
        return (await new Request(r).arrayBuffer()).byteLength;
    if (utils$1.isArrayBufferView(r))
        return r.byteLength;
    if (utils$1.isURLSearchParams(r) && (r = r + ""),
    utils$1.isString(r))
        return (await encodeText(r)).byteLength
}
  , resolveBodyLength = async(r,d)=>{
    const f = utils$1.toFiniteNumber(r.getContentLength());
    return f ?? getBodyLength(d)
}
;
var fetchAdapter = isFetchSupported && (async r=>{
    let {url: d, method: f, data: m, signal: k, cancelToken: y, timeout: ee, onDownloadProgress: dt, onUploadProgress: mt, responseType: yt, headers: pt, withCredentials: bt="same-origin", fetchOptions: wt} = resolveConfig(r);
    yt = yt ? (yt + "").toLowerCase() : "text";
    let[xt,At] = k || y || ee ? composeSignals$1([k, y], ee) : [], Ct, Pt;
    const $t = ()=>{
        !Ct && setTimeout(()=>{
            xt && xt.unsubscribe()
        }
        ),
        Ct = !0
    }
    ;
    let Ot;
    try {
        if (mt && supportsRequestStream && f !== "get" && f !== "head" && (Ot = await resolveBodyLength(pt, m)) !== 0) {
            let Kt = new Request(d,{
                method: "POST",
                body: m,
                duplex: "half"
            }), ir;
            utils$1.isFormData(m) && (ir = Kt.headers.get("content-type")) && pt.setContentType(ir),
            Kt.body && (m = trackStream(Kt.body, DEFAULT_CHUNK_SIZE, fetchProgressDecorator(Ot, progressEventReducer(mt)), null, encodeText))
        }
        utils$1.isString(bt) || (bt = bt ? "cors" : "omit"),
        Pt = new Request(d,{
            ...wt,
            signal: xt,
            method: f.toUpperCase(),
            headers: pt.normalize().toJSON(),
            body: m,
            duplex: "half",
            withCredentials: bt
        });
        let Nt = await fetch(Pt);
        const zt = supportsResponseStream && (yt === "stream" || yt === "response");
        if (supportsResponseStream && (dt || zt)) {
            const Kt = {};
            ["status", "statusText", "headers"].forEach(or=>{
                Kt[or] = Nt[or]
            }
            );
            const ir = utils$1.toFiniteNumber(Nt.headers.get("content-length"));
            Nt = new Response(trackStream(Nt.body, DEFAULT_CHUNK_SIZE, dt && fetchProgressDecorator(ir, progressEventReducer(dt, !0)), zt && $t, encodeText),Kt)
        }
        yt = yt || "text";
        let Wt = await resolvers[utils$1.findKey(resolvers, yt) || "text"](Nt, r);
        return !zt && $t(),
        At && At(),
        await new Promise((Kt,ir)=>{
            settle(Kt, ir, {
                data: Wt,
                headers: AxiosHeaders$1.from(Nt.headers),
                status: Nt.status,
                statusText: Nt.statusText,
                config: r,
                request: Pt
            })
        }
        )
    } catch (Nt) {
        throw $t(),
        Nt && Nt.name === "TypeError" && /fetch/i.test(Nt.message) ? Object.assign(new AxiosError("Network Error",AxiosError.ERR_NETWORK,r,Pt), {
            cause: Nt.cause || Nt
        }) : AxiosError.from(Nt, Nt && Nt.code, r, Pt)
    }
}
);
const knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter,
    fetch: fetchAdapter
};
utils$1.forEach(knownAdapters, (r,d)=>{
    if (r) {
        try {
            Object.defineProperty(r, "name", {
                value: d
            })
        } catch {}
        Object.defineProperty(r, "adapterName", {
            value: d
        })
    }
}
);
const renderReason = r=>`- ${r}`
  , isResolvedHandle = r=>utils$1.isFunction(r) || r === null || r === !1;
var adapters = {
    getAdapter: r=>{
        r = utils$1.isArray(r) ? r : [r];
        const {length: d} = r;
        let f, m;
        const k = {};
        for (let y = 0; y < d; y++) {
            f = r[y];
            let ee;
            if (m = f,
            !isResolvedHandle(f) && (m = knownAdapters[(ee = String(f)).toLowerCase()],
            m === void 0))
                throw new AxiosError(`Unknown adapter '${ee}'`);
            if (m)
                break;
            k[ee || "#" + y] = m
        }
        if (!m) {
            const y = Object.entries(k).map(([dt,mt])=>`adapter ${dt} ` + (mt === !1 ? "is not supported by the environment" : "is not available in the build"));
            let ee = d ? y.length > 1 ? `since :
` + y.map(renderReason).join(`
`) : " " + renderReason(y[0]) : "as no adapter specified";
            throw new AxiosError("There is no suitable adapter to dispatch the request " + ee,"ERR_NOT_SUPPORT")
        }
        return m
    }
    ,
    adapters: knownAdapters
};
function throwIfCancellationRequested(r) {
    if (r.cancelToken && r.cancelToken.throwIfRequested(),
    r.signal && r.signal.aborted)
        throw new CanceledError(null,r)
}
function dispatchRequest(r) {
    return throwIfCancellationRequested(r),
    r.headers = AxiosHeaders$1.from(r.headers),
    r.data = transformData.call(r, r.transformRequest),
    ["post", "put", "patch"].indexOf(r.method) !== -1 && r.headers.setContentType("application/x-www-form-urlencoded", !1),
    adapters.getAdapter(r.adapter || defaults$1.adapter)(r).then(function(m) {
        return throwIfCancellationRequested(r),
        m.data = transformData.call(r, r.transformResponse, m),
        m.headers = AxiosHeaders$1.from(m.headers),
        m
    }, function(m) {
        return isCancel(m) || (throwIfCancellationRequested(r),
        m && m.response && (m.response.data = transformData.call(r, r.transformResponse, m.response),
        m.response.headers = AxiosHeaders$1.from(m.response.headers))),
        Promise.reject(m)
    })
}
const VERSION = "1.7.2"
  , validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((r,d)=>{
    validators$1[r] = function(m) {
        return typeof m === r || "a" + (d < 1 ? "n " : " ") + r
    }
}
);
const deprecatedWarnings = {};
validators$1.transitional = function r(d, f, m) {
    function k(y, ee) {
        return "[Axios v" + VERSION + "] Transitional option '" + y + "'" + ee + (m ? ". " + m : "")
    }
    return (y,ee,dt)=>{
        if (d === !1)
            throw new AxiosError(k(ee, " has been removed" + (f ? " in " + f : "")),AxiosError.ERR_DEPRECATED);
        return f && !deprecatedWarnings[ee] && (deprecatedWarnings[ee] = !0,
        console.warn(k(ee, " has been deprecated since v" + f + " and will be removed in the near future"))),
        d ? d(y, ee, dt) : !0
    }
}
;
function assertOptions(r, d, f) {
    if (typeof r != "object")
        throw new AxiosError("options must be an object",AxiosError.ERR_BAD_OPTION_VALUE);
    const m = Object.keys(r);
    let k = m.length;
    for (; k-- > 0; ) {
        const y = m[k]
          , ee = d[y];
        if (ee) {
            const dt = r[y]
              , mt = dt === void 0 || ee(dt, y, r);
            if (mt !== !0)
                throw new AxiosError("option " + y + " must be " + mt,AxiosError.ERR_BAD_OPTION_VALUE);
            continue
        }
        if (f !== !0)
            throw new AxiosError("Unknown option " + y,AxiosError.ERR_BAD_OPTION)
    }
}
var validator = {
    assertOptions,
    validators: validators$1
};
const validators = validator.validators;
class Axios {
    constructor(d) {
        this.defaults = d,
        this.interceptors = {
            request: new InterceptorManager$1,
            response: new InterceptorManager$1
        }
    }
    async request(d, f) {
        try {
            return await this._request(d, f)
        } catch (m) {
            if (m instanceof Error) {
                let k;
                Error.captureStackTrace ? Error.captureStackTrace(k = {}) : k = new Error;
                const y = k.stack ? k.stack.replace(/^.+\n/, "") : "";
                try {
                    m.stack ? y && !String(m.stack).endsWith(y.replace(/^.+\n.+\n/, "")) && (m.stack += `
` + y) : m.stack = y
                } catch {}
            }
            throw m
        }
    }
    _request(d, f) {
        typeof d == "string" ? (f = f || {},
        f.url = d) : f = d || {},
        f = mergeConfig(this.defaults, f);
        const {transitional: m, paramsSerializer: k, headers: y} = f;
        m !== void 0 && validator.assertOptions(m, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
        }, !1),
        k != null && (utils$1.isFunction(k) ? f.paramsSerializer = {
            serialize: k
        } : validator.assertOptions(k, {
            encode: validators.function,
            serialize: validators.function
        }, !0)),
        f.method = (f.method || this.defaults.method || "get").toLowerCase();
        let ee = y && utils$1.merge(y.common, y[f.method]);
        y && utils$1.forEach(["delete", "get", "head", "post", "put", "patch", "common"], At=>{
            delete y[At]
        }
        ),
        f.headers = AxiosHeaders$1.concat(ee, y);
        const dt = [];
        let mt = !0;
        this.interceptors.request.forEach(function(Ct) {
            typeof Ct.runWhen == "function" && Ct.runWhen(f) === !1 || (mt = mt && Ct.synchronous,
            dt.unshift(Ct.fulfilled, Ct.rejected))
        });
        const yt = [];
        this.interceptors.response.forEach(function(Ct) {
            yt.push(Ct.fulfilled, Ct.rejected)
        });
        let pt, bt = 0, wt;
        if (!mt) {
            const At = [dispatchRequest.bind(this), void 0];
            for (At.unshift.apply(At, dt),
            At.push.apply(At, yt),
            wt = At.length,
            pt = Promise.resolve(f); bt < wt; )
                pt = pt.then(At[bt++], At[bt++]);
            return pt
        }
        wt = dt.length;
        let xt = f;
        for (bt = 0; bt < wt; ) {
            const At = dt[bt++]
              , Ct = dt[bt++];
            try {
                xt = At(xt)
            } catch (Pt) {
                Ct.call(this, Pt);
                break
            }
        }
        try {
            pt = dispatchRequest.call(this, xt)
        } catch (At) {
            return Promise.reject(At)
        }
        for (bt = 0,
        wt = yt.length; bt < wt; )
            pt = pt.then(yt[bt++], yt[bt++]);
        return pt
    }
    getUri(d) {
        d = mergeConfig(this.defaults, d);
        const f = buildFullPath(d.baseURL, d.url);
        return buildURL(f, d.params, d.paramsSerializer)
    }
}
utils$1.forEach(["delete", "get", "head", "options"], function r(d) {
    Axios.prototype[d] = function(f, m) {
        return this.request(mergeConfig(m || {}, {
            method: d,
            url: f,
            data: (m || {}).data
        }))
    }
});
utils$1.forEach(["post", "put", "patch"], function r(d) {
    function f(m) {
        return function(y, ee, dt) {
            return this.request(mergeConfig(dt || {}, {
                method: d,
                headers: m ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: y,
                data: ee
            }))
        }
    }
    Axios.prototype[d] = f(),
    Axios.prototype[d + "Form"] = f(!0)
});
var Axios$1 = Axios;
class CancelToken {
    constructor(d) {
        if (typeof d != "function")
            throw new TypeError("executor must be a function.");
        let f;
        this.promise = new Promise(function(y) {
            f = y
        }
        );
        const m = this;
        this.promise.then(k=>{
            if (!m._listeners)
                return;
            let y = m._listeners.length;
            for (; y-- > 0; )
                m._listeners[y](k);
            m._listeners = null
        }
        ),
        this.promise.then = k=>{
            let y;
            const ee = new Promise(dt=>{
                m.subscribe(dt),
                y = dt
            }
            ).then(k);
            return ee.cancel = function() {
                m.unsubscribe(y)
            }
            ,
            ee
        }
        ,
        d(function(y, ee, dt) {
            m.reason || (m.reason = new CanceledError(y,ee,dt),
            f(m.reason))
        })
    }
    throwIfRequested() {
        if (this.reason)
            throw this.reason
    }
    subscribe(d) {
        if (this.reason) {
            d(this.reason);
            return
        }
        this._listeners ? this._listeners.push(d) : this._listeners = [d]
    }
    unsubscribe(d) {
        if (!this._listeners)
            return;
        const f = this._listeners.indexOf(d);
        f !== -1 && this._listeners.splice(f, 1)
    }
    static source() {
        let d;
        return {
            token: new CancelToken(function(k) {
                d = k
            }
            ),
            cancel: d
        }
    }
}
var CancelToken$1 = CancelToken;
function spread(r) {
    return function(f) {
        return r.apply(null, f)
    }
}
function isAxiosError(r) {
    return utils$1.isObject(r) && r.isAxiosError === !0
}
const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([r,d])=>{
    HttpStatusCode[d] = r
}
);
var HttpStatusCode$1 = HttpStatusCode;
function createInstance(r) {
    const d = new Axios$1(r)
      , f = bind(Axios$1.prototype.request, d);
    return utils$1.extend(f, Axios$1.prototype, d, {
        allOwnKeys: !0
    }),
    utils$1.extend(f, d, null, {
        allOwnKeys: !0
    }),
    f.create = function(k) {
        return createInstance(mergeConfig(r, k))
    }
    ,
    f
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function r(d) {
    return Promise.all(d)
}
;
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = r=>formDataToJSON(utils$1.isHTMLForm(r) ? new FormData(r) : r);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
var axios_1$2 = axios
  , lib = {}
  , external = {}
  , errors = {}
  , en = {}
  , util = {};
(function(r) {
    Object.defineProperty(r, "__esModule", {
        value: !0
    }),
    r.getParsedType = r.ZodParsedType = r.objectUtil = r.util = void 0;
    var d;
    (function(m) {
        m.assertEqual = dt=>dt;
        function k(dt) {}
        m.assertIs = k;
        function y(dt) {
            throw new Error
        }
        m.assertNever = y,
        m.arrayToEnum = dt=>{
            const mt = {};
            for (const yt of dt)
                mt[yt] = yt;
            return mt
        }
        ,
        m.getValidEnumValues = dt=>{
            const mt = m.objectKeys(dt).filter(pt=>typeof dt[dt[pt]] != "number")
              , yt = {};
            for (const pt of mt)
                yt[pt] = dt[pt];
            return m.objectValues(yt)
        }
        ,
        m.objectValues = dt=>m.objectKeys(dt).map(function(mt) {
            return dt[mt]
        }),
        m.objectKeys = typeof Object.keys == "function" ? dt=>Object.keys(dt) : dt=>{
            const mt = [];
            for (const yt in dt)
                Object.prototype.hasOwnProperty.call(dt, yt) && mt.push(yt);
            return mt
        }
        ,
        m.find = (dt,mt)=>{
            for (const yt of dt)
                if (mt(yt))
                    return yt
        }
        ,
        m.isInteger = typeof Number.isInteger == "function" ? dt=>Number.isInteger(dt) : dt=>typeof dt == "number" && isFinite(dt) && Math.floor(dt) === dt;
        function ee(dt, mt=" | ") {
            return dt.map(yt=>typeof yt == "string" ? `'${yt}'` : yt).join(mt)
        }
        m.joinValues = ee,
        m.jsonStringifyReplacer = (dt,mt)=>typeof mt == "bigint" ? mt.toString() : mt
    }
    )(d = r.util || (r.util = {})),
    function(m) {
        m.mergeShapes = (k,y)=>({
            ...k,
            ...y
        })
    }(r.objectUtil || (r.objectUtil = {})),
    r.ZodParsedType = d.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]);
    const f = m=>{
        switch (typeof m) {
        case "undefined":
            return r.ZodParsedType.undefined;
        case "string":
            return r.ZodParsedType.string;
        case "number":
            return isNaN(m) ? r.ZodParsedType.nan : r.ZodParsedType.number;
        case "boolean":
            return r.ZodParsedType.boolean;
        case "function":
            return r.ZodParsedType.function;
        case "bigint":
            return r.ZodParsedType.bigint;
        case "symbol":
            return r.ZodParsedType.symbol;
        case "object":
            return Array.isArray(m) ? r.ZodParsedType.array : m === null ? r.ZodParsedType.null : m.then && typeof m.then == "function" && m.catch && typeof m.catch == "function" ? r.ZodParsedType.promise : typeof Map < "u" && m instanceof Map ? r.ZodParsedType.map : typeof Set < "u" && m instanceof Set ? r.ZodParsedType.set : typeof Date < "u" && m instanceof Date ? r.ZodParsedType.date : r.ZodParsedType.object;
        default:
            return r.ZodParsedType.unknown
        }
    }
    ;
    r.getParsedType = f
}
)(util);
var ZodError$1 = {};
Object.defineProperty(ZodError$1, "__esModule", {
    value: !0
});
ZodError$1.ZodError = ZodError$1.quotelessJson = ZodError$1.ZodIssueCode = void 0;
const util_1$1 = util;
ZodError$1.ZodIssueCode = util_1$1.util.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
const quotelessJson = r=>JSON.stringify(r, null, 2).replace(/"([^"]+)":/g, "$1:");
ZodError$1.quotelessJson = quotelessJson;
class ZodError extends Error {
    constructor(d) {
        super(),
        this.issues = [],
        this.addIssue = m=>{
            this.issues = [...this.issues, m]
        }
        ,
        this.addIssues = (m=[])=>{
            this.issues = [...this.issues, ...m]
        }
        ;
        const f = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, f) : this.__proto__ = f,
        this.name = "ZodError",
        this.issues = d
    }
    get errors() {
        return this.issues
    }
    format(d) {
        const f = d || function(y) {
            return y.message
        }
          , m = {
            _errors: []
        }
          , k = y=>{
            for (const ee of y.issues)
                if (ee.code === "invalid_union")
                    ee.unionErrors.map(k);
                else if (ee.code === "invalid_return_type")
                    k(ee.returnTypeError);
                else if (ee.code === "invalid_arguments")
                    k(ee.argumentsError);
                else if (ee.path.length === 0)
                    m._errors.push(f(ee));
                else {
                    let dt = m
                      , mt = 0;
                    for (; mt < ee.path.length; ) {
                        const yt = ee.path[mt];
                        mt === ee.path.length - 1 ? (dt[yt] = dt[yt] || {
                            _errors: []
                        },
                        dt[yt]._errors.push(f(ee))) : dt[yt] = dt[yt] || {
                            _errors: []
                        },
                        dt = dt[yt],
                        mt++
                    }
                }
        }
        ;
        return k(this),
        m
    }
    static assert(d) {
        if (!(d instanceof ZodError))
            throw new Error(`Not a ZodError: ${d}`)
    }
    toString() {
        return this.message
    }
    get message() {
        return JSON.stringify(this.issues, util_1$1.util.jsonStringifyReplacer, 2)
    }
    get isEmpty() {
        return this.issues.length === 0
    }
    flatten(d=f=>f.message) {
        const f = {}
          , m = [];
        for (const k of this.issues)
            k.path.length > 0 ? (f[k.path[0]] = f[k.path[0]] || [],
            f[k.path[0]].push(d(k))) : m.push(d(k));
        return {
            formErrors: m,
            fieldErrors: f
        }
    }
    get formErrors() {
        return this.flatten()
    }
}
ZodError$1.ZodError = ZodError;
ZodError.create = r=>new ZodError(r);
Object.defineProperty(en, "__esModule", {
    value: !0
});
const util_1 = util
  , ZodError_1 = ZodError$1
  , errorMap = (r,d)=>{
    let f;
    switch (r.code) {
    case ZodError_1.ZodIssueCode.invalid_type:
        r.received === util_1.ZodParsedType.undefined ? f = "Required" : f = `Expected ${r.expected}, received ${r.received}`;
        break;
    case ZodError_1.ZodIssueCode.invalid_literal:
        f = `Invalid literal value, expected ${JSON.stringify(r.expected, util_1.util.jsonStringifyReplacer)}`;
        break;
    case ZodError_1.ZodIssueCode.unrecognized_keys:
        f = `Unrecognized key(s) in object: ${util_1.util.joinValues(r.keys, ", ")}`;
        break;
    case ZodError_1.ZodIssueCode.invalid_union:
        f = "Invalid input";
        break;
    case ZodError_1.ZodIssueCode.invalid_union_discriminator:
        f = `Invalid discriminator value. Expected ${util_1.util.joinValues(r.options)}`;
        break;
    case ZodError_1.ZodIssueCode.invalid_enum_value:
        f = `Invalid enum value. Expected ${util_1.util.joinValues(r.options)}, received '${r.received}'`;
        break;
    case ZodError_1.ZodIssueCode.invalid_arguments:
        f = "Invalid function arguments";
        break;
    case ZodError_1.ZodIssueCode.invalid_return_type:
        f = "Invalid function return type";
        break;
    case ZodError_1.ZodIssueCode.invalid_date:
        f = "Invalid date";
        break;
    case ZodError_1.ZodIssueCode.invalid_string:
        typeof r.validation == "object" ? "includes"in r.validation ? (f = `Invalid input: must include "${r.validation.includes}"`,
        typeof r.validation.position == "number" && (f = `${f} at one or more positions greater than or equal to ${r.validation.position}`)) : "startsWith"in r.validation ? f = `Invalid input: must start with "${r.validation.startsWith}"` : "endsWith"in r.validation ? f = `Invalid input: must end with "${r.validation.endsWith}"` : util_1.util.assertNever(r.validation) : r.validation !== "regex" ? f = `Invalid ${r.validation}` : f = "Invalid";
        break;
    case ZodError_1.ZodIssueCode.too_small:
        r.type === "array" ? f = `Array must contain ${r.exact ? "exactly" : r.inclusive ? "at least" : "more than"} ${r.minimum} element(s)` : r.type === "string" ? f = `String must contain ${r.exact ? "exactly" : r.inclusive ? "at least" : "over"} ${r.minimum} character(s)` : r.type === "number" ? f = `Number must be ${r.exact ? "exactly equal to " : r.inclusive ? "greater than or equal to " : "greater than "}${r.minimum}` : r.type === "date" ? f = `Date must be ${r.exact ? "exactly equal to " : r.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(r.minimum))}` : f = "Invalid input";
        break;
    case ZodError_1.ZodIssueCode.too_big:
        r.type === "array" ? f = `Array must contain ${r.exact ? "exactly" : r.inclusive ? "at most" : "less than"} ${r.maximum} element(s)` : r.type === "string" ? f = `String must contain ${r.exact ? "exactly" : r.inclusive ? "at most" : "under"} ${r.maximum} character(s)` : r.type === "number" ? f = `Number must be ${r.exact ? "exactly" : r.inclusive ? "less than or equal to" : "less than"} ${r.maximum}` : r.type === "bigint" ? f = `BigInt must be ${r.exact ? "exactly" : r.inclusive ? "less than or equal to" : "less than"} ${r.maximum}` : r.type === "date" ? f = `Date must be ${r.exact ? "exactly" : r.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(r.maximum))}` : f = "Invalid input";
        break;
    case ZodError_1.ZodIssueCode.custom:
        f = "Invalid input";
        break;
    case ZodError_1.ZodIssueCode.invalid_intersection_types:
        f = "Intersection results could not be merged";
        break;
    case ZodError_1.ZodIssueCode.not_multiple_of:
        f = `Number must be a multiple of ${r.multipleOf}`;
        break;
    case ZodError_1.ZodIssueCode.not_finite:
        f = "Number must be finite";
        break;
    default:
        f = d.defaultError,
        util_1.util.assertNever(r)
    }
    return {
        message: f
    }
}
;
en.default = errorMap;
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(r) {
    return r && r.__esModule ? r : {
        default: r
    }
}
;
Object.defineProperty(errors, "__esModule", {
    value: !0
});
errors.getErrorMap = errors.setErrorMap = errors.defaultErrorMap = void 0;
const en_1 = __importDefault$2(en);
errors.defaultErrorMap = en_1.default;
let overrideErrorMap = en_1.default;
function setErrorMap(r) {
    overrideErrorMap = r
}
errors.setErrorMap = setErrorMap;
function getErrorMap() {
    return overrideErrorMap
}
errors.getErrorMap = getErrorMap;
var parseUtil = {};
(function(r) {
    var d = commonjsGlobal && commonjsGlobal.__importDefault || function(xt) {
        return xt && xt.__esModule ? xt : {
            default: xt
        }
    }
    ;
    Object.defineProperty(r, "__esModule", {
        value: !0
    }),
    r.isAsync = r.isValid = r.isDirty = r.isAborted = r.OK = r.DIRTY = r.INVALID = r.ParseStatus = r.addIssueToContext = r.EMPTY_PATH = r.makeIssue = void 0;
    const f = errors
      , m = d(en)
      , k = xt=>{
        const {data: At, path: Ct, errorMaps: Pt, issueData: $t} = xt
          , Ot = [...Ct, ...$t.path || []]
          , Nt = {
            ...$t,
            path: Ot
        };
        if ($t.message !== void 0)
            return {
                ...$t,
                path: Ot,
                message: $t.message
            };
        let zt = "";
        const Wt = Pt.filter(Kt=>!!Kt).slice().reverse();
        for (const Kt of Wt)
            zt = Kt(Nt, {
                data: At,
                defaultError: zt
            }).message;
        return {
            ...$t,
            path: Ot,
            message: zt
        }
    }
    ;
    r.makeIssue = k,
    r.EMPTY_PATH = [];
    function y(xt, At) {
        const Ct = (0,
        f.getErrorMap)()
          , Pt = (0,
        r.makeIssue)({
            issueData: At,
            data: xt.data,
            path: xt.path,
            errorMaps: [xt.common.contextualErrorMap, xt.schemaErrorMap, Ct, Ct === m.default ? void 0 : m.default].filter($t=>!!$t)
        });
        xt.common.issues.push(Pt)
    }
    r.addIssueToContext = y;
    class ee {
        constructor() {
            this.value = "valid"
        }
        dirty() {
            this.value === "valid" && (this.value = "dirty")
        }
        abort() {
            this.value !== "aborted" && (this.value = "aborted")
        }
        static mergeArray(At, Ct) {
            const Pt = [];
            for (const $t of Ct) {
                if ($t.status === "aborted")
                    return r.INVALID;
                $t.status === "dirty" && At.dirty(),
                Pt.push($t.value)
            }
            return {
                status: At.value,
                value: Pt
            }
        }
        static async mergeObjectAsync(At, Ct) {
            const Pt = [];
            for (const $t of Ct) {
                const Ot = await $t.key
                  , Nt = await $t.value;
                Pt.push({
                    key: Ot,
                    value: Nt
                })
            }
            return ee.mergeObjectSync(At, Pt)
        }
        static mergeObjectSync(At, Ct) {
            const Pt = {};
            for (const $t of Ct) {
                const {key: Ot, value: Nt} = $t;
                if (Ot.status === "aborted" || Nt.status === "aborted")
                    return r.INVALID;
                Ot.status === "dirty" && At.dirty(),
                Nt.status === "dirty" && At.dirty(),
                Ot.value !== "__proto__" && (typeof Nt.value < "u" || $t.alwaysSet) && (Pt[Ot.value] = Nt.value)
            }
            return {
                status: At.value,
                value: Pt
            }
        }
    }
    r.ParseStatus = ee,
    r.INVALID = Object.freeze({
        status: "aborted"
    });
    const dt = xt=>({
        status: "dirty",
        value: xt
    });
    r.DIRTY = dt;
    const mt = xt=>({
        status: "valid",
        value: xt
    });
    r.OK = mt;
    const yt = xt=>xt.status === "aborted";
    r.isAborted = yt;
    const pt = xt=>xt.status === "dirty";
    r.isDirty = pt;
    const bt = xt=>xt.status === "valid";
    r.isValid = bt;
    const wt = xt=>typeof Promise < "u" && xt instanceof Promise;
    r.isAsync = wt
}
)(parseUtil);
var typeAliases = {};
Object.defineProperty(typeAliases, "__esModule", {
    value: !0
});
var types = {}
  , errorUtil = {};
(function(r) {
    Object.defineProperty(r, "__esModule", {
        value: !0
    }),
    r.errorUtil = void 0,
    function(d) {
        d.errToObj = f=>typeof f == "string" ? {
            message: f
        } : f || {},
        d.toString = f=>typeof f == "string" ? f : f == null ? void 0 : f.message
    }(r.errorUtil || (r.errorUtil = {}))
}
)(errorUtil);
(function(r) {
    var d = commonjsGlobal && commonjsGlobal.__classPrivateFieldGet || function(yr, Lt, Gt, Qt) {
        if (Gt === "a" && !Qt)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof Lt == "function" ? yr !== Lt || !Qt : !Lt.has(yr))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return Gt === "m" ? Qt : Gt === "a" ? Qt.call(yr) : Qt ? Qt.value : Lt.get(yr)
    }
    , f = commonjsGlobal && commonjsGlobal.__classPrivateFieldSet || function(yr, Lt, Gt, Qt, pr) {
        if (Qt === "m")
            throw new TypeError("Private method is not writable");
        if (Qt === "a" && !pr)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof Lt == "function" ? yr !== Lt || !pr : !Lt.has(yr))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return Qt === "a" ? pr.call(yr, Gt) : pr ? pr.value = Gt : Lt.set(yr, Gt),
        Gt
    }
    , m, k;
    Object.defineProperty(r, "__esModule", {
        value: !0
    }),
    r.boolean = r.bigint = r.array = r.any = r.coerce = r.ZodFirstPartyTypeKind = r.late = r.ZodSchema = r.Schema = r.custom = r.ZodReadonly = r.ZodPipeline = r.ZodBranded = r.BRAND = r.ZodNaN = r.ZodCatch = r.ZodDefault = r.ZodNullable = r.ZodOptional = r.ZodTransformer = r.ZodEffects = r.ZodPromise = r.ZodNativeEnum = r.ZodEnum = r.ZodLiteral = r.ZodLazy = r.ZodFunction = r.ZodSet = r.ZodMap = r.ZodRecord = r.ZodTuple = r.ZodIntersection = r.ZodDiscriminatedUnion = r.ZodUnion = r.ZodObject = r.ZodArray = r.ZodVoid = r.ZodNever = r.ZodUnknown = r.ZodAny = r.ZodNull = r.ZodUndefined = r.ZodSymbol = r.ZodDate = r.ZodBoolean = r.ZodBigInt = r.ZodNumber = r.ZodString = r.datetimeRegex = r.ZodType = void 0,
    r.NEVER = r.void = r.unknown = r.union = r.undefined = r.tuple = r.transformer = r.symbol = r.string = r.strictObject = r.set = r.record = r.promise = r.preprocess = r.pipeline = r.ostring = r.optional = r.onumber = r.oboolean = r.object = r.number = r.nullable = r.null = r.never = r.nativeEnum = r.nan = r.map = r.literal = r.lazy = r.intersection = r.instanceof = r.function = r.enum = r.effect = r.discriminatedUnion = r.date = void 0;
    const y = errors
      , ee = errorUtil
      , dt = parseUtil
      , mt = util
      , yt = ZodError$1;
    class pt {
        constructor(Lt, Gt, Qt, pr) {
            this._cachedPath = [],
            this.parent = Lt,
            this.data = Gt,
            this._path = Qt,
            this._key = pr
        }
        get path() {
            return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)),
            this._cachedPath
        }
    }
    const bt = (yr,Lt)=>{
        if ((0,
        dt.isValid)(Lt))
            return {
                success: !0,
                data: Lt.value
            };
        if (!yr.common.issues.length)
            throw new Error("Validation failed but no issues detected.");
        return {
            success: !1,
            get error() {
                if (this._error)
                    return this._error;
                const Gt = new yt.ZodError(yr.common.issues);
                return this._error = Gt,
                this._error
            }
        }
    }
    ;
    function wt(yr) {
        if (!yr)
            return {};
        const {errorMap: Lt, invalid_type_error: Gt, required_error: Qt, description: pr} = yr;
        if (Lt && (Gt || Qt))
            throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
        return Lt ? {
            errorMap: Lt,
            description: pr
        } : {
            errorMap: (Mr,Br)=>{
                var Fr, Kr;
                const {message: Xr} = yr;
                return Mr.code === "invalid_enum_value" ? {
                    message: Xr ?? Br.defaultError
                } : typeof Br.data > "u" ? {
                    message: (Fr = Xr ?? Qt) !== null && Fr !== void 0 ? Fr : Br.defaultError
                } : Mr.code !== "invalid_type" ? {
                    message: Br.defaultError
                } : {
                    message: (Kr = Xr ?? Gt) !== null && Kr !== void 0 ? Kr : Br.defaultError
                }
            }
            ,
            description: pr
        }
    }
    class xt {
        constructor(Lt) {
            this.spa = this.safeParseAsync,
            this._def = Lt,
            this.parse = this.parse.bind(this),
            this.safeParse = this.safeParse.bind(this),
            this.parseAsync = this.parseAsync.bind(this),
            this.safeParseAsync = this.safeParseAsync.bind(this),
            this.spa = this.spa.bind(this),
            this.refine = this.refine.bind(this),
            this.refinement = this.refinement.bind(this),
            this.superRefine = this.superRefine.bind(this),
            this.optional = this.optional.bind(this),
            this.nullable = this.nullable.bind(this),
            this.nullish = this.nullish.bind(this),
            this.array = this.array.bind(this),
            this.promise = this.promise.bind(this),
            this.or = this.or.bind(this),
            this.and = this.and.bind(this),
            this.transform = this.transform.bind(this),
            this.brand = this.brand.bind(this),
            this.default = this.default.bind(this),
            this.catch = this.catch.bind(this),
            this.describe = this.describe.bind(this),
            this.pipe = this.pipe.bind(this),
            this.readonly = this.readonly.bind(this),
            this.isNullable = this.isNullable.bind(this),
            this.isOptional = this.isOptional.bind(this)
        }
        get description() {
            return this._def.description
        }
        _getType(Lt) {
            return (0,
            mt.getParsedType)(Lt.data)
        }
        _getOrReturnCtx(Lt, Gt) {
            return Gt || {
                common: Lt.parent.common,
                data: Lt.data,
                parsedType: (0,
                mt.getParsedType)(Lt.data),
                schemaErrorMap: this._def.errorMap,
                path: Lt.path,
                parent: Lt.parent
            }
        }
        _processInputParams(Lt) {
            return {
                status: new dt.ParseStatus,
                ctx: {
                    common: Lt.parent.common,
                    data: Lt.data,
                    parsedType: (0,
                    mt.getParsedType)(Lt.data),
                    schemaErrorMap: this._def.errorMap,
                    path: Lt.path,
                    parent: Lt.parent
                }
            }
        }
        _parseSync(Lt) {
            const Gt = this._parse(Lt);
            if ((0,
            dt.isAsync)(Gt))
                throw new Error("Synchronous parse encountered promise.");
            return Gt
        }
        _parseAsync(Lt) {
            const Gt = this._parse(Lt);
            return Promise.resolve(Gt)
        }
        parse(Lt, Gt) {
            const Qt = this.safeParse(Lt, Gt);
            if (Qt.success)
                return Qt.data;
            throw Qt.error
        }
        safeParse(Lt, Gt) {
            var Qt;
            const pr = {
                common: {
                    issues: [],
                    async: (Qt = Gt == null ? void 0 : Gt.async) !== null && Qt !== void 0 ? Qt : !1,
                    contextualErrorMap: Gt == null ? void 0 : Gt.errorMap
                },
                path: (Gt == null ? void 0 : Gt.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: Lt,
                parsedType: (0,
                mt.getParsedType)(Lt)
            }
              , dr = this._parseSync({
                data: Lt,
                path: pr.path,
                parent: pr
            });
            return bt(pr, dr)
        }
        async parseAsync(Lt, Gt) {
            const Qt = await this.safeParseAsync(Lt, Gt);
            if (Qt.success)
                return Qt.data;
            throw Qt.error
        }
        async safeParseAsync(Lt, Gt) {
            const Qt = {
                common: {
                    issues: [],
                    contextualErrorMap: Gt == null ? void 0 : Gt.errorMap,
                    async: !0
                },
                path: (Gt == null ? void 0 : Gt.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: Lt,
                parsedType: (0,
                mt.getParsedType)(Lt)
            }
              , pr = this._parse({
                data: Lt,
                path: Qt.path,
                parent: Qt
            })
              , dr = await ((0,
            dt.isAsync)(pr) ? pr : Promise.resolve(pr));
            return bt(Qt, dr)
        }
        refine(Lt, Gt) {
            const Qt = pr=>typeof Gt == "string" || typeof Gt > "u" ? {
                message: Gt
            } : typeof Gt == "function" ? Gt(pr) : Gt;
            return this._refinement((pr,dr)=>{
                const Mr = Lt(pr)
                  , Br = ()=>dr.addIssue({
                    code: yt.ZodIssueCode.custom,
                    ...Qt(pr)
                });
                return typeof Promise < "u" && Mr instanceof Promise ? Mr.then(Fr=>Fr ? !0 : (Br(),
                !1)) : Mr ? !0 : (Br(),
                !1)
            }
            )
        }
        refinement(Lt, Gt) {
            return this._refinement((Qt,pr)=>Lt(Qt) ? !0 : (pr.addIssue(typeof Gt == "function" ? Gt(Qt, pr) : Gt),
            !1))
        }
        _refinement(Lt) {
            return new _r({
                schema: this,
                typeName: Ur.ZodEffects,
                effect: {
                    type: "refinement",
                    refinement: Lt
                }
            })
        }
        superRefine(Lt) {
            return this._refinement(Lt)
        }
        optional() {
            return Ar.create(this, this._def)
        }
        nullable() {
            return Ft.create(this, this._def)
        }
        nullish() {
            return this.nullable().optional()
        }
        array() {
            return rr.create(this, this._def)
        }
        promise() {
            return hr.create(this, this._def)
        }
        or(Lt) {
            return Xt.create([this, Lt], this._def)
        }
        and(Lt) {
            return Nr.create(this, Lt, this._def)
        }
        transform(Lt) {
            return new _r({
                ...wt(this._def),
                schema: this,
                typeName: Ur.ZodEffects,
                effect: {
                    type: "transform",
                    transform: Lt
                }
            })
        }
        default(Lt) {
            const Gt = typeof Lt == "function" ? Lt : ()=>Lt;
            return new Ut({
                ...wt(this._def),
                innerType: this,
                defaultValue: Gt,
                typeName: Ur.ZodDefault
            })
        }
        brand() {
            return new br({
                typeName: Ur.ZodBranded,
                type: this,
                ...wt(this._def)
            })
        }
        catch(Lt) {
            const Gt = typeof Lt == "function" ? Lt : ()=>Lt;
            return new Dt({
                ...wt(this._def),
                innerType: this,
                catchValue: Gt,
                typeName: Ur.ZodCatch
            })
        }
        describe(Lt) {
            const Gt = this.constructor;
            return new Gt({
                ...this._def,
                description: Lt
            })
        }
        pipe(Lt) {
            return Cr.create(this, Lt)
        }
        readonly() {
            return xr.create(this)
        }
        isOptional() {
            return this.safeParse(void 0).success
        }
        isNullable() {
            return this.safeParse(null).success
        }
    }
    r.ZodType = xt,
    r.Schema = xt,
    r.ZodSchema = xt;
    const At = /^c[^\s-]{8,}$/i
      , Ct = /^[0-9a-z]+$/
      , Pt = /^[0-9A-HJKMNP-TV-Z]{26}$/
      , $t = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i
      , Ot = /^[a-z0-9_-]{21}$/i
      , Nt = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/
      , zt = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i
      , Wt = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
    let Kt;
    const ir = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/
      , or = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/
      , tr = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/
      , wr = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))"
      , Ht = new RegExp(`^${wr}$`);
    function Mt(yr) {
        let Lt = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
        return yr.precision ? Lt = `${Lt}\\.\\d{${yr.precision}}` : yr.precision == null && (Lt = `${Lt}(\\.\\d+)?`),
        Lt
    }
    function _t(yr) {
        return new RegExp(`^${Mt(yr)}$`)
    }
    function gt(yr) {
        let Lt = `${wr}T${Mt(yr)}`;
        const Gt = [];
        return Gt.push(yr.local ? "Z?" : "Z"),
        yr.offset && Gt.push("([+-]\\d{2}:?\\d{2})"),
        Lt = `${Lt}(${Gt.join("|")})`,
        new RegExp(`^${Lt}$`)
    }
    r.datetimeRegex = gt;
    function vt(yr, Lt) {
        return !!((Lt === "v4" || !Lt) && ir.test(yr) || (Lt === "v6" || !Lt) && or.test(yr))
    }
    class Et extends xt {
        _parse(Lt) {
            if (this._def.coerce && (Lt.data = String(Lt.data)),
            this._getType(Lt) !== mt.ZodParsedType.string) {
                const dr = this._getOrReturnCtx(Lt);
                return (0,
                dt.addIssueToContext)(dr, {
                    code: yt.ZodIssueCode.invalid_type,
                    expected: mt.ZodParsedType.string,
                    received: dr.parsedType
                }),
                dt.INVALID
            }
            const Qt = new dt.ParseStatus;
            let pr;
            for (const dr of this._def.checks)
                if (dr.kind === "min")
                    Lt.data.length < dr.value && (pr = this._getOrReturnCtx(Lt, pr),
                    (0,
                    dt.addIssueToContext)(pr, {
                        code: yt.ZodIssueCode.too_small,
                        minimum: dr.value,
                        type: "string",
                        inclusive: !0,
                        exact: !1,
                        message: dr.message
                    }),
                    Qt.dirty());
                else if (dr.kind === "max")
                    Lt.data.length > dr.value && (pr = this._getOrReturnCtx(Lt, pr),
                    (0,
                    dt.addIssueToContext)(pr, {
                        code: yt.ZodIssueCode.too_big,
                        maximum: dr.value,
                        type: "string",
                        inclusive: !0,
                        exact: !1,
                        message: dr.message
                    }),
                    Qt.dirty());
                else if (dr.kind === "length") {
                    const Mr = Lt.data.length > dr.value
                      , Br = Lt.data.length < dr.value;
                    (Mr || Br) && (pr = this._getOrReturnCtx(Lt, pr),
                    Mr ? (0,
                    dt.addIssueToContext)(pr, {
                        code: yt.ZodIssueCode.too_big,
                        maximum: dr.value,
                        type: "string",
                        inclusive: !0,
                        exact: !0,
                        message: dr.message
                    }) : Br && (0,
                    dt.addIssueToContext)(pr, {
                        code: yt.ZodIssueCode.too_small,
                        minimum: dr.value,
                        type: "string",
                        inclusive: !0,
                        exact: !0,
                        message: dr.message
                    }),
                    Qt.dirty())
                } else if (dr.kind === "email")
                    zt.test(Lt.data) || (pr = this._getOrReturnCtx(Lt, pr),
                    (0,
                    dt.addIssueToContext)(pr, {
                        validation: "email",
                        code: yt.ZodIssueCode.invalid_string,
                        message: dr.message
                    }),
                    Qt.dirty());
                else if (dr.kind === "emoji")
                    Kt || (Kt = new RegExp(Wt,"u")),
                    Kt.test(Lt.data) || (pr = this._getOrReturnCtx(Lt, pr),
                    (0,
                    dt.addIssueToContext)(pr, {
                        validation: "emoji",
                        code: yt.ZodIssueCode.invalid_string,
                        message: dr.message
                    }),
                    Qt.dirty());
                else if (dr.kind === "uuid")
                    $t.test(Lt.data) || (pr = this._getOrReturnCtx(Lt, pr),
                    (0,
                    dt.addIssueToContext)(pr, {
                        validation: "uuid",
                        code: yt.ZodIssueCode.invalid_string,
                        message: dr.message
                    }),
                    Qt.dirty());
                else if (dr.kind === "nanoid")
                    Ot.test(Lt.data) || (pr = this._getOrReturnCtx(Lt, pr),
                    (0,
                    dt.addIssueToContext)(pr, {
                        validation: "nanoid",
                        code: yt.ZodIssueCode.invalid_string,
                        message: dr.message
                    }),
                    Qt.dirty());
                else if (dr.kind === "cuid")
                    At.test(Lt.data) || (pr = this._getOrReturnCtx(Lt, pr),
                    (0,
                    dt.addIssueToContext)(pr, {
                        validation: "cuid",
                        code: yt.ZodIssueCode.invalid_string,
                        message: dr.message
                    }),
                    Qt.dirty());
                else if (dr.kind === "cuid2")
                    Ct.test(Lt.data) || (pr = this._getOrReturnCtx(Lt, pr),
                    (0,
                    dt.addIssueToContext)(pr, {
                        validation: "cuid2",
                        code: yt.ZodIssueCode.invalid_string,
                        message: dr.message
                    }),
                    Qt.dirty());
                else if (dr.kind === "ulid")
                    Pt.test(Lt.data) || (pr = this._getOrReturnCtx(Lt, pr),
                    (0,
                    dt.addIssueToContext)(pr, {
                        validation: "ulid",
                        code: yt.ZodIssueCode.invalid_string,
                        message: dr.message
                    }),
                    Qt.dirty());
                else if (dr.kind === "url")
                    try {
                        new URL(Lt.data)
                    } catch {
                        pr = this._getOrReturnCtx(Lt, pr),
                        (0,
                        dt.addIssueToContext)(pr, {
                            validation: "url",
                            code: yt.ZodIssueCode.invalid_string,
                            message: dr.message
                        }),
                        Qt.dirty()
                    }
                else
                    dr.kind === "regex" ? (dr.regex.lastIndex = 0,
                    dr.regex.test(Lt.data) || (pr = this._getOrReturnCtx(Lt, pr),
                    (0,
                    dt.addIssueToContext)(pr, {
                        validation: "regex",
                        code: yt.ZodIssueCode.invalid_string,
                        message: dr.message
                    }),
                    Qt.dirty())) : dr.kind === "trim" ? Lt.data = Lt.data.trim() : dr.kind === "includes" ? Lt.data.includes(dr.value, dr.position) || (pr = this._getOrReturnCtx(Lt, pr),
                    (0,
                    dt.addIssueToContext)(pr, {
                        code: yt.ZodIssueCode.invalid_string,
                        validation: {
                            includes: dr.value,
                            position: dr.position
                        },
                        message: dr.message
                    }),
                    Qt.dirty()) : dr.kind === "toLowerCase" ? Lt.data = Lt.data.toLowerCase() : dr.kind === "toUpperCase" ? Lt.data = Lt.data.toUpperCase() : dr.kind === "startsWith" ? Lt.data.startsWith(dr.value) || (pr = this._getOrReturnCtx(Lt, pr),
                    (0,
                    dt.addIssueToContext)(pr, {
                        code: yt.ZodIssueCode.invalid_string,
                        validation: {
                            startsWith: dr.value
                        },
                        message: dr.message
                    }),
                    Qt.dirty()) : dr.kind === "endsWith" ? Lt.data.endsWith(dr.value) || (pr = this._getOrReturnCtx(Lt, pr),
                    (0,
                    dt.addIssueToContext)(pr, {
                        code: yt.ZodIssueCode.invalid_string,
                        validation: {
                            endsWith: dr.value
                        },
                        message: dr.message
                    }),
                    Qt.dirty()) : dr.kind === "datetime" ? gt(dr).test(Lt.data) || (pr = this._getOrReturnCtx(Lt, pr),
                    (0,
                    dt.addIssueToContext)(pr, {
                        code: yt.ZodIssueCode.invalid_string,
                        validation: "datetime",
                        message: dr.message
                    }),
                    Qt.dirty()) : dr.kind === "date" ? Ht.test(Lt.data) || (pr = this._getOrReturnCtx(Lt, pr),
                    (0,
                    dt.addIssueToContext)(pr, {
                        code: yt.ZodIssueCode.invalid_string,
                        validation: "date",
                        message: dr.message
                    }),
                    Qt.dirty()) : dr.kind === "time" ? _t(dr).test(Lt.data) || (pr = this._getOrReturnCtx(Lt, pr),
                    (0,
                    dt.addIssueToContext)(pr, {
                        code: yt.ZodIssueCode.invalid_string,
                        validation: "time",
                        message: dr.message
                    }),
                    Qt.dirty()) : dr.kind === "duration" ? Nt.test(Lt.data) || (pr = this._getOrReturnCtx(Lt, pr),
                    (0,
                    dt.addIssueToContext)(pr, {
                        validation: "duration",
                        code: yt.ZodIssueCode.invalid_string,
                        message: dr.message
                    }),
                    Qt.dirty()) : dr.kind === "ip" ? vt(Lt.data, dr.version) || (pr = this._getOrReturnCtx(Lt, pr),
                    (0,
                    dt.addIssueToContext)(pr, {
                        validation: "ip",
                        code: yt.ZodIssueCode.invalid_string,
                        message: dr.message
                    }),
                    Qt.dirty()) : dr.kind === "base64" ? tr.test(Lt.data) || (pr = this._getOrReturnCtx(Lt, pr),
                    (0,
                    dt.addIssueToContext)(pr, {
                        validation: "base64",
                        code: yt.ZodIssueCode.invalid_string,
                        message: dr.message
                    }),
                    Qt.dirty()) : mt.util.assertNever(dr);
            return {
                status: Qt.value,
                value: Lt.data
            }
        }
        _regex(Lt, Gt, Qt) {
            return this.refinement(pr=>Lt.test(pr), {
                validation: Gt,
                code: yt.ZodIssueCode.invalid_string,
                ...ee.errorUtil.errToObj(Qt)
            })
        }
        _addCheck(Lt) {
            return new Et({
                ...this._def,
                checks: [...this._def.checks, Lt]
            })
        }
        email(Lt) {
            return this._addCheck({
                kind: "email",
                ...ee.errorUtil.errToObj(Lt)
            })
        }
        url(Lt) {
            return this._addCheck({
                kind: "url",
                ...ee.errorUtil.errToObj(Lt)
            })
        }
        emoji(Lt) {
            return this._addCheck({
                kind: "emoji",
                ...ee.errorUtil.errToObj(Lt)
            })
        }
        uuid(Lt) {
            return this._addCheck({
                kind: "uuid",
                ...ee.errorUtil.errToObj(Lt)
            })
        }
        nanoid(Lt) {
            return this._addCheck({
                kind: "nanoid",
                ...ee.errorUtil.errToObj(Lt)
            })
        }
        cuid(Lt) {
            return this._addCheck({
                kind: "cuid",
                ...ee.errorUtil.errToObj(Lt)
            })
        }
        cuid2(Lt) {
            return this._addCheck({
                kind: "cuid2",
                ...ee.errorUtil.errToObj(Lt)
            })
        }
        ulid(Lt) {
            return this._addCheck({
                kind: "ulid",
                ...ee.errorUtil.errToObj(Lt)
            })
        }
        base64(Lt) {
            return this._addCheck({
                kind: "base64",
                ...ee.errorUtil.errToObj(Lt)
            })
        }
        ip(Lt) {
            return this._addCheck({
                kind: "ip",
                ...ee.errorUtil.errToObj(Lt)
            })
        }
        datetime(Lt) {
            var Gt, Qt;
            return typeof Lt == "string" ? this._addCheck({
                kind: "datetime",
                precision: null,
                offset: !1,
                local: !1,
                message: Lt
            }) : this._addCheck({
                kind: "datetime",
                precision: typeof (Lt == null ? void 0 : Lt.precision) > "u" ? null : Lt == null ? void 0 : Lt.precision,
                offset: (Gt = Lt == null ? void 0 : Lt.offset) !== null && Gt !== void 0 ? Gt : !1,
                local: (Qt = Lt == null ? void 0 : Lt.local) !== null && Qt !== void 0 ? Qt : !1,
                ...ee.errorUtil.errToObj(Lt == null ? void 0 : Lt.message)
            })
        }
        date(Lt) {
            return this._addCheck({
                kind: "date",
                message: Lt
            })
        }
        time(Lt) {
            return typeof Lt == "string" ? this._addCheck({
                kind: "time",
                precision: null,
                message: Lt
            }) : this._addCheck({
                kind: "time",
                precision: typeof (Lt == null ? void 0 : Lt.precision) > "u" ? null : Lt == null ? void 0 : Lt.precision,
                ...ee.errorUtil.errToObj(Lt == null ? void 0 : Lt.message)
            })
        }
        duration(Lt) {
            return this._addCheck({
                kind: "duration",
                ...ee.errorUtil.errToObj(Lt)
            })
        }
        regex(Lt, Gt) {
            return this._addCheck({
                kind: "regex",
                regex: Lt,
                ...ee.errorUtil.errToObj(Gt)
            })
        }
        includes(Lt, Gt) {
            return this._addCheck({
                kind: "includes",
                value: Lt,
                position: Gt == null ? void 0 : Gt.position,
                ...ee.errorUtil.errToObj(Gt == null ? void 0 : Gt.message)
            })
        }
        startsWith(Lt, Gt) {
            return this._addCheck({
                kind: "startsWith",
                value: Lt,
                ...ee.errorUtil.errToObj(Gt)
            })
        }
        endsWith(Lt, Gt) {
            return this._addCheck({
                kind: "endsWith",
                value: Lt,
                ...ee.errorUtil.errToObj(Gt)
            })
        }
        min(Lt, Gt) {
            return this._addCheck({
                kind: "min",
                value: Lt,
                ...ee.errorUtil.errToObj(Gt)
            })
        }
        max(Lt, Gt) {
            return this._addCheck({
                kind: "max",
                value: Lt,
                ...ee.errorUtil.errToObj(Gt)
            })
        }
        length(Lt, Gt) {
            return this._addCheck({
                kind: "length",
                value: Lt,
                ...ee.errorUtil.errToObj(Gt)
            })
        }
        nonempty(Lt) {
            return this.min(1, ee.errorUtil.errToObj(Lt))
        }
        trim() {
            return new Et({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: "trim"
                }]
            })
        }
        toLowerCase() {
            return new Et({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: "toLowerCase"
                }]
            })
        }
        toUpperCase() {
            return new Et({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: "toUpperCase"
                }]
            })
        }
        get isDatetime() {
            return !!this._def.checks.find(Lt=>Lt.kind === "datetime")
        }
        get isDate() {
            return !!this._def.checks.find(Lt=>Lt.kind === "date")
        }
        get isTime() {
            return !!this._def.checks.find(Lt=>Lt.kind === "time")
        }
        get isDuration() {
            return !!this._def.checks.find(Lt=>Lt.kind === "duration")
        }
        get isEmail() {
            return !!this._def.checks.find(Lt=>Lt.kind === "email")
        }
        get isURL() {
            return !!this._def.checks.find(Lt=>Lt.kind === "url")
        }
        get isEmoji() {
            return !!this._def.checks.find(Lt=>Lt.kind === "emoji")
        }
        get isUUID() {
            return !!this._def.checks.find(Lt=>Lt.kind === "uuid")
        }
        get isNANOID() {
            return !!this._def.checks.find(Lt=>Lt.kind === "nanoid")
        }
        get isCUID() {
            return !!this._def.checks.find(Lt=>Lt.kind === "cuid")
        }
        get isCUID2() {
            return !!this._def.checks.find(Lt=>Lt.kind === "cuid2")
        }
        get isULID() {
            return !!this._def.checks.find(Lt=>Lt.kind === "ulid")
        }
        get isIP() {
            return !!this._def.checks.find(Lt=>Lt.kind === "ip")
        }
        get isBase64() {
            return !!this._def.checks.find(Lt=>Lt.kind === "base64")
        }
        get minLength() {
            let Lt = null;
            for (const Gt of this._def.checks)
                Gt.kind === "min" && (Lt === null || Gt.value > Lt) && (Lt = Gt.value);
            return Lt
        }
        get maxLength() {
            let Lt = null;
            for (const Gt of this._def.checks)
                Gt.kind === "max" && (Lt === null || Gt.value < Lt) && (Lt = Gt.value);
            return Lt
        }
    }
    r.ZodString = Et,
    Et.create = yr=>{
        var Lt;
        return new Et({
            checks: [],
            typeName: Ur.ZodString,
            coerce: (Lt = yr == null ? void 0 : yr.coerce) !== null && Lt !== void 0 ? Lt : !1,
            ...wt(yr)
        })
    }
    ;
    function Bt(yr, Lt) {
        const Gt = (yr.toString().split(".")[1] || "").length
          , Qt = (Lt.toString().split(".")[1] || "").length
          , pr = Gt > Qt ? Gt : Qt
          , dr = parseInt(yr.toFixed(pr).replace(".", ""))
          , Mr = parseInt(Lt.toFixed(pr).replace(".", ""));
        return dr % Mr / Math.pow(10, pr)
    }
    class Rt extends xt {
        constructor() {
            super(...arguments),
            this.min = this.gte,
            this.max = this.lte,
            this.step = this.multipleOf
        }
        _parse(Lt) {
            if (this._def.coerce && (Lt.data = Number(Lt.data)),
            this._getType(Lt) !== mt.ZodParsedType.number) {
                const dr = this._getOrReturnCtx(Lt);
                return (0,
                dt.addIssueToContext)(dr, {
                    code: yt.ZodIssueCode.invalid_type,
                    expected: mt.ZodParsedType.number,
                    received: dr.parsedType
                }),
                dt.INVALID
            }
            let Qt;
            const pr = new dt.ParseStatus;
            for (const dr of this._def.checks)
                dr.kind === "int" ? mt.util.isInteger(Lt.data) || (Qt = this._getOrReturnCtx(Lt, Qt),
                (0,
                dt.addIssueToContext)(Qt, {
                    code: yt.ZodIssueCode.invalid_type,
                    expected: "integer",
                    received: "float",
                    message: dr.message
                }),
                pr.dirty()) : dr.kind === "min" ? (dr.inclusive ? Lt.data < dr.value : Lt.data <= dr.value) && (Qt = this._getOrReturnCtx(Lt, Qt),
                (0,
                dt.addIssueToContext)(Qt, {
                    code: yt.ZodIssueCode.too_small,
                    minimum: dr.value,
                    type: "number",
                    inclusive: dr.inclusive,
                    exact: !1,
                    message: dr.message
                }),
                pr.dirty()) : dr.kind === "max" ? (dr.inclusive ? Lt.data > dr.value : Lt.data >= dr.value) && (Qt = this._getOrReturnCtx(Lt, Qt),
                (0,
                dt.addIssueToContext)(Qt, {
                    code: yt.ZodIssueCode.too_big,
                    maximum: dr.value,
                    type: "number",
                    inclusive: dr.inclusive,
                    exact: !1,
                    message: dr.message
                }),
                pr.dirty()) : dr.kind === "multipleOf" ? Bt(Lt.data, dr.value) !== 0 && (Qt = this._getOrReturnCtx(Lt, Qt),
                (0,
                dt.addIssueToContext)(Qt, {
                    code: yt.ZodIssueCode.not_multiple_of,
                    multipleOf: dr.value,
                    message: dr.message
                }),
                pr.dirty()) : dr.kind === "finite" ? Number.isFinite(Lt.data) || (Qt = this._getOrReturnCtx(Lt, Qt),
                (0,
                dt.addIssueToContext)(Qt, {
                    code: yt.ZodIssueCode.not_finite,
                    message: dr.message
                }),
                pr.dirty()) : mt.util.assertNever(dr);
            return {
                status: pr.value,
                value: Lt.data
            }
        }
        gte(Lt, Gt) {
            return this.setLimit("min", Lt, !0, ee.errorUtil.toString(Gt))
        }
        gt(Lt, Gt) {
            return this.setLimit("min", Lt, !1, ee.errorUtil.toString(Gt))
        }
        lte(Lt, Gt) {
            return this.setLimit("max", Lt, !0, ee.errorUtil.toString(Gt))
        }
        lt(Lt, Gt) {
            return this.setLimit("max", Lt, !1, ee.errorUtil.toString(Gt))
        }
        setLimit(Lt, Gt, Qt, pr) {
            return new Rt({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: Lt,
                    value: Gt,
                    inclusive: Qt,
                    message: ee.errorUtil.toString(pr)
                }]
            })
        }
        _addCheck(Lt) {
            return new Rt({
                ...this._def,
                checks: [...this._def.checks, Lt]
            })
        }
        int(Lt) {
            return this._addCheck({
                kind: "int",
                message: ee.errorUtil.toString(Lt)
            })
        }
        positive(Lt) {
            return this._addCheck({
                kind: "min",
                value: 0,
                inclusive: !1,
                message: ee.errorUtil.toString(Lt)
            })
        }
        negative(Lt) {
            return this._addCheck({
                kind: "max",
                value: 0,
                inclusive: !1,
                message: ee.errorUtil.toString(Lt)
            })
        }
        nonpositive(Lt) {
            return this._addCheck({
                kind: "max",
                value: 0,
                inclusive: !0,
                message: ee.errorUtil.toString(Lt)
            })
        }
        nonnegative(Lt) {
            return this._addCheck({
                kind: "min",
                value: 0,
                inclusive: !0,
                message: ee.errorUtil.toString(Lt)
            })
        }
        multipleOf(Lt, Gt) {
            return this._addCheck({
                kind: "multipleOf",
                value: Lt,
                message: ee.errorUtil.toString(Gt)
            })
        }
        finite(Lt) {
            return this._addCheck({
                kind: "finite",
                message: ee.errorUtil.toString(Lt)
            })
        }
        safe(Lt) {
            return this._addCheck({
                kind: "min",
                inclusive: !0,
                value: Number.MIN_SAFE_INTEGER,
                message: ee.errorUtil.toString(Lt)
            })._addCheck({
                kind: "max",
                inclusive: !0,
                value: Number.MAX_SAFE_INTEGER,
                message: ee.errorUtil.toString(Lt)
            })
        }
        get minValue() {
            let Lt = null;
            for (const Gt of this._def.checks)
                Gt.kind === "min" && (Lt === null || Gt.value > Lt) && (Lt = Gt.value);
            return Lt
        }
        get maxValue() {
            let Lt = null;
            for (const Gt of this._def.checks)
                Gt.kind === "max" && (Lt === null || Gt.value < Lt) && (Lt = Gt.value);
            return Lt
        }
        get isInt() {
            return !!this._def.checks.find(Lt=>Lt.kind === "int" || Lt.kind === "multipleOf" && mt.util.isInteger(Lt.value))
        }
        get isFinite() {
            let Lt = null
              , Gt = null;
            for (const Qt of this._def.checks) {
                if (Qt.kind === "finite" || Qt.kind === "int" || Qt.kind === "multipleOf")
                    return !0;
                Qt.kind === "min" ? (Gt === null || Qt.value > Gt) && (Gt = Qt.value) : Qt.kind === "max" && (Lt === null || Qt.value < Lt) && (Lt = Qt.value)
            }
            return Number.isFinite(Gt) && Number.isFinite(Lt)
        }
    }
    r.ZodNumber = Rt,
    Rt.create = yr=>new Rt({
        checks: [],
        typeName: Ur.ZodNumber,
        coerce: (yr == null ? void 0 : yr.coerce) || !1,
        ...wt(yr)
    });
    class kt extends xt {
        constructor() {
            super(...arguments),
            this.min = this.gte,
            this.max = this.lte
        }
        _parse(Lt) {
            if (this._def.coerce && (Lt.data = BigInt(Lt.data)),
            this._getType(Lt) !== mt.ZodParsedType.bigint) {
                const dr = this._getOrReturnCtx(Lt);
                return (0,
                dt.addIssueToContext)(dr, {
                    code: yt.ZodIssueCode.invalid_type,
                    expected: mt.ZodParsedType.bigint,
                    received: dr.parsedType
                }),
                dt.INVALID
            }
            let Qt;
            const pr = new dt.ParseStatus;
            for (const dr of this._def.checks)
                dr.kind === "min" ? (dr.inclusive ? Lt.data < dr.value : Lt.data <= dr.value) && (Qt = this._getOrReturnCtx(Lt, Qt),
                (0,
                dt.addIssueToContext)(Qt, {
                    code: yt.ZodIssueCode.too_small,
                    type: "bigint",
                    minimum: dr.value,
                    inclusive: dr.inclusive,
                    message: dr.message
                }),
                pr.dirty()) : dr.kind === "max" ? (dr.inclusive ? Lt.data > dr.value : Lt.data >= dr.value) && (Qt = this._getOrReturnCtx(Lt, Qt),
                (0,
                dt.addIssueToContext)(Qt, {
                    code: yt.ZodIssueCode.too_big,
                    type: "bigint",
                    maximum: dr.value,
                    inclusive: dr.inclusive,
                    message: dr.message
                }),
                pr.dirty()) : dr.kind === "multipleOf" ? Lt.data % dr.value !== BigInt(0) && (Qt = this._getOrReturnCtx(Lt, Qt),
                (0,
                dt.addIssueToContext)(Qt, {
                    code: yt.ZodIssueCode.not_multiple_of,
                    multipleOf: dr.value,
                    message: dr.message
                }),
                pr.dirty()) : mt.util.assertNever(dr);
            return {
                status: pr.value,
                value: Lt.data
            }
        }
        gte(Lt, Gt) {
            return this.setLimit("min", Lt, !0, ee.errorUtil.toString(Gt))
        }
        gt(Lt, Gt) {
            return this.setLimit("min", Lt, !1, ee.errorUtil.toString(Gt))
        }
        lte(Lt, Gt) {
            return this.setLimit("max", Lt, !0, ee.errorUtil.toString(Gt))
        }
        lt(Lt, Gt) {
            return this.setLimit("max", Lt, !1, ee.errorUtil.toString(Gt))
        }
        setLimit(Lt, Gt, Qt, pr) {
            return new kt({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: Lt,
                    value: Gt,
                    inclusive: Qt,
                    message: ee.errorUtil.toString(pr)
                }]
            })
        }
        _addCheck(Lt) {
            return new kt({
                ...this._def,
                checks: [...this._def.checks, Lt]
            })
        }
        positive(Lt) {
            return this._addCheck({
                kind: "min",
                value: BigInt(0),
                inclusive: !1,
                message: ee.errorUtil.toString(Lt)
            })
        }
        negative(Lt) {
            return this._addCheck({
                kind: "max",
                value: BigInt(0),
                inclusive: !1,
                message: ee.errorUtil.toString(Lt)
            })
        }
        nonpositive(Lt) {
            return this._addCheck({
                kind: "max",
                value: BigInt(0),
                inclusive: !0,
                message: ee.errorUtil.toString(Lt)
            })
        }
        nonnegative(Lt) {
            return this._addCheck({
                kind: "min",
                value: BigInt(0),
                inclusive: !0,
                message: ee.errorUtil.toString(Lt)
            })
        }
        multipleOf(Lt, Gt) {
            return this._addCheck({
                kind: "multipleOf",
                value: Lt,
                message: ee.errorUtil.toString(Gt)
            })
        }
        get minValue() {
            let Lt = null;
            for (const Gt of this._def.checks)
                Gt.kind === "min" && (Lt === null || Gt.value > Lt) && (Lt = Gt.value);
            return Lt
        }
        get maxValue() {
            let Lt = null;
            for (const Gt of this._def.checks)
                Gt.kind === "max" && (Lt === null || Gt.value < Lt) && (Lt = Gt.value);
            return Lt
        }
    }
    r.ZodBigInt = kt,
    kt.create = yr=>{
        var Lt;
        return new kt({
            checks: [],
            typeName: Ur.ZodBigInt,
            coerce: (Lt = yr == null ? void 0 : yr.coerce) !== null && Lt !== void 0 ? Lt : !1,
            ...wt(yr)
        })
    }
    ;
    class Tt extends xt {
        _parse(Lt) {
            if (this._def.coerce && (Lt.data = !!Lt.data),
            this._getType(Lt) !== mt.ZodParsedType.boolean) {
                const Qt = this._getOrReturnCtx(Lt);
                return (0,
                dt.addIssueToContext)(Qt, {
                    code: yt.ZodIssueCode.invalid_type,
                    expected: mt.ZodParsedType.boolean,
                    received: Qt.parsedType
                }),
                dt.INVALID
            }
            return (0,
            dt.OK)(Lt.data)
        }
    }
    r.ZodBoolean = Tt,
    Tt.create = yr=>new Tt({
        typeName: Ur.ZodBoolean,
        coerce: (yr == null ? void 0 : yr.coerce) || !1,
        ...wt(yr)
    });
    class It extends xt {
        _parse(Lt) {
            if (this._def.coerce && (Lt.data = new Date(Lt.data)),
            this._getType(Lt) !== mt.ZodParsedType.date) {
                const dr = this._getOrReturnCtx(Lt);
                return (0,
                dt.addIssueToContext)(dr, {
                    code: yt.ZodIssueCode.invalid_type,
                    expected: mt.ZodParsedType.date,
                    received: dr.parsedType
                }),
                dt.INVALID
            }
            if (isNaN(Lt.data.getTime())) {
                const dr = this._getOrReturnCtx(Lt);
                return (0,
                dt.addIssueToContext)(dr, {
                    code: yt.ZodIssueCode.invalid_date
                }),
                dt.INVALID
            }
            const Qt = new dt.ParseStatus;
            let pr;
            for (const dr of this._def.checks)
                dr.kind === "min" ? Lt.data.getTime() < dr.value && (pr = this._getOrReturnCtx(Lt, pr),
                (0,
                dt.addIssueToContext)(pr, {
                    code: yt.ZodIssueCode.too_small,
                    message: dr.message,
                    inclusive: !0,
                    exact: !1,
                    minimum: dr.value,
                    type: "date"
                }),
                Qt.dirty()) : dr.kind === "max" ? Lt.data.getTime() > dr.value && (pr = this._getOrReturnCtx(Lt, pr),
                (0,
                dt.addIssueToContext)(pr, {
                    code: yt.ZodIssueCode.too_big,
                    message: dr.message,
                    inclusive: !0,
                    exact: !1,
                    maximum: dr.value,
                    type: "date"
                }),
                Qt.dirty()) : mt.util.assertNever(dr);
            return {
                status: Qt.value,
                value: new Date(Lt.data.getTime())
            }
        }
        _addCheck(Lt) {
            return new It({
                ...this._def,
                checks: [...this._def.checks, Lt]
            })
        }
        min(Lt, Gt) {
            return this._addCheck({
                kind: "min",
                value: Lt.getTime(),
                message: ee.errorUtil.toString(Gt)
            })
        }
        max(Lt, Gt) {
            return this._addCheck({
                kind: "max",
                value: Lt.getTime(),
                message: ee.errorUtil.toString(Gt)
            })
        }
        get minDate() {
            let Lt = null;
            for (const Gt of this._def.checks)
                Gt.kind === "min" && (Lt === null || Gt.value > Lt) && (Lt = Gt.value);
            return Lt != null ? new Date(Lt) : null
        }
        get maxDate() {
            let Lt = null;
            for (const Gt of this._def.checks)
                Gt.kind === "max" && (Lt === null || Gt.value < Lt) && (Lt = Gt.value);
            return Lt != null ? new Date(Lt) : null
        }
    }
    r.ZodDate = It,
    It.create = yr=>new It({
        checks: [],
        coerce: (yr == null ? void 0 : yr.coerce) || !1,
        typeName: Ur.ZodDate,
        ...wt(yr)
    });
    class St extends xt {
        _parse(Lt) {
            if (this._getType(Lt) !== mt.ZodParsedType.symbol) {
                const Qt = this._getOrReturnCtx(Lt);
                return (0,
                dt.addIssueToContext)(Qt, {
                    code: yt.ZodIssueCode.invalid_type,
                    expected: mt.ZodParsedType.symbol,
                    received: Qt.parsedType
                }),
                dt.INVALID
            }
            return (0,
            dt.OK)(Lt.data)
        }
    }
    r.ZodSymbol = St,
    St.create = yr=>new St({
        typeName: Ur.ZodSymbol,
        ...wt(yr)
    });
    class qt extends xt {
        _parse(Lt) {
            if (this._getType(Lt) !== mt.ZodParsedType.undefined) {
                const Qt = this._getOrReturnCtx(Lt);
                return (0,
                dt.addIssueToContext)(Qt, {
                    code: yt.ZodIssueCode.invalid_type,
                    expected: mt.ZodParsedType.undefined,
                    received: Qt.parsedType
                }),
                dt.INVALID
            }
            return (0,
            dt.OK)(Lt.data)
        }
    }
    r.ZodUndefined = qt,
    qt.create = yr=>new qt({
        typeName: Ur.ZodUndefined,
        ...wt(yr)
    });
    class ur extends xt {
        _parse(Lt) {
            if (this._getType(Lt) !== mt.ZodParsedType.null) {
                const Qt = this._getOrReturnCtx(Lt);
                return (0,
                dt.addIssueToContext)(Qt, {
                    code: yt.ZodIssueCode.invalid_type,
                    expected: mt.ZodParsedType.null,
                    received: Qt.parsedType
                }),
                dt.INVALID
            }
            return (0,
            dt.OK)(Lt.data)
        }
    }
    r.ZodNull = ur,
    ur.create = yr=>new ur({
        typeName: Ur.ZodNull,
        ...wt(yr)
    });
    class gr extends xt {
        constructor() {
            super(...arguments),
            this._any = !0
        }
        _parse(Lt) {
            return (0,
            dt.OK)(Lt.data)
        }
    }
    r.ZodAny = gr,
    gr.create = yr=>new gr({
        typeName: Ur.ZodAny,
        ...wt(yr)
    });
    class lr extends xt {
        constructor() {
            super(...arguments),
            this._unknown = !0
        }
        _parse(Lt) {
            return (0,
            dt.OK)(Lt.data)
        }
    }
    r.ZodUnknown = lr,
    lr.create = yr=>new lr({
        typeName: Ur.ZodUnknown,
        ...wt(yr)
    });
    class Zt extends xt {
        _parse(Lt) {
            const Gt = this._getOrReturnCtx(Lt);
            return (0,
            dt.addIssueToContext)(Gt, {
                code: yt.ZodIssueCode.invalid_type,
                expected: mt.ZodParsedType.never,
                received: Gt.parsedType
            }),
            dt.INVALID
        }
    }
    r.ZodNever = Zt,
    Zt.create = yr=>new Zt({
        typeName: Ur.ZodNever,
        ...wt(yr)
    });
    class Vt extends xt {
        _parse(Lt) {
            if (this._getType(Lt) !== mt.ZodParsedType.undefined) {
                const Qt = this._getOrReturnCtx(Lt);
                return (0,
                dt.addIssueToContext)(Qt, {
                    code: yt.ZodIssueCode.invalid_type,
                    expected: mt.ZodParsedType.void,
                    received: Qt.parsedType
                }),
                dt.INVALID
            }
            return (0,
            dt.OK)(Lt.data)
        }
    }
    r.ZodVoid = Vt,
    Vt.create = yr=>new Vt({
        typeName: Ur.ZodVoid,
        ...wt(yr)
    });
    class rr extends xt {
        _parse(Lt) {
            const {ctx: Gt, status: Qt} = this._processInputParams(Lt)
              , pr = this._def;
            if (Gt.parsedType !== mt.ZodParsedType.array)
                return (0,
                dt.addIssueToContext)(Gt, {
                    code: yt.ZodIssueCode.invalid_type,
                    expected: mt.ZodParsedType.array,
                    received: Gt.parsedType
                }),
                dt.INVALID;
            if (pr.exactLength !== null) {
                const Mr = Gt.data.length > pr.exactLength.value
                  , Br = Gt.data.length < pr.exactLength.value;
                (Mr || Br) && ((0,
                dt.addIssueToContext)(Gt, {
                    code: Mr ? yt.ZodIssueCode.too_big : yt.ZodIssueCode.too_small,
                    minimum: Br ? pr.exactLength.value : void 0,
                    maximum: Mr ? pr.exactLength.value : void 0,
                    type: "array",
                    inclusive: !0,
                    exact: !0,
                    message: pr.exactLength.message
                }),
                Qt.dirty())
            }
            if (pr.minLength !== null && Gt.data.length < pr.minLength.value && ((0,
            dt.addIssueToContext)(Gt, {
                code: yt.ZodIssueCode.too_small,
                minimum: pr.minLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: pr.minLength.message
            }),
            Qt.dirty()),
            pr.maxLength !== null && Gt.data.length > pr.maxLength.value && ((0,
            dt.addIssueToContext)(Gt, {
                code: yt.ZodIssueCode.too_big,
                maximum: pr.maxLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: pr.maxLength.message
            }),
            Qt.dirty()),
            Gt.common.async)
                return Promise.all([...Gt.data].map((Mr,Br)=>pr.type._parseAsync(new pt(Gt,Mr,Gt.path,Br)))).then(Mr=>dt.ParseStatus.mergeArray(Qt, Mr));
            const dr = [...Gt.data].map((Mr,Br)=>pr.type._parseSync(new pt(Gt,Mr,Gt.path,Br)));
            return dt.ParseStatus.mergeArray(Qt, dr)
        }
        get element() {
            return this._def.type
        }
        min(Lt, Gt) {
            return new rr({
                ...this._def,
                minLength: {
                    value: Lt,
                    message: ee.errorUtil.toString(Gt)
                }
            })
        }
        max(Lt, Gt) {
            return new rr({
                ...this._def,
                maxLength: {
                    value: Lt,
                    message: ee.errorUtil.toString(Gt)
                }
            })
        }
        length(Lt, Gt) {
            return new rr({
                ...this._def,
                exactLength: {
                    value: Lt,
                    message: ee.errorUtil.toString(Gt)
                }
            })
        }
        nonempty(Lt) {
            return this.min(1, Lt)
        }
    }
    r.ZodArray = rr,
    rr.create = (yr,Lt)=>new rr({
        type: yr,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: Ur.ZodArray,
        ...wt(Lt)
    });
    function fr(yr) {
        if (yr instanceof Yt) {
            const Lt = {};
            for (const Gt in yr.shape) {
                const Qt = yr.shape[Gt];
                Lt[Gt] = Ar.create(fr(Qt))
            }
            return new Yt({
                ...yr._def,
                shape: ()=>Lt
            })
        } else
            return yr instanceof rr ? new rr({
                ...yr._def,
                type: fr(yr.element)
            }) : yr instanceof Ar ? Ar.create(fr(yr.unwrap())) : yr instanceof Ft ? Ft.create(fr(yr.unwrap())) : yr instanceof Dr ? Dr.create(yr.items.map(Lt=>fr(Lt))) : yr
    }
    class Yt extends xt {
        constructor() {
            super(...arguments),
            this._cached = null,
            this.nonstrict = this.passthrough,
            this.augment = this.extend
        }
        _getCached() {
            if (this._cached !== null)
                return this._cached;
            const Lt = this._def.shape()
              , Gt = mt.util.objectKeys(Lt);
            return this._cached = {
                shape: Lt,
                keys: Gt
            }
        }
        _parse(Lt) {
            if (this._getType(Lt) !== mt.ZodParsedType.object) {
                const Kr = this._getOrReturnCtx(Lt);
                return (0,
                dt.addIssueToContext)(Kr, {
                    code: yt.ZodIssueCode.invalid_type,
                    expected: mt.ZodParsedType.object,
                    received: Kr.parsedType
                }),
                dt.INVALID
            }
            const {status: Qt, ctx: pr} = this._processInputParams(Lt)
              , {shape: dr, keys: Mr} = this._getCached()
              , Br = [];
            if (!(this._def.catchall instanceof Zt && this._def.unknownKeys === "strip"))
                for (const Kr in pr.data)
                    Mr.includes(Kr) || Br.push(Kr);
            const Fr = [];
            for (const Kr of Mr) {
                const Xr = dr[Kr]
                  , Cn = pr.data[Kr];
                Fr.push({
                    key: {
                        status: "valid",
                        value: Kr
                    },
                    value: Xr._parse(new pt(pr,Cn,pr.path,Kr)),
                    alwaysSet: Kr in pr.data
                })
            }
            if (this._def.catchall instanceof Zt) {
                const Kr = this._def.unknownKeys;
                if (Kr === "passthrough")
                    for (const Xr of Br)
                        Fr.push({
                            key: {
                                status: "valid",
                                value: Xr
                            },
                            value: {
                                status: "valid",
                                value: pr.data[Xr]
                            }
                        });
                else if (Kr === "strict")
                    Br.length > 0 && ((0,
                    dt.addIssueToContext)(pr, {
                        code: yt.ZodIssueCode.unrecognized_keys,
                        keys: Br
                    }),
                    Qt.dirty());
                else if (Kr !== "strip")
                    throw new Error("Internal ZodObject error: invalid unknownKeys value.")
            } else {
                const Kr = this._def.catchall;
                for (const Xr of Br) {
                    const Cn = pr.data[Xr];
                    Fr.push({
                        key: {
                            status: "valid",
                            value: Xr
                        },
                        value: Kr._parse(new pt(pr,Cn,pr.path,Xr)),
                        alwaysSet: Xr in pr.data
                    })
                }
            }
            return pr.common.async ? Promise.resolve().then(async()=>{
                const Kr = [];
                for (const Xr of Fr) {
                    const Cn = await Xr.key
                      , Er = await Xr.value;
                    Kr.push({
                        key: Cn,
                        value: Er,
                        alwaysSet: Xr.alwaysSet
                    })
                }
                return Kr
            }
            ).then(Kr=>dt.ParseStatus.mergeObjectSync(Qt, Kr)) : dt.ParseStatus.mergeObjectSync(Qt, Fr)
        }
        get shape() {
            return this._def.shape()
        }
        strict(Lt) {
            return ee.errorUtil.errToObj,
            new Yt({
                ...this._def,
                unknownKeys: "strict",
                ...Lt !== void 0 ? {
                    errorMap: (Gt,Qt)=>{
                        var pr, dr, Mr, Br;
                        const Fr = (Mr = (dr = (pr = this._def).errorMap) === null || dr === void 0 ? void 0 : dr.call(pr, Gt, Qt).message) !== null && Mr !== void 0 ? Mr : Qt.defaultError;
                        return Gt.code === "unrecognized_keys" ? {
                            message: (Br = ee.errorUtil.errToObj(Lt).message) !== null && Br !== void 0 ? Br : Fr
                        } : {
                            message: Fr
                        }
                    }
                } : {}
            })
        }
        strip() {
            return new Yt({
                ...this._def,
                unknownKeys: "strip"
            })
        }
        passthrough() {
            return new Yt({
                ...this._def,
                unknownKeys: "passthrough"
            })
        }
        extend(Lt) {
            return new Yt({
                ...this._def,
                shape: ()=>({
                    ...this._def.shape(),
                    ...Lt
                })
            })
        }
        merge(Lt) {
            return new Yt({
                unknownKeys: Lt._def.unknownKeys,
                catchall: Lt._def.catchall,
                shape: ()=>({
                    ...this._def.shape(),
                    ...Lt._def.shape()
                }),
                typeName: Ur.ZodObject
            })
        }
        setKey(Lt, Gt) {
            return this.augment({
                [Lt]: Gt
            })
        }
        catchall(Lt) {
            return new Yt({
                ...this._def,
                catchall: Lt
            })
        }
        pick(Lt) {
            const Gt = {};
            return mt.util.objectKeys(Lt).forEach(Qt=>{
                Lt[Qt] && this.shape[Qt] && (Gt[Qt] = this.shape[Qt])
            }
            ),
            new Yt({
                ...this._def,
                shape: ()=>Gt
            })
        }
        omit(Lt) {
            const Gt = {};
            return mt.util.objectKeys(this.shape).forEach(Qt=>{
                Lt[Qt] || (Gt[Qt] = this.shape[Qt])
            }
            ),
            new Yt({
                ...this._def,
                shape: ()=>Gt
            })
        }
        deepPartial() {
            return fr(this)
        }
        partial(Lt) {
            const Gt = {};
            return mt.util.objectKeys(this.shape).forEach(Qt=>{
                const pr = this.shape[Qt];
                Lt && !Lt[Qt] ? Gt[Qt] = pr : Gt[Qt] = pr.optional()
            }
            ),
            new Yt({
                ...this._def,
                shape: ()=>Gt
            })
        }
        required(Lt) {
            const Gt = {};
            return mt.util.objectKeys(this.shape).forEach(Qt=>{
                if (Lt && !Lt[Qt])
                    Gt[Qt] = this.shape[Qt];
                else {
                    let dr = this.shape[Qt];
                    for (; dr instanceof Ar; )
                        dr = dr._def.innerType;
                    Gt[Qt] = dr
                }
            }
            ),
            new Yt({
                ...this._def,
                shape: ()=>Gt
            })
        }
        keyof() {
            return Gr(mt.util.objectKeys(this.shape))
        }
    }
    r.ZodObject = Yt,
    Yt.create = (yr,Lt)=>new Yt({
        shape: ()=>yr,
        unknownKeys: "strip",
        catchall: Zt.create(),
        typeName: Ur.ZodObject,
        ...wt(Lt)
    }),
    Yt.strictCreate = (yr,Lt)=>new Yt({
        shape: ()=>yr,
        unknownKeys: "strict",
        catchall: Zt.create(),
        typeName: Ur.ZodObject,
        ...wt(Lt)
    }),
    Yt.lazycreate = (yr,Lt)=>new Yt({
        shape: yr,
        unknownKeys: "strip",
        catchall: Zt.create(),
        typeName: Ur.ZodObject,
        ...wt(Lt)
    });
    class Xt extends xt {
        _parse(Lt) {
            const {ctx: Gt} = this._processInputParams(Lt)
              , Qt = this._def.options;
            function pr(dr) {
                for (const Br of dr)
                    if (Br.result.status === "valid")
                        return Br.result;
                for (const Br of dr)
                    if (Br.result.status === "dirty")
                        return Gt.common.issues.push(...Br.ctx.common.issues),
                        Br.result;
                const Mr = dr.map(Br=>new yt.ZodError(Br.ctx.common.issues));
                return (0,
                dt.addIssueToContext)(Gt, {
                    code: yt.ZodIssueCode.invalid_union,
                    unionErrors: Mr
                }),
                dt.INVALID
            }
            if (Gt.common.async)
                return Promise.all(Qt.map(async dr=>{
                    const Mr = {
                        ...Gt,
                        common: {
                            ...Gt.common,
                            issues: []
                        },
                        parent: null
                    };
                    return {
                        result: await dr._parseAsync({
                            data: Gt.data,
                            path: Gt.path,
                            parent: Mr
                        }),
                        ctx: Mr
                    }
                }
                )).then(pr);
            {
                let dr;
                const Mr = [];
                for (const Fr of Qt) {
                    const Kr = {
                        ...Gt,
                        common: {
                            ...Gt.common,
                            issues: []
                        },
                        parent: null
                    }
                      , Xr = Fr._parseSync({
                        data: Gt.data,
                        path: Gt.path,
                        parent: Kr
                    });
                    if (Xr.status === "valid")
                        return Xr;
                    Xr.status === "dirty" && !dr && (dr = {
                        result: Xr,
                        ctx: Kr
                    }),
                    Kr.common.issues.length && Mr.push(Kr.common.issues)
                }
                if (dr)
                    return Gt.common.issues.push(...dr.ctx.common.issues),
                    dr.result;
                const Br = Mr.map(Fr=>new yt.ZodError(Fr));
                return (0,
                dt.addIssueToContext)(Gt, {
                    code: yt.ZodIssueCode.invalid_union,
                    unionErrors: Br
                }),
                dt.INVALID
            }
        }
        get options() {
            return this._def.options
        }
    }
    r.ZodUnion = Xt,
    Xt.create = (yr,Lt)=>new Xt({
        options: yr,
        typeName: Ur.ZodUnion,
        ...wt(Lt)
    });
    const Sr = yr=>yr instanceof un ? Sr(yr.schema) : yr instanceof _r ? Sr(yr.innerType()) : yr instanceof Qr ? [yr.value] : yr instanceof vr ? yr.options : yr instanceof ar ? mt.util.objectValues(yr.enum) : yr instanceof Ut ? Sr(yr._def.innerType) : yr instanceof qt ? [void 0] : yr instanceof ur ? [null] : yr instanceof Ar ? [void 0, ...Sr(yr.unwrap())] : yr instanceof Ft ? [null, ...Sr(yr.unwrap())] : yr instanceof br || yr instanceof xr ? Sr(yr.unwrap()) : yr instanceof Dt ? Sr(yr._def.innerType) : [];
    class Rr extends xt {
        _parse(Lt) {
            const {ctx: Gt} = this._processInputParams(Lt);
            if (Gt.parsedType !== mt.ZodParsedType.object)
                return (0,
                dt.addIssueToContext)(Gt, {
                    code: yt.ZodIssueCode.invalid_type,
                    expected: mt.ZodParsedType.object,
                    received: Gt.parsedType
                }),
                dt.INVALID;
            const Qt = this.discriminator
              , pr = Gt.data[Qt]
              , dr = this.optionsMap.get(pr);
            return dr ? Gt.common.async ? dr._parseAsync({
                data: Gt.data,
                path: Gt.path,
                parent: Gt
            }) : dr._parseSync({
                data: Gt.data,
                path: Gt.path,
                parent: Gt
            }) : ((0,
            dt.addIssueToContext)(Gt, {
                code: yt.ZodIssueCode.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [Qt]
            }),
            dt.INVALID)
        }
        get discriminator() {
            return this._def.discriminator
        }
        get options() {
            return this._def.options
        }
        get optionsMap() {
            return this._def.optionsMap
        }
        static create(Lt, Gt, Qt) {
            const pr = new Map;
            for (const dr of Gt) {
                const Mr = Sr(dr.shape[Lt]);
                if (!Mr.length)
                    throw new Error(`A discriminator value for key \`${Lt}\` could not be extracted from all schema options`);
                for (const Br of Mr) {
                    if (pr.has(Br))
                        throw new Error(`Discriminator property ${String(Lt)} has duplicate value ${String(Br)}`);
                    pr.set(Br, dr)
                }
            }
            return new Rr({
                typeName: Ur.ZodDiscriminatedUnion,
                discriminator: Lt,
                options: Gt,
                optionsMap: pr,
                ...wt(Qt)
            })
        }
    }
    r.ZodDiscriminatedUnion = Rr;
    function qr(yr, Lt) {
        const Gt = (0,
        mt.getParsedType)(yr)
          , Qt = (0,
        mt.getParsedType)(Lt);
        if (yr === Lt)
            return {
                valid: !0,
                data: yr
            };
        if (Gt === mt.ZodParsedType.object && Qt === mt.ZodParsedType.object) {
            const pr = mt.util.objectKeys(Lt)
              , dr = mt.util.objectKeys(yr).filter(Br=>pr.indexOf(Br) !== -1)
              , Mr = {
                ...yr,
                ...Lt
            };
            for (const Br of dr) {
                const Fr = qr(yr[Br], Lt[Br]);
                if (!Fr.valid)
                    return {
                        valid: !1
                    };
                Mr[Br] = Fr.data
            }
            return {
                valid: !0,
                data: Mr
            }
        } else if (Gt === mt.ZodParsedType.array && Qt === mt.ZodParsedType.array) {
            if (yr.length !== Lt.length)
                return {
                    valid: !1
                };
            const pr = [];
            for (let dr = 0; dr < yr.length; dr++) {
                const Mr = yr[dr]
                  , Br = Lt[dr]
                  , Fr = qr(Mr, Br);
                if (!Fr.valid)
                    return {
                        valid: !1
                    };
                pr.push(Fr.data)
            }
            return {
                valid: !0,
                data: pr
            }
        } else
            return Gt === mt.ZodParsedType.date && Qt === mt.ZodParsedType.date && +yr == +Lt ? {
                valid: !0,
                data: yr
            } : {
                valid: !1
            }
    }
    class Nr extends xt {
        _parse(Lt) {
            const {status: Gt, ctx: Qt} = this._processInputParams(Lt)
              , pr = (dr,Mr)=>{
                if ((0,
                dt.isAborted)(dr) || (0,
                dt.isAborted)(Mr))
                    return dt.INVALID;
                const Br = qr(dr.value, Mr.value);
                return Br.valid ? (((0,
                dt.isDirty)(dr) || (0,
                dt.isDirty)(Mr)) && Gt.dirty(),
                {
                    status: Gt.value,
                    value: Br.data
                }) : ((0,
                dt.addIssueToContext)(Qt, {
                    code: yt.ZodIssueCode.invalid_intersection_types
                }),
                dt.INVALID)
            }
            ;
            return Qt.common.async ? Promise.all([this._def.left._parseAsync({
                data: Qt.data,
                path: Qt.path,
                parent: Qt
            }), this._def.right._parseAsync({
                data: Qt.data,
                path: Qt.path,
                parent: Qt
            })]).then(([dr,Mr])=>pr(dr, Mr)) : pr(this._def.left._parseSync({
                data: Qt.data,
                path: Qt.path,
                parent: Qt
            }), this._def.right._parseSync({
                data: Qt.data,
                path: Qt.path,
                parent: Qt
            }))
        }
    }
    r.ZodIntersection = Nr,
    Nr.create = (yr,Lt,Gt)=>new Nr({
        left: yr,
        right: Lt,
        typeName: Ur.ZodIntersection,
        ...wt(Gt)
    });
    class Dr extends xt {
        _parse(Lt) {
            const {status: Gt, ctx: Qt} = this._processInputParams(Lt);
            if (Qt.parsedType !== mt.ZodParsedType.array)
                return (0,
                dt.addIssueToContext)(Qt, {
                    code: yt.ZodIssueCode.invalid_type,
                    expected: mt.ZodParsedType.array,
                    received: Qt.parsedType
                }),
                dt.INVALID;
            if (Qt.data.length < this._def.items.length)
                return (0,
                dt.addIssueToContext)(Qt, {
                    code: yt.ZodIssueCode.too_small,
                    minimum: this._def.items.length,
                    inclusive: !0,
                    exact: !1,
                    type: "array"
                }),
                dt.INVALID;
            !this._def.rest && Qt.data.length > this._def.items.length && ((0,
            dt.addIssueToContext)(Qt, {
                code: yt.ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: "array"
            }),
            Gt.dirty());
            const dr = [...Qt.data].map((Mr,Br)=>{
                const Fr = this._def.items[Br] || this._def.rest;
                return Fr ? Fr._parse(new pt(Qt,Mr,Qt.path,Br)) : null
            }
            ).filter(Mr=>!!Mr);
            return Qt.common.async ? Promise.all(dr).then(Mr=>dt.ParseStatus.mergeArray(Gt, Mr)) : dt.ParseStatus.mergeArray(Gt, dr)
        }
        get items() {
            return this._def.items
        }
        rest(Lt) {
            return new Dr({
                ...this._def,
                rest: Lt
            })
        }
    }
    r.ZodTuple = Dr,
    Dr.create = (yr,Lt)=>{
        if (!Array.isArray(yr))
            throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
        return new Dr({
            items: yr,
            typeName: Ur.ZodTuple,
            rest: null,
            ...wt(Lt)
        })
    }
    ;
    class Or extends xt {
        get keySchema() {
            return this._def.keyType
        }
        get valueSchema() {
            return this._def.valueType
        }
        _parse(Lt) {
            const {status: Gt, ctx: Qt} = this._processInputParams(Lt);
            if (Qt.parsedType !== mt.ZodParsedType.object)
                return (0,
                dt.addIssueToContext)(Qt, {
                    code: yt.ZodIssueCode.invalid_type,
                    expected: mt.ZodParsedType.object,
                    received: Qt.parsedType
                }),
                dt.INVALID;
            const pr = []
              , dr = this._def.keyType
              , Mr = this._def.valueType;
            for (const Br in Qt.data)
                pr.push({
                    key: dr._parse(new pt(Qt,Br,Qt.path,Br)),
                    value: Mr._parse(new pt(Qt,Qt.data[Br],Qt.path,Br)),
                    alwaysSet: Br in Qt.data
                });
            return Qt.common.async ? dt.ParseStatus.mergeObjectAsync(Gt, pr) : dt.ParseStatus.mergeObjectSync(Gt, pr)
        }
        get element() {
            return this._def.valueType
        }
        static create(Lt, Gt, Qt) {
            return Gt instanceof xt ? new Or({
                keyType: Lt,
                valueType: Gt,
                typeName: Ur.ZodRecord,
                ...wt(Qt)
            }) : new Or({
                keyType: Et.create(),
                valueType: Lt,
                typeName: Ur.ZodRecord,
                ...wt(Gt)
            })
        }
    }
    r.ZodRecord = Or;
    class $r extends xt {
        get keySchema() {
            return this._def.keyType
        }
        get valueSchema() {
            return this._def.valueType
        }
        _parse(Lt) {
            const {status: Gt, ctx: Qt} = this._processInputParams(Lt);
            if (Qt.parsedType !== mt.ZodParsedType.map)
                return (0,
                dt.addIssueToContext)(Qt, {
                    code: yt.ZodIssueCode.invalid_type,
                    expected: mt.ZodParsedType.map,
                    received: Qt.parsedType
                }),
                dt.INVALID;
            const pr = this._def.keyType
              , dr = this._def.valueType
              , Mr = [...Qt.data.entries()].map(([Br,Fr],Kr)=>({
                key: pr._parse(new pt(Qt,Br,Qt.path,[Kr, "key"])),
                value: dr._parse(new pt(Qt,Fr,Qt.path,[Kr, "value"]))
            }));
            if (Qt.common.async) {
                const Br = new Map;
                return Promise.resolve().then(async()=>{
                    for (const Fr of Mr) {
                        const Kr = await Fr.key
                          , Xr = await Fr.value;
                        if (Kr.status === "aborted" || Xr.status === "aborted")
                            return dt.INVALID;
                        (Kr.status === "dirty" || Xr.status === "dirty") && Gt.dirty(),
                        Br.set(Kr.value, Xr.value)
                    }
                    return {
                        status: Gt.value,
                        value: Br
                    }
                }
                )
            } else {
                const Br = new Map;
                for (const Fr of Mr) {
                    const Kr = Fr.key
                      , Xr = Fr.value;
                    if (Kr.status === "aborted" || Xr.status === "aborted")
                        return dt.INVALID;
                    (Kr.status === "dirty" || Xr.status === "dirty") && Gt.dirty(),
                    Br.set(Kr.value, Xr.value)
                }
                return {
                    status: Gt.value,
                    value: Br
                }
            }
        }
    }
    r.ZodMap = $r,
    $r.create = (yr,Lt,Gt)=>new $r({
        valueType: Lt,
        keyType: yr,
        typeName: Ur.ZodMap,
        ...wt(Gt)
    });
    class Zr extends xt {
        _parse(Lt) {
            const {status: Gt, ctx: Qt} = this._processInputParams(Lt);
            if (Qt.parsedType !== mt.ZodParsedType.set)
                return (0,
                dt.addIssueToContext)(Qt, {
                    code: yt.ZodIssueCode.invalid_type,
                    expected: mt.ZodParsedType.set,
                    received: Qt.parsedType
                }),
                dt.INVALID;
            const pr = this._def;
            pr.minSize !== null && Qt.data.size < pr.minSize.value && ((0,
            dt.addIssueToContext)(Qt, {
                code: yt.ZodIssueCode.too_small,
                minimum: pr.minSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: pr.minSize.message
            }),
            Gt.dirty()),
            pr.maxSize !== null && Qt.data.size > pr.maxSize.value && ((0,
            dt.addIssueToContext)(Qt, {
                code: yt.ZodIssueCode.too_big,
                maximum: pr.maxSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: pr.maxSize.message
            }),
            Gt.dirty());
            const dr = this._def.valueType;
            function Mr(Fr) {
                const Kr = new Set;
                for (const Xr of Fr) {
                    if (Xr.status === "aborted")
                        return dt.INVALID;
                    Xr.status === "dirty" && Gt.dirty(),
                    Kr.add(Xr.value)
                }
                return {
                    status: Gt.value,
                    value: Kr
                }
            }
            const Br = [...Qt.data.values()].map((Fr,Kr)=>dr._parse(new pt(Qt,Fr,Qt.path,Kr)));
            return Qt.common.async ? Promise.all(Br).then(Fr=>Mr(Fr)) : Mr(Br)
        }
        min(Lt, Gt) {
            return new Zr({
                ...this._def,
                minSize: {
                    value: Lt,
                    message: ee.errorUtil.toString(Gt)
                }
            })
        }
        max(Lt, Gt) {
            return new Zr({
                ...this._def,
                maxSize: {
                    value: Lt,
                    message: ee.errorUtil.toString(Gt)
                }
            })
        }
        size(Lt, Gt) {
            return this.min(Lt, Gt).max(Lt, Gt)
        }
        nonempty(Lt) {
            return this.min(1, Lt)
        }
    }
    r.ZodSet = Zr,
    Zr.create = (yr,Lt)=>new Zr({
        valueType: yr,
        minSize: null,
        maxSize: null,
        typeName: Ur.ZodSet,
        ...wt(Lt)
    });
    class Hr extends xt {
        constructor() {
            super(...arguments),
            this.validate = this.implement
        }
        _parse(Lt) {
            const {ctx: Gt} = this._processInputParams(Lt);
            if (Gt.parsedType !== mt.ZodParsedType.function)
                return (0,
                dt.addIssueToContext)(Gt, {
                    code: yt.ZodIssueCode.invalid_type,
                    expected: mt.ZodParsedType.function,
                    received: Gt.parsedType
                }),
                dt.INVALID;
            function Qt(Br, Fr) {
                return (0,
                dt.makeIssue)({
                    data: Br,
                    path: Gt.path,
                    errorMaps: [Gt.common.contextualErrorMap, Gt.schemaErrorMap, (0,
                    y.getErrorMap)(), y.defaultErrorMap].filter(Kr=>!!Kr),
                    issueData: {
                        code: yt.ZodIssueCode.invalid_arguments,
                        argumentsError: Fr
                    }
                })
            }
            function pr(Br, Fr) {
                return (0,
                dt.makeIssue)({
                    data: Br,
                    path: Gt.path,
                    errorMaps: [Gt.common.contextualErrorMap, Gt.schemaErrorMap, (0,
                    y.getErrorMap)(), y.defaultErrorMap].filter(Kr=>!!Kr),
                    issueData: {
                        code: yt.ZodIssueCode.invalid_return_type,
                        returnTypeError: Fr
                    }
                })
            }
            const dr = {
                errorMap: Gt.common.contextualErrorMap
            }
              , Mr = Gt.data;
            if (this._def.returns instanceof hr) {
                const Br = this;
                return (0,
                dt.OK)(async function(...Fr) {
                    const Kr = new yt.ZodError([])
                      , Xr = await Br._def.args.parseAsync(Fr, dr).catch(kn=>{
                        throw Kr.addIssue(Qt(Fr, kn)),
                        Kr
                    }
                    )
                      , Cn = await Reflect.apply(Mr, this, Xr);
                    return await Br._def.returns._def.type.parseAsync(Cn, dr).catch(kn=>{
                        throw Kr.addIssue(pr(Cn, kn)),
                        Kr
                    }
                    )
                })
            } else {
                const Br = this;
                return (0,
                dt.OK)(function(...Fr) {
                    const Kr = Br._def.args.safeParse(Fr, dr);
                    if (!Kr.success)
                        throw new yt.ZodError([Qt(Fr, Kr.error)]);
                    const Xr = Reflect.apply(Mr, this, Kr.data)
                      , Cn = Br._def.returns.safeParse(Xr, dr);
                    if (!Cn.success)
                        throw new yt.ZodError([pr(Xr, Cn.error)]);
                    return Cn.data
                })
            }
        }
        parameters() {
            return this._def.args
        }
        returnType() {
            return this._def.returns
        }
        args(...Lt) {
            return new Hr({
                ...this._def,
                args: Dr.create(Lt).rest(lr.create())
            })
        }
        returns(Lt) {
            return new Hr({
                ...this._def,
                returns: Lt
            })
        }
        implement(Lt) {
            return this.parse(Lt)
        }
        strictImplement(Lt) {
            return this.parse(Lt)
        }
        static create(Lt, Gt, Qt) {
            return new Hr({
                args: Lt || Dr.create([]).rest(lr.create()),
                returns: Gt || lr.create(),
                typeName: Ur.ZodFunction,
                ...wt(Qt)
            })
        }
    }
    r.ZodFunction = Hr;
    class un extends xt {
        get schema() {
            return this._def.getter()
        }
        _parse(Lt) {
            const {ctx: Gt} = this._processInputParams(Lt);
            return this._def.getter()._parse({
                data: Gt.data,
                path: Gt.path,
                parent: Gt
            })
        }
    }
    r.ZodLazy = un,
    un.create = (yr,Lt)=>new un({
        getter: yr,
        typeName: Ur.ZodLazy,
        ...wt(Lt)
    });
    class Qr extends xt {
        _parse(Lt) {
            if (Lt.data !== this._def.value) {
                const Gt = this._getOrReturnCtx(Lt);
                return (0,
                dt.addIssueToContext)(Gt, {
                    received: Gt.data,
                    code: yt.ZodIssueCode.invalid_literal,
                    expected: this._def.value
                }),
                dt.INVALID
            }
            return {
                status: "valid",
                value: Lt.data
            }
        }
        get value() {
            return this._def.value
        }
    }
    r.ZodLiteral = Qr,
    Qr.create = (yr,Lt)=>new Qr({
        value: yr,
        typeName: Ur.ZodLiteral,
        ...wt(Lt)
    });
    function Gr(yr, Lt) {
        return new vr({
            values: yr,
            typeName: Ur.ZodEnum,
            ...wt(Lt)
        })
    }
    class vr extends xt {
        constructor() {
            super(...arguments),
            m.set(this, void 0)
        }
        _parse(Lt) {
            if (typeof Lt.data != "string") {
                const Gt = this._getOrReturnCtx(Lt)
                  , Qt = this._def.values;
                return (0,
                dt.addIssueToContext)(Gt, {
                    expected: mt.util.joinValues(Qt),
                    received: Gt.parsedType,
                    code: yt.ZodIssueCode.invalid_type
                }),
                dt.INVALID
            }
            if (d(this, m, "f") || f(this, m, new Set(this._def.values), "f"),
            !d(this, m, "f").has(Lt.data)) {
                const Gt = this._getOrReturnCtx(Lt)
                  , Qt = this._def.values;
                return (0,
                dt.addIssueToContext)(Gt, {
                    received: Gt.data,
                    code: yt.ZodIssueCode.invalid_enum_value,
                    options: Qt
                }),
                dt.INVALID
            }
            return (0,
            dt.OK)(Lt.data)
        }
        get options() {
            return this._def.values
        }
        get enum() {
            const Lt = {};
            for (const Gt of this._def.values)
                Lt[Gt] = Gt;
            return Lt
        }
        get Values() {
            const Lt = {};
            for (const Gt of this._def.values)
                Lt[Gt] = Gt;
            return Lt
        }
        get Enum() {
            const Lt = {};
            for (const Gt of this._def.values)
                Lt[Gt] = Gt;
            return Lt
        }
        extract(Lt, Gt=this._def) {
            return vr.create(Lt, {
                ...this._def,
                ...Gt
            })
        }
        exclude(Lt, Gt=this._def) {
            return vr.create(this.options.filter(Qt=>!Lt.includes(Qt)), {
                ...this._def,
                ...Gt
            })
        }
    }
    r.ZodEnum = vr,
    m = new WeakMap,
    vr.create = Gr;
    class ar extends xt {
        constructor() {
            super(...arguments),
            k.set(this, void 0)
        }
        _parse(Lt) {
            const Gt = mt.util.getValidEnumValues(this._def.values)
              , Qt = this._getOrReturnCtx(Lt);
            if (Qt.parsedType !== mt.ZodParsedType.string && Qt.parsedType !== mt.ZodParsedType.number) {
                const pr = mt.util.objectValues(Gt);
                return (0,
                dt.addIssueToContext)(Qt, {
                    expected: mt.util.joinValues(pr),
                    received: Qt.parsedType,
                    code: yt.ZodIssueCode.invalid_type
                }),
                dt.INVALID
            }
            if (d(this, k, "f") || f(this, k, new Set(mt.util.getValidEnumValues(this._def.values)), "f"),
            !d(this, k, "f").has(Lt.data)) {
                const pr = mt.util.objectValues(Gt);
                return (0,
                dt.addIssueToContext)(Qt, {
                    received: Qt.data,
                    code: yt.ZodIssueCode.invalid_enum_value,
                    options: pr
                }),
                dt.INVALID
            }
            return (0,
            dt.OK)(Lt.data)
        }
        get enum() {
            return this._def.values
        }
    }
    r.ZodNativeEnum = ar,
    k = new WeakMap,
    ar.create = (yr,Lt)=>new ar({
        values: yr,
        typeName: Ur.ZodNativeEnum,
        ...wt(Lt)
    });
    class hr extends xt {
        unwrap() {
            return this._def.type
        }
        _parse(Lt) {
            const {ctx: Gt} = this._processInputParams(Lt);
            if (Gt.parsedType !== mt.ZodParsedType.promise && Gt.common.async === !1)
                return (0,
                dt.addIssueToContext)(Gt, {
                    code: yt.ZodIssueCode.invalid_type,
                    expected: mt.ZodParsedType.promise,
                    received: Gt.parsedType
                }),
                dt.INVALID;
            const Qt = Gt.parsedType === mt.ZodParsedType.promise ? Gt.data : Promise.resolve(Gt.data);
            return (0,
            dt.OK)(Qt.then(pr=>this._def.type.parseAsync(pr, {
                path: Gt.path,
                errorMap: Gt.common.contextualErrorMap
            })))
        }
    }
    r.ZodPromise = hr,
    hr.create = (yr,Lt)=>new hr({
        type: yr,
        typeName: Ur.ZodPromise,
        ...wt(Lt)
    });
    class _r extends xt {
        innerType() {
            return this._def.schema
        }
        sourceType() {
            return this._def.schema._def.typeName === Ur.ZodEffects ? this._def.schema.sourceType() : this._def.schema
        }
        _parse(Lt) {
            const {status: Gt, ctx: Qt} = this._processInputParams(Lt)
              , pr = this._def.effect || null
              , dr = {
                addIssue: Mr=>{
                    (0,
                    dt.addIssueToContext)(Qt, Mr),
                    Mr.fatal ? Gt.abort() : Gt.dirty()
                }
                ,
                get path() {
                    return Qt.path
                }
            };
            if (dr.addIssue = dr.addIssue.bind(dr),
            pr.type === "preprocess") {
                const Mr = pr.transform(Qt.data, dr);
                if (Qt.common.async)
                    return Promise.resolve(Mr).then(async Br=>{
                        if (Gt.value === "aborted")
                            return dt.INVALID;
                        const Fr = await this._def.schema._parseAsync({
                            data: Br,
                            path: Qt.path,
                            parent: Qt
                        });
                        return Fr.status === "aborted" ? dt.INVALID : Fr.status === "dirty" || Gt.value === "dirty" ? (0,
                        dt.DIRTY)(Fr.value) : Fr
                    }
                    );
                {
                    if (Gt.value === "aborted")
                        return dt.INVALID;
                    const Br = this._def.schema._parseSync({
                        data: Mr,
                        path: Qt.path,
                        parent: Qt
                    });
                    return Br.status === "aborted" ? dt.INVALID : Br.status === "dirty" || Gt.value === "dirty" ? (0,
                    dt.DIRTY)(Br.value) : Br
                }
            }
            if (pr.type === "refinement") {
                const Mr = Br=>{
                    const Fr = pr.refinement(Br, dr);
                    if (Qt.common.async)
                        return Promise.resolve(Fr);
                    if (Fr instanceof Promise)
                        throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                    return Br
                }
                ;
                if (Qt.common.async === !1) {
                    const Br = this._def.schema._parseSync({
                        data: Qt.data,
                        path: Qt.path,
                        parent: Qt
                    });
                    return Br.status === "aborted" ? dt.INVALID : (Br.status === "dirty" && Gt.dirty(),
                    Mr(Br.value),
                    {
                        status: Gt.value,
                        value: Br.value
                    })
                } else
                    return this._def.schema._parseAsync({
                        data: Qt.data,
                        path: Qt.path,
                        parent: Qt
                    }).then(Br=>Br.status === "aborted" ? dt.INVALID : (Br.status === "dirty" && Gt.dirty(),
                    Mr(Br.value).then(()=>({
                        status: Gt.value,
                        value: Br.value
                    }))))
            }
            if (pr.type === "transform")
                if (Qt.common.async === !1) {
                    const Mr = this._def.schema._parseSync({
                        data: Qt.data,
                        path: Qt.path,
                        parent: Qt
                    });
                    if (!(0,
                    dt.isValid)(Mr))
                        return Mr;
                    const Br = pr.transform(Mr.value, dr);
                    if (Br instanceof Promise)
                        throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                    return {
                        status: Gt.value,
                        value: Br
                    }
                } else
                    return this._def.schema._parseAsync({
                        data: Qt.data,
                        path: Qt.path,
                        parent: Qt
                    }).then(Mr=>(0,
                    dt.isValid)(Mr) ? Promise.resolve(pr.transform(Mr.value, dr)).then(Br=>({
                        status: Gt.value,
                        value: Br
                    })) : Mr);
            mt.util.assertNever(pr)
        }
    }
    r.ZodEffects = _r,
    r.ZodTransformer = _r,
    _r.create = (yr,Lt,Gt)=>new _r({
        schema: yr,
        typeName: Ur.ZodEffects,
        effect: Lt,
        ...wt(Gt)
    }),
    _r.createWithPreprocess = (yr,Lt,Gt)=>new _r({
        schema: Lt,
        effect: {
            type: "preprocess",
            transform: yr
        },
        typeName: Ur.ZodEffects,
        ...wt(Gt)
    });
    class Ar extends xt {
        _parse(Lt) {
            return this._getType(Lt) === mt.ZodParsedType.undefined ? (0,
            dt.OK)(void 0) : this._def.innerType._parse(Lt)
        }
        unwrap() {
            return this._def.innerType
        }
    }
    r.ZodOptional = Ar,
    Ar.create = (yr,Lt)=>new Ar({
        innerType: yr,
        typeName: Ur.ZodOptional,
        ...wt(Lt)
    });
    class Ft extends xt {
        _parse(Lt) {
            return this._getType(Lt) === mt.ZodParsedType.null ? (0,
            dt.OK)(null) : this._def.innerType._parse(Lt)
        }
        unwrap() {
            return this._def.innerType
        }
    }
    r.ZodNullable = Ft,
    Ft.create = (yr,Lt)=>new Ft({
        innerType: yr,
        typeName: Ur.ZodNullable,
        ...wt(Lt)
    });
    class Ut extends xt {
        _parse(Lt) {
            const {ctx: Gt} = this._processInputParams(Lt);
            let Qt = Gt.data;
            return Gt.parsedType === mt.ZodParsedType.undefined && (Qt = this._def.defaultValue()),
            this._def.innerType._parse({
                data: Qt,
                path: Gt.path,
                parent: Gt
            })
        }
        removeDefault() {
            return this._def.innerType
        }
    }
    r.ZodDefault = Ut,
    Ut.create = (yr,Lt)=>new Ut({
        innerType: yr,
        typeName: Ur.ZodDefault,
        defaultValue: typeof Lt.default == "function" ? Lt.default : ()=>Lt.default,
        ...wt(Lt)
    });
    class Dt extends xt {
        _parse(Lt) {
            const {ctx: Gt} = this._processInputParams(Lt)
              , Qt = {
                ...Gt,
                common: {
                    ...Gt.common,
                    issues: []
                }
            }
              , pr = this._def.innerType._parse({
                data: Qt.data,
                path: Qt.path,
                parent: {
                    ...Qt
                }
            });
            return (0,
            dt.isAsync)(pr) ? pr.then(dr=>({
                status: "valid",
                value: dr.status === "valid" ? dr.value : this._def.catchValue({
                    get error() {
                        return new yt.ZodError(Qt.common.issues)
                    },
                    input: Qt.data
                })
            })) : {
                status: "valid",
                value: pr.status === "valid" ? pr.value : this._def.catchValue({
                    get error() {
                        return new yt.ZodError(Qt.common.issues)
                    },
                    input: Qt.data
                })
            }
        }
        removeCatch() {
            return this._def.innerType
        }
    }
    r.ZodCatch = Dt,
    Dt.create = (yr,Lt)=>new Dt({
        innerType: yr,
        typeName: Ur.ZodCatch,
        catchValue: typeof Lt.catch == "function" ? Lt.catch : ()=>Lt.catch,
        ...wt(Lt)
    });
    class er extends xt {
        _parse(Lt) {
            if (this._getType(Lt) !== mt.ZodParsedType.nan) {
                const Qt = this._getOrReturnCtx(Lt);
                return (0,
                dt.addIssueToContext)(Qt, {
                    code: yt.ZodIssueCode.invalid_type,
                    expected: mt.ZodParsedType.nan,
                    received: Qt.parsedType
                }),
                dt.INVALID
            }
            return {
                status: "valid",
                value: Lt.data
            }
        }
    }
    r.ZodNaN = er,
    er.create = yr=>new er({
        typeName: Ur.ZodNaN,
        ...wt(yr)
    }),
    r.BRAND = Symbol("zod_brand");
    class br extends xt {
        _parse(Lt) {
            const {ctx: Gt} = this._processInputParams(Lt)
              , Qt = Gt.data;
            return this._def.type._parse({
                data: Qt,
                path: Gt.path,
                parent: Gt
            })
        }
        unwrap() {
            return this._def.type
        }
    }
    r.ZodBranded = br;
    class Cr extends xt {
        _parse(Lt) {
            const {status: Gt, ctx: Qt} = this._processInputParams(Lt);
            if (Qt.common.async)
                return (async()=>{
                    const dr = await this._def.in._parseAsync({
                        data: Qt.data,
                        path: Qt.path,
                        parent: Qt
                    });
                    return dr.status === "aborted" ? dt.INVALID : dr.status === "dirty" ? (Gt.dirty(),
                    (0,
                    dt.DIRTY)(dr.value)) : this._def.out._parseAsync({
                        data: dr.value,
                        path: Qt.path,
                        parent: Qt
                    })
                }
                )();
            {
                const pr = this._def.in._parseSync({
                    data: Qt.data,
                    path: Qt.path,
                    parent: Qt
                });
                return pr.status === "aborted" ? dt.INVALID : pr.status === "dirty" ? (Gt.dirty(),
                {
                    status: "dirty",
                    value: pr.value
                }) : this._def.out._parseSync({
                    data: pr.value,
                    path: Qt.path,
                    parent: Qt
                })
            }
        }
        static create(Lt, Gt) {
            return new Cr({
                in: Lt,
                out: Gt,
                typeName: Ur.ZodPipeline
            })
        }
    }
    r.ZodPipeline = Cr;
    class xr extends xt {
        _parse(Lt) {
            const Gt = this._def.innerType._parse(Lt)
              , Qt = pr=>((0,
            dt.isValid)(pr) && (pr.value = Object.freeze(pr.value)),
            pr);
            return (0,
            dt.isAsync)(Gt) ? Gt.then(pr=>Qt(pr)) : Qt(Gt)
        }
        unwrap() {
            return this._def.innerType
        }
    }
    r.ZodReadonly = xr,
    xr.create = (yr,Lt)=>new xr({
        innerType: yr,
        typeName: Ur.ZodReadonly,
        ...wt(Lt)
    });
    function Lr(yr, Lt={}, Gt) {
        return yr ? gr.create().superRefine((Qt,pr)=>{
            var dr, Mr;
            if (!yr(Qt)) {
                const Br = typeof Lt == "function" ? Lt(Qt) : typeof Lt == "string" ? {
                    message: Lt
                } : Lt
                  , Fr = (Mr = (dr = Br.fatal) !== null && dr !== void 0 ? dr : Gt) !== null && Mr !== void 0 ? Mr : !0
                  , Kr = typeof Br == "string" ? {
                    message: Br
                } : Br;
                pr.addIssue({
                    code: "custom",
                    ...Kr,
                    fatal: Fr
                })
            }
        }
        ) : gr.create()
    }
    r.custom = Lr,
    r.late = {
        object: Yt.lazycreate
    };
    var Ur;
    (function(yr) {
        yr.ZodString = "ZodString",
        yr.ZodNumber = "ZodNumber",
        yr.ZodNaN = "ZodNaN",
        yr.ZodBigInt = "ZodBigInt",
        yr.ZodBoolean = "ZodBoolean",
        yr.ZodDate = "ZodDate",
        yr.ZodSymbol = "ZodSymbol",
        yr.ZodUndefined = "ZodUndefined",
        yr.ZodNull = "ZodNull",
        yr.ZodAny = "ZodAny",
        yr.ZodUnknown = "ZodUnknown",
        yr.ZodNever = "ZodNever",
        yr.ZodVoid = "ZodVoid",
        yr.ZodArray = "ZodArray",
        yr.ZodObject = "ZodObject",
        yr.ZodUnion = "ZodUnion",
        yr.ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
        yr.ZodIntersection = "ZodIntersection",
        yr.ZodTuple = "ZodTuple",
        yr.ZodRecord = "ZodRecord",
        yr.ZodMap = "ZodMap",
        yr.ZodSet = "ZodSet",
        yr.ZodFunction = "ZodFunction",
        yr.ZodLazy = "ZodLazy",
        yr.ZodLiteral = "ZodLiteral",
        yr.ZodEnum = "ZodEnum",
        yr.ZodEffects = "ZodEffects",
        yr.ZodNativeEnum = "ZodNativeEnum",
        yr.ZodOptional = "ZodOptional",
        yr.ZodNullable = "ZodNullable",
        yr.ZodDefault = "ZodDefault",
        yr.ZodCatch = "ZodCatch",
        yr.ZodPromise = "ZodPromise",
        yr.ZodBranded = "ZodBranded",
        yr.ZodPipeline = "ZodPipeline",
        yr.ZodReadonly = "ZodReadonly"
    }
    )(Ur = r.ZodFirstPartyTypeKind || (r.ZodFirstPartyTypeKind = {}));
    const Ir = (yr,Lt={
        message: `Input not instance of ${yr.name}`
    })=>Lr(Gt=>Gt instanceof yr, Lt);
    r.instanceof = Ir;
    const Jr = Et.create;
    r.string = Jr;
    const Wr = Rt.create;
    r.number = Wr;
    const Yr = er.create;
    r.nan = Yr;
    const Sn = kt.create;
    r.bigint = Sn;
    const pn = Tt.create;
    r.boolean = pn;
    const tn = It.create;
    r.date = tn;
    const Bn = St.create;
    r.symbol = Bn;
    const An = qt.create;
    r.undefined = An;
    const dn = ur.create;
    r.null = dn;
    const Rn = gr.create;
    r.any = Rn;
    const En = lr.create;
    r.unknown = En;
    const an = Zt.create;
    r.never = an;
    const Un = Vt.create;
    r.void = Un;
    const Jt = rr.create;
    r.array = Jt;
    const nr = Yt.create;
    r.object = nr;
    const sr = Yt.strictCreate;
    r.strictObject = sr;
    const jt = Xt.create;
    r.union = jt;
    const cr = Rr.create;
    r.discriminatedUnion = cr;
    const Tr = Nr.create;
    r.intersection = Tr;
    const kr = Dr.create;
    r.tuple = kr;
    const Pr = Or.create;
    r.record = Pr;
    const zr = $r.create;
    r.map = zr;
    const Vr = Zr.create;
    r.set = Vr;
    const jr = Hr.create;
    r.function = jr;
    const Mn = un.create;
    r.lazy = Mn;
    const nn = Qr.create;
    r.literal = nn;
    const gn = vr.create;
    r.enum = gn;
    const mn = ar.create;
    r.nativeEnum = mn;
    const xn = hr.create;
    r.promise = xn;
    const _n = _r.create;
    r.effect = _n,
    r.transformer = _n;
    const yn = Ar.create;
    r.optional = yn;
    const wn = Ft.create;
    r.nullable = wn;
    const vn = _r.createWithPreprocess;
    r.preprocess = vn;
    const sn = Cr.create;
    r.pipeline = sn;
    const hn = ()=>Jr().optional();
    r.ostring = hn;
    const rn = ()=>Wr().optional();
    r.onumber = rn;
    const ln = ()=>pn().optional();
    r.oboolean = ln,
    r.coerce = {
        string: yr=>Et.create({
            ...yr,
            coerce: !0
        }),
        number: yr=>Rt.create({
            ...yr,
            coerce: !0
        }),
        boolean: yr=>Tt.create({
            ...yr,
            coerce: !0
        }),
        bigint: yr=>kt.create({
            ...yr,
            coerce: !0
        }),
        date: yr=>It.create({
            ...yr,
            coerce: !0
        })
    },
    r.NEVER = dt.INVALID
}
)(types);
(function(r) {
    var d = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(m, k, y, ee) {
        ee === void 0 && (ee = y),
        Object.defineProperty(m, ee, {
            enumerable: !0,
            get: function() {
                return k[y]
            }
        })
    }
    : function(m, k, y, ee) {
        ee === void 0 && (ee = y),
        m[ee] = k[y]
    }
    )
      , f = commonjsGlobal && commonjsGlobal.__exportStar || function(m, k) {
        for (var y in m)
            y !== "default" && !Object.prototype.hasOwnProperty.call(k, y) && d(k, m, y)
    }
    ;
    Object.defineProperty(r, "__esModule", {
        value: !0
    }),
    f(errors, r),
    f(parseUtil, r),
    f(typeAliases, r),
    f(util, r),
    f(types, r),
    f(ZodError$1, r)
}
)(external);
(function(r) {
    var d = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(ee, dt, mt, yt) {
        yt === void 0 && (yt = mt),
        Object.defineProperty(ee, yt, {
            enumerable: !0,
            get: function() {
                return dt[mt]
            }
        })
    }
    : function(ee, dt, mt, yt) {
        yt === void 0 && (yt = mt),
        ee[yt] = dt[mt]
    }
    )
      , f = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(ee, dt) {
        Object.defineProperty(ee, "default", {
            enumerable: !0,
            value: dt
        })
    }
    : function(ee, dt) {
        ee.default = dt
    }
    )
      , m = commonjsGlobal && commonjsGlobal.__importStar || function(ee) {
        if (ee && ee.__esModule)
            return ee;
        var dt = {};
        if (ee != null)
            for (var mt in ee)
                mt !== "default" && Object.prototype.hasOwnProperty.call(ee, mt) && d(dt, ee, mt);
        return f(dt, ee),
        dt
    }
      , k = commonjsGlobal && commonjsGlobal.__exportStar || function(ee, dt) {
        for (var mt in ee)
            mt !== "default" && !Object.prototype.hasOwnProperty.call(dt, mt) && d(dt, ee, mt)
    }
    ;
    Object.defineProperty(r, "__esModule", {
        value: !0
    }),
    r.z = void 0;
    const y = m(external);
    r.z = y,
    k(external, r),
    r.default = y
}
)(lib);
const name = "@ton/ton"
  , version$1 = "14.0.0"
  , repository = "https://github.com/ton-org/ton.git"
  , author = "Whales Corp. <developers@whalescorp.com>"
  , license = "MIT"
  , main = "dist/index.js"
  , files = ["dist"]
  , scripts = {
    docs: "rm -fr docs && typedoc src/index.ts",
    build: "rm -fr dist && tsc --declaration",
    test: "jest --verbose --runInBand",
    release: "yarn build && yarn release-it --npm.yarn1"
}
  , devDependencies = {
    "@release-it/keep-a-changelog": "^5.0.0",
    "@ton/core": "^0.56.0",
    "@ton/crypto": "3.2.0",
    "@ton/emulator": "^2.1.1",
    "@types/jest": "^27.0.1",
    "@types/node": "^16.7.10",
    buffer: "^6.0.3",
    expect: "^27.1.0",
    jest: "^27.1.0",
    "jest-mock": "^27.1.0",
    karma: "^6.3.4",
    "karma-chrome-launcher": "^3.1.0",
    "karma-jasmine": "^4.0.1",
    "karma-typescript": "^5.5.2",
    "karma-webpack": "^5.0.0",
    prando: "^6.0.1",
    "release-it": "^17.1.1",
    "ts-jest": "^27.0.5",
    "ts-loader": "^9.2.5",
    "ts-node": "^10.7.0",
    typedoc: "^0.23.24",
    typescript: "^4.4.2",
    webpack: "^5.51.2"
}
  , dependencies = {
    axios: "^1.6.7",
    dataloader: "^2.0.0",
    "symbol.inspect": "1.0.1",
    teslabot: "^1.3.0",
    zod: "^3.21.4"
}
  , peerDependencies = {
    "@ton/core": ">=0.56.0",
    "@ton/crypto": ">=3.2.0"
}
  , publishConfig = {
    access: "public",
    registry: "https://registry.npmjs.org/"
}
  , packageManager = "yarn@3.4.1"
  , require$$4 = {
    name,
    version: version$1,
    repository,
    author,
    license,
    main,
    files,
    scripts,
    devDependencies,
    dependencies,
    peerDependencies,
    publishConfig,
    "release-it": {
        github: {
            release: !0
        },
        plugins: {
            "@release-it/keep-a-changelog": {
                filename: "CHANGELOG.md"
            }
        }
    },
    packageManager
};
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(r) {
    return r && r.__esModule ? r : {
        default: r
    }
}
;
Object.defineProperty(HttpApi$1, "__esModule", {
    value: !0
});
HttpApi$1.HttpApi = void 0;
const TonCache_1 = TonCache
  , dataloader_1 = __importDefault$1(dataloader)
  , axios_1$1 = __importDefault$1(axios_1$2)
  , zod_1$1 = lib
  , version = require$$4.version
  , blockIdExt = zod_1$1.z.object({
    "@type": zod_1$1.z.literal("ton.blockIdExt"),
    workchain: zod_1$1.z.number(),
    shard: zod_1$1.z.string(),
    seqno: zod_1$1.z.number(),
    root_hash: zod_1$1.z.string(),
    file_hash: zod_1$1.z.string()
})
  , addressInformation = zod_1$1.z.object({
    balance: zod_1$1.z.union([zod_1$1.z.number(), zod_1$1.z.string()]),
    state: zod_1$1.z.union([zod_1$1.z.literal("active"), zod_1$1.z.literal("uninitialized"), zod_1$1.z.literal("frozen")]),
    data: zod_1$1.z.string(),
    code: zod_1$1.z.string(),
    last_transaction_id: zod_1$1.z.object({
        "@type": zod_1$1.z.literal("internal.transactionId"),
        lt: zod_1$1.z.string(),
        hash: zod_1$1.z.string()
    }),
    block_id: blockIdExt,
    sync_utime: zod_1$1.z.number()
})
  , bocResponse = zod_1$1.z.object({
    "@type": zod_1$1.z.literal("ok")
})
  , feeResponse = zod_1$1.z.object({
    "@type": zod_1$1.z.literal("query.fees"),
    source_fees: zod_1$1.z.object({
        "@type": zod_1$1.z.literal("fees"),
        in_fwd_fee: zod_1$1.z.number(),
        storage_fee: zod_1$1.z.number(),
        gas_fee: zod_1$1.z.number(),
        fwd_fee: zod_1$1.z.number()
    })
})
  , callGetMethod = zod_1$1.z.object({
    gas_used: zod_1$1.z.number(),
    exit_code: zod_1$1.z.number(),
    stack: zod_1$1.z.array(zod_1$1.z.unknown())
})
  , messageData = zod_1$1.z.union([zod_1$1.z.object({
    "@type": zod_1$1.z.literal("msg.dataRaw"),
    body: zod_1$1.z.string()
}), zod_1$1.z.object({
    "@type": zod_1$1.z.literal("msg.dataText"),
    text: zod_1$1.z.string()
}), zod_1$1.z.object({
    "@type": zod_1$1.z.literal("msg.dataDecryptedText"),
    text: zod_1$1.z.string()
}), zod_1$1.z.object({
    "@type": zod_1$1.z.literal("msg.dataEncryptedText"),
    text: zod_1$1.z.string()
})])
  , message = zod_1$1.z.object({
    source: zod_1$1.z.string(),
    destination: zod_1$1.z.string(),
    value: zod_1$1.z.string(),
    fwd_fee: zod_1$1.z.string(),
    ihr_fee: zod_1$1.z.string(),
    created_lt: zod_1$1.z.string(),
    body_hash: zod_1$1.z.string(),
    msg_data: messageData,
    message: zod_1$1.z.string().optional()
})
  , transaction = zod_1$1.z.object({
    data: zod_1$1.z.string(),
    utime: zod_1$1.z.number(),
    transaction_id: zod_1$1.z.object({
        lt: zod_1$1.z.string(),
        hash: zod_1$1.z.string()
    }),
    fee: zod_1$1.z.string(),
    storage_fee: zod_1$1.z.string(),
    other_fee: zod_1$1.z.string(),
    in_msg: zod_1$1.z.union([zod_1$1.z.undefined(), message]),
    out_msgs: zod_1$1.z.array(message)
})
  , getTransactions = zod_1$1.z.array(transaction)
  , getMasterchain = zod_1$1.z.object({
    state_root_hash: zod_1$1.z.string(),
    last: blockIdExt,
    init: blockIdExt
})
  , getShards = zod_1$1.z.object({
    shards: zod_1$1.z.array(blockIdExt)
})
  , blockShortTxt = zod_1$1.z.object({
    "@type": zod_1$1.z.literal("blocks.shortTxId"),
    mode: zod_1$1.z.number(),
    account: zod_1$1.z.string(),
    lt: zod_1$1.z.string(),
    hash: zod_1$1.z.string()
})
  , getBlockTransactions = zod_1$1.z.object({
    id: blockIdExt,
    req_count: zod_1$1.z.number(),
    incomplete: zod_1$1.z.boolean(),
    transactions: zod_1$1.z.array(blockShortTxt)
});
class TypedCache {
    constructor(d, f, m, k) {
        this.namespace = d,
        this.cache = f,
        this.codec = m,
        this.keyEncoder = k
    }
    async get(d) {
        let f = await this.cache.get(this.namespace, this.keyEncoder(d));
        if (f) {
            let m = this.codec.safeParse(JSON.parse(f));
            if (m.success)
                return m.data
        }
        return null
    }
    async set(d, f) {
        f !== null ? await this.cache.set(this.namespace, this.keyEncoder(d), JSON.stringify(f)) : await this.cache.set(this.namespace, this.keyEncoder(d), null)
    }
}
class HttpApi {
    constructor(d, f) {
        this.endpoint = d,
        this.cache = new TonCache_1.InMemoryCache,
        this.parameters = {
            timeout: (f == null ? void 0 : f.timeout) || 3e4,
            apiKey: f == null ? void 0 : f.apiKey,
            adapter: f == null ? void 0 : f.adapter
        },
        this.shardCache = new TypedCache("ton-shard",this.cache,zod_1$1.z.array(blockIdExt),m=>m + ""),
        this.shardLoader = new dataloader_1.default(async m=>await Promise.all(m.map(async k=>{
            const y = await this.shardCache.get(k);
            if (y)
                return y;
            let ee = (await this.doCall("shards", {
                seqno: k
            }, getShards)).shards;
            return await this.shardCache.set(k, ee),
            ee
        }
        ))),
        this.shardTransactionsCache = new TypedCache("ton-shard-tx",this.cache,getBlockTransactions,m=>m.workchain + ":" + m.shard + ":" + m.seqno),
        this.shardTransactionsLoader = new dataloader_1.default(async m=>await Promise.all(m.map(async k=>{
            const y = await this.shardTransactionsCache.get(k);
            if (y)
                return y;
            let ee = await this.doCall("getBlockTransactions", {
                workchain: k.workchain,
                seqno: k.seqno,
                shard: k.shard
            }, getBlockTransactions);
            return await this.shardTransactionsCache.set(k, ee),
            ee
        }
        )),{
            cacheKeyFn: m=>m.workchain + ":" + m.shard + ":" + m.seqno
        })
    }
    getAddressInformation(d) {
        return this.doCall("getAddressInformation", {
            address: d.toString()
        }, addressInformation)
    }
    async getTransactions(d, f) {
        const m = f.inclusive;
        delete f.inclusive;
        let k;
        f.hash && (k = Buffer.from(f.hash, "base64").toString("hex"));
        let y = f.limit;
        f.hash && f.lt && m !== !0 && y++;
        let ee = await this.doCall("getTransactions", {
            address: d.toString(),
            ...f,
            limit: y,
            hash: k
        }, getTransactions);
        return ee.length > y && (ee = ee.slice(0, y)),
        f.hash && f.lt && m !== !0 && ee.shift(),
        ee
    }
    async getMasterchainInfo() {
        return await this.doCall("getMasterchainInfo", {}, getMasterchain)
    }
    async getShards(d) {
        return await this.shardLoader.load(d)
    }
    async getBlockTransactions(d, f, m) {
        return await this.shardTransactionsLoader.load({
            workchain: d,
            seqno: f,
            shard: m
        })
    }
    async getTransaction(d, f, m) {
        let k = Buffer.from(m, "base64").toString("hex")
          , ee = (await this.doCall("getTransactions", {
            address: d.toString(),
            lt: f,
            hash: k,
            limit: 1
        }, getTransactions)).find(dt=>dt.transaction_id.lt === f && dt.transaction_id.hash === m);
        return ee || null
    }
    async callGetMethod(d, f, m) {
        return await this.doCall("runGetMethod", {
            address: d.toString(),
            method: f,
            stack: serializeStack(m)
        }, callGetMethod)
    }
    async sendBoc(d) {
        await this.doCall("sendBoc", {
            boc: d.toString("base64")
        }, bocResponse)
    }
    async estimateFee(d, f) {
        return await this.doCall("estimateFee", {
            address: d.toString(),
            body: f.body.toBoc().toString("base64"),
            init_data: f.initData ? f.initData.toBoc().toString("base64") : "",
            init_code: f.initCode ? f.initCode.toBoc().toString("base64") : "",
            ignore_chksig: f.ignoreSignature
        }, feeResponse)
    }
    async tryLocateResultTx(d, f, m) {
        return await this.doCall("tryLocateResultTx", {
            source: d.toString(),
            destination: f.toString(),
            created_lt: m
        }, transaction)
    }
    async tryLocateSourceTx(d, f, m) {
        return await this.doCall("tryLocateSourceTx", {
            source: d.toString(),
            destination: f.toString(),
            created_lt: m
        }, transaction)
    }
    async doCall(d, f, m) {
        let k = {
            "Content-Type": "application/json",
            "X-Ton-Client-Version": version
        };
        this.parameters.apiKey && (k["X-API-Key"] = this.parameters.apiKey);
        let y = await axios_1$1.default.post(this.endpoint, JSON.stringify({
            id: "1",
            jsonrpc: "2.0",
            method: d,
            params: f
        }), {
            headers: k,
            timeout: this.parameters.timeout,
            adapter: this.parameters.adapter
        });
        if (y.status !== 200 || !y.data.ok)
            throw Error("Received error: " + JSON.stringify(y.data));
        let ee = m.safeParse(y.data.result);
        if (ee.success)
            return ee.data;
        throw Error("Malformed response: " + ee.error.format()._errors.join(", "))
    }
}
HttpApi$1.HttpApi = HttpApi;
function serializeStack(r) {
    let d = [];
    for (let f of r)
        if (f.type === "int")
            d.push(["num", f.value.toString()]);
        else if (f.type === "cell")
            d.push(["tvm.Cell", f.cell.toBoc().toString("base64")]);
        else if (f.type === "slice")
            d.push(["tvm.Slice", f.cell.toBoc().toString("base64")]);
        else if (f.type === "builder")
            d.push(["tvm.Builder", f.cell.toBoc().toString("base64")]);
        else
            throw Error("Unsupported stack item type: " + f.type);
    return d
}
var TonClient$1 = {};
Object.defineProperty(TonClient$1, "__esModule", {
    value: !0
});
TonClient$1.TonClient = void 0;
const HttpApi_1 = HttpApi$1
  , core_1$k = dist$1;
class TonClient {
    constructor(d) {
        this.parameters = {
            endpoint: d.endpoint
        },
        this.api = new HttpApi_1.HttpApi(this.parameters.endpoint,{
            timeout: d.timeout,
            apiKey: d.apiKey,
            adapter: d.httpAdapter
        })
    }
    async getBalance(d) {
        return (await this.getContractState(d)).balance
    }
    async runMethod(d, f, m=[]) {
        let k = await this.api.callGetMethod(d, f, m);
        if (k.exit_code !== 0)
            throw Error("Unable to execute get method. Got exit_code: " + k.exit_code);
        return {
            gas_used: k.gas_used,
            stack: parseStack(k.stack)
        }
    }
    async callGetMethod(d, f, m=[]) {
        return this.runMethod(d, f, m)
    }
    async runMethodWithError(d, f, m=[]) {
        let k = await this.api.callGetMethod(d, f, m);
        return {
            gas_used: k.gas_used,
            stack: parseStack(k.stack),
            exit_code: k.exit_code
        }
    }
    async callGetMethodWithError(d, f, m=[]) {
        return this.runMethodWithError(d, f, m)
    }
    async getTransactions(d, f) {
        let m = await this.api.getTransactions(d, f)
          , k = [];
        for (let y of m)
            k.push((0,
            core_1$k.loadTransaction)(core_1$k.Cell.fromBoc(Buffer.from(y.data, "base64"))[0].beginParse()));
        return k
    }
    async getTransaction(d, f, m) {
        let k = await this.api.getTransaction(d, f, m);
        return k ? (0,
        core_1$k.loadTransaction)(core_1$k.Cell.fromBoc(Buffer.from(k.data, "base64"))[0].beginParse()) : null
    }
    async tryLocateResultTx(d, f, m) {
        let k = await this.api.tryLocateResultTx(d, f, m);
        return (0,
        core_1$k.loadTransaction)(core_1$k.Cell.fromBase64(k.data).beginParse())
    }
    async tryLocateSourceTx(d, f, m) {
        let k = await this.api.tryLocateSourceTx(d, f, m);
        return (0,
        core_1$k.loadTransaction)(core_1$k.Cell.fromBase64(k.data).beginParse())
    }
    async getMasterchainInfo() {
        let d = await this.api.getMasterchainInfo();
        return {
            workchain: d.init.workchain,
            shard: d.last.shard,
            initSeqno: d.init.seqno,
            latestSeqno: d.last.seqno
        }
    }
    async getWorkchainShards(d) {
        return (await this.api.getShards(d)).map(m=>({
            workchain: m.workchain,
            shard: m.shard,
            seqno: m.seqno
        }))
    }
    async getShardTransactions(d, f, m) {
        let k = await this.api.getBlockTransactions(d, f, m);
        if (k.incomplete)
            throw Error("Unsupported");
        return k.transactions.map(y=>({
            account: core_1$k.Address.parseRaw(y.account),
            lt: y.lt,
            hash: y.hash
        }))
    }
    async sendMessage(d) {
        const f = (0,
        core_1$k.beginCell)().store((0,
        core_1$k.storeMessage)(d)).endCell().toBoc();
        await this.api.sendBoc(f)
    }
    async sendFile(d) {
        await this.api.sendBoc(d)
    }
    async estimateExternalMessageFee(d, f) {
        return await this.api.estimateFee(d, {
            body: f.body,
            initCode: f.initCode,
            initData: f.initData,
            ignoreSignature: f.ignoreSignature
        })
    }
    async sendExternalMessage(d, f) {
        if (await this.isContractDeployed(d.address) || !d.init) {
            const m = (0,
            core_1$k.external)({
                to: d.address,
                body: f
            });
            await this.sendMessage(m)
        } else {
            const m = (0,
            core_1$k.external)({
                to: d.address,
                init: d.init,
                body: f
            });
            await this.sendMessage(m)
        }
    }
    async isContractDeployed(d) {
        return (await this.getContractState(d)).state === "active"
    }
    async getContractState(d) {
        let f = await this.api.getAddressInformation(d)
          , m = BigInt(f.balance)
          , k = f.state;
        return {
            balance: m,
            state: k,
            code: f.code !== "" ? Buffer.from(f.code, "base64") : null,
            data: f.data !== "" ? Buffer.from(f.data, "base64") : null,
            lastTransaction: f.last_transaction_id.lt !== "0" ? {
                lt: f.last_transaction_id.lt,
                hash: f.last_transaction_id.hash
            } : null,
            blockId: {
                workchain: f.block_id.workchain,
                shard: f.block_id.shard,
                seqno: f.block_id.seqno
            },
            timestampt: f.sync_utime
        }
    }
    open(d) {
        return (0,
        core_1$k.openContract)(d, f=>createProvider$1(this, f.address, f.init))
    }
    provider(d, f) {
        return createProvider$1(this, d, f ?? null)
    }
}
TonClient$1.TonClient = TonClient;
function parseStackEntry(r) {
    const d = r["@type"];
    switch (d) {
    case "tvm.list":
    case "tvm.tuple":
        return r.elements.map(parseStackEntry);
    case "tvm.cell":
        return core_1$k.Cell.fromBoc(Buffer.from(r.bytes, "base64"))[0];
    case "tvm.slice":
        return core_1$k.Cell.fromBoc(Buffer.from(r.bytes, "base64"))[0];
    case "tvm.stackEntryCell":
        return parseStackEntry(r.cell);
    case "tvm.stackEntrySlice":
        return parseStackEntry(r.slice);
    case "tvm.stackEntryTuple":
        return parseStackEntry(r.tuple);
    case "tvm.stackEntryList":
        return parseStackEntry(r.list);
    case "tvm.stackEntryNumber":
        return parseStackEntry(r.number);
    case "tvm.numberDecimal":
        return BigInt(r.number);
    default:
        throw Error("Unsupported item type: " + d)
    }
}
function parseStackItem(r) {
    if (r[0] === "num") {
        let d = r[1];
        return d.startsWith("-") ? {
            type: "int",
            value: -BigInt(d.slice(1))
        } : {
            type: "int",
            value: BigInt(d)
        }
    } else {
        if (r[0] === "null")
            return {
                type: "null"
            };
        if (r[0] === "cell")
            return {
                type: "cell",
                cell: core_1$k.Cell.fromBoc(Buffer.from(r[1].bytes, "base64"))[0]
            };
        if (r[0] === "slice")
            return {
                type: "slice",
                cell: core_1$k.Cell.fromBoc(Buffer.from(r[1].bytes, "base64"))[0]
            };
        if (r[0] === "builder")
            return {
                type: "builder",
                cell: core_1$k.Cell.fromBoc(Buffer.from(r[1].bytes, "base64"))[0]
            };
        if (r[0] === "tuple" || r[0] === "list")
            return r[1].elements.length === 0 ? {
                type: "null"
            } : {
                type: "tuple",
                items: r[1].elements.map(parseStackEntry)
            };
        throw Error("Unsupported stack item type: " + r[0])
    }
}
function parseStack(r) {
    let d = [];
    for (let f of r)
        d.push(parseStackItem(f));
    return new core_1$k.TupleReader(d)
}
function createProvider$1(r, d, f) {
    return {
        async getState() {
            let m = await r.getContractState(d), k = m.balance, y = m.lastTransaction ? {
                lt: BigInt(m.lastTransaction.lt),
                hash: Buffer.from(m.lastTransaction.hash, "base64")
            } : null, ee;
            if (m.state === "active")
                ee = {
                    type: "active",
                    code: m.code ? m.code : null,
                    data: m.data ? m.data : null
                };
            else if (m.state === "uninitialized")
                ee = {
                    type: "uninit"
                };
            else if (m.state === "frozen")
                ee = {
                    type: "frozen",
                    stateHash: Buffer.alloc(0)
                };
            else
                throw Error("Unsupported state");
            return {
                balance: k,
                last: y,
                state: ee
            }
        },
        async get(m, k) {
            return {
                stack: (await r.callGetMethod(d, m, k)).stack
            }
        },
        async external(m) {
            let k = null;
            f && !await r.isContractDeployed(d) && (k = f);
            const y = (0,
            core_1$k.external)({
                to: d,
                init: k,
                body: m
            });
            let ee = (0,
            core_1$k.beginCell)().store((0,
            core_1$k.storeMessage)(y)).endCell().toBoc();
            await r.sendFile(ee)
        },
        async internal(m, k) {
            let y = null;
            f && !await r.isContractDeployed(d) && (y = f);
            let ee = !0;
            k.bounce !== null && k.bounce !== void 0 && (ee = k.bounce);
            let dt;
            typeof k.value == "string" ? dt = (0,
            core_1$k.toNano)(k.value) : dt = k.value;
            let mt = null;
            typeof k.body == "string" ? mt = (0,
            core_1$k.comment)(k.body) : k.body && (mt = k.body),
            await m.send({
                to: d,
                value: dt,
                bounce: ee,
                sendMode: k.sendMode,
                init: y,
                body: mt
            })
        },
        open(m) {
            return (0,
            core_1$k.openContract)(m, k=>createProvider$1(r, k.address, k.init ?? null))
        },
        getTransactions(m, k, y, ee) {
            return r.getTransactions(m, {
                limit: ee ?? 100,
                lt: k.toString(),
                hash: y.toString("base64"),
                inclusive: !0
            })
        }
    }
}
var TonClient4$1 = {}
  , toUrlSafe$1 = {};
Object.defineProperty(toUrlSafe$1, "__esModule", {
    value: !0
});
toUrlSafe$1.toUrlSafe = void 0;
function toUrlSafe(r) {
    for (; r.indexOf("/") >= 0; )
        r = r.replace("/", "_");
    for (; r.indexOf("+") >= 0; )
        r = r.replace("+", "-");
    for (; r.indexOf("=") >= 0; )
        r = r.replace("=", "");
    return r
}
toUrlSafe$1.toUrlSafe = toUrlSafe;
var __classPrivateFieldSet = commonjsGlobal && commonjsGlobal.__classPrivateFieldSet || function(r, d, f, m, k) {
    if (m === "m")
        throw new TypeError("Private method is not writable");
    if (m === "a" && !k)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof d == "function" ? r !== d || !k : !d.has(r))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return m === "a" ? k.call(r, f) : k ? k.value = f : d.set(r, f),
    f
}
, __classPrivateFieldGet = commonjsGlobal && commonjsGlobal.__classPrivateFieldGet || function(r, d, f, m) {
    if (f === "a" && !m)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof d == "function" ? r !== d || !m : !d.has(r))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return f === "m" ? m : f === "a" ? m.call(r) : m ? m.value : d.get(r)
}
, __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(r) {
    return r && r.__esModule ? r : {
        default: r
    }
}
, _TonClient4_endpoint, _TonClient4_timeout, _TonClient4_adapter, _TonClient4_axios;
Object.defineProperty(TonClient4$1, "__esModule", {
    value: !0
});
TonClient4$1.TonClient4 = void 0;
const axios_1 = __importDefault(axios_1$2)
  , core_1$j = dist$1
  , toUrlSafe_1 = toUrlSafe$1
  , zod_1 = lib;
class TonClient4 {
    constructor(d) {
        _TonClient4_endpoint.set(this, void 0),
        _TonClient4_timeout.set(this, void 0),
        _TonClient4_adapter.set(this, void 0),
        _TonClient4_axios.set(this, void 0),
        __classPrivateFieldSet(this, _TonClient4_axios, axios_1.default.create(), "f"),
        __classPrivateFieldSet(this, _TonClient4_endpoint, d.endpoint, "f"),
        __classPrivateFieldSet(this, _TonClient4_timeout, d.timeout || 5e3, "f"),
        __classPrivateFieldSet(this, _TonClient4_adapter, d.httpAdapter, "f"),
        d.requestInterceptor && __classPrivateFieldGet(this, _TonClient4_axios, "f").interceptors.request.use(d.requestInterceptor)
    }
    async getLastBlock() {
        let d = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/latest", {
            adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
            timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f")
        })
          , f = lastBlockCodec.safeParse(d.data);
        if (!f.success)
            throw Error("Mailformed response: " + f.error.format()._errors.join(", "));
        return f.data
    }
    async getBlock(d) {
        let f = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + d, {
            adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
            timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f")
        })
          , m = blockCodec.safeParse(f.data);
        if (!m.success)
            throw Error("Mailformed response");
        if (!m.data.exist)
            throw Error("Block is out of scope");
        return m.data.block
    }
    async getBlockByUtime(d) {
        let f = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/utime/" + d, {
            adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
            timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f")
        })
          , m = blockCodec.safeParse(f.data);
        if (!m.success)
            throw Error("Mailformed response");
        if (!m.data.exist)
            throw Error("Block is out of scope");
        return m.data.block
    }
    async getAccount(d, f) {
        let m = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + d + "/" + f.toString({
            urlSafe: !0
        }), {
            adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
            timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f")
        })
          , k = accountCodec.safeParse(m.data);
        if (!k.success)
            throw Error("Mailformed response");
        return k.data
    }
    async getAccountLite(d, f) {
        let m = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + d + "/" + f.toString({
            urlSafe: !0
        }) + "/lite", {
            adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
            timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f")
        })
          , k = accountLiteCodec.safeParse(m.data);
        if (!k.success)
            throw Error("Mailformed response");
        return k.data
    }
    async isContractDeployed(d, f) {
        return (await this.getAccountLite(d, f)).account.state.type === "active"
    }
    async isAccountChanged(d, f, m) {
        let k = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + d + "/" + f.toString({
            urlSafe: !0
        }) + "/changed/" + m.toString(10), {
            adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
            timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f")
        })
          , y = changedCodec.safeParse(k.data);
        if (!y.success)
            throw Error("Mailformed response");
        return y.data
    }
    async getAccountTransactions(d, f, m) {
        let k = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/account/" + d.toString({
            urlSafe: !0
        }) + "/tx/" + f.toString(10) + "/" + (0,
        toUrlSafe_1.toUrlSafe)(m.toString("base64")), {
            adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
            timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f")
        })
          , y = transactionsCodec.safeParse(k.data);
        if (!y.success)
            throw Error("Mailformed response");
        let ee = y.data
          , dt = []
          , mt = core_1$j.Cell.fromBoc(Buffer.from(ee.boc, "base64"));
        for (let yt = 0; yt < ee.blocks.length; yt++)
            dt.push({
                block: ee.blocks[yt],
                tx: (0,
                core_1$j.loadTransaction)(mt[yt].beginParse())
            });
        return dt
    }
    async getAccountTransactionsParsed(d, f, m, k=20) {
        let y = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/account/" + d.toString({
            urlSafe: !0
        }) + "/tx/parsed/" + f.toString(10) + "/" + (0,
        toUrlSafe_1.toUrlSafe)(m.toString("base64")), {
            adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
            timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f"),
            params: {
                count: k
            }
        })
          , ee = parsedTransactionsCodec.safeParse(y.data);
        if (!ee.success)
            throw Error("Mailformed response");
        return ee.data
    }
    async getConfig(d, f) {
        let m = "";
        f && f.length > 0 && (m = "/" + [...f].sort().join(","));
        let k = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + d + "/config" + m, {
            adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
            timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f")
        })
          , y = configCodec.safeParse(k.data);
        if (!y.success)
            throw Error("Mailformed response");
        return y.data
    }
    async runMethod(d, f, m, k) {
        let y = k && k.length > 0 ? "/" + (0,
        toUrlSafe_1.toUrlSafe)((0,
        core_1$j.serializeTuple)(k).toBoc({
            idx: !1,
            crc32: !1
        }).toString("base64")) : ""
          , ee = __classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + d + "/" + f.toString({
            urlSafe: !0
        }) + "/run/" + encodeURIComponent(m) + y
          , dt = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(ee, {
            adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
            timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f")
        })
          , mt = runMethodCodec.safeParse(dt.data);
        if (!mt.success)
            throw Error("Mailformed response");
        let yt = mt.data.resultRaw ? (0,
        core_1$j.parseTuple)(core_1$j.Cell.fromBoc(Buffer.from(mt.data.resultRaw, "base64"))[0]) : [];
        return {
            exitCode: mt.data.exitCode,
            result: yt,
            resultRaw: mt.data.resultRaw,
            block: mt.data.block,
            shardBlock: mt.data.shardBlock,
            reader: new core_1$j.TupleReader(yt)
        }
    }
    async sendMessage(d) {
        let f = await __classPrivateFieldGet(this, _TonClient4_axios, "f").post(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/send", {
            boc: d.toString("base64")
        }, {
            adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
            timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f")
        });
        if (!sendCodec.safeParse(f.data).success)
            throw Error("Mailformed response");
        return {
            status: f.data.status
        }
    }
    open(d) {
        return (0,
        core_1$j.openContract)(d, f=>createProvider(this, null, f.address, f.init))
    }
    openAt(d, f) {
        return (0,
        core_1$j.openContract)(f, m=>createProvider(this, d, m.address, m.init))
    }
    provider(d, f) {
        return createProvider(this, null, d, f ?? null)
    }
    providerAt(d, f, m) {
        return createProvider(this, d, f, m ?? null)
    }
}
TonClient4$1.TonClient4 = TonClient4;
_TonClient4_endpoint = new WeakMap,
_TonClient4_timeout = new WeakMap,
_TonClient4_adapter = new WeakMap,
_TonClient4_axios = new WeakMap;
function createProvider(r, d, f, m) {
    return {
        async getState() {
            let k = d;
            k === null && (k = (await r.getLastBlock()).last.seqno);
            let y = await r.getAccount(k, f), ee = y.account.last ? {
                lt: BigInt(y.account.last.lt),
                hash: Buffer.from(y.account.last.hash, "base64")
            } : null, dt;
            if (y.account.state.type === "active")
                dt = {
                    type: "active",
                    code: y.account.state.code ? Buffer.from(y.account.state.code, "base64") : null,
                    data: y.account.state.data ? Buffer.from(y.account.state.data, "base64") : null
                };
            else if (y.account.state.type === "uninit")
                dt = {
                    type: "uninit"
                };
            else if (y.account.state.type === "frozen")
                dt = {
                    type: "frozen",
                    stateHash: Buffer.from(y.account.state.stateHash, "base64")
                };
            else
                throw Error("Unsupported state");
            return {
                balance: BigInt(y.account.balance.coins),
                last: ee,
                state: dt
            }
        },
        async get(k, y) {
            let ee = d;
            ee === null && (ee = (await r.getLastBlock()).last.seqno);
            let dt = await r.runMethod(ee, f, k, y);
            if (dt.exitCode !== 0 && dt.exitCode !== 1)
                throw Error("Exit code: " + dt.exitCode);
            return {
                stack: new core_1$j.TupleReader(dt.result)
            }
        },
        async external(k) {
            let y = await r.getLastBlock()
              , ee = null;
            m && (await r.getAccountLite(y.last.seqno, f)).account.state.type !== "active" && (ee = m);
            const dt = (0,
            core_1$j.external)({
                to: f,
                init: ee,
                body: k
            });
            let mt = (0,
            core_1$j.beginCell)().store((0,
            core_1$j.storeMessage)(dt)).endCell().toBoc();
            await r.sendMessage(mt)
        },
        async internal(k, y) {
            let ee = await r.getLastBlock()
              , dt = null;
            m && (await r.getAccountLite(ee.last.seqno, f)).account.state.type !== "active" && (dt = m);
            let mt = !0;
            y.bounce !== null && y.bounce !== void 0 && (mt = y.bounce);
            let yt;
            typeof y.value == "string" ? yt = (0,
            core_1$j.toNano)(y.value) : yt = y.value;
            let pt = null;
            typeof y.body == "string" ? pt = (0,
            core_1$j.comment)(y.body) : y.body && (pt = y.body),
            await k.send({
                to: f,
                value: yt,
                bounce: mt,
                sendMode: y.sendMode,
                init: dt,
                body: pt
            })
        },
        open(k) {
            return (0,
            core_1$j.openContract)(k, y=>createProvider(r, d, y.address, y.init ?? null))
        },
        async getTransactions(k, y, ee, dt) {
            const mt = typeof dt == "number";
            if (mt && dt <= 0)
                return [];
            let yt = [];
            do {
                const pt = await r.getAccountTransactions(k, y, ee)
                  , bt = pt[0].tx
                  , [wt,xt] = [bt.lt, bt.hash()];
                if (yt.length > 0 && wt === y && xt.equals(ee) && pt.shift(),
                pt.length === 0)
                    break;
                const Ct = pt[pt.length - 1].tx
                  , [Pt,$t] = [Ct.lt, Ct.hash()];
                if (Pt === y && $t.equals(ee))
                    break;
                yt.push(...pt.map(Ot=>Ot.tx)),
                y = Pt,
                ee = $t
            } while (mt && yt.length < dt);
            return mt && (yt = yt.slice(0, dt)),
            yt
        }
    }
}
const lastBlockCodec = zod_1.z.object({
    last: zod_1.z.object({
        seqno: zod_1.z.number(),
        shard: zod_1.z.string(),
        workchain: zod_1.z.number(),
        fileHash: zod_1.z.string(),
        rootHash: zod_1.z.string()
    }),
    init: zod_1.z.object({
        fileHash: zod_1.z.string(),
        rootHash: zod_1.z.string()
    }),
    stateRootHash: zod_1.z.string(),
    now: zod_1.z.number()
})
  , blockCodec = zod_1.z.union([zod_1.z.object({
    exist: zod_1.z.literal(!1)
}), zod_1.z.object({
    exist: zod_1.z.literal(!0),
    block: zod_1.z.object({
        shards: zod_1.z.array(zod_1.z.object({
            workchain: zod_1.z.number(),
            seqno: zod_1.z.number(),
            shard: zod_1.z.string(),
            rootHash: zod_1.z.string(),
            fileHash: zod_1.z.string(),
            transactions: zod_1.z.array(zod_1.z.object({
                account: zod_1.z.string(),
                hash: zod_1.z.string(),
                lt: zod_1.z.string()
            }))
        }))
    })
})])
  , storageStatCodec = zod_1.z.object({
    lastPaid: zod_1.z.number(),
    duePayment: zod_1.z.union([zod_1.z.null(), zod_1.z.string()]),
    used: zod_1.z.object({
        bits: zod_1.z.number(),
        cells: zod_1.z.number(),
        publicCells: zod_1.z.number()
    })
})
  , accountCodec = zod_1.z.object({
    account: zod_1.z.object({
        state: zod_1.z.union([zod_1.z.object({
            type: zod_1.z.literal("uninit")
        }), zod_1.z.object({
            type: zod_1.z.literal("active"),
            code: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
            data: zod_1.z.union([zod_1.z.string(), zod_1.z.null()])
        }), zod_1.z.object({
            type: zod_1.z.literal("frozen"),
            stateHash: zod_1.z.string()
        })]),
        balance: zod_1.z.object({
            coins: zod_1.z.string()
        }),
        last: zod_1.z.union([zod_1.z.null(), zod_1.z.object({
            lt: zod_1.z.string(),
            hash: zod_1.z.string()
        })]),
        storageStat: zod_1.z.union([zod_1.z.null(), storageStatCodec])
    }),
    block: zod_1.z.object({
        workchain: zod_1.z.number(),
        seqno: zod_1.z.number(),
        shard: zod_1.z.string(),
        rootHash: zod_1.z.string(),
        fileHash: zod_1.z.string()
    })
})
  , accountLiteCodec = zod_1.z.object({
    account: zod_1.z.object({
        state: zod_1.z.union([zod_1.z.object({
            type: zod_1.z.literal("uninit")
        }), zod_1.z.object({
            type: zod_1.z.literal("active"),
            codeHash: zod_1.z.string(),
            dataHash: zod_1.z.string()
        }), zod_1.z.object({
            type: zod_1.z.literal("frozen"),
            stateHash: zod_1.z.string()
        })]),
        balance: zod_1.z.object({
            coins: zod_1.z.string()
        }),
        last: zod_1.z.union([zod_1.z.null(), zod_1.z.object({
            lt: zod_1.z.string(),
            hash: zod_1.z.string()
        })]),
        storageStat: zod_1.z.union([zod_1.z.null(), storageStatCodec])
    })
})
  , changedCodec = zod_1.z.object({
    changed: zod_1.z.boolean(),
    block: zod_1.z.object({
        workchain: zod_1.z.number(),
        seqno: zod_1.z.number(),
        shard: zod_1.z.string(),
        rootHash: zod_1.z.string(),
        fileHash: zod_1.z.string()
    })
})
  , runMethodCodec = zod_1.z.object({
    exitCode: zod_1.z.number(),
    resultRaw: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
    block: zod_1.z.object({
        workchain: zod_1.z.number(),
        seqno: zod_1.z.number(),
        shard: zod_1.z.string(),
        rootHash: zod_1.z.string(),
        fileHash: zod_1.z.string()
    }),
    shardBlock: zod_1.z.object({
        workchain: zod_1.z.number(),
        seqno: zod_1.z.number(),
        shard: zod_1.z.string(),
        rootHash: zod_1.z.string(),
        fileHash: zod_1.z.string()
    })
})
  , configCodec = zod_1.z.object({
    config: zod_1.z.object({
        cell: zod_1.z.string(),
        address: zod_1.z.string(),
        globalBalance: zod_1.z.object({
            coins: zod_1.z.string()
        })
    })
})
  , sendCodec = zod_1.z.object({
    status: zod_1.z.number()
})
  , blocksCodec = zod_1.z.array(zod_1.z.object({
    workchain: zod_1.z.number(),
    seqno: zod_1.z.number(),
    shard: zod_1.z.string(),
    rootHash: zod_1.z.string(),
    fileHash: zod_1.z.string()
}))
  , transactionsCodec = zod_1.z.object({
    blocks: blocksCodec,
    boc: zod_1.z.string()
})
  , parsedAddressExternalCodec = zod_1.z.object({
    bits: zod_1.z.number(),
    data: zod_1.z.string()
})
  , parsedMessageInfoCodec = zod_1.z.union([zod_1.z.object({
    type: zod_1.z.literal("internal"),
    value: zod_1.z.string(),
    dest: zod_1.z.string(),
    src: zod_1.z.string(),
    bounced: zod_1.z.boolean(),
    bounce: zod_1.z.boolean(),
    ihrDisabled: zod_1.z.boolean(),
    createdAt: zod_1.z.number(),
    createdLt: zod_1.z.string(),
    fwdFee: zod_1.z.string(),
    ihrFee: zod_1.z.string()
}), zod_1.z.object({
    type: zod_1.z.literal("external-in"),
    dest: zod_1.z.string(),
    src: zod_1.z.union([parsedAddressExternalCodec, zod_1.z.null()]),
    importFee: zod_1.z.string()
}), zod_1.z.object({
    type: zod_1.z.literal("external-out"),
    dest: zod_1.z.union([parsedAddressExternalCodec, zod_1.z.null()])
})])
  , parsedStateInitCodec = zod_1.z.object({
    splitDepth: zod_1.z.union([zod_1.z.number(), zod_1.z.null()]),
    code: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
    data: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
    special: zod_1.z.union([zod_1.z.object({
        tick: zod_1.z.boolean(),
        tock: zod_1.z.boolean()
    }), zod_1.z.null()])
})
  , parsedMessageCodec = zod_1.z.object({
    body: zod_1.z.string(),
    info: parsedMessageInfoCodec,
    init: zod_1.z.union([parsedStateInitCodec, zod_1.z.null()])
})
  , accountStatusCodec = zod_1.z.union([zod_1.z.literal("uninitialized"), zod_1.z.literal("frozen"), zod_1.z.literal("active"), zod_1.z.literal("non-existing")])
  , txBodyCodec = zod_1.z.union([zod_1.z.object({
    type: zod_1.z.literal("comment"),
    comment: zod_1.z.string()
}), zod_1.z.object({
    type: zod_1.z.literal("payload"),
    cell: zod_1.z.string()
})])
  , parsedOperationItemCodec = zod_1.z.union([zod_1.z.object({
    kind: zod_1.z.literal("ton"),
    amount: zod_1.z.string()
}), zod_1.z.object({
    kind: zod_1.z.literal("token"),
    amount: zod_1.z.string()
})])
  , supportedMessageTypeCodec = zod_1.z.union([zod_1.z.literal("jetton::excesses"), zod_1.z.literal("jetton::transfer"), zod_1.z.literal("jetton::transfer_notification"), zod_1.z.literal("deposit"), zod_1.z.literal("deposit::ok"), zod_1.z.literal("withdraw"), zod_1.z.literal("withdraw::all"), zod_1.z.literal("withdraw::delayed"), zod_1.z.literal("withdraw::ok"), zod_1.z.literal("airdrop")])
  , opCodec = zod_1.z.object({
    type: supportedMessageTypeCodec,
    options: zod_1.z.optional(zod_1.z.record(zod_1.z.string()))
})
  , parsedOperationCodec = zod_1.z.object({
    address: zod_1.z.string(),
    comment: zod_1.z.optional(zod_1.z.string()),
    items: zod_1.z.array(parsedOperationItemCodec),
    op: zod_1.z.optional(opCodec)
})
  , parsedTransactionCodec = zod_1.z.object({
    address: zod_1.z.string(),
    lt: zod_1.z.string(),
    hash: zod_1.z.string(),
    prevTransaction: zod_1.z.object({
        lt: zod_1.z.string(),
        hash: zod_1.z.string()
    }),
    time: zod_1.z.number(),
    outMessagesCount: zod_1.z.number(),
    oldStatus: accountStatusCodec,
    newStatus: accountStatusCodec,
    fees: zod_1.z.string(),
    update: zod_1.z.object({
        oldHash: zod_1.z.string(),
        newHash: zod_1.z.string()
    }),
    inMessage: zod_1.z.union([parsedMessageCodec, zod_1.z.null()]),
    outMessages: zod_1.z.array(parsedMessageCodec),
    parsed: zod_1.z.object({
        seqno: zod_1.z.union([zod_1.z.number(), zod_1.z.null()]),
        body: zod_1.z.union([txBodyCodec, zod_1.z.null()]),
        status: zod_1.z.union([zod_1.z.literal("success"), zod_1.z.literal("failed"), zod_1.z.literal("pending")]),
        dest: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
        kind: zod_1.z.union([zod_1.z.literal("out"), zod_1.z.literal("in")]),
        amount: zod_1.z.string(),
        resolvedAddress: zod_1.z.string(),
        bounced: zod_1.z.boolean(),
        mentioned: zod_1.z.array(zod_1.z.string())
    }),
    operation: parsedOperationCodec
})
  , parsedTransactionsCodec = zod_1.z.object({
    blocks: blocksCodec,
    transactions: zod_1.z.array(parsedTransactionCodec)
});
var WalletContractV1R1$1 = {}
  , createWalletTransfer = {}
  , WalletContractV5Beta$1 = {}
  , WalletV5BetaWalletId = {};
Object.defineProperty(WalletV5BetaWalletId, "__esModule", {
    value: !0
});
WalletV5BetaWalletId.storeWalletIdV5Beta = WalletV5BetaWalletId.loadWalletIdV5Beta = void 0;
const core_1$i = dist$1
  , walletV5BetaVersionsSerialisation = {
    v5: 0
};
function loadWalletIdV5Beta(r) {
    var dt;
    const d = new core_1$i.BitReader(new core_1$i.BitString(typeof r == "bigint" ? Buffer.from(r.toString(16), "hex") : r instanceof core_1$i.Slice ? r.loadBuffer(10) : r,0,80))
      , f = d.loadInt(32)
      , m = d.loadInt(8)
      , k = d.loadUint(8)
      , y = d.loadUint(32)
      , ee = (dt = Object.entries(walletV5BetaVersionsSerialisation).find(([mt,yt])=>yt === k)) == null ? void 0 : dt[0];
    if (ee === void 0)
        throw new Error(`Can't deserialize walletId: unknown wallet version ${k}`);
    return {
        networkGlobalId: f,
        workChain: m,
        walletVersion: ee,
        subwalletNumber: y
    }
}
WalletV5BetaWalletId.loadWalletIdV5Beta = loadWalletIdV5Beta;
function storeWalletIdV5Beta(r) {
    return d=>{
        d.storeInt(r.networkGlobalId, 32),
        d.storeInt(r.workChain, 8),
        d.storeUint(walletV5BetaVersionsSerialisation[r.walletVersion], 8),
        d.storeUint(r.subwalletNumber, 32)
    }
}
WalletV5BetaWalletId.storeWalletIdV5Beta = storeWalletIdV5Beta;
var hasRequiredWalletContractV5Beta;
function requireWalletContractV5Beta() {
    if (hasRequiredWalletContractV5Beta)
        return WalletContractV5Beta$1;
    hasRequiredWalletContractV5Beta = 1,
    Object.defineProperty(WalletContractV5Beta$1, "__esModule", {
        value: !0
    }),
    WalletContractV5Beta$1.WalletContractV5Beta = void 0;
    const r = dist$1
      , d = requireCreateWalletTransfer()
      , f = WalletV5BetaWalletId;
    class m {
        static create(y) {
            var dt, mt, yt, pt;
            const ee = {
                networkGlobalId: ((dt = y.walletId) == null ? void 0 : dt.networkGlobalId) ?? -239,
                workChain: ((mt = y == null ? void 0 : y.walletId) == null ? void 0 : mt.workChain) ?? 0,
                subwalletNumber: ((yt = y == null ? void 0 : y.walletId) == null ? void 0 : yt.subwalletNumber) ?? 0,
                walletVersion: ((pt = y == null ? void 0 : y.walletId) == null ? void 0 : pt.walletVersion) ?? "v5"
            };
            return new m(ee,y.publicKey)
        }
        constructor(y, ee) {
            this.walletId = y,
            this.publicKey = ee,
            this.walletId = y;
            let dt = r.Cell.fromBoc(Buffer.from("te6cckEBAQEAIwAIQgLkzzsvTG1qYeoPK1RH0mZ4WyavNjfbLe7mvNGqgm80Eg3NjhE=", "base64"))[0]
              , mt = (0,
            r.beginCell)().storeInt(0, 33).store((0,
            f.storeWalletIdV5Beta)(this.walletId)).storeBuffer(this.publicKey, 32).storeBit(0).endCell();
            this.init = {
                code: dt,
                data: mt
            },
            this.address = (0,
            r.contractAddress)(this.walletId.workChain, {
                code: dt,
                data: mt
            })
        }
        async getBalance(y) {
            return (await y.getState()).balance
        }
        async getSeqno(y) {
            return (await y.getState()).state.type === "active" ? (await y.get("seqno", [])).stack.readNumber() : 0
        }
        async getExtensions(y) {
            return (await y.getState()).state.type === "active" ? (await y.get("get_extensions", [])).stack.readCellOpt() : null
        }
        async getExtensionsArray(y) {
            const ee = await this.getExtensions(y);
            if (!ee)
                return [];
            const dt = r.Dictionary.loadDirect(r.Dictionary.Keys.BigUint(256), r.Dictionary.Values.BigInt(8), ee);
            return dt.keys().map(mt=>{
                const yt = dt.get(mt)
                  , pt = mt ^ yt + 1n;
                return r.Address.parseRaw(`${yt}:${pt.toString(16).padStart(64, "0")}`)
            }
            )
        }
        async getIsSecretKeyAuthEnabled(y) {
            return (await y.get("get_is_signature_auth_allowed", [])).stack.readNumber() !== 0
        }
        async send(y, ee) {
            await y.external(ee)
        }
        async sendTransfer(y, ee) {
            const dt = await this.createTransfer(ee);
            await this.send(y, dt)
        }
        async sendAddExtension(y, ee) {
            const dt = await this.createAddExtension(ee);
            await this.send(y, dt)
        }
        async sendRemoveExtension(y, ee) {
            const dt = await this.createRemoveExtension(ee);
            await this.send(y, dt)
        }
        async sendActionsBatch(y, ee) {
            const dt = await this.createRequest(ee);
            await this.send(y, dt)
        }
        createActions(y) {
            return y.messages.map(dt=>({
                type: "sendMsg",
                mode: y.sendMode,
                outMsg: dt
            }))
        }
        createTransfer(y) {
            return this.createRequest({
                ...y,
                actions: this.createActions({
                    messages: y.messages,
                    sendMode: y.sendMode
                })
            })
        }
        createAddExtension(y) {
            return this.createRequest({
                ...y,
                actions: [{
                    type: "addExtension",
                    address: y.extensionAddress
                }]
            })
        }
        createRemoveExtension(y) {
            return this.createRequest({
                ...y,
                actions: [{
                    type: "removeExtension",
                    address: y.extensionAddress
                }]
            })
        }
        createRequest(y) {
            return y.authType === "extension" ? (0,
            d.createWalletTransferV5Beta)(y) : (0,
            d.createWalletTransferV5Beta)({
                ...y,
                walletId: (0,
                f.storeWalletIdV5Beta)(this.walletId)
            })
        }
        sender(y, ee) {
            return {
                send: async dt=>{
                    let mt = await this.getSeqno(y)
                      , yt = this.createTransfer({
                        seqno: mt,
                        secretKey: ee,
                        sendMode: dt.sendMode ?? r.SendMode.PAY_GAS_SEPARATELY + r.SendMode.IGNORE_ERRORS,
                        messages: [(0,
                        r.internal)({
                            to: dt.to,
                            value: dt.value,
                            init: dt.init,
                            body: dt.body,
                            bounce: dt.bounce
                        })]
                    });
                    await this.send(y, yt)
                }
            }
        }
    }
    return WalletContractV5Beta$1.WalletContractV5Beta = m,
    m.OpCodes = {
        auth_extension: 1702392942,
        auth_signed_external: 1936287598,
        auth_signed_internal: 1936289396
    },
    WalletContractV5Beta$1
}
var WalletV5BetaActions = {}
  , WalletV5OutActions = {};
Object.defineProperty(WalletV5OutActions, "__esModule", {
    value: !0
});
WalletV5OutActions.isOutActionBasic = WalletV5OutActions.isOutActionExtended = void 0;
function isOutActionExtended(r) {
    return r.type === "setIsPublicKeyEnabled" || r.type === "addExtension" || r.type === "removeExtension"
}
WalletV5OutActions.isOutActionExtended = isOutActionExtended;
function isOutActionBasic(r) {
    return !isOutActionExtended(r)
}
WalletV5OutActions.isOutActionBasic = isOutActionBasic;
Object.defineProperty(WalletV5BetaActions, "__esModule", {
    value: !0
});
WalletV5BetaActions.loadOutListExtendedV5Beta = WalletV5BetaActions.storeOutListExtendedV5Beta = WalletV5BetaActions.loadOutActionV5BetaExtended = WalletV5BetaActions.storeOutActionExtendedV5Beta = void 0;
const core_1$h = dist$1
  , WalletV5OutActions_1$1 = WalletV5OutActions
  , outActionSetIsPublicKeyEnabledTag$1 = 550222170;
function storeOutActionSetIsPublicKeyEnabled$1(r) {
    return d=>{
        d.storeUint(outActionSetIsPublicKeyEnabledTag$1, 32).storeUint(r.isEnabled ? 1 : 0, 1)
    }
}
const outActionAddExtensionTag$1 = 474012575;
function storeOutActionAddExtension$1(r) {
    return d=>{
        d.storeUint(outActionAddExtensionTag$1, 32).storeAddress(r.address)
    }
}
const outActionRemoveExtensionTag$1 = 1588524196;
function storeOutActionRemoveExtension$1(r) {
    return d=>{
        d.storeUint(outActionRemoveExtensionTag$1, 32).storeAddress(r.address)
    }
}
function storeOutActionExtendedV5Beta(r) {
    switch (r.type) {
    case "setIsPublicKeyEnabled":
        return storeOutActionSetIsPublicKeyEnabled$1(r);
    case "addExtension":
        return storeOutActionAddExtension$1(r);
    case "removeExtension":
        return storeOutActionRemoveExtension$1(r);
    default:
        throw new Error("Unknown action type" + (r == null ? void 0 : r.type))
    }
}
WalletV5BetaActions.storeOutActionExtendedV5Beta = storeOutActionExtendedV5Beta;
function loadOutActionV5BetaExtended(r) {
    const d = r.loadUint(32);
    switch (d) {
    case outActionSetIsPublicKeyEnabledTag$1:
        return {
            type: "setIsPublicKeyEnabled",
            isEnabled: !!r.loadUint(1)
        };
    case outActionAddExtensionTag$1:
        return {
            type: "addExtension",
            address: r.loadAddress()
        };
    case outActionRemoveExtensionTag$1:
        return {
            type: "removeExtension",
            address: r.loadAddress()
        };
    default:
        throw new Error(`Unknown extended out action tag 0x${d.toString(16)}`)
    }
}
WalletV5BetaActions.loadOutActionV5BetaExtended = loadOutActionV5BetaExtended;
function storeOutListExtendedV5Beta(r) {
    const [d,...f] = r;
    if (!d || !(0,
    WalletV5OutActions_1$1.isOutActionExtended)(d)) {
        if (r.some(WalletV5OutActions_1$1.isOutActionExtended))
            throw new Error("Can't serialize actions list: all extended actions must be placed before out actions");
        return m=>{
            m.storeUint(0, 1).storeRef((0,
            core_1$h.beginCell)().store((0,
            core_1$h.storeOutList)(r)).endCell())
        }
    }
    return m=>{
        m.storeUint(1, 1).store(storeOutActionExtendedV5Beta(d)).storeRef((0,
        core_1$h.beginCell)().store(storeOutListExtendedV5Beta(f)).endCell())
    }
}
WalletV5BetaActions.storeOutListExtendedV5Beta = storeOutListExtendedV5Beta;
function loadOutListExtendedV5Beta(r) {
    const d = [];
    for (; r.loadUint(1); ) {
        const m = loadOutActionV5BetaExtended(r);
        d.push(m),
        r = r.loadRef().beginParse()
    }
    const f = (0,
    core_1$h.loadOutList)(r.loadRef().beginParse());
    if (f.some(m=>m.type === "setCode"))
        throw new Error("Can't deserialize actions list: only sendMsg actions are allowed for wallet v5");
    return d.concat(f)
}
WalletV5BetaActions.loadOutListExtendedV5Beta = loadOutListExtendedV5Beta;
var singer = {};
Object.defineProperty(singer, "__esModule", {
    value: !0
});
singer.signPayload = void 0;
const crypto_1$2 = requireDist();
function signPayload(r, d, f) {
    return "secretKey"in r ? f((0,
    crypto_1$2.sign)(d.endCell().hash(), r.secretKey), d) : r.signer(d.endCell()).then(m=>f(m, d))
}
singer.signPayload = signPayload;
var WalletContractV5R1$1 = {}
  , WalletV5R1WalletId = {};
Object.defineProperty(WalletV5R1WalletId, "__esModule", {
    value: !0
});
WalletV5R1WalletId.storeWalletIdV5R1 = WalletV5R1WalletId.loadWalletIdV5R1 = WalletV5R1WalletId.isWalletIdV5R1ClientContext = void 0;
const core_1$g = dist$1;
function isWalletIdV5R1ClientContext(r) {
    return typeof r != "number"
}
WalletV5R1WalletId.isWalletIdV5R1ClientContext = isWalletIdV5R1ClientContext;
const walletV5R1VersionsSerialisation = {
    v5r1: 0
};
function loadWalletIdV5R1(r, d) {
    var ee;
    const f = new core_1$g.BitReader(new core_1$g.BitString(typeof r == "bigint" ? Buffer.from(r.toString(16), "hex") : r instanceof core_1$g.Slice ? r.loadBuffer(4) : r,0,32)).loadInt(32)
      , m = BigInt(f) ^ BigInt(d)
      , k = (0,
    core_1$g.beginCell)().storeInt(m, 32).endCell().beginParse();
    if (k.loadUint(1)) {
        const dt = k.loadInt(8)
          , mt = k.loadUint(8)
          , yt = k.loadUint(15)
          , pt = (ee = Object.entries(walletV5R1VersionsSerialisation).find(([bt,wt])=>wt === mt)) == null ? void 0 : ee[0];
        if (pt === void 0)
            throw new Error(`Can't deserialize walletId: unknown wallet version ${mt}`);
        return {
            networkGlobalId: d,
            context: {
                walletVersion: pt,
                workChain: dt,
                subwalletNumber: yt
            }
        }
    } else {
        const dt = k.loadUint(31);
        return {
            networkGlobalId: d,
            context: dt
        }
    }
}
WalletV5R1WalletId.loadWalletIdV5R1 = loadWalletIdV5R1;
function storeWalletIdV5R1(r) {
    return d=>{
        let f;
        return isWalletIdV5R1ClientContext(r.context) ? f = (0,
        core_1$g.beginCell)().storeUint(1, 1).storeInt(r.context.workChain, 8).storeUint(walletV5R1VersionsSerialisation[r.context.walletVersion], 8).storeUint(r.context.subwalletNumber, 15).endCell().beginParse().loadInt(32) : f = (0,
        core_1$g.beginCell)().storeUint(0, 1).storeUint(r.context, 31).endCell().beginParse().loadInt(32),
        d.storeInt(BigInt(r.networkGlobalId) ^ BigInt(f), 32)
    }
}
WalletV5R1WalletId.storeWalletIdV5R1 = storeWalletIdV5R1;
var hasRequiredWalletContractV5R1;
function requireWalletContractV5R1() {
    if (hasRequiredWalletContractV5R1)
        return WalletContractV5R1$1;
    hasRequiredWalletContractV5R1 = 1,
    Object.defineProperty(WalletContractV5R1$1, "__esModule", {
        value: !0
    }),
    WalletContractV5R1$1.WalletContractV5R1 = void 0;
    const r = dist$1
      , d = requireCreateWalletTransfer()
      , f = WalletV5R1WalletId;
    class m {
        static create(y) {
            var dt, mt, yt;
            let ee = 0;
            return "workChain"in y && y.workChain != null && (ee = y.workChain),
            (dt = y.walletId) != null && dt.context && (0,
            f.isWalletIdV5R1ClientContext)(y.walletId.context) && y.walletId.context.workChain != null && (ee = y.walletId.context.workChain),
            new m(ee,y.publicKey,{
                networkGlobalId: ((mt = y.walletId) == null ? void 0 : mt.networkGlobalId) ?? -239,
                context: ((yt = y.walletId) == null ? void 0 : yt.context) ?? {
                    workChain: 0,
                    walletVersion: "v5r1",
                    subwalletNumber: 0
                }
            })
        }
        constructor(y, ee, dt) {
            this.publicKey = ee,
            this.walletId = dt,
            this.walletId = dt;
            let mt = r.Cell.fromBoc(Buffer.from("b5ee9c7241021401000281000114ff00f4a413f4bcf2c80b01020120020d020148030402dcd020d749c120915b8f6320d70b1f2082106578746ebd21821073696e74bdb0925f03e082106578746eba8eb48020d72101d074d721fa4030fa44f828fa443058bd915be0ed44d0810141d721f4058307f40e6fa1319130e18040d721707fdb3ce03120d749810280b99130e070e2100f020120050c020120060902016e07080019adce76a2684020eb90eb85ffc00019af1df6a2684010eb90eb858fc00201480a0b0017b325fb51341c75c875c2c7e00011b262fb513435c280200019be5f0f6a2684080a0eb90fa02c0102f20e011e20d70b1f82107369676ebaf2e08a7f0f01e68ef0eda2edfb218308d722028308d723208020d721d31fd31fd31fed44d0d200d31f20d31fd3ffd70a000af90140ccf9109a28945f0adb31e1f2c087df02b35007b0f2d0845125baf2e0855036baf2e086f823bbf2d0882292f800de01a47fc8ca00cb1f01cf16c9ed542092f80fde70db3cd81003f6eda2edfb02f404216e926c218e4c0221d73930709421c700b38e2d01d72820761e436c20d749c008f2e09320d74ac002f2e09320d71d06c712c2005230b0f2d089d74cd7393001a4e86c128407bbf2e093d74ac000f2e093ed55e2d20001c000915be0ebd72c08142091709601d72c081c12e25210b1e30f20d74a111213009601fa4001fa44f828fa443058baf2e091ed44d0810141d718f405049d7fc8ca0040048307f453f2e08b8e14038307f45bf2e08c22d70a00216e01b3b0f2d090e2c85003cf1612f400c9ed54007230d72c08248e2d21f2e092d200ed44d0d2005113baf2d08f54503091319c01810140d721d70a00f2e08ee2c8ca0058cf16c9ed5493f2c08de20010935bdb31e1d74cd0b4d6c35e", "hex"))[0]
              , yt = (0,
            r.beginCell)().storeUint(1, 1).storeUint(0, 32).store((0,
            f.storeWalletIdV5R1)(this.walletId)).storeBuffer(this.publicKey, 32).storeBit(0).endCell();
            this.init = {
                code: mt,
                data: yt
            },
            this.address = (0,
            r.contractAddress)(y, {
                code: mt,
                data: yt
            })
        }
        async getBalance(y) {
            return (await y.getState()).balance
        }
        async getSeqno(y) {
            return (await y.getState()).state.type === "active" ? (await y.get("seqno", [])).stack.readNumber() : 0
        }
        async getExtensions(y) {
            return (await y.getState()).state.type === "active" ? (await y.get("get_extensions", [])).stack.readCellOpt() : null
        }
        async getExtensionsArray(y) {
            const ee = await this.getExtensions(y);
            return ee ? r.Dictionary.loadDirect(r.Dictionary.Keys.BigUint(256), r.Dictionary.Values.BigInt(1), ee).keys().map(mt=>{
                const yt = this.address.workChain;
                return r.Address.parseRaw(`${yt}:${mt.toString(16).padStart(64, "0")}`)
            }
            ) : []
        }
        async getIsSecretKeyAuthEnabled(y) {
            return (await y.get("is_signature_allowed", [])).stack.readBoolean()
        }
        async send(y, ee) {
            await y.external(ee)
        }
        async sendTransfer(y, ee) {
            const dt = await this.createTransfer(ee);
            await this.send(y, dt)
        }
        async sendAddExtension(y, ee) {
            const dt = await this.createAddExtension(ee);
            await this.send(y, dt)
        }
        async sendRemoveExtension(y, ee) {
            const dt = await this.createRemoveExtension(ee);
            await this.send(y, dt)
        }
        createActions(y) {
            return y.messages.map(dt=>({
                type: "sendMsg",
                mode: y.sendMode,
                outMsg: dt
            }))
        }
        createTransfer(y) {
            return this.createRequest({
                actions: this.createActions({
                    messages: y.messages,
                    sendMode: y.sendMode
                }),
                ...y
            })
        }
        createAddExtension(y) {
            return this.createRequest({
                actions: [{
                    type: "addExtension",
                    address: y.extensionAddress
                }],
                ...y
            })
        }
        createRemoveExtension(y) {
            return this.createRequest({
                actions: [{
                    type: "removeExtension",
                    address: y.extensionAddress
                }],
                ...y
            })
        }
        createRequest(y) {
            return y.authType === "extension" ? (0,
            d.createWalletTransferV5R1)(y) : (0,
            d.createWalletTransferV5R1)({
                ...y,
                walletId: (0,
                f.storeWalletIdV5R1)(this.walletId)
            })
        }
        sender(y, ee) {
            return {
                send: async dt=>{
                    let mt = await this.getSeqno(y)
                      , yt = this.createTransfer({
                        seqno: mt,
                        secretKey: ee,
                        sendMode: dt.sendMode ?? r.SendMode.PAY_GAS_SEPARATELY + r.SendMode.IGNORE_ERRORS,
                        messages: [(0,
                        r.internal)({
                            to: dt.to,
                            value: dt.value,
                            init: dt.init,
                            body: dt.body,
                            bounce: dt.bounce
                        })]
                    });
                    await this.send(y, yt)
                }
            }
        }
    }
    return WalletContractV5R1$1.WalletContractV5R1 = m,
    m.OpCodes = {
        auth_extension: 1702392942,
        auth_signed_external: 1936287598,
        auth_signed_internal: 1936289396
    },
    WalletContractV5R1$1
}
var WalletV5R1Actions = {};
Object.defineProperty(WalletV5R1Actions, "__esModule", {
    value: !0
});
WalletV5R1Actions.patchV5R1ActionsSendMode = WalletV5R1Actions.toSafeV5R1SendMode = WalletV5R1Actions.loadOutListExtendedV5R1 = WalletV5R1Actions.storeOutListExtendedV5R1 = WalletV5R1Actions.loadOutActionExtendedV5R1 = WalletV5R1Actions.storeOutActionExtendedV5R1 = void 0;
const core_1$f = dist$1
  , WalletV5OutActions_1 = WalletV5OutActions
  , outActionSetIsPublicKeyEnabledTag = 4;
function storeOutActionSetIsPublicKeyEnabled(r) {
    return d=>{
        d.storeUint(outActionSetIsPublicKeyEnabledTag, 8).storeUint(r.isEnabled ? 1 : 0, 1)
    }
}
const outActionAddExtensionTag = 2;
function storeOutActionAddExtension(r) {
    return d=>{
        d.storeUint(outActionAddExtensionTag, 8).storeAddress(r.address)
    }
}
const outActionRemoveExtensionTag = 3;
function storeOutActionRemoveExtension(r) {
    return d=>{
        d.storeUint(outActionRemoveExtensionTag, 8).storeAddress(r.address)
    }
}
function storeOutActionExtendedV5R1(r) {
    switch (r.type) {
    case "setIsPublicKeyEnabled":
        return storeOutActionSetIsPublicKeyEnabled(r);
    case "addExtension":
        return storeOutActionAddExtension(r);
    case "removeExtension":
        return storeOutActionRemoveExtension(r);
    default:
        throw new Error("Unknown action type" + (r == null ? void 0 : r.type))
    }
}
WalletV5R1Actions.storeOutActionExtendedV5R1 = storeOutActionExtendedV5R1;
function loadOutActionExtendedV5R1(r) {
    const d = r.loadUint(8);
    switch (d) {
    case outActionSetIsPublicKeyEnabledTag:
        return {
            type: "setIsPublicKeyEnabled",
            isEnabled: !!r.loadUint(1)
        };
    case outActionAddExtensionTag:
        return {
            type: "addExtension",
            address: r.loadAddress()
        };
    case outActionRemoveExtensionTag:
        return {
            type: "removeExtension",
            address: r.loadAddress()
        };
    default:
        throw new Error(`Unknown extended out action tag 0x${d.toString(16)}`)
    }
}
WalletV5R1Actions.loadOutActionExtendedV5R1 = loadOutActionExtendedV5R1;
function storeOutListExtendedV5R1(r) {
    const d = r.filter(WalletV5OutActions_1.isOutActionExtended)
      , f = r.filter(WalletV5OutActions_1.isOutActionBasic);
    return m=>{
        const k = f.length ? (0,
        core_1$f.beginCell)().store((0,
        core_1$f.storeOutList)(f.slice().reverse())) : null;
        if (m.storeMaybeRef(k),
        d.length === 0)
            m.storeUint(0, 1);
        else {
            const [y,...ee] = d;
            m.storeUint(1, 1).store(storeOutActionExtendedV5R1(y)),
            ee.length > 0 && m.storeRef(packExtendedActionsRec(ee))
        }
    }
}
WalletV5R1Actions.storeOutListExtendedV5R1 = storeOutListExtendedV5R1;
function packExtendedActionsRec(r) {
    const [d,...f] = r;
    let m = (0,
    core_1$f.beginCell)().store(storeOutActionExtendedV5R1(d));
    return f.length > 0 && (m = m.storeRef(packExtendedActionsRec(f))),
    m.endCell()
}
function loadOutListExtendedV5R1(r) {
    const d = []
      , f = r.loadMaybeRef();
    if (f) {
        const m = (0,
        core_1$f.loadOutList)(f.beginParse());
        if (m.some(k=>k.type !== "sendMsg"))
            throw new Error("Can't deserialize actions list: only sendMsg actions are allowed for wallet v5r1");
        d.push(...m)
    }
    if (r.loadBoolean()) {
        const m = loadOutActionExtendedV5R1(r);
        d.push(m)
    }
    for (; r.remainingRefs > 0; ) {
        r = r.loadRef().beginParse();
        const m = loadOutActionExtendedV5R1(r);
        d.push(m)
    }
    return d
}
WalletV5R1Actions.loadOutListExtendedV5R1 = loadOutListExtendedV5R1;
function toSafeV5R1SendMode(r, d) {
    return d === "internal" || d === "extension" ? r : r | core_1$f.SendMode.IGNORE_ERRORS
}
WalletV5R1Actions.toSafeV5R1SendMode = toSafeV5R1SendMode;
function patchV5R1ActionsSendMode(r, d) {
    return r.map(f=>f.type === "sendMsg" ? {
        ...f,
        mode: toSafeV5R1SendMode(f.mode, d)
    } : f)
}
WalletV5R1Actions.patchV5R1ActionsSendMode = patchV5R1ActionsSendMode;
var hasRequiredCreateWalletTransfer;
function requireCreateWalletTransfer() {
    if (hasRequiredCreateWalletTransfer)
        return createWalletTransfer;
    hasRequiredCreateWalletTransfer = 1,
    Object.defineProperty(createWalletTransfer, "__esModule", {
        value: !0
    }),
    createWalletTransfer.createWalletTransferV5R1 = createWalletTransfer.createWalletTransferV5Beta = createWalletTransfer.createWalletTransferV4 = createWalletTransfer.createWalletTransferV3 = createWalletTransfer.createWalletTransferV2 = createWalletTransfer.createWalletTransferV1 = void 0;
    const r = dist$1
      , d = requireDist()
      , f = requireWalletContractV5Beta()
      , m = WalletV5BetaActions
      , k = singer
      , y = requireWalletContractV5R1()
      , ee = WalletV5R1Actions;
    function dt(Ct, Pt) {
        return (0,
        r.beginCell)().storeBuffer(Ct).storeBuilder(Pt).endCell()
    }
    function mt(Ct, Pt) {
        return (0,
        r.beginCell)().storeBuilder(Pt).storeBuffer(Ct).endCell()
    }
    function yt(Ct) {
        let Pt = (0,
        r.beginCell)().storeUint(Ct.seqno, 32);
        Ct.message && (Pt.storeUint(Ct.sendMode, 8),
        Pt.storeRef((0,
        r.beginCell)().store((0,
        r.storeMessageRelaxed)(Ct.message))));
        let $t = (0,
        d.sign)(Pt.endCell().hash(), Ct.secretKey);
        return (0,
        r.beginCell)().storeBuffer($t).storeBuilder(Pt).endCell()
    }
    createWalletTransfer.createWalletTransferV1 = yt;
    function pt(Ct) {
        if (Ct.messages.length > 4)
            throw Error("Maximum number of messages in a single transfer is 4");
        let Pt = (0,
        r.beginCell)().storeUint(Ct.seqno, 32);
        if (Ct.seqno === 0)
            for (let Nt = 0; Nt < 32; Nt++)
                Pt.storeBit(1);
        else
            Pt.storeUint(Ct.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
        for (let Nt of Ct.messages)
            Pt.storeUint(Ct.sendMode, 8),
            Pt.storeRef((0,
            r.beginCell)().store((0,
            r.storeMessageRelaxed)(Nt)));
        let $t = (0,
        d.sign)(Pt.endCell().hash(), Ct.secretKey);
        return (0,
        r.beginCell)().storeBuffer($t).storeBuilder(Pt).endCell()
    }
    createWalletTransfer.createWalletTransferV2 = pt;
    function bt(Ct) {
        if (Ct.messages.length > 4)
            throw Error("Maximum number of messages in a single transfer is 4");
        let Pt = (0,
        r.beginCell)().storeUint(Ct.walletId, 32);
        if (Ct.seqno === 0)
            for (let $t = 0; $t < 32; $t++)
                Pt.storeBit(1);
        else
            Pt.storeUint(Ct.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
        Pt.storeUint(Ct.seqno, 32);
        for (let $t of Ct.messages)
            Pt.storeUint(Ct.sendMode, 8),
            Pt.storeRef((0,
            r.beginCell)().store((0,
            r.storeMessageRelaxed)($t)));
        return (0,
        k.signPayload)(Ct, Pt, dt)
    }
    createWalletTransfer.createWalletTransferV3 = bt;
    function wt(Ct) {
        if (Ct.messages.length > 4)
            throw Error("Maximum number of messages in a single transfer is 4");
        let Pt = (0,
        r.beginCell)().storeUint(Ct.walletId, 32);
        if (Ct.seqno === 0)
            for (let $t = 0; $t < 32; $t++)
                Pt.storeBit(1);
        else
            Pt.storeUint(Ct.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
        Pt.storeUint(Ct.seqno, 32),
        Pt.storeUint(0, 8);
        for (let $t of Ct.messages)
            Pt.storeUint(Ct.sendMode, 8),
            Pt.storeRef((0,
            r.beginCell)().store((0,
            r.storeMessageRelaxed)($t)));
        return (0,
        k.signPayload)(Ct, Pt, dt)
    }
    createWalletTransfer.createWalletTransferV4 = wt;
    function xt(Ct) {
        if (Ct.actions.length > 255)
            throw Error("Maximum number of OutActions in a single request is 255");
        if (Ct.authType === "extension")
            return (0,
            r.beginCell)().storeUint(f.WalletContractV5Beta.OpCodes.auth_extension, 32).store((0,
            m.storeOutListExtendedV5Beta)(Ct.actions)).endCell();
        const Pt = (0,
        r.beginCell)().storeUint(Ct.authType === "internal" ? f.WalletContractV5Beta.OpCodes.auth_signed_internal : f.WalletContractV5Beta.OpCodes.auth_signed_external, 32).store(Ct.walletId);
        if (Ct.seqno === 0)
            for (let $t = 0; $t < 32; $t++)
                Pt.storeBit(1);
        else
            Pt.storeUint(Ct.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
        return Pt.storeUint(Ct.seqno, 32).store((0,
        m.storeOutListExtendedV5Beta)(Ct.actions)),
        (0,
        k.signPayload)(Ct, Pt, mt)
    }
    createWalletTransfer.createWalletTransferV5Beta = xt;
    function At(Ct) {
        if (Ct.actions.length > 255)
            throw Error("Maximum number of OutActions in a single request is 255");
        if (Ct = {
            ...Ct
        },
        Ct.authType === "extension")
            return (0,
            r.beginCell)().storeUint(y.WalletContractV5R1.OpCodes.auth_extension, 32).storeUint(Ct.queryId ?? 0, 64).store((0,
            ee.storeOutListExtendedV5R1)(Ct.actions)).endCell();
        Ct.actions = (0,
        ee.patchV5R1ActionsSendMode)(Ct.actions, Ct.authType);
        const Pt = (0,
        r.beginCell)().storeUint(Ct.authType === "internal" ? y.WalletContractV5R1.OpCodes.auth_signed_internal : y.WalletContractV5R1.OpCodes.auth_signed_external, 32).store(Ct.walletId);
        if (Ct.seqno === 0)
            for (let $t = 0; $t < 32; $t++)
                Pt.storeBit(1);
        else
            Pt.storeUint(Ct.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
        return Pt.storeUint(Ct.seqno, 32).store((0,
        ee.storeOutListExtendedV5R1)(Ct.actions)),
        (0,
        k.signPayload)(Ct, Pt, mt)
    }
    return createWalletTransfer.createWalletTransferV5R1 = At,
    createWalletTransfer
}
Object.defineProperty(WalletContractV1R1$1, "__esModule", {
    value: !0
});
WalletContractV1R1$1.WalletContractV1R1 = void 0;
const core_1$e = dist$1
  , createWalletTransfer_1$7 = requireCreateWalletTransfer();
class WalletContractV1R1 {
    static create(d) {
        return new WalletContractV1R1(d.workchain,d.publicKey)
    }
    constructor(d, f) {
        this.workchain = d,
        this.publicKey = f;
        let m = core_1$e.Cell.fromBoc(Buffer.from("te6cckEBAQEARAAAhP8AIN2k8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVEH98Ik=", "base64"))[0]
          , k = (0,
        core_1$e.beginCell)().storeUint(0, 32).storeBuffer(f).endCell();
        this.init = {
            code: m,
            data: k
        },
        this.address = (0,
        core_1$e.contractAddress)(d, {
            code: m,
            data: k
        })
    }
    async getBalance(d) {
        return (await d.getState()).balance
    }
    async getSeqno(d) {
        let f = await d.getState();
        return f.state.type === "active" ? core_1$e.Cell.fromBoc(f.state.data)[0].beginParse().loadUint(32) : 0
    }
    async send(d, f) {
        await d.external(f)
    }
    async sendTransfer(d, f) {
        let m = this.createTransfer(f);
        await this.send(d, m)
    }
    createTransfer(d) {
        let f = core_1$e.SendMode.PAY_GAS_SEPARATELY;
        return d.sendMode !== null && d.sendMode !== void 0 && (f = d.sendMode),
        (0,
        createWalletTransfer_1$7.createWalletTransferV1)({
            seqno: d.seqno,
            sendMode: f,
            secretKey: d.secretKey,
            message: d.message
        })
    }
    sender(d, f) {
        return {
            send: async m=>{
                let k = await this.getSeqno(d)
                  , y = this.createTransfer({
                    seqno: k,
                    secretKey: f,
                    sendMode: m.sendMode,
                    message: (0,
                    core_1$e.internal)({
                        to: m.to,
                        value: m.value,
                        init: m.init,
                        body: m.body,
                        bounce: m.bounce
                    })
                });
                await this.send(d, y)
            }
        }
    }
}
WalletContractV1R1$1.WalletContractV1R1 = WalletContractV1R1;
var WalletContractV1R2$1 = {};
Object.defineProperty(WalletContractV1R2$1, "__esModule", {
    value: !0
});
WalletContractV1R2$1.WalletContractV1R2 = void 0;
const core_1$d = dist$1
  , createWalletTransfer_1$6 = requireCreateWalletTransfer();
class WalletContractV1R2 {
    static create(d) {
        return new WalletContractV1R2(d.workchain,d.publicKey)
    }
    constructor(d, f) {
        this.workchain = d,
        this.publicKey = f;
        let m = core_1$d.Cell.fromBoc(Buffer.from("te6cckEBAQEAUwAAov8AIN0gggFMl7qXMO1E0NcLH+Ck8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVNDieG8=", "base64"))[0]
          , k = (0,
        core_1$d.beginCell)().storeUint(0, 32).storeBuffer(f).endCell();
        this.init = {
            code: m,
            data: k
        },
        this.address = (0,
        core_1$d.contractAddress)(d, {
            code: m,
            data: k
        })
    }
    async getBalance(d) {
        return (await d.getState()).balance
    }
    async getSeqno(d) {
        return (await d.getState()).state.type === "active" ? (await d.get("seqno", [])).stack.readNumber() : 0
    }
    async send(d, f) {
        await d.external(f)
    }
    async sendTransfer(d, f) {
        let m = this.createTransfer(f);
        await this.send(d, m)
    }
    createTransfer(d) {
        let f = core_1$d.SendMode.PAY_GAS_SEPARATELY;
        return d.sendMode !== null && d.sendMode !== void 0 && (f = d.sendMode),
        (0,
        createWalletTransfer_1$6.createWalletTransferV1)({
            seqno: d.seqno,
            sendMode: f,
            secretKey: d.secretKey,
            message: d.message
        })
    }
    sender(d, f) {
        return {
            send: async m=>{
                let k = await this.getSeqno(d)
                  , y = this.createTransfer({
                    seqno: k,
                    secretKey: f,
                    sendMode: m.sendMode,
                    message: (0,
                    core_1$d.internal)({
                        to: m.to,
                        value: m.value,
                        init: m.init,
                        body: m.body,
                        bounce: m.bounce
                    })
                });
                await this.send(d, y)
            }
        }
    }
}
WalletContractV1R2$1.WalletContractV1R2 = WalletContractV1R2;
var WalletContractV1R3$1 = {};
Object.defineProperty(WalletContractV1R3$1, "__esModule", {
    value: !0
});
WalletContractV1R3$1.WalletContractV1R3 = void 0;
const core_1$c = dist$1
  , createWalletTransfer_1$5 = requireCreateWalletTransfer();
class WalletContractV1R3 {
    static create(d) {
        return new WalletContractV1R3(d.workchain,d.publicKey)
    }
    constructor(d, f) {
        this.workchain = d,
        this.publicKey = f;
        let m = core_1$c.Cell.fromBoc(Buffer.from("te6cckEBAQEAXwAAuv8AIN0gggFMl7ohggEznLqxnHGw7UTQ0x/XC//jBOCk8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVLW4bkI=", "base64"))[0]
          , k = (0,
        core_1$c.beginCell)().storeUint(0, 32).storeBuffer(f).endCell();
        this.init = {
            code: m,
            data: k
        },
        this.address = (0,
        core_1$c.contractAddress)(d, {
            code: m,
            data: k
        })
    }
    async getBalance(d) {
        return (await d.getState()).balance
    }
    async getSeqno(d) {
        return (await d.getState()).state.type === "active" ? (await d.get("seqno", [])).stack.readNumber() : 0
    }
    async send(d, f) {
        await d.external(f)
    }
    async sendTransfer(d, f) {
        let m = this.createTransfer(f);
        await this.send(d, m)
    }
    createTransfer(d) {
        let f = core_1$c.SendMode.PAY_GAS_SEPARATELY;
        return d.sendMode !== null && d.sendMode !== void 0 && (f = d.sendMode),
        (0,
        createWalletTransfer_1$5.createWalletTransferV1)({
            seqno: d.seqno,
            sendMode: f,
            secretKey: d.secretKey,
            message: d.message
        })
    }
    sender(d, f) {
        return {
            send: async m=>{
                let k = await this.getSeqno(d)
                  , y = this.createTransfer({
                    seqno: k,
                    secretKey: f,
                    sendMode: m.sendMode,
                    message: (0,
                    core_1$c.internal)({
                        to: m.to,
                        value: m.value,
                        init: m.init,
                        body: m.body,
                        bounce: m.bounce
                    })
                });
                await this.send(d, y)
            }
        }
    }
}
WalletContractV1R3$1.WalletContractV1R3 = WalletContractV1R3;
var WalletContractV2R1$1 = {};
Object.defineProperty(WalletContractV2R1$1, "__esModule", {
    value: !0
});
WalletContractV2R1$1.WalletContractV2R1 = void 0;
const core_1$b = dist$1
  , createWalletTransfer_1$4 = requireCreateWalletTransfer();
class WalletContractV2R1 {
    static create(d) {
        return new WalletContractV2R1(d.workchain,d.publicKey)
    }
    constructor(d, f) {
        this.workchain = d,
        this.publicKey = f;
        let m = core_1$b.Cell.fromBoc(Buffer.from("te6cckEBAQEAVwAAqv8AIN0gggFMl7qXMO1E0NcLH+Ck8mCDCNcYINMf0x8B+CO78mPtRNDTH9P/0VExuvKhA/kBVBBC+RDyovgAApMg10qW0wfUAvsA6NGkyMsfy//J7VShNwu2", "base64"))[0]
          , k = (0,
        core_1$b.beginCell)().storeUint(0, 32).storeBuffer(f).endCell();
        this.init = {
            code: m,
            data: k
        },
        this.address = (0,
        core_1$b.contractAddress)(d, {
            code: m,
            data: k
        })
    }
    async getBalance(d) {
        return (await d.getState()).balance
    }
    async getSeqno(d) {
        return (await d.getState()).state.type === "active" ? (await d.get("seqno", [])).stack.readNumber() : 0
    }
    async send(d, f) {
        await d.external(f)
    }
    async sendTransfer(d, f) {
        let m = this.createTransfer(f);
        await this.send(d, m)
    }
    createTransfer(d) {
        let f = core_1$b.SendMode.PAY_GAS_SEPARATELY;
        return d.sendMode !== null && d.sendMode !== void 0 && (f = d.sendMode),
        (0,
        createWalletTransfer_1$4.createWalletTransferV2)({
            seqno: d.seqno,
            sendMode: f,
            secretKey: d.secretKey,
            messages: d.messages,
            timeout: d.timeout
        })
    }
    sender(d, f) {
        return {
            send: async m=>{
                let k = await this.getSeqno(d)
                  , y = this.createTransfer({
                    seqno: k,
                    secretKey: f,
                    sendMode: m.sendMode,
                    messages: [(0,
                    core_1$b.internal)({
                        to: m.to,
                        value: m.value,
                        init: m.init,
                        body: m.body,
                        bounce: m.bounce
                    })]
                });
                await this.send(d, y)
            }
        }
    }
}
WalletContractV2R1$1.WalletContractV2R1 = WalletContractV2R1;
var WalletContractV2R2$1 = {};
Object.defineProperty(WalletContractV2R2$1, "__esModule", {
    value: !0
});
WalletContractV2R2$1.WalletContractV2R2 = void 0;
const core_1$a = dist$1
  , createWalletTransfer_1$3 = requireCreateWalletTransfer();
class WalletContractV2R2 {
    static create(d) {
        return new WalletContractV2R2(d.workchain,d.publicKey)
    }
    constructor(d, f) {
        this.workchain = d,
        this.publicKey = f;
        let m = core_1$a.Cell.fromBoc(Buffer.from("te6cckEBAQEAYwAAwv8AIN0gggFMl7ohggEznLqxnHGw7UTQ0x/XC//jBOCk8mCDCNcYINMf0x8B+CO78mPtRNDTH9P/0VExuvKhA/kBVBBC+RDyovgAApMg10qW0wfUAvsA6NGkyMsfy//J7VQETNeh", "base64"))[0]
          , k = (0,
        core_1$a.beginCell)().storeUint(0, 32).storeBuffer(f).endCell();
        this.init = {
            code: m,
            data: k
        },
        this.address = (0,
        core_1$a.contractAddress)(d, {
            code: m,
            data: k
        })
    }
    async getBalance(d) {
        return (await d.getState()).balance
    }
    async getSeqno(d) {
        return (await d.getState()).state.type === "active" ? (await d.get("seqno", [])).stack.readNumber() : 0
    }
    async send(d, f) {
        await d.external(f)
    }
    async sendTransfer(d, f) {
        let m = this.createTransfer(f);
        await this.send(d, m)
    }
    createTransfer(d) {
        let f = core_1$a.SendMode.PAY_GAS_SEPARATELY;
        return d.sendMode !== null && d.sendMode !== void 0 && (f = d.sendMode),
        (0,
        createWalletTransfer_1$3.createWalletTransferV2)({
            seqno: d.seqno,
            sendMode: f,
            secretKey: d.secretKey,
            messages: d.messages,
            timeout: d.timeout
        })
    }
    sender(d, f) {
        return {
            send: async m=>{
                let k = await this.getSeqno(d)
                  , y = this.createTransfer({
                    seqno: k,
                    secretKey: f,
                    sendMode: m.sendMode,
                    messages: [(0,
                    core_1$a.internal)({
                        to: m.to,
                        value: m.value,
                        init: m.init,
                        body: m.body,
                        bounce: m.bounce
                    })]
                });
                await this.send(d, y)
            }
        }
    }
}
WalletContractV2R2$1.WalletContractV2R2 = WalletContractV2R2;
var WalletContractV3R1$1 = {};
Object.defineProperty(WalletContractV3R1$1, "__esModule", {
    value: !0
});
WalletContractV3R1$1.WalletContractV3R1 = void 0;
const core_1$9 = dist$1
  , createWalletTransfer_1$2 = requireCreateWalletTransfer();
class WalletContractV3R1 {
    static create(d) {
        return new WalletContractV3R1(d.workchain,d.publicKey,d.walletId)
    }
    constructor(d, f, m) {
        this.workchain = d,
        this.publicKey = f,
        m != null ? this.walletId = m : this.walletId = 698983191 + d;
        let k = core_1$9.Cell.fromBoc(Buffer.from("te6cckEBAQEAYgAAwP8AIN0gggFMl7qXMO1E0NcLH+Ck8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVD++buA=", "base64"))[0]
          , y = (0,
        core_1$9.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(f).endCell();
        this.init = {
            code: k,
            data: y
        },
        this.address = (0,
        core_1$9.contractAddress)(d, {
            code: k,
            data: y
        })
    }
    async getBalance(d) {
        return (await d.getState()).balance
    }
    async getSeqno(d) {
        return (await d.getState()).state.type === "active" ? (await d.get("seqno", [])).stack.readNumber() : 0
    }
    async send(d, f) {
        await d.external(f)
    }
    async sendTransfer(d, f) {
        let m = this.createTransfer(f);
        await this.send(d, m)
    }
    createTransfer(d) {
        return (0,
        createWalletTransfer_1$2.createWalletTransferV3)({
            ...d,
            sendMode: d.sendMode ?? core_1$9.SendMode.PAY_GAS_SEPARATELY,
            walletId: this.walletId
        })
    }
    sender(d, f) {
        return {
            send: async m=>{
                let k = await this.getSeqno(d)
                  , y = this.createTransfer({
                    seqno: k,
                    secretKey: f,
                    sendMode: m.sendMode,
                    messages: [(0,
                    core_1$9.internal)({
                        to: m.to,
                        value: m.value,
                        init: m.init,
                        body: m.body,
                        bounce: m.bounce
                    })]
                });
                await this.send(d, y)
            }
        }
    }
}
WalletContractV3R1$1.WalletContractV3R1 = WalletContractV3R1;
var WalletContractV3R2$1 = {};
Object.defineProperty(WalletContractV3R2$1, "__esModule", {
    value: !0
});
WalletContractV3R2$1.WalletContractV3R2 = void 0;
const core_1$8 = dist$1
  , createWalletTransfer_1$1 = requireCreateWalletTransfer();
class WalletContractV3R2 {
    static create(d) {
        return new WalletContractV3R2(d.workchain,d.publicKey,d.walletId)
    }
    constructor(d, f, m) {
        this.workchain = d,
        this.publicKey = f,
        m != null ? this.walletId = m : this.walletId = 698983191 + d;
        let k = core_1$8.Cell.fromBoc(Buffer.from("te6cckEBAQEAcQAA3v8AIN0gggFMl7ohggEznLqxn3Gw7UTQ0x/THzHXC//jBOCk8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVBC9ba0=", "base64"))[0]
          , y = (0,
        core_1$8.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(f).endCell();
        this.init = {
            code: k,
            data: y
        },
        this.address = (0,
        core_1$8.contractAddress)(d, {
            code: k,
            data: y
        })
    }
    async getBalance(d) {
        return (await d.getState()).balance
    }
    async getSeqno(d) {
        return (await d.getState()).state.type === "active" ? (await d.get("seqno", [])).stack.readNumber() : 0
    }
    async send(d, f) {
        await d.external(f)
    }
    async sendTransfer(d, f) {
        let m = this.createTransfer(f);
        await this.send(d, m)
    }
    createTransfer(d) {
        return (0,
        createWalletTransfer_1$1.createWalletTransferV3)({
            ...d,
            sendMode: d.sendMode ?? core_1$8.SendMode.PAY_GAS_SEPARATELY,
            walletId: this.walletId
        })
    }
    sender(d, f) {
        return {
            send: async m=>{
                let k = await this.getSeqno(d)
                  , y = this.createTransfer({
                    seqno: k,
                    secretKey: f,
                    sendMode: m.sendMode,
                    messages: [(0,
                    core_1$8.internal)({
                        to: m.to,
                        value: m.value,
                        init: m.init,
                        body: m.body,
                        bounce: m.bounce
                    })]
                });
                await this.send(d, y)
            }
        }
    }
}
WalletContractV3R2$1.WalletContractV3R2 = WalletContractV3R2;
var WalletContractV4$1 = {};
Object.defineProperty(WalletContractV4$1, "__esModule", {
    value: !0
});
WalletContractV4$1.WalletContractV4 = void 0;
const core_1$7 = dist$1
  , createWalletTransfer_1 = requireCreateWalletTransfer();
class WalletContractV4 {
    static create(d) {
        return new WalletContractV4(d.workchain,d.publicKey,d.walletId)
    }
    constructor(d, f, m) {
        this.workchain = d,
        this.publicKey = f,
        m != null ? this.walletId = m : this.walletId = 698983191 + d;
        let k = core_1$7.Cell.fromBoc(Buffer.from("te6ccgECFAEAAtQAART/APSkE/S88sgLAQIBIAIDAgFIBAUE+PKDCNcYINMf0x/THwL4I7vyZO1E0NMf0x/T//QE0VFDuvKhUVG68qIF+QFUEGT5EPKj+AAkpMjLH1JAyx9SMMv/UhD0AMntVPgPAdMHIcAAn2xRkyDXSpbTB9QC+wDoMOAhwAHjACHAAuMAAcADkTDjDQOkyMsfEssfy/8QERITAubQAdDTAyFxsJJfBOAi10nBIJJfBOAC0x8hghBwbHVnvSKCEGRzdHK9sJJfBeAD+kAwIPpEAcjKB8v/ydDtRNCBAUDXIfQEMFyBAQj0Cm+hMbOSXwfgBdM/yCWCEHBsdWe6kjgw4w0DghBkc3RyupJfBuMNBgcCASAICQB4AfoA9AQw+CdvIjBQCqEhvvLgUIIQcGx1Z4MesXCAGFAEywUmzxZY+gIZ9ADLaRfLH1Jgyz8gyYBA+wAGAIpQBIEBCPRZMO1E0IEBQNcgyAHPFvQAye1UAXKwjiOCEGRzdHKDHrFwgBhQBcsFUAPPFiP6AhPLassfyz/JgED7AJJfA+ICASAKCwBZvSQrb2omhAgKBrkPoCGEcNQICEekk30pkQzmkD6f+YN4EoAbeBAUiYcVnzGEAgFYDA0AEbjJftRNDXCx+AA9sp37UTQgQFA1yH0BDACyMoHy//J0AGBAQj0Cm+hMYAIBIA4PABmtznaiaEAga5Drhf/AABmvHfaiaEAQa5DrhY/AAG7SB/oA1NQi+QAFyMoHFcv/ydB3dIAYyMsFywIizxZQBfoCFMtrEszMyXP7AMhAFIEBCPRR8qcCAHCBAQjXGPoA0z/IVCBHgQEI9FHyp4IQbm90ZXB0gBjIywXLAlAGzxZQBPoCFMtqEssfyz/Jc/sAAgBsgQEI1xj6ANM/MFIkgQEI9Fnyp4IQZHN0cnB0gBjIywXLAlAFzxZQA/oCE8tqyx8Syz/Jc/sAAAr0AMntVA==", "base64"))[0]
          , y = (0,
        core_1$7.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(this.publicKey).storeBit(0).endCell();
        this.init = {
            code: k,
            data: y
        },
        this.address = (0,
        core_1$7.contractAddress)(d, {
            code: k,
            data: y
        })
    }
    async getBalance(d) {
        return (await d.getState()).balance
    }
    async getSeqno(d) {
        return (await d.getState()).state.type === "active" ? (await d.get("seqno", [])).stack.readNumber() : 0
    }
    async send(d, f) {
        await d.external(f)
    }
    async sendTransfer(d, f) {
        let m = this.createTransfer(f);
        await this.send(d, m)
    }
    createTransfer(d) {
        return (0,
        createWalletTransfer_1.createWalletTransferV4)({
            ...d,
            sendMode: d.sendMode ?? core_1$7.SendMode.PAY_GAS_SEPARATELY,
            walletId: this.walletId
        })
    }
    sender(d, f) {
        return {
            send: async m=>{
                let k = await this.getSeqno(d)
                  , y = this.createTransfer({
                    seqno: k,
                    secretKey: f,
                    sendMode: m.sendMode,
                    messages: [(0,
                    core_1$7.internal)({
                        to: m.to,
                        value: m.value,
                        init: m.init,
                        body: m.body,
                        bounce: m.bounce
                    })]
                });
                await this.send(d, y)
            }
        }
    }
}
WalletContractV4$1.WalletContractV4 = WalletContractV4;
var WalletContractV5Beta = {};
(function(r) {
    var d = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(m, k, y, ee) {
        ee === void 0 && (ee = y);
        var dt = Object.getOwnPropertyDescriptor(k, y);
        (!dt || ("get"in dt ? !k.__esModule : dt.writable || dt.configurable)) && (dt = {
            enumerable: !0,
            get: function() {
                return k[y]
            }
        }),
        Object.defineProperty(m, ee, dt)
    }
    : function(m, k, y, ee) {
        ee === void 0 && (ee = y),
        m[ee] = k[y]
    }
    )
      , f = commonjsGlobal && commonjsGlobal.__exportStar || function(m, k) {
        for (var y in m)
            y !== "default" && !Object.prototype.hasOwnProperty.call(k, y) && d(k, m, y)
    }
    ;
    Object.defineProperty(r, "__esModule", {
        value: !0
    }),
    f(requireWalletContractV5Beta(), r),
    f(WalletV5BetaActions, r),
    f(WalletV5BetaWalletId, r)
}
)(WalletContractV5Beta);
var WalletContractV5R1 = {};
(function(r) {
    var d = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(m, k, y, ee) {
        ee === void 0 && (ee = y);
        var dt = Object.getOwnPropertyDescriptor(k, y);
        (!dt || ("get"in dt ? !k.__esModule : dt.writable || dt.configurable)) && (dt = {
            enumerable: !0,
            get: function() {
                return k[y]
            }
        }),
        Object.defineProperty(m, ee, dt)
    }
    : function(m, k, y, ee) {
        ee === void 0 && (ee = y),
        m[ee] = k[y]
    }
    )
      , f = commonjsGlobal && commonjsGlobal.__exportStar || function(m, k) {
        for (var y in m)
            y !== "default" && !Object.prototype.hasOwnProperty.call(k, y) && d(k, m, y)
    }
    ;
    Object.defineProperty(r, "__esModule", {
        value: !0
    }),
    f(requireWalletContractV5R1(), r),
    f(WalletV5R1Actions, r),
    f(WalletV5R1WalletId, r)
}
)(WalletContractV5R1);
var JettonMaster$1 = {};
Object.defineProperty(JettonMaster$1, "__esModule", {
    value: !0
});
JettonMaster$1.JettonMaster = void 0;
const core_1$6 = dist$1;
class JettonMaster {
    static create(d) {
        return new JettonMaster(d)
    }
    constructor(d) {
        this.address = d
    }
    async getWalletAddress(d, f) {
        return (await d.get("get_wallet_address", [{
            type: "slice",
            cell: (0,
            core_1$6.beginCell)().storeAddress(f).endCell()
        }])).stack.readAddress()
    }
    async getJettonData(d) {
        let f = await d.get("get_jetton_data", [])
          , m = f.stack.readBigNumber()
          , k = f.stack.readBoolean()
          , y = f.stack.readAddress()
          , ee = f.stack.readCell()
          , dt = f.stack.readCell();
        return {
            totalSupply: m,
            mintable: k,
            adminAddress: y,
            content: ee,
            walletCode: dt
        }
    }
}
JettonMaster$1.JettonMaster = JettonMaster;
var JettonWallet$2 = {};
Object.defineProperty(JettonWallet$2, "__esModule", {
    value: !0
});
JettonWallet$2.JettonWallet = void 0;
let JettonWallet$1 = class Qn {
    static create(d) {
        return new Qn(d)
    }
    constructor(d) {
        this.address = d
    }
    async getBalance(d) {
        return (await d.getState()).state.type !== "active" ? 0n : (await d.get("get_wallet_data", [])).stack.readBigNumber()
    }
}
;
JettonWallet$2.JettonWallet = JettonWallet$1;
var MultisigOrder$1 = {};
Object.defineProperty(MultisigOrder$1, "__esModule", {
    value: !0
});
MultisigOrder$1.MultisigOrder = void 0;
const crypto_1$1 = requireDist()
  , core_1$5 = dist$1;
class MultisigOrder {
    constructor(d) {
        this.signatures = {},
        this.payload = d
    }
    static fromCell(d) {
        var ee;
        let f = d.beginParse()
          , m = (ee = f.loadMaybeRef()) == null ? void 0 : ee.beginParse();
        const k = f.asCell();
        let y = new MultisigOrder(k);
        if (m) {
            for (; m.remainingBits > 0; ) {
                const dt = m.loadBuffer(64)
                  , mt = m.loadUint(8);
                y.signatures[mt] = dt,
                m.remainingRefs > 0 ? m = m.loadRef().asSlice() : m.skip(1)
            }
            m.endParse()
        }
        return y
    }
    static fromPayload(d) {
        return new MultisigOrder(d)
    }
    addSignature(d, f, m) {
        const k = this.payload.hash();
        if (!(0,
        crypto_1$1.signVerify)(k, f, m.owners.get(d).slice(0, -1)))
            throw Error("invalid signature");
        this.signatures[d] = f
    }
    sign(d, f) {
        const m = this.payload.hash();
        return this.signatures[d] = (0,
        crypto_1$1.sign)(m, f),
        m
    }
    unionSignatures(d) {
        this.signatures = Object.assign({}, this.signatures, d.signatures)
    }
    clearSignatures() {
        this.signatures = {}
    }
    toCell(d) {
        let f = (0,
        core_1$5.beginCell)().storeBit(0);
        for (const m in this.signatures) {
            const k = this.signatures[m];
            f = (0,
            core_1$5.beginCell)().storeBit(1).storeRef((0,
            core_1$5.beginCell)().storeBuffer(k).storeUint(parseInt(m), 8).storeBuilder(f).endCell())
        }
        return (0,
        core_1$5.beginCell)().storeUint(d, 8).storeBuilder(f).storeBuilder(this.payload.asBuilder()).endCell()
    }
}
MultisigOrder$1.MultisigOrder = MultisigOrder;
var MultisigOrderBuilder$1 = {};
Object.defineProperty(MultisigOrderBuilder$1, "__esModule", {
    value: !0
});
MultisigOrderBuilder$1.MultisigOrderBuilder = void 0;
const core_1$4 = dist$1
  , MultisigOrder_1 = MultisigOrder$1;
class MultisigOrderBuilder {
    constructor(d, f) {
        this.messages = (0,
        core_1$4.beginCell)(),
        this.queryId = 0n,
        this.walletId = d,
        this.queryOffset = f || 7200
    }
    addMessage(d, f) {
        if (this.messages.refs >= 4)
            throw Error("only 4 refs are allowed");
        this.updateQueryId(),
        this.messages.storeUint(f, 8),
        this.messages.storeRef((0,
        core_1$4.beginCell)().store((0,
        core_1$4.storeMessageRelaxed)(d)).endCell())
    }
    clearMessages() {
        this.messages = (0,
        core_1$4.beginCell)()
    }
    build() {
        return MultisigOrder_1.MultisigOrder.fromPayload((0,
        core_1$4.beginCell)().storeUint(this.walletId, 32).storeUint(this.queryId, 64).storeBuilder(this.messages).endCell())
    }
    updateQueryId() {
        const d = BigInt(Math.floor(Date.now() / 1e3 + this.queryOffset));
        this.queryId = d << 32n
    }
}
MultisigOrderBuilder$1.MultisigOrderBuilder = MultisigOrderBuilder;
var MultisigWallet$1 = {};
Object.defineProperty(MultisigWallet$1, "__esModule", {
    value: !0
});
MultisigWallet$1.MultisigWallet = void 0;
const crypto_1 = requireDist()
  , core_1$3 = dist$1
  , MULTISIG_CODE = core_1$3.Cell.fromBase64("te6ccgECKwEABBgAART/APSkE/S88sgLAQIBIAIDAgFIBAUE2vIgxwCOgzDbPOCDCNcYIPkBAdMH2zwiwAAToVNxePQOb6Hyn9s8VBq6+RDyoAb0BCD5AQHTH1EYuvKq0z9wUwHwCgHCCAGDCryx8mhTFYBA9A5voSCYDqQgwgryZw7f+COqH1NAufJhVCOjU04gIyEiAgLMBgcCASAMDQIBIAgJAgFmCgsAA9GEAiPymAvHoHN9CYbZ5S7Z4BPHohwhJQAtAKkItdJEqCTItdKlwLUAdAT8ArobBKAATwhbpEx4CBukTDgAdAg10rDAJrUAvALyFjPFszJ4HHXI8gBzxb0AMmACASAODwIBIBQVARW77ZbVA0cFUg2zyCoCAUgQEQIBIBITAXOxHXQgwjXGCD5AQHTB4IB1MTtQ9hTIHj0Dm+h8p/XC/9eMfkQ8qCuAfQEIW6TW3Ey4PkBWNs8AaQBgJwA9rtqA6ADoAPoCAXoCEfyAgPyA3XlP+AXkegAA54tkwAAXrhlXP8EA1WZ2oexAAgEgFhcCASAYGQFRtyVbZ4YmRmpGEAgegc30McJNhFpAADMaYeYuAFrgJhwLb+4cC3d0bhAjAYm1WZtnhqvgb+2xxsoicAgej430pBHEoFpAADHDhBACGuQkuuBk9kUWE5kAOeLKhACQCB6IYFImHFImHFImXEA2YlzNijAjAgEgGhsAF7UGtc4QQDVZnah7EAIBIBwdAgOZOB4fARGsGm2eL4G2CUAjABWt+UEAzJV2oewYQAENqTbPBVfBYCMAFa3f3CCAarM7UPYgAiDbPALyZfgAUENxQxPbPO1UIyoACtP/0wcwBKDbPC+uUyCw8mISsQKkJbNTHLmwJYEA4aojoCi8sPJpggGGoPgBBZcCERACPj4wjo0REB/bPEDXePRDEL0F4lQWW1Rz51YQU9zbPFRxClR6vCQlKCYAIO1E0NMf0wfTB9M/9AT0BNEAXgGOGjDSAAHyo9MH0wdQA9cBIPkBBfkBFbrypFAD4GwhIddKqgIi10m68qtwVCATAAwByMv/ywcE1ts87VT4D3AlblOJvrGYEG4QLVDHXwePGzBUJANQTds8UFWgRlAQSRA6SwlTuds8UFQWf+L4AAeDJaGOLCaAQPSWb6UglDBTA7neII4WODk5CNIAAZfTBzAW8AcFkTDifwgHBZJsMeKz5jAGKicoKQBgcI4pA9CDCNcY0wf0BDBTFnj0Dm+h8qXXC/9URUT5EPKmrlIgsVIDvRShI27mbCIyAH5SML6OIF8D+ACTItdKmALTB9QC+wAC6DJwyMoAQBSAQPRDAvAHjhdxyMsAFMsHEssHWM8BWM8WQBOAQPRDAeIBII6KEEUQNEMA2zztVJJfBuIqABzIyx/LB8sHyz/0APQAyQ==");
class MultisigWallet {
    constructor(d, f, m, k, y) {
        this.provider = null,
        this.owners = core_1$3.Dictionary.empty(),
        this.workchain = f,
        this.walletId = m,
        this.k = k;
        for (let ee = 0; ee < d.length; ee += 1)
            this.owners.set(ee, Buffer.concat([d[ee], Buffer.alloc(1)]));
        this.init = {
            code: MULTISIG_CODE,
            data: (0,
            core_1$3.beginCell)().storeUint(this.walletId, 32).storeUint(this.owners.size, 8).storeUint(this.k, 8).storeUint(0, 64).storeDict(this.owners, core_1$3.Dictionary.Keys.Uint(8), core_1$3.Dictionary.Values.Buffer(33)).storeBit(0).endCell()
        },
        this.address = (y == null ? void 0 : y.address) || (0,
        core_1$3.contractAddress)(f, this.init),
        y != null && y.provider ? this.provider = y.provider : y != null && y.client && (this.provider = y.client.provider(this.address, {
            code: this.init.code,
            data: this.init.data
        }))
    }
    static async fromAddress(d, f) {
        let m;
        if (f.provider)
            m = f.provider;
        else {
            if (!f.client)
                throw Error("Either provider or client must be specified");
            m = f.client.provider(d, {
                code: null,
                data: null
            })
        }
        const k = (await m.getState()).state;
        if (k.type !== "active")
            throw Error("Contract must be active");
        const y = core_1$3.Cell.fromBoc(k.data)[0].beginParse()
          , ee = y.loadUint(32);
        y.skip(8);
        const dt = y.loadUint(8);
        y.skip(64);
        const mt = y.loadDict(core_1$3.Dictionary.Keys.Uint(8), core_1$3.Dictionary.Values.Buffer(33));
        let yt = [];
        for (const [pt,bt] of mt) {
            const wt = bt.subarray(0, 32);
            yt.push(wt)
        }
        return new MultisigWallet(yt,d.workChain,ee,dt,{
            address: d,
            provider: m,
            client: f.client
        })
    }
    async deployExternal(d) {
        if (!d && !this.provider)
            throw Error("you must specify provider if there is no such property in MultisigWallet instance");
        d || (d = this.provider),
        await d.external(core_1$3.Cell.EMPTY)
    }
    async deployInternal(d, f=1000000000n) {
        await d.send({
            sendMode: core_1$3.SendMode.PAY_GAS_SEPARATELY + core_1$3.SendMode.IGNORE_ERRORS,
            to: this.address,
            value: f,
            init: this.init,
            body: core_1$3.Cell.EMPTY,
            bounce: !0
        })
    }
    async sendOrder(d, f, m) {
        if (!m && !this.provider)
            throw Error("you must specify provider if there is no such property in MultisigWallet instance");
        m || (m = this.provider);
        let k = (0,
        crypto_1.keyPairFromSecretKey)(f).publicKey
          , y = this.getOwnerIdByPubkey(k)
          , ee = d.toCell(y)
          , dt = (0,
        crypto_1.sign)(ee.hash(), f);
        ee = (0,
        core_1$3.beginCell)().storeBuffer(dt).storeSlice(ee.asSlice()).endCell(),
        await m.external(ee)
    }
    async sendOrderWithoutSecretKey(d, f, m, k) {
        if (!k && !this.provider)
            throw Error("you must specify provider if there is no such property in MultisigWallet instance");
        k || (k = this.provider);
        let y = d.toCell(m);
        y = (0,
        core_1$3.beginCell)().storeBuffer(f).storeSlice(y.asSlice()).endCell(),
        await k.external(y)
    }
    getOwnerIdByPubkey(d) {
        for (const [f,m] of this.owners)
            if (m.subarray(0, 32).equals(d))
                return f;
        throw Error("public key is not an owner")
    }
}
MultisigWallet$1.MultisigWallet = MultisigWallet;
var ElectorContract$1 = {};
Object.defineProperty(ElectorContract$1, "__esModule", {
    value: !0
});
ElectorContract$1.ElectorContract = void 0;
const core_1$2 = dist$1
  , FrozenDictValue = {
    serialize(r, d) {
        throw Error("not implemented")
    },
    parse(r) {
        const d = new core_1$2.Address(-1,r.loadBuffer(32))
          , f = r.loadUintBig(64)
          , m = r.loadCoins();
        return {
            address: d,
            weight: f,
            stake: m
        }
    }
}
  , EntitiesDictValue = {
    serialize(r, d) {
        throw Error("not implemented")
    },
    parse(r) {
        const d = r.loadCoins();
        r.skip(64);
        const f = new core_1$2.Address(-1,r.loadBuffer(32))
          , m = r.loadBuffer(32);
        return {
            stake: d,
            address: f,
            adnl: m
        }
    }
};
class ElectorContract {
    static create() {
        return new ElectorContract
    }
    constructor() {
        this.address = core_1$2.Address.parseRaw("-1:3333333333333333333333333333333333333333333333333333333333333333")
    }
    async getReturnedStake(d, f) {
        if (f.workChain !== -1)
            throw Error("Only masterchain addresses could have stake");
        return (await d.get("compute_returned_stake", [{
            type: "int",
            value: BigInt("0x" + f.hash.toString("hex"))
        }])).stack.readBigNumber()
    }
    async getPastElectionsList(d) {
        const f = await d.get("past_elections_list", [])
          , m = new core_1$2.TupleReader(f.stack.readLispList())
          , k = [];
        for (; m.remaining > 0; ) {
            const y = m.readTuple()
              , ee = y.readNumber()
              , dt = y.readNumber();
            y.pop();
            const mt = y.readNumber();
            k.push({
                id: ee,
                unfreezeAt: dt,
                stakeHeld: mt
            })
        }
        return k
    }
    async getPastElections(d) {
        const f = await d.get("past_elections", [])
          , m = new core_1$2.TupleReader(f.stack.readLispList())
          , k = [];
        for (; m.remaining > 0; ) {
            const y = m.readTuple()
              , ee = y.readNumber()
              , dt = y.readNumber()
              , mt = y.readNumber();
            y.pop();
            const yt = y.readCell()
              , pt = y.readBigNumber()
              , bt = y.readBigNumber();
            let wt = new Map;
            const xt = yt.beginParse().loadDictDirect(core_1$2.Dictionary.Keys.Buffer(32), FrozenDictValue);
            for (const [At,Ct] of xt)
                wt.set(BigInt("0x" + At.toString("hex")).toString(10), {
                    address: Ct.address,
                    weight: Ct.weight,
                    stake: Ct.stake
                });
            k.push({
                id: ee,
                unfreezeAt: dt,
                stakeHeld: mt,
                totalStake: pt,
                bonuses: bt,
                frozen: wt
            })
        }
        return k
    }
    async getElectionEntities(d) {
        const f = await d.getState();
        if (f.state.type !== "active")
            throw Error("Unexpected error");
        const k = core_1$2.Cell.fromBoc(f.state.data)[0].beginParse();
        if (!k.loadBit())
            return null;
        const y = k.loadRef().beginParse()
          , ee = y.loadUint(32)
          , dt = y.loadUint(32)
          , mt = y.loadCoins()
          , yt = y.loadCoins()
          , pt = y.loadDict(core_1$2.Dictionary.Keys.Buffer(32), EntitiesDictValue);
        let bt = [];
        if (pt)
            for (const [wt,xt] of pt)
                bt.push({
                    pubkey: wt,
                    stake: xt.stake,
                    address: xt.address,
                    adnl: xt.adnl
                });
        return {
            minStake: mt,
            allStakes: yt,
            endElectionsTime: dt,
            startWorkTime: ee,
            entities: bt
        }
    }
    async getActiveElectionId(d) {
        const m = (await d.get("active_election_id", [])).stack.readNumber();
        return m > 0 ? m : null
    }
    async getComplaints(d, f) {
        const m = new core_1$2.TupleBuilder;
        m.writeNumber(f);
        const k = await d.get("list_complaints", m.build());
        if (k.stack.peek().type === "null")
            return [];
        const y = new core_1$2.TupleReader(k.stack.readLispList())
          , ee = [];
        for (; y.remaining > 0; ) {
            const dt = y.readTuple()
              , mt = dt.readBigNumber()
              , yt = dt.readTuple()
              , pt = yt.readTuple()
              , bt = Buffer.from(pt.readBigNumber().toString(16), "hex");
            pt.readCell();
            const wt = pt.readNumber()
              , xt = pt.readNumber()
              , At = new core_1$2.Address(-1,Buffer.from(pt.readBigNumber().toString(16), "hex"))
              , Ct = pt.readBigNumber()
              , Pt = pt.readBigNumber()
              , $t = pt.readBigNumber()
              , Ot = []
              , Nt = new core_1$2.TupleReader(yt.readLispList());
            for (; Nt.remaining > 0; )
                Ot.push(Nt.readNumber());
            const zt = yt.readBigNumber()
              , Wt = yt.readBigNumber();
            ee.push({
                id: mt,
                publicKey: bt,
                createdAt: wt,
                severity: xt,
                paid: Ct,
                suggestedFine: Pt,
                suggestedFinePart: $t,
                rewardAddress: At,
                votes: Ot,
                remainingWeight: Wt,
                vsetId: zt
            })
        }
        return ee
    }
}
ElectorContract$1.ElectorContract = ElectorContract;
var ConfigParser = {};
Object.defineProperty(ConfigParser, "__esModule", {
    value: !0
});
ConfigParser.parseFullConfig = ConfigParser.loadConfigParamsAsSlice = ConfigParser.loadConfigParamById = ConfigParser.parseVotingSetup = ConfigParser.parseProposalSetup = ConfigParser.configParse29 = ConfigParser.configParse28 = ConfigParser.configParseMsgPrices = ConfigParser.configParseGasLimitsPrices = ConfigParser.configParseBridge = ConfigParser.configParseValidatorSet = ConfigParser.configParse12 = ConfigParser.configParseWorkchainDescriptor = ConfigParser.configParse40 = ConfigParser.configParse8 = ConfigParser.configParse18 = ConfigParser.configParse17 = ConfigParser.configParse16 = ConfigParser.configParse15 = ConfigParser.configParse13 = ConfigParser.configParse5 = ConfigParser.configParseMasterAddressRequired = ConfigParser.parseBridge = ConfigParser.parseValidatorSet = ConfigParser.configParseMasterAddress = void 0;
const core_1$1 = dist$1;
function configParseMasterAddress(r) {
    return r ? new core_1$1.Address(-1,r.loadBuffer(32)) : null
}
ConfigParser.configParseMasterAddress = configParseMasterAddress;
function readPublicKey(r) {
    if (r.loadUint(32) !== 2390828938)
        throw Error("Invalid config");
    return r.loadBuffer(32)
}
const ValidatorDescriptionDictValue = {
    serialize(r, d) {
        throw Error("not implemented")
    },
    parse(r) {
        const d = r.loadUint(8);
        if (d === 83)
            return {
                publicKey: readPublicKey(r),
                weight: r.loadUintBig(64),
                adnlAddress: null
            };
        if (d === 115)
            return {
                publicKey: readPublicKey(r),
                weight: r.loadUintBig(64),
                adnlAddress: r.loadBuffer(32)
            };
        throw Error("Invalid config")
    }
};
function parseValidatorSet(r) {
    const d = r.loadUint(8);
    if (d === 17) {
        const f = r.loadUint(32)
          , m = r.loadUint(32)
          , k = r.loadUint(16)
          , y = r.loadUint(16)
          , ee = r.loadDictDirect(core_1$1.Dictionary.Keys.Uint(16), ValidatorDescriptionDictValue);
        return {
            timeSince: f,
            timeUntil: m,
            total: k,
            main: y,
            totalWeight: null,
            list: ee
        }
    } else if (d === 18) {
        const f = r.loadUint(32)
          , m = r.loadUint(32)
          , k = r.loadUint(16)
          , y = r.loadUint(16)
          , ee = r.loadUintBig(64)
          , dt = r.loadDict(core_1$1.Dictionary.Keys.Uint(16), ValidatorDescriptionDictValue);
        return {
            timeSince: f,
            timeUntil: m,
            total: k,
            main: y,
            totalWeight: ee,
            list: dt
        }
    }
}
ConfigParser.parseValidatorSet = parseValidatorSet;
function parseBridge(r) {
    const d = new core_1$1.Address(-1,r.loadBuffer(32))
      , f = new core_1$1.Address(-1,r.loadBuffer(32))
      , m = r.loadDict(core_1$1.Dictionary.Keys.Buffer(32), core_1$1.Dictionary.Values.Buffer(32))
      , k = new Map;
    for (const [ee,dt] of m)
        k.set(new core_1$1.Address(-1,ee).toString(), dt);
    const y = r.loadBuffer(32);
    return {
        bridgeAddress: d,
        oracleMultisigAddress: f,
        oracles: k,
        externalChainAddress: y
    }
}
ConfigParser.parseBridge = parseBridge;
function configParseMasterAddressRequired(r) {
    if (!r)
        throw Error("Invalid config");
    return configParseMasterAddress(r)
}
ConfigParser.configParseMasterAddressRequired = configParseMasterAddressRequired;
function configParse5(r) {
    if (!r)
        throw Error("Invalid config");
    if (r.loadUint(8) === 1) {
        const f = r.loadBit() ? new core_1$1.Address(-1,r.loadBuffer(32)) : null
          , m = r.loadUint(32)
          , k = r.loadUint(32);
        return {
            blackholeAddr: f,
            feeBurnNominator: m,
            feeBurnDenominator: k
        }
    }
    throw new Error("Invalid config")
}
ConfigParser.configParse5 = configParse5;
function configParse13(r) {
    if (!r)
        throw Error("Invalid config");
    if (r.loadUint(8) === 26) {
        const f = r.loadCoins()
          , m = r.loadCoins()
          , k = r.loadCoins();
        return {
            deposit: f,
            bitPrice: m,
            cellPrice: k
        }
    }
    throw new Error("Invalid config")
}
ConfigParser.configParse13 = configParse13;
function configParse15(r) {
    if (!r)
        throw Error("Invalid config");
    const d = r.loadUint(32)
      , f = r.loadUint(32)
      , m = r.loadUint(32)
      , k = r.loadUint(32);
    return {
        validatorsElectedFor: d,
        electorsStartBefore: f,
        electorsEndBefore: m,
        stakeHeldFor: k
    }
}
ConfigParser.configParse15 = configParse15;
function configParse16(r) {
    if (!r)
        throw Error("Invalid config");
    const d = r.loadUint(16)
      , f = r.loadUint(16)
      , m = r.loadUint(16);
    return {
        maxValidators: d,
        maxMainValidators: f,
        minValidators: m
    }
}
ConfigParser.configParse16 = configParse16;
function configParse17(r) {
    if (!r)
        throw Error("Invalid config");
    const d = r.loadCoins()
      , f = r.loadCoins()
      , m = r.loadCoins()
      , k = r.loadUint(32);
    return {
        minStake: d,
        maxStake: f,
        minTotalStake: m,
        maxStakeFactor: k
    }
}
ConfigParser.configParse17 = configParse17;
const StoragePricesDictValue = {
    serialize(r, d) {
        throw Error("not implemented")
    },
    parse(r) {
        if (r.loadUint(8) !== 204)
            throw Error("Invalid config");
        const f = r.loadUint(32)
          , m = r.loadUintBig(64)
          , k = r.loadUintBig(64)
          , y = r.loadUintBig(64)
          , ee = r.loadUintBig(64);
        return {
            utime_since: f,
            bit_price_ps: m,
            cell_price_ps: k,
            mc_bit_price_ps: y,
            mc_cell_price_ps: ee
        }
    }
};
function configParse18(r) {
    if (!r)
        throw Error("Invalid config");
    return r.loadDictDirect(core_1$1.Dictionary.Keys.Buffer(4), StoragePricesDictValue).values()
}
ConfigParser.configParse18 = configParse18;
function configParse8(r) {
    if (!r)
        return {
            version: 0,
            capabilities: 0n
        };
    const d = r.loadUint(32)
      , f = r.loadUintBig(64);
    return {
        version: d,
        capabilities: f
    }
}
ConfigParser.configParse8 = configParse8;
function configParse40(r) {
    if (!r)
        return null;
    if (r.loadUint(8) !== 1)
        throw Error("Invalid config");
    const f = r.loadCoins()
      , m = r.loadCoins()
      , k = r.loadUint(16)
      , y = r.loadUint(16)
      , ee = r.loadUint(16)
      , dt = r.loadUint(16)
      , mt = r.loadUint(16)
      , yt = r.loadUint(16)
      , pt = r.loadUint(16)
      , bt = r.loadUint(16)
      , wt = r.loadUint(16);
    return {
        defaultFlatFine: f,
        defaultProportionaFine: m,
        severityFlatMult: k,
        severityProportionalMult: y,
        unfunishableInterval: ee,
        longInterval: dt,
        longFlatMult: mt,
        longProportionalMult: yt,
        mediumInterval: pt,
        mediumFlatMult: bt,
        mediumProportionalMult: wt
    }
}
ConfigParser.configParse40 = configParse40;
function configParseWorkchainDescriptor(r) {
    if (r.loadUint(8) !== 166)
        throw Error("Invalid config");
    const d = r.loadUint(32)
      , f = r.loadUint(8)
      , m = r.loadUint(8)
      , k = r.loadUint(8)
      , y = r.loadBit()
      , ee = r.loadBit()
      , dt = r.loadBit()
      , mt = r.loadUint(13)
      , yt = r.loadBuffer(32)
      , pt = r.loadBuffer(32)
      , bt = r.loadUint(32);
    if (r.loadBit())
        throw Error("Invalid config");
    const wt = r.loadUint(32)
      , xt = r.loadUintBig(64);
    return {
        enabledSince: d,
        actialMinSplit: f,
        min_split: m,
        max_split: k,
        basic: y,
        active: ee,
        accept_msgs: dt,
        flags: mt,
        zerostateRootHash: yt,
        zerostateFileHash: pt,
        version: bt,
        format: {
            vmVersion: wt,
            vmMode: xt
        }
    }
}
ConfigParser.configParseWorkchainDescriptor = configParseWorkchainDescriptor;
const WorkchainDescriptorDictValue = {
    serialize(r, d) {
        throw Error("not implemented")
    },
    parse(r) {
        if (r.loadUint(8) !== 166)
            throw Error("Invalid config");
        const d = r.loadUint(32)
          , f = r.loadUint(8)
          , m = r.loadUint(8)
          , k = r.loadUint(8)
          , y = r.loadBit()
          , ee = r.loadBit()
          , dt = r.loadBit()
          , mt = r.loadUint(13)
          , yt = r.loadBuffer(32)
          , pt = r.loadBuffer(32)
          , bt = r.loadUint(32);
        if (r.loadBit())
            throw Error("Invalid config");
        const wt = r.loadUint(32)
          , xt = r.loadUintBig(64);
        return {
            enabledSince: d,
            actialMinSplit: f,
            min_split: m,
            max_split: k,
            basic: y,
            active: ee,
            accept_msgs: dt,
            flags: mt,
            zerostateRootHash: yt,
            zerostateFileHash: pt,
            version: bt,
            format: {
                vmVersion: wt,
                vmMode: xt
            }
        }
    }
};
function configParse12(r) {
    if (!r)
        throw Error("Invalid config");
    const d = r.loadDict(core_1$1.Dictionary.Keys.Uint(32), WorkchainDescriptorDictValue);
    if (d)
        return d;
    throw Error("No workchains exist")
}
ConfigParser.configParse12 = configParse12;
function configParseValidatorSet(r) {
    return r ? parseValidatorSet(r) : null
}
ConfigParser.configParseValidatorSet = configParseValidatorSet;
function configParseBridge(r) {
    return r ? parseBridge(r) : null
}
ConfigParser.configParseBridge = configParseBridge;
function parseGasLimitsInternal(r) {
    const d = r.loadUint(8);
    if (d === 222) {
        const f = r.loadUintBig(64)
          , m = r.loadUintBig(64)
          , k = r.loadUintBig(64)
          , y = r.loadUintBig(64)
          , ee = r.loadUintBig(64)
          , dt = r.loadUintBig(64)
          , mt = r.loadUintBig(64);
        return {
            gasPrice: f,
            gasLimit: m,
            specialGasLimit: k,
            gasCredit: y,
            blockGasLimit: ee,
            freezeDueLimit: dt,
            deleteDueLimit: mt
        }
    } else if (d === 221) {
        const f = r.loadUintBig(64)
          , m = r.loadUintBig(64)
          , k = r.loadUintBig(64)
          , y = r.loadUintBig(64)
          , ee = r.loadUintBig(64)
          , dt = r.loadUintBig(64);
        return {
            gasPrice: f,
            gasLimit: m,
            gasCredit: k,
            blockGasLimit: y,
            freezeDueLimit: ee,
            deleteDueLimit: dt
        }
    } else
        throw Error("Invalid config")
}
function configParseGasLimitsPrices(r) {
    if (!r)
        throw Error("Invalid config");
    if (r.loadUint(8) === 209) {
        const f = r.loadUintBig(64)
          , m = r.loadUintBig(64)
          , k = parseGasLimitsInternal(r);
        return {
            flatLimit: f,
            flatGasPrice: m,
            other: k
        }
    } else
        throw Error("Invalid config")
}
ConfigParser.configParseGasLimitsPrices = configParseGasLimitsPrices;
function configParseMsgPrices(r) {
    if (!r)
        throw new Error("Invalid config");
    if (r.loadUint(8) !== 234)
        throw new Error("Invalid msg prices param");
    return {
        lumpPrice: r.loadUintBig(64),
        bitPrice: r.loadUintBig(64),
        cellPrice: r.loadUintBig(64),
        ihrPriceFactor: r.loadUint(32),
        firstFrac: r.loadUint(16),
        nextFrac: r.loadUint(16)
    }
}
ConfigParser.configParseMsgPrices = configParseMsgPrices;
function configParse28(r) {
    if (!r)
        throw new Error("Invalid config");
    const d = r.loadUint(8);
    if (d === 193) {
        const f = r.loadUint(32)
          , m = r.loadUint(32)
          , k = r.loadUint(32)
          , y = r.loadUint(32);
        return {
            masterCatchainLifetime: f,
            shardCatchainLifetime: m,
            shardValidatorsLifetime: k,
            shardValidatorsCount: y
        }
    }
    if (d === 194) {
        const f = r.loadUint(7)
          , m = r.loadBit()
          , k = r.loadUint(32)
          , y = r.loadUint(32)
          , ee = r.loadUint(32)
          , dt = r.loadUint(32);
        return {
            flags: f,
            suffleMasterValidators: m,
            masterCatchainLifetime: k,
            shardCatchainLifetime: y,
            shardValidatorsLifetime: ee,
            shardValidatorsCount: dt
        }
    }
    throw new Error("Invalid config")
}
ConfigParser.configParse28 = configParse28;
function configParse29(r) {
    if (!r)
        throw new Error("Invalid config");
    const d = r.loadUint(8);
    if (d === 214) {
        const f = r.loadUint(32)
          , m = r.loadUint(32)
          , k = r.loadUint(32)
          , y = r.loadUint(32)
          , ee = r.loadUint(32)
          , dt = r.loadUint(32)
          , mt = r.loadUint(32)
          , yt = r.loadUint(32);
        return {
            roundCandidates: f,
            nextCandidateDelay: m,
            consensusTimeout: k,
            fastAttempts: y,
            attemptDuration: ee,
            catchainMaxDeps: dt,
            maxBlockBytes: mt,
            maxColaltedBytes: yt
        }
    } else if (d === 215) {
        const f = r.loadUint(7)
          , m = r.loadBit()
          , k = r.loadUint(8)
          , y = r.loadUint(32)
          , ee = r.loadUint(32)
          , dt = r.loadUint(32)
          , mt = r.loadUint(32)
          , yt = r.loadUint(32)
          , pt = r.loadUint(32)
          , bt = r.loadUint(32);
        return {
            flags: f,
            newCatchainIds: m,
            roundCandidates: k,
            nextCandidateDelay: y,
            consensusTimeout: ee,
            fastAttempts: dt,
            attemptDuration: mt,
            catchainMaxDeps: yt,
            maxBlockBytes: pt,
            maxColaltedBytes: bt
        }
    } else if (d === 216) {
        const f = r.loadUint(7)
          , m = r.loadBit()
          , k = r.loadUint(8)
          , y = r.loadUint(32)
          , ee = r.loadUint(32)
          , dt = r.loadUint(32)
          , mt = r.loadUint(32)
          , yt = r.loadUint(32)
          , pt = r.loadUint(32)
          , bt = r.loadUint(32)
          , wt = r.loadUint(16);
        return {
            flags: f,
            newCatchainIds: m,
            roundCandidates: k,
            nextCandidateDelay: y,
            consensusTimeout: ee,
            fastAttempts: dt,
            attemptDuration: mt,
            catchainMaxDeps: yt,
            maxBlockBytes: pt,
            maxColaltedBytes: bt,
            protoVersion: wt
        }
    } else if (d === 217) {
        const f = r.loadUint(7)
          , m = r.loadBit()
          , k = r.loadUint(8)
          , y = r.loadUint(32)
          , ee = r.loadUint(32)
          , dt = r.loadUint(32)
          , mt = r.loadUint(32)
          , yt = r.loadUint(32)
          , pt = r.loadUint(32)
          , bt = r.loadUint(32)
          , wt = r.loadUint(16)
          , xt = r.loadUint(32);
        return {
            flags: f,
            newCatchainIds: m,
            roundCandidates: k,
            nextCandidateDelay: y,
            consensusTimeout: ee,
            fastAttempts: dt,
            attemptDuration: mt,
            catchainMaxDeps: yt,
            maxBlockBytes: pt,
            maxColaltedBytes: bt,
            protoVersion: wt,
            catchainMaxBlocksCoeff: xt
        }
    }
    throw new Error("Invalid config")
}
ConfigParser.configParse29 = configParse29;
function parseProposalSetup(r) {
    if (r.loadUint(8) !== 54)
        throw new Error("Invalid config");
    const f = r.loadUint(8)
      , m = r.loadUint(8)
      , k = r.loadUint(8)
      , y = r.loadUint(8)
      , ee = r.loadUint(32)
      , dt = r.loadUint(32)
      , mt = r.loadUint(32)
      , yt = r.loadUint(32);
    return {
        minTotalRounds: f,
        maxTotalRounds: m,
        minWins: k,
        maxLoses: y,
        minStoreSec: ee,
        maxStoreSec: dt,
        bitPrice: mt,
        cellPrice: yt
    }
}
ConfigParser.parseProposalSetup = parseProposalSetup;
function parseVotingSetup(r) {
    if (!r)
        throw new Error("Invalid config");
    if (r.loadUint(8) !== 145)
        throw new Error("Invalid config");
    const f = parseProposalSetup(r.loadRef().beginParse())
      , m = parseProposalSetup(r.loadRef().beginParse());
    return {
        normalParams: f,
        criticalParams: m
    }
}
ConfigParser.parseVotingSetup = parseVotingSetup;
function loadConfigParams(r) {
    return core_1$1.Cell.fromBase64(r).beginParse().loadDictDirect(core_1$1.Dictionary.Keys.Int(32), core_1$1.Dictionary.Values.Cell())
}
function loadConfigParamById(r, d) {
    return loadConfigParams(r).get(d)
}
ConfigParser.loadConfigParamById = loadConfigParamById;
function loadConfigParamsAsSlice(r) {
    const d = loadConfigParams(r)
      , f = new Map;
    for (const [m,k] of d)
        f.set(m, k.beginParse());
    return f
}
ConfigParser.loadConfigParamsAsSlice = loadConfigParamsAsSlice;
function parseFullConfig(r) {
    return {
        configAddress: configParseMasterAddressRequired(r.get(0)),
        electorAddress: configParseMasterAddressRequired(r.get(1)),
        minterAddress: configParseMasterAddress(r.get(2)),
        feeCollectorAddress: configParseMasterAddress(r.get(3)),
        dnsRootAddress: configParseMasterAddress(r.get(4)),
        burningConfig: configParse5(r.get(5)),
        globalVersion: configParse8(r.get(8)),
        workchains: configParse12(r.get(12)),
        voting: parseVotingSetup(r.get(11)),
        validators: {
            ...configParse15(r.get(15)),
            ...configParse16(r.get(16)),
            ...configParse17(r.get(17))
        },
        storagePrices: configParse18(r.get(18)),
        gasPrices: {
            masterchain: configParseGasLimitsPrices(r.get(20)),
            workchain: configParseGasLimitsPrices(r.get(21))
        },
        msgPrices: {
            masterchain: configParseMsgPrices(r.get(24)),
            workchain: configParseMsgPrices(r.get(25))
        },
        validatorSets: {
            prevValidators: configParseValidatorSet(r.get(32)),
            prevTempValidators: configParseValidatorSet(r.get(33)),
            currentValidators: configParseValidatorSet(r.get(34)),
            currentTempValidators: configParseValidatorSet(r.get(35)),
            nextValidators: configParseValidatorSet(r.get(36)),
            nextTempValidators: configParseValidatorSet(r.get(37))
        },
        validatorsPunish: configParse40(r.get(40)),
        bridges: {
            ethereum: configParseBridge(r.get(71)),
            binance: configParseBridge(r.get(72)),
            polygon: configParseBridge(r.get(73))
        },
        catchain: configParse28(r.get(28)),
        consensus: configParse29(r.get(29))
    }
}
ConfigParser.parseFullConfig = parseFullConfig;
var fees = {};
Object.defineProperty(fees, "__esModule", {
    value: !0
});
fees.computeMessageForwardFees = fees.computeExternalMessageFees = fees.computeGasPrices = fees.computeFwdFees = fees.computeStorageFees = void 0;
const core_1 = dist$1;
function computeStorageFees(r) {
    const {lastPaid: d, now: f, storagePrices: m, storageStat: k, special: y, masterchain: ee} = r;
    if (f <= d || m.length === 0 || f < m[0].utime_since || y)
        return BigInt(0);
    let dt = Math.max(d, m[0].utime_since)
      , mt = BigInt(0);
    for (let yt = 0; yt < m.length && dt < f; yt++) {
        let pt = yt < m.length - 1 ? Math.min(f, m[yt + 1].utime_since) : f
          , bt = BigInt(0);
        if (dt < pt) {
            let wt = pt - dt;
            bt += BigInt(k.cells) * (ee ? m[yt].mc_cell_price_ps : m[yt].cell_price_ps),
            bt += BigInt(k.bits) * (ee ? m[yt].mc_bit_price_ps : m[yt].bit_price_ps),
            bt = bt * BigInt(wt)
        }
        dt = pt,
        mt += bt
    }
    return shr16ceil(mt)
}
fees.computeStorageFees = computeStorageFees;
function computeFwdFees(r, d, f) {
    return r.lumpPrice + shr16ceil(r.bitPrice * f + r.cellPrice * d)
}
fees.computeFwdFees = computeFwdFees;
function computeGasPrices(r, d) {
    return r <= d.flatLimit ? d.flatPrice : d.flatPrice + (d.price * (r - d.flatLimit) >> 16n)
}
fees.computeGasPrices = computeGasPrices;
function computeExternalMessageFees(r, d) {
    let f = collectCellStats(d);
    return f.bits -= d.bits.length,
    f.cells -= 1,
    computeFwdFees(r, BigInt(f.cells), BigInt(f.bits))
}
fees.computeExternalMessageFees = computeExternalMessageFees;
function computeMessageForwardFees(r, d) {
    let f = (0,
    core_1.loadMessageRelaxed)(d.beginParse())
      , m = {
        bits: 0,
        cells: 0
    };
    if (f.init) {
        const mt = new core_1.Cell().asBuilder();
        (0,
        core_1.storeStateInit)(f.init)(mt);
        const yt = mt.endCell();
        let pt = collectCellStats(yt);
        pt.bits -= yt.bits.length,
        pt.cells -= 1,
        m.bits += pt.bits,
        m.cells += pt.cells
    }
    let k = collectCellStats(f.body);
    k.bits -= f.body.bits.length,
    k.cells -= 1,
    m.bits += k.bits,
    m.cells += k.cells;
    let y = computeFwdFees(r, BigInt(m.cells), BigInt(m.bits))
      , ee = y * BigInt(r.firstFrac) >> 16n
      , dt = y - ee;
    return {
        fees: ee,
        remaining: dt
    }
}
fees.computeMessageForwardFees = computeMessageForwardFees;
function collectCellStats(r) {
    let d = r.bits.length
      , f = 1;
    for (let m of r.refs) {
        let k = collectCellStats(m);
        f += k.cells,
        d += k.bits
    }
    return {
        bits: d,
        cells: f
    }
}
function shr16ceil(r) {
    let d = r % 65536n
      , f = r >> 16n;
    return d !== 0n && (f += 1n),
    f
}
(function(r) {
    var d = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(or, tr, wr, Ht) {
        Ht === void 0 && (Ht = wr);
        var Mt = Object.getOwnPropertyDescriptor(tr, wr);
        (!Mt || ("get"in Mt ? !tr.__esModule : Mt.writable || Mt.configurable)) && (Mt = {
            enumerable: !0,
            get: function() {
                return tr[wr]
            }
        }),
        Object.defineProperty(or, Ht, Mt)
    }
    : function(or, tr, wr, Ht) {
        Ht === void 0 && (Ht = wr),
        or[Ht] = tr[wr]
    }
    )
      , f = commonjsGlobal && commonjsGlobal.__exportStar || function(or, tr) {
        for (var wr in or)
            wr !== "default" && !Object.prototype.hasOwnProperty.call(tr, wr) && d(tr, or, wr)
    }
    ;
    Object.defineProperty(r, "__esModule", {
        value: !0
    }),
    r.computeStorageFees = r.computeMessageForwardFees = r.computeGasPrices = r.computeFwdFees = r.computeExternalMessageFees = r.loadConfigParamsAsSlice = r.loadConfigParamById = r.parseFullConfig = r.parseVotingSetup = r.parseValidatorSet = r.parseProposalSetup = r.parseBridge = r.configParseWorkchainDescriptor = r.configParseValidatorSet = r.configParseMsgPrices = r.configParseMasterAddressRequired = r.configParseMasterAddress = r.configParseGasLimitsPrices = r.configParseBridge = r.configParse40 = r.configParse29 = r.configParse28 = r.configParse18 = r.configParse17 = r.configParse16 = r.configParse15 = r.configParse13 = r.configParse12 = r.configParse8 = r.configParse5 = r.ElectorContract = r.MultisigWallet = r.MultisigOrderBuilder = r.MultisigOrder = r.JettonWallet = r.JettonMaster = r.WalletContractV5R1 = r.WalletContractV5Beta = r.WalletContractV4 = r.WalletContractV3R2 = r.WalletContractV3R1 = r.WalletContractV2R2 = r.WalletContractV2R1 = r.WalletContractV1R3 = r.WalletContractV1R2 = r.WalletContractV1R1 = r.TonClient4 = r.TonClient = r.HttpApi = void 0,
    f(dist$1, r);
    var m = HttpApi$1;
    Object.defineProperty(r, "HttpApi", {
        enumerable: !0,
        get: function() {
            return m.HttpApi
        }
    });
    var k = TonClient$1;
    Object.defineProperty(r, "TonClient", {
        enumerable: !0,
        get: function() {
            return k.TonClient
        }
    });
    var y = TonClient4$1;
    Object.defineProperty(r, "TonClient4", {
        enumerable: !0,
        get: function() {
            return y.TonClient4
        }
    });
    var ee = WalletContractV1R1$1;
    Object.defineProperty(r, "WalletContractV1R1", {
        enumerable: !0,
        get: function() {
            return ee.WalletContractV1R1
        }
    });
    var dt = WalletContractV1R2$1;
    Object.defineProperty(r, "WalletContractV1R2", {
        enumerable: !0,
        get: function() {
            return dt.WalletContractV1R2
        }
    });
    var mt = WalletContractV1R3$1;
    Object.defineProperty(r, "WalletContractV1R3", {
        enumerable: !0,
        get: function() {
            return mt.WalletContractV1R3
        }
    });
    var yt = WalletContractV2R1$1;
    Object.defineProperty(r, "WalletContractV2R1", {
        enumerable: !0,
        get: function() {
            return yt.WalletContractV2R1
        }
    });
    var pt = WalletContractV2R2$1;
    Object.defineProperty(r, "WalletContractV2R2", {
        enumerable: !0,
        get: function() {
            return pt.WalletContractV2R2
        }
    });
    var bt = WalletContractV3R1$1;
    Object.defineProperty(r, "WalletContractV3R1", {
        enumerable: !0,
        get: function() {
            return bt.WalletContractV3R1
        }
    });
    var wt = WalletContractV3R2$1;
    Object.defineProperty(r, "WalletContractV3R2", {
        enumerable: !0,
        get: function() {
            return wt.WalletContractV3R2
        }
    });
    var xt = WalletContractV4$1;
    Object.defineProperty(r, "WalletContractV4", {
        enumerable: !0,
        get: function() {
            return xt.WalletContractV4
        }
    });
    var At = WalletContractV5Beta;
    Object.defineProperty(r, "WalletContractV5Beta", {
        enumerable: !0,
        get: function() {
            return At.WalletContractV5Beta
        }
    });
    var Ct = WalletContractV5R1;
    Object.defineProperty(r, "WalletContractV5R1", {
        enumerable: !0,
        get: function() {
            return Ct.WalletContractV5R1
        }
    });
    var Pt = JettonMaster$1;
    Object.defineProperty(r, "JettonMaster", {
        enumerable: !0,
        get: function() {
            return Pt.JettonMaster
        }
    });
    var $t = JettonWallet$2;
    Object.defineProperty(r, "JettonWallet", {
        enumerable: !0,
        get: function() {
            return $t.JettonWallet
        }
    });
    var Ot = MultisigOrder$1;
    Object.defineProperty(r, "MultisigOrder", {
        enumerable: !0,
        get: function() {
            return Ot.MultisigOrder
        }
    });
    var Nt = MultisigOrderBuilder$1;
    Object.defineProperty(r, "MultisigOrderBuilder", {
        enumerable: !0,
        get: function() {
            return Nt.MultisigOrderBuilder
        }
    });
    var zt = MultisigWallet$1;
    Object.defineProperty(r, "MultisigWallet", {
        enumerable: !0,
        get: function() {
            return zt.MultisigWallet
        }
    });
    var Wt = ElectorContract$1;
    Object.defineProperty(r, "ElectorContract", {
        enumerable: !0,
        get: function() {
            return Wt.ElectorContract
        }
    });
    var Kt = ConfigParser;
    Object.defineProperty(r, "configParse5", {
        enumerable: !0,
        get: function() {
            return Kt.configParse5
        }
    }),
    Object.defineProperty(r, "configParse8", {
        enumerable: !0,
        get: function() {
            return Kt.configParse8
        }
    }),
    Object.defineProperty(r, "configParse12", {
        enumerable: !0,
        get: function() {
            return Kt.configParse12
        }
    }),
    Object.defineProperty(r, "configParse13", {
        enumerable: !0,
        get: function() {
            return Kt.configParse13
        }
    }),
    Object.defineProperty(r, "configParse15", {
        enumerable: !0,
        get: function() {
            return Kt.configParse15
        }
    }),
    Object.defineProperty(r, "configParse16", {
        enumerable: !0,
        get: function() {
            return Kt.configParse16
        }
    }),
    Object.defineProperty(r, "configParse17", {
        enumerable: !0,
        get: function() {
            return Kt.configParse17
        }
    }),
    Object.defineProperty(r, "configParse18", {
        enumerable: !0,
        get: function() {
            return Kt.configParse18
        }
    }),
    Object.defineProperty(r, "configParse28", {
        enumerable: !0,
        get: function() {
            return Kt.configParse28
        }
    }),
    Object.defineProperty(r, "configParse29", {
        enumerable: !0,
        get: function() {
            return Kt.configParse29
        }
    }),
    Object.defineProperty(r, "configParse40", {
        enumerable: !0,
        get: function() {
            return Kt.configParse40
        }
    }),
    Object.defineProperty(r, "configParseBridge", {
        enumerable: !0,
        get: function() {
            return Kt.configParseBridge
        }
    }),
    Object.defineProperty(r, "configParseGasLimitsPrices", {
        enumerable: !0,
        get: function() {
            return Kt.configParseGasLimitsPrices
        }
    }),
    Object.defineProperty(r, "configParseMasterAddress", {
        enumerable: !0,
        get: function() {
            return Kt.configParseMasterAddress
        }
    }),
    Object.defineProperty(r, "configParseMasterAddressRequired", {
        enumerable: !0,
        get: function() {
            return Kt.configParseMasterAddressRequired
        }
    }),
    Object.defineProperty(r, "configParseMsgPrices", {
        enumerable: !0,
        get: function() {
            return Kt.configParseMsgPrices
        }
    }),
    Object.defineProperty(r, "configParseValidatorSet", {
        enumerable: !0,
        get: function() {
            return Kt.configParseValidatorSet
        }
    }),
    Object.defineProperty(r, "configParseWorkchainDescriptor", {
        enumerable: !0,
        get: function() {
            return Kt.configParseWorkchainDescriptor
        }
    }),
    Object.defineProperty(r, "parseBridge", {
        enumerable: !0,
        get: function() {
            return Kt.parseBridge
        }
    }),
    Object.defineProperty(r, "parseProposalSetup", {
        enumerable: !0,
        get: function() {
            return Kt.parseProposalSetup
        }
    }),
    Object.defineProperty(r, "parseValidatorSet", {
        enumerable: !0,
        get: function() {
            return Kt.parseValidatorSet
        }
    }),
    Object.defineProperty(r, "parseVotingSetup", {
        enumerable: !0,
        get: function() {
            return Kt.parseVotingSetup
        }
    }),
    Object.defineProperty(r, "parseFullConfig", {
        enumerable: !0,
        get: function() {
            return Kt.parseFullConfig
        }
    }),
    Object.defineProperty(r, "loadConfigParamById", {
        enumerable: !0,
        get: function() {
            return Kt.loadConfigParamById
        }
    }),
    Object.defineProperty(r, "loadConfigParamsAsSlice", {
        enumerable: !0,
        get: function() {
            return Kt.loadConfigParamsAsSlice
        }
    });
    var ir = fees;
    Object.defineProperty(r, "computeExternalMessageFees", {
        enumerable: !0,
        get: function() {
            return ir.computeExternalMessageFees
        }
    }),
    Object.defineProperty(r, "computeFwdFees", {
        enumerable: !0,
        get: function() {
            return ir.computeFwdFees
        }
    }),
    Object.defineProperty(r, "computeGasPrices", {
        enumerable: !0,
        get: function() {
            return ir.computeGasPrices
        }
    }),
    Object.defineProperty(r, "computeMessageForwardFees", {
        enumerable: !0,
        get: function() {
            return ir.computeMessageForwardFees
        }
    }),
    Object.defineProperty(r, "computeStorageFees", {
        enumerable: !0,
        get: function() {
            return ir.computeStorageFees
        }
    })
}
)(dist$2);
function toAddress(r) {
    return r instanceof dist$2.Address ? r : dist$2.address(r.toString())
}
class Contract {
    constructor(d, f) {
        this.address = toAddress(d)
    }
    static create(d) {
        return new this(d)
    }
}
class JettonMinter extends Contract {
    async getWalletAddress(d, f) {
        return (await d.get("get_wallet_address", [{
            type: "slice",
            cell: dist$2.beginCell().storeAddress(toAddress(f)).endCell()
        }])).stack.readAddress()
    }
    async getJettonData(d) {
        const f = await d.get("get_jetton_data", []);
        return {
            totalSupply: f.stack.readBigNumber(),
            canIncSupply: !!f.stack.readNumber(),
            adminAddress: f.stack.readAddressOpt(),
            contentRaw: f.stack.readCell(),
            jettonWalletCode: f.stack.readCell()
        }
    }
}
function createJettonTransferMessage(r) {
    const d = dist$2.beginCell();
    return d.storeUint(260734629, 32),
    d.storeUint(r.queryId, 64),
    d.storeCoins(BigInt(r.amount)),
    d.storeAddress(toAddress(r.destination)),
    d.storeAddress(r.responseDestination ? toAddress(r.responseDestination) : void 0),
    r.customPayload ? (d.storeBit(!0),
    d.storeRef(r.customPayload)) : d.storeBit(!1),
    d.storeCoins(BigInt(r.forwardTonAmount)),
    r.forwardPayload ? (d.storeBit(!0),
    d.storeRef(r.forwardPayload)) : d.storeBit(!1),
    d.endCell()
}
const DEX_OP_CODES = {
    ADD_LIQUIDITY: 1935855772,
    SWAP: 630424929,
    PROVIDE_LIQUIDITY: 4244235663,
    DIRECT_ADD_LIQUIDITY: 1291331587,
    REFUND: 200537159,
    RESET_GAS: 1117846339,
    COLLECT_FEES: 533429565,
    REQUEST_BURN: 1499400124
}
  , DEX_VERSION = {
    v1: "v1"
};
class JettonWallet extends Contract {
    async getBalance(d) {
        if ((await d.getState()).state.type !== "active")
            return BigInt(0);
        const {balance: m} = await this.getWalletData(d);
        return m
    }
    async getWalletData(d) {
        const f = await d.get("get_wallet_data", []);
        return {
            balance: f.stack.readBigNumber(),
            ownerAddress: f.stack.readAddress(),
            jettonMasterAddress: f.stack.readAddress(),
            jettonWalletCode: f.stack.readCell()
        }
    }
}
const _LpAccountV1 = class ei extends Contract {
    constructor(d, {gasConstants: f, ...m}={}) {
        super(d, m),
        this.gasConstants = {
            ...ei.gasConstants,
            ...f
        }
    }
    async createRefundBody(d) {
        return dist$2.beginCell().storeUint(DEX_OP_CODES.REFUND, 32).storeUint((d == null ? void 0 : d.queryId) ?? 0, 64).endCell()
    }
    async getRefundTxParams(d, f) {
        const m = this.address
          , k = await this.createRefundBody({
            queryId: f == null ? void 0 : f.queryId
        })
          , y = BigInt((f == null ? void 0 : f.gasAmount) ?? this.gasConstants.refund);
        return {
            to: m,
            value: y,
            body: k
        }
    }
    async sendRefund(d, f, m) {
        const k = await this.getRefundTxParams(d, m);
        return f.send(k)
    }
    async createDirectAddLiquidityBody(d) {
        return dist$2.beginCell().storeUint(DEX_OP_CODES.DIRECT_ADD_LIQUIDITY, 32).storeUint((d == null ? void 0 : d.queryId) ?? 0, 64).storeCoins(BigInt(d.amount0)).storeCoins(BigInt(d.amount1)).storeCoins(BigInt(d.minimumLpToMint ?? 1)).endCell()
    }
    async getDirectAddLiquidityTxParams(d, f) {
        const m = this.address
          , k = await this.createDirectAddLiquidityBody({
            amount0: f.amount0,
            amount1: f.amount1,
            minimumLpToMint: f.minimumLpToMint,
            queryId: f.queryId
        })
          , y = BigInt(f.gasAmount ?? this.gasConstants.directAddLp);
        return {
            to: m,
            value: y,
            body: k
        }
    }
    async sendDirectAddLiquidity(d, f, m) {
        const k = await this.getDirectAddLiquidityTxParams(d, m);
        return f.send(k)
    }
    async createResetGasBody(d) {
        return dist$2.beginCell().storeUint(DEX_OP_CODES.RESET_GAS, 32).storeUint((d == null ? void 0 : d.queryId) ?? 0, 64).endCell()
    }
    async getResetGasTxParams(d, f) {
        const m = this.address
          , k = await this.createResetGasBody({
            queryId: f == null ? void 0 : f.queryId
        })
          , y = BigInt((f == null ? void 0 : f.gasAmount) ?? this.gasConstants.resetGas);
        return {
            to: m,
            value: y,
            body: k
        }
    }
    async sendResetGas(d, f, m) {
        const k = await this.getResetGasTxParams(d, m);
        return f.send(k)
    }
    async getLpAccountData(d) {
        const f = await d.get("get_lp_account_data", []);
        return {
            userAddress: f.stack.readAddress(),
            poolAddress: f.stack.readAddress(),
            amount0: f.stack.readBigNumber(),
            amount1: f.stack.readBigNumber()
        }
    }
}
;
_LpAccountV1.version = DEX_VERSION.v1;
_LpAccountV1.gasConstants = {
    refund: dist$2.toNano("0.3"),
    directAddLp: dist$2.toNano("0.3"),
    resetGas: dist$2.toNano("0.3")
};
let LpAccountV1 = _LpAccountV1;
const _PoolV1 = class ti extends JettonMinter {
    constructor(d, {gasConstants: f, ...m}={}) {
        super(d, m),
        this.gasConstants = {
            ...ti.gasConstants,
            ...f
        }
    }
    async createCollectFeesBody(d) {
        return dist$2.beginCell().storeUint(DEX_OP_CODES.COLLECT_FEES, 32).storeUint((d == null ? void 0 : d.queryId) ?? 0, 64).endCell()
    }
    async getCollectFeeTxParams(d, f) {
        const m = this.address
          , k = await this.createCollectFeesBody({
            queryId: f == null ? void 0 : f.queryId
        })
          , y = BigInt((f == null ? void 0 : f.gasAmount) ?? this.gasConstants.collectFees);
        return {
            to: m,
            value: y,
            body: k
        }
    }
    async sendCollectFees(d, f, m) {
        const k = await this.getCollectFeeTxParams(d, m);
        return f.send(k)
    }
    async createBurnBody(d) {
        return dist$2.beginCell().storeUint(DEX_OP_CODES.REQUEST_BURN, 32).storeUint((d == null ? void 0 : d.queryId) ?? 0, 64).storeCoins(BigInt(d.amount)).storeAddress(toAddress(d.responseAddress)).endCell()
    }
    async getBurnTxParams(d, f) {
        const [m,k] = await Promise.all([this.getWalletAddress(d, f.responseAddress), this.createBurnBody({
            amount: f.amount,
            responseAddress: f.responseAddress,
            queryId: f.queryId
        })])
          , y = BigInt(f.gasAmount ?? this.gasConstants.burn);
        return {
            to: m,
            value: y,
            body: k
        }
    }
    async sendBurn(d, f, m) {
        const k = await this.getBurnTxParams(d, m);
        return f.send(k)
    }
    async getExpectedOutputs(d, f) {
        const m = await d.get("get_expected_outputs", [{
            type: "int",
            value: BigInt(f.amount)
        }, {
            type: "slice",
            cell: dist$2.beginCell().storeAddress(toAddress(f.jettonWallet)).endCell()
        }]);
        return {
            jettonToReceive: m.stack.readBigNumber(),
            protocolFeePaid: m.stack.readBigNumber(),
            refFeePaid: m.stack.readBigNumber()
        }
    }
    async getExpectedTokens(d, f) {
        return (await d.get("get_expected_tokens", [{
            type: "int",
            value: BigInt(f.amount0)
        }, {
            type: "int",
            value: BigInt(f.amount1)
        }])).stack.readBigNumber()
    }
    async getExpectedLiquidity(d, f) {
        const m = await d.get("get_expected_liquidity", [{
            type: "int",
            value: BigInt(f.jettonAmount)
        }]);
        return {
            amount0: m.stack.readBigNumber(),
            amount1: m.stack.readBigNumber()
        }
    }
    async getLpAccountAddress(d, f) {
        return (await d.get("get_lp_account_address", [{
            type: "slice",
            cell: dist$2.beginCell().storeAddress(toAddress(f.ownerAddress)).endCell()
        }])).stack.readAddress()
    }
    async getJettonWallet(d, f) {
        const m = await this.getWalletAddress(d, f.ownerAddress);
        return JettonWallet.create(m)
    }
    async getPoolData(d) {
        const f = await d.get("get_pool_data", []);
        return {
            reserve0: f.stack.readBigNumber(),
            reserve1: f.stack.readBigNumber(),
            token0WalletAddress: f.stack.readAddress(),
            token1WalletAddress: f.stack.readAddress(),
            lpFee: f.stack.readBigNumber(),
            protocolFee: f.stack.readBigNumber(),
            refFee: f.stack.readBigNumber(),
            protocolFeeAddress: f.stack.readAddress(),
            collectedToken0ProtocolFee: f.stack.readBigNumber(),
            collectedToken1ProtocolFee: f.stack.readBigNumber()
        }
    }
    async getLpAccount(d, f) {
        const m = await this.getLpAccountAddress(d, f);
        return LpAccountV1.create(m)
    }
}
;
_PoolV1.version = DEX_VERSION.v1;
_PoolV1.gasConstants = {
    collectFees: dist$2.toNano("1.1"),
    burn: dist$2.toNano("0.5")
};
let PoolV1 = _PoolV1;
const _RouterV1 = class Yn extends Contract {
    constructor(d=Yn.address, {gasConstants: f, ...m}={}) {
        super(d, m),
        this.gasConstants = {
            ...Yn.gasConstants,
            ...f
        }
    }
    async createSwapBody(d) {
        const f = dist$2.beginCell();
        return f.storeUint(DEX_OP_CODES.SWAP, 32),
        f.storeAddress(toAddress(d.askJettonWalletAddress)),
        f.storeCoins(BigInt(d.minAskAmount)),
        f.storeAddress(toAddress(d.userWalletAddress)),
        d.referralAddress ? (f.storeUint(1, 1),
        f.storeAddress(toAddress(d.referralAddress))) : f.storeUint(0, 1),
        f.endCell()
    }
    async getSwapJettonToJettonTxParams(d, f) {
        const [m,k] = await Promise.all([d.open(JettonMinter.create(f.offerJettonAddress)).getWalletAddress(f.userWalletAddress), d.open(JettonMinter.create(f.askJettonAddress)).getWalletAddress(this.address)])
          , y = await this.createSwapBody({
            userWalletAddress: f.userWalletAddress,
            minAskAmount: f.minAskAmount,
            askJettonWalletAddress: k,
            referralAddress: f.referralAddress
        })
          , ee = BigInt(f.forwardGasAmount ?? this.gasConstants.swapJettonToJetton.forwardGasAmount)
          , dt = createJettonTransferMessage({
            queryId: f.queryId ?? 0,
            amount: f.offerAmount,
            destination: this.address,
            responseDestination: f.userWalletAddress,
            forwardTonAmount: ee,
            forwardPayload: y
        })
          , mt = BigInt(f.gasAmount ?? this.gasConstants.swapJettonToJetton.gasAmount);
        return {
            to: m,
            value: mt,
            body: dt
        }
    }
    async sendSwapJettonToJetton(d, f, m) {
        const k = await this.getSwapJettonToJettonTxParams(d, m);
        return f.send(k)
    }
    async getSwapJettonToTonTxParams(d, f) {
        return await this.getSwapJettonToJettonTxParams(d, {
            ...f,
            askJettonAddress: f.proxyTon.address,
            gasAmount: f.gasAmount ?? this.gasConstants.swapJettonToTon.gasAmount,
            forwardGasAmount: f.forwardGasAmount ?? this.gasConstants.swapJettonToTon.forwardGasAmount
        })
    }
    async sendSwapJettonToTon(d, f, m) {
        const k = await this.getSwapJettonToTonTxParams(d, m);
        return f.send(k)
    }
    async getSwapTonToJettonTxParams(d, f) {
        const [m,k] = await Promise.all([d.open(f.proxyTon).getWalletAddress(this.address), d.open(JettonMinter.create(f.askJettonAddress)).getWalletAddress(this.address)])
          , y = await this.createSwapBody({
            userWalletAddress: f.userWalletAddress,
            minAskAmount: f.minAskAmount,
            askJettonWalletAddress: k,
            referralAddress: f.referralAddress
        })
          , ee = BigInt(f.forwardGasAmount ?? this.gasConstants.swapTonToJetton.forwardGasAmount)
          , dt = createJettonTransferMessage({
            queryId: f.queryId ?? 0,
            amount: f.offerAmount,
            destination: this.address,
            forwardTonAmount: ee,
            forwardPayload: y
        })
          , mt = BigInt(f.offerAmount) + ee;
        return {
            to: m,
            value: mt,
            body: dt
        }
    }
    async sendSwapTonToJetton(d, f, m) {
        const k = await this.getSwapTonToJettonTxParams(d, m);
        return f.send(k)
    }
    async createProvideLiquidityBody(d) {
        return dist$2.beginCell().storeUint(DEX_OP_CODES.PROVIDE_LIQUIDITY, 32).storeAddress(toAddress(d.routerWalletAddress)).storeCoins(BigInt(d.minLpOut)).endCell()
    }
    async getProvideLiquidityJettonTxParams(d, f) {
        const [m,k] = await Promise.all([d.open(JettonMinter.create(f.sendTokenAddress)).getWalletAddress(f.userWalletAddress), d.open(JettonMinter.create(f.otherTokenAddress)).getWalletAddress(this.address)])
          , y = await this.createProvideLiquidityBody({
            routerWalletAddress: k,
            minLpOut: f.minLpOut
        })
          , ee = BigInt(f.forwardGasAmount ?? this.gasConstants.provideLpJetton.forwardGasAmount)
          , dt = createJettonTransferMessage({
            queryId: f.queryId ?? 0,
            amount: f.sendAmount,
            destination: this.address,
            responseDestination: f.userWalletAddress,
            forwardTonAmount: ee,
            forwardPayload: y
        })
          , mt = BigInt(f.gasAmount ?? this.gasConstants.provideLpJetton.gasAmount);
        return {
            to: m,
            value: mt,
            body: dt
        }
    }
    async sendProvideLiquidityJetton(d, f, m) {
        const k = await this.getProvideLiquidityJettonTxParams(d, m);
        return f.send(k)
    }
    async getProvideLiquidityTonTxParams(d, f) {
        const [m,k] = await Promise.all([d.open(f.proxyTon).getWalletAddress(this.address), d.open(JettonMinter.create(f.otherTokenAddress)).getWalletAddress(this.address)])
          , y = await this.createProvideLiquidityBody({
            routerWalletAddress: k,
            minLpOut: f.minLpOut
        })
          , ee = BigInt(f.forwardGasAmount ?? this.gasConstants.provideLpTon.forwardGasAmount)
          , dt = createJettonTransferMessage({
            queryId: f.queryId ?? 0,
            amount: f.sendAmount,
            destination: this.address,
            forwardTonAmount: ee,
            forwardPayload: y
        })
          , mt = BigInt(f.sendAmount) + ee;
        return {
            to: m,
            value: mt,
            body: dt
        }
    }
    async sendProvideLiquidityTon(d, f, m) {
        const k = await this.getProvideLiquidityTonTxParams(d, m);
        return f.send(k)
    }
    async getPoolAddress(d, f) {
        return (await d.get("get_pool_address", [{
            type: "slice",
            cell: dist$2.beginCell().storeAddress(toAddress(f.token0)).endCell()
        }, {
            type: "slice",
            cell: dist$2.beginCell().storeAddress(toAddress(f.token1)).endCell()
        }])).stack.readAddress()
    }
    async getPoolAddressByJettonMinters(d, f) {
        const [m,k] = await Promise.all([d.open(JettonMinter.create(f.token0)).getWalletAddress(this.address), d.open(JettonMinter.create(f.token1)).getWalletAddress(this.address)]);
        return await this.getPoolAddress(d, {
            token0: m,
            token1: k
        })
    }
    async getPool(d, f) {
        const m = await this.getPoolAddressByJettonMinters(d, {
            token0: f.token0,
            token1: f.token1
        });
        return PoolV1.create(m)
    }
    async getRouterData(d) {
        const f = await d.get("get_router_data", []);
        return {
            isLocked: f.stack.readBoolean(),
            adminAddress: f.stack.readAddress(),
            tempUpgrade: f.stack.readCell(),
            poolCode: f.stack.readCell(),
            jettonLpWalletCode: f.stack.readCell(),
            lpAccountCode: f.stack.readCell()
        }
    }
}
;
_RouterV1.version = DEX_VERSION.v1;
_RouterV1.address = dist$2.address("EQB3ncyBUTjZUA5EnFKR5_EnOMI9V1tTEAAPaiU71gc4TiUt");
_RouterV1.gasConstants = {
    swapJettonToJetton: {
        gasAmount: dist$2.toNano("0.22"),
        forwardGasAmount: dist$2.toNano("0.175")
    },
    swapJettonToTon: {
        gasAmount: dist$2.toNano("0.17"),
        forwardGasAmount: dist$2.toNano("0.125")
    },
    swapTonToJetton: {
        forwardGasAmount: dist$2.toNano("0.185")
    },
    provideLpJetton: {
        gasAmount: dist$2.toNano("0.3"),
        forwardGasAmount: dist$2.toNano("0.24")
    },
    provideLpTon: {
        forwardGasAmount: dist$2.toNano("0.26")
    }
};
let RouterV1 = _RouterV1;
const DEX$1 = {
    Router: RouterV1,
    Pool: PoolV1,
    LpAccount: LpAccountV1
}
  , DEX = {
    [DEX_VERSION.v1]: DEX$1
}
  , pTON_VERSION = {
    v1: "v1"
}
  , _PtonV1 = class ri extends JettonMinter {
    constructor(d=ri.address, f) {
        super(d, f)
    }
}
;
_PtonV1.version = pTON_VERSION.v1;
_PtonV1.address = dist$2.address("EQCM3B12QK1e4yZSf8GtBRT0aLMNyEsBc_DhVfRRtOEffLez");
let PtonV1 = _PtonV1;
const pTON = {
    [pTON_VERSION.v1]: PtonV1
};
class StonFiService {
    constructor(d) {
        fn(this, "client", new ut);
        fn(this, "_tonClient");
        fn(this, "_dexType", new DEX.v1.Router);
        fn(this, "_dex");
        fn(this, "_pageLoadingStatus", a$1("not_loaded"));
        fn(this, "_assets", a$1([]));
        fn(this, "_pairs", []);
        fn(this, "_waleltAssets", a$1([]));
        fn(this, "REF_ADDRESS", "UQAeAzyCCmXPQg6_C4TJECfjCiFtIXrC4pkFXjM50PDMlB8s");
        fn(this, "TON_ADDRESS", "EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c");
        fn(this, "USDT_ADDRESS", "EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs");
        this._auth = d
    }
    async loadPageData() {
        return this._pageLoadingStatus.value === "not_loaded" && (this._pageLoadingStatus.value = "loading",
        this._assets.value = await this.client.getAssets(),
        this._pairs = await this.client.getSwapPairs(),
        this._pageLoadingStatus.value = "loaded"),
        {
            assets: this._assets.value,
            pairs: this._pairs
        }
    }
    async updateWalletAssets() {
        const d = this._auth.getAddress();
        d && (console.log("Updating assets"),
        this._waleltAssets.value = await this.getWalletAssets(d))
    }
    async updateWalletAsset(d, f) {
        const m = await this.getWalletAsset(d, f)
          , k = this._waleltAssets.value.findIndex(y=>y.contractAddress === d);
        k === -1 ? this._waleltAssets.value = [...this._waleltAssets.value, m] : this._waleltAssets.value[k] = m
    }
    init() {
        this._tonClient || (this._tonClient = new dist$2.TonClient({
            endpoint: "https://toncenter.com/api/v2/jsonRPC"
        }),
        this._dex = this._tonClient.open(new DEX.v1.Router))
    }
    get dex() {
        return checked(this._dex)
    }
    get tonClient() {
        return checked(this._tonClient)
    }
    get isPageLoading() {
        return this._pageLoadingStatus.value !== "loaded"
    }
    get assets() {
        return this._assets.value
    }
    get pairs() {
        return this._pairs
    }
    async getWalletAssets(d) {
        return await this.client.getWalletAssets(d)
    }
    get waleltAssets() {
        return this._waleltAssets.value
    }
    async getWalletAsset(d, f) {
        return await this.client.getWalletAsset({
            assetAddress: d,
            walletAddress: f
        })
    }
    async simulateSwap(d, f, m, k) {
        return await this.client.simulateSwap({
            askAddress: d,
            offerAddress: f,
            offerUnits: m,
            slippageTolerance: k,
            referralAddress: this.REF_ADDRESS
        })
    }
    async simulateReverseSwap(d, f, m, k) {
        return await this.client.simulateReverseSwap({
            askAddress: d,
            askUnits: m,
            offerAddress: f,
            slippageTolerance: k,
            referralAddress: this.REF_ADDRESS
        })
    }
    async trade(d, f, m, k) {
        var yt;
        const y = this._auth.getAddress();
        if (!y)
            return;
        const ee = parseInt(y.slice(-13), 16) + Date.now()
          , dt = await this.getTradeParams(y, d, f, m, k, ee);
        if (!dt)
            return;
        const mt = await this._auth.sendTon(dt.to.toString(), dt.value.toString(), (yt = dt.body) == null ? void 0 : yt.toBoc().toString("base64"));
        if (mt)
            return {
                response: mt,
                queryId: ee
            }
    }
    async getTradeParams(d, f, m, k, y, ee) {
        return m === this.TON_ADDRESS ? await this.dex.getSwapTonToJettonTxParams({
            userWalletAddress: d,
            offerAmount: f,
            askJettonAddress: k,
            minAskAmount: y,
            proxyTon: new pTON.v1,
            referralAddress: this.REF_ADDRESS,
            queryId: ee
        }) : k === this.TON_ADDRESS ? await this.dex.getSwapJettonToTonTxParams({
            userWalletAddress: d,
            offerJettonAddress: m,
            offerAmount: f,
            proxyTon: new pTON.v1,
            minAskAmount: y,
            referralAddress: this.REF_ADDRESS,
            queryId: ee
        }) : await this.dex.getSwapJettonToJettonTxParams({
            userWalletAddress: d,
            offerJettonAddress: m,
            offerAmount: f,
            askJettonAddress: k,
            minAskAmount: y,
            referralAddress: this.REF_ADDRESS,
            queryId: ee
        })
    }
    async waitTokenChange(d, f, m) {
        const k = d.contractAddress
          , y = 30;
        let ee = 0;
        for (; ee < y; ) {
            ee += 1;
            const dt = await this.getWalletAsset(k, f);
            if (m(d, dt))
                return dt;
            await sleep(5e3)
        }
        return null
    }
    async waitTradeResult(d, f) {
        let k = 0;
        for (; k < 30; ) {
            const y = await this.getSwapStatus(d.toString(), f);
            if (console.log(y),
            y["@type"] === "Found")
                return y;
            k++,
            await sleep(5e3)
        }
        return null
    }
    async getSwapStatus(d, f) {
        return await this.client.getSwapStatus({
            queryId: d,
            ownerAddress: f,
            routerAddress: this.dex.address.toString()
        })
    }
    async getTxResult(d, f) {
        let k = 0;
        const y = dist$2.Cell.fromBase64(f.boc).hash().toString("base64")
          , ee = dist$1.Address.parse(d);
        for (console.log(ee.toString({
            bounceable: !0
        })); k < 10; ) {
            k += 1,
            console.log("waiting transaction...");
            const dt = await this.tonClient.getTransactions(ee, {
                limit: 10
            });
            for (const mt of dt)
                if (mt && mt.inMessage) {
                    const pt = dist$2.beginCell().store(dist$2.storeMessage(mt.inMessage)).endCell().hash().toString("base64");
                    if (console.log("InMsgHash", pt),
                    pt === y)
                        return mt
                }
            await sleep(3e3)
        }
        return null
    }
}
class TapsSubmitService {
    constructor(d) {
        fn(this, "_next_submit_time", 0);
        fn(this, "_submission_in_progress", !1);
        fn(this, "_started", !1);
        fn(this, "_interval_time", 2e3);
        fn(this, "_submitTry", 0);
        this.app = d
    }
    start() {
        this._started || (this._started = !0,
        this._next_submit_time = this.calcNextSubmitTime,
        this.runLoop().catch(console.error))
    }
    async runLoop() {
        for (; this._started; ) {
            try {
                await this.loop()
            } catch (m) {
                console.error(m)
            }
            const d = this._interval_time * 2 ** this._submitTry
              , f = this.app.settings.submit_interval_s * 2 * 1e3;
            await sleep(Math.min(d, f))
        }
    }
    async loop() {
        if (Date.parse(this.app.settings.start_date) >= this.app.player.now)
            return;
        const d = this.app.env === "dev" ? 120 : 3600
          , f = this.app.env === "dev" ? 10 : 300;
        if (this.app.player.login_ts + d * 1e3 - this.app.player.now <= f * 1e3) {
            const mt = await this.app.doLogin();
            if (mt instanceof ApiError) {
                if (mt.status === 400 || mt.status >= 500)
                    return window.location.reload();
                this._submitTry++,
                this.app.log.error("login_failed", mt);
                return
            } else
                mt && this.app.refreshLogin(mt)
        }
        const k = this.app.player.now > this.calcIdleNextSubmitTime
          , y = this.app.player.now > this._next_submit_time
          , ee = this.app.player.activeBoosts.sort((mt,yt)=>mt.end - yt.end)[0]
          , dt = ee ? ee.end - this.app.player.now < this._interval_time : !1;
        dt && this.app.player.updateBoost(!1),
        (k || y || dt) && (this._next_submit_time = this.calcNextSubmitTime,
        await this.submitTaps())
    }
    async submitTaps() {
        if (this.app.player.taps === 0 || this._submission_in_progress)
            return !1;
        let d = !1;
        this._submission_in_progress = !0;
        const f = this.app.player.taps
          , m = this.app.player.usedEnergy
          , k = this.app.player.tappedBalance
          , y = time.now()
          , ee = {
            "Content-Id": this.hs(this.app.player.id, y).toString()
        };
        try {
            const dt = await this.app.api.player_submitTaps.post({
                taps: f,
                time: y
            }, void 0, ee);
            this.app.player.commitState(f, k, m),
            this.app.player.update(dt.player),
            this._submitTry = 0,
            Telegram.WebApp.disableClosingConfirmation(),
            d = !0
        } catch (dt) {
            if (dt instanceof ApiError && dt.status === 400)
                return window.location.reload(),
                !1;
            this._submitTry++,
            this.app.log.error("player_submitTaps failed", dt)
        }
        return this._submission_in_progress = !1,
        d
    }
    hs(d, f) {
        return d * f % d
    }
    get calcNextSubmitTime() {
        return time.addSeconds(time.now(), this.app.settings.submit_interval_s)
    }
    get calcIdleNextSubmitTime() {
        return time.addSeconds(this.app.player.lastTapAt || this._next_submit_time, 2)
    }
}
class AppLog {
    constructor() {
        fn(this, "openHandler", ()=>{}
        );
        fn(this, "_messages", a$1([]))
    }
    info(...d) {
        console.info(d.join(" "));
        const f = {
            s: "I",
            m: d.join(" ")
        };
        this._messages.value = [...this._messages.value, f]
    }
    warn(...d) {
        console.warn(d.join(" "));
        const f = {
            s: "W",
            m: d.join(" ")
        };
        this._messages.value = [...this._messages.value, f]
    }
    error(...d) {
        const f = {
            s: "E",
            m: ""
        };
        for (const m of d)
            m instanceof ApiError ? f.m += `${m.status} - ${m.message} ` : m instanceof Error ? f.e = m : f.m += String(m) + " ";
        console.error(f.s, f.m),
        this._messages.value = [...this._messages.value, f],
        this.openHandler()
    }
    open() {
        this.openHandler()
    }
    get messages() {
        return this._messages.value
    }
}
var define_import_meta_env_default = {
    VITE_APP_BUILD_HASH: "ca9e9c2",
    VITE_APP_BUILD_DATE: "2024-08-08T19:31:25Z",
    VITE_APP_BUILD_NUM: "652",
    VITE_APP_ENV: "prod",
    VITE_APP_TITLE: "TapSwap",
    VITE_APP_BACKEND_URL: "https://api.tapswap.club",
    VITE_APP_BOT_NAME: "tapswap_bot",
    BASE_URL: "/",
    MODE: "prod",
    DEV: !1,
    PROD: !0,
    SSR: !1
};
class AppContextValue {
    constructor() {
        fn(this, "env", "prod");
        fn(this, "localData", new LocalData);
        fn(this, "backendUrl", this.localData.backend_url || "https://api.tapswap.club");
        fn(this, "devInitData", define_import_meta_env_default.VITE_APP_INIT_DATA);
        fn(this, "log", new AppLog);
        fn(this, "navService", new NavService);
        fn(this, "notification", new NotificationService);
        fn(this, "auth", new TonAuthService(this.env === "prod" ? "-239" : "-3"));
        fn(this, "invoicesService", new InvoicesService(this));
        fn(this, "stonFiService", new StonFiService(this.auth));
        fn(this, "api", new TapokAPI({
            baseUrl: this.backendUrl,
            authToken: ()=>this._authToken,
            errorHandler: d=>this.onApiError(d),
            headers: {
                "x-app": "tapswap_server",
                "x-touch": isTouchDevice() ? "1" : "0",
                "Cache-Id": SecureUtil.makeRandomString(8)
            }
        }));
        fn(this, "tapsSubmitService", new TapsSubmitService(this));
        fn(this, "_botKey");
        fn(this, "_authToken", "");
        fn(this, "_gameConf");
        fn(this, "_player");
        fn(this, "_account");
        fn(this, "_settings");
        fn(this, "_adsService");
        fn(this, "_debug_enabled", !1);
        fn(this, "_inviteLink", "");
        fn(this, "_payments_enabled");
        fn(this, "_town_loaded", !1);
        this.log.info("[AppContext] buildHash: ca9e9c2"),
        this.log.info("[AppContext] buildDate: 2024-08-08T19:31:25Z"),
        this.log.info("[AppContext] buildNum: 652"),
        this.log.info(`[AppContext] backendUrl: ${this.backendUrl}`),
        this.api.headers.set("x-cv", "652"),
        window.ctx = this,
        window.onerror = (f,m,k,y,ee)=>(ee ? this.log.error(ee) : (this.log.error(f),
        this.log.error(`source: ${m}`),
        this.log.error(`line: ${k}:${y}`)),
        !1)
    }
    onApiError(d) {
        d.status === 401 && location.reload()
    }
    initAppBot() {
        var d;
        try {
            const f = new URL(window.location.href)
              , m = f.searchParams.get("bot");
            this.log.info(`[AppContext] url: ${f.origin}${f.pathname}`),
            this.log.info(`[AppContext] bot: ${m}`),
            m !== null && (this._botKey = m)
        } catch (f) {
            this.log.error(f, (d = document == null ? void 0 : document.location) == null ? void 0 : d.search)
        }
    }
    login(d) {
        this._authToken = d.access_token,
        this._settings = d.settings,
        this._gameConf = new GameConf(d.conf),
        this._player = new PlayerModel(this._gameConf,d.player,d.bot_shares,d.blocks),
        this._account = new AccountModel(this._gameConf,d.account),
        this._inviteLink = d.invite_url,
        this._debug_enabled = d.debug_enabled;
        const f = Math.random() < (d.settings.payment_chance || 0);
        this._payments_enabled = d.settings.payments_enabled && f,
        this._adsService = new AdsService(this.api,this._player,this.log,this._settings),
        this.tapsSubmitService.start()
    }
    async doLogin() {
        const d = await this.executeLogin();
        if (d) {
            if (d instanceof ApiError)
                return d;
            if (d.chq) {
                const f = ChqService.execute(d.chq);
                return this.executeLogin(f)
            }
            return d
        }
    }
    async executeLogin(d) {
        const f = this.getLoginParams();
        if (f) {
            d && (f.chr = d);
            try {
                const k = await (d ? this.api.account_challenge : this.api.account_login).post(f);
                return k.wait_s && (this.localData.wait_until = time.addSeconds(time.now(), k.wait_s),
                this.localData.flush()),
                (k.debug_enabled && !this.localData.debug_enabled || !k.debug_enabled && this.localData.debug_enabled) && (this.localData.debug_enabled = k.debug_enabled || null,
                this.localData.flush()),
                k
            } catch (m) {
                const k = m;
                return this.log.error("login_failed", k),
                k.status >= 500 && (this.localData.wait_until = time.addSeconds(time.now(), 10),
                this.localData.flush()),
                m
            }
        }
    }
    refreshLogin(d) {
        this._authToken = d.access_token,
        this._player && (this._player.login_ts = d.player.login_ts)
    }
    get gameConf() {
        return checked(this._gameConf)
    }
    get player() {
        return checked(this._player)
    }
    get account() {
        return checked(this._account)
    }
    get botKey() {
        return this._botKey
    }
    get inviteLink() {
        return this._inviteLink
    }
    getInitData() {
        const d = Telegram.WebApp.initData;
        if (d)
            return this.log.info("[AppContext] using telegram init_data"),
            this.log.info(d),
            d;
        if (this.env !== "prod" && this.devInitData)
            return this.log.warn("[AppContext] using dev init_data"),
            this.log.info(this.devInitData),
            this.devInitData;
        const f = window.localStorage.getItem("init_data");
        return f ? (this.log.info("[AppContext] using storage init_data"),
        this.log.info(f),
        f) : (this.log.error("[AppContext] init_data not found"),
        "")
    }
    getLoginParams() {
        const d = this.getInitData();
        if (!d)
            return;
		for (var key in d) {
			console.log('[DEBUG] InitData', key, '->', d[key])}
        const f = {
            init_data: d,
            referrer: ""
        };
        return this.botKey && (f.bot_key = this.botKey),
        f
    }
    get debugEnabled() {
        return this._debug_enabled === !0 || this.localData.debug_enabled === !0
    }
    get payments_enabled() {
        return this._payments_enabled || this.debugEnabled
    }
    get settings() {
        return checked(this._settings)
    }
    get adsService() {
        return checked(this._adsService)
    }
    get town_loaded() {
        return this._town_loaded
    }
    set town_loaded(d) {
        this._town_loaded = d
    }
    get updateTime() {
        return this.env === "prod" ? 1723464e6 : 17231292e5
    }
}
class TonAuthService {
    constructor(d) {
        fn(this, "tonConnectUI");
        fn(this, "connected", a$1(!1));
        this._chaninId = d
    }
    async disconnectWallet() {
        !this.tonConnectUI || !this.tonConnectUI.connected || await this.tonConnectUI.connector.disconnect()
    }
    async connectToWallet() {
        !this.tonConnectUI || this.tonConnectUI.connected || (this.tonConnectUI.connector.connected || await this.tonConnectUI.connector.restoreConnection(),
        this.tonConnectUI.connector.connected || await this.tonConnectUI.openModal())
    }
    getAddress() {
        var d;
        if (!(!this.tonConnectUI || !this.tonConnectUI.connected))
            return (d = this.tonConnectUI.connector.wallet) == null ? void 0 : d.account.address
    }
    async unPauseConnection() {
        this.tonConnectUI && await this.tonConnectUI.connector.unPauseConnection()
    }
    pauseConnection() {
        if (this.tonConnectUI)
            try {
                this.tonConnectUI.connector.pauseConnection()
            } catch {}
    }
    init() {
        if (this.tonConnectUI)
            return;
        const d = new TonConnect({
            manifestUrl: "https://app.tapswap.club/tonconnect-manifest.json",
            disableAutoPauseConnection: !0
        })
          , f = new TonConnectUI({
            connector: d,
            restoreConnection: !1
        });
        f.onStatusChange(()=>{
            f.connector.connected && this.pauseConnection(),
            this.connected.value = f.connector.connected
        }
        ),
        this.tonConnectUI = f,
        isScreenIsLocked() && lockPage(!0)
    }
    async sendTon(d, f, m) {
        if (!(!this.tonConnectUI || !this.tonConnectUI.connected))
            return await this.tonConnectUI.sendTransaction({
                validUntil: Math.floor(Date.now() / 1e3) + 360,
                messages: [{
                    address: d,
                    amount: f,
                    payload: m
                }]
            })
    }
}
const appContextValue = new AppContextValue
  , AppContext = F$1(appContextValue)
  , L = {
    common: {
        from: "From",
        league_desc: "Your number of shares determines the league you enter."
    },
    button: {
        refferal: "Ref",
        task: "Tasks",
        boost: "Boost",
        invite: "Invite a friend",
        invite_copy: "Copy",
        invite_copied: "Copied",
        claim: "Claim",
        get_it: "Get it!",
        tap_tap: "Earn",
        stats: "Stats",
        start_mission: "Start mission",
        finish_mission: "Finish mission",
        check: "Check",
        submit: "Submit",
        go: "Go",
        open: "Open",
        connect_wallet: "Connect wallet",
        disconnect_wallet: "Disconnect wallet",
        pay: "Pay",
        close: "Close",
        watch: "Watch",
        watch_stream: "Watch stream",
        apply: "Apply code",
        town: "Town",
        account: "Account",
        dex: "Dex",
        subscribe: "Subscribe",
        upgrade: "Upgrade",
        buy: "Buy"
    },
    account: {
        your_balance: "Your Share balance"
    },
    task: {
        task_list: "Leagues:",
        ref_list: "Refer Tasks:",
        tabs: {
            leagues: "Leagues",
            ref_task: "Ref",
            missions: "Special",
            cinema: "Cinema",
            referral: "Ref",
            stats: "Stats",
            settings: "Settings",
            info: "Info"
        }
    },
    boost: {
        free_boost: "Your daily boosters:",
        boost: "Boosters:",
        level: "%value% level",
        current_level: "Current level:",
        upgrade_price: "Upgrade price:",
        max_upgrade_reached: "max upgrade reached:",
        insuffisient_funds: "insuffisient funds",
        free: "Free",
        addon_description: "Watch the video to get a free boost",
        addon_applied: "You have successfully activated the additional boost",
        addon_error: "Sorry, no free boost available right now, try again later",
        watch_ads: "Watch ads",
        get_free_boost: "Get a Free Boost",
        energy: {
            title: "Full Tank",
            body: "Fill your energy to the max."
        },
        turbo: {
            title: "Taping Guru",
            body: "Multiply your tap income by x5 for 20 seconds. Do not use energy while active."
        },
        double: {
            title: "Boost x2",
            body: "Take advantage of this limited-time offer to boost your productivity. Purchase this boost to permanently multiply your tap and bot income by x2."
        },
        balance_double: {
            title: "Double Balance",
            body: "Double your Shares balance with this limited-time offer. Available only once!"
        }
    },
    upgrades: {
        tap: {
            title: "Multitap",
            body1: "Increase amount of TAP you can earn per one tap.",
            body2: "+1 per tap for each level."
        },
        energy: {
            title: "Energy limit",
            body1: "Increase the limit of energy storage.",
            body2: "+500 energy limit for each level."
        },
        charge: {
            title: "Recharging speed",
            body1: "Increase speed of recharge",
            body2: "+1 per second."
        },
        tap_bot: {
            title: "Tap Bot",
            body1: "Tap bot will tap when your energy is full.",
            body2: "Max bot work duration is 12 hours."
        }
    },
    ref: {
        empty: "You don't have referrals 😭",
        ref_list: "My Referals list:",
        my_ref_bonus: "My ref bonus:",
        my_ref: "My ref:",
        value_ref: "$value$ Referrals",
        invite_link: "My invite link:"
    },
    stat: {
        title: "Stats",
        total_t: "Total Touches:",
        total_b: "Total Share Balance:",
        total_p: "Total Players:",
        daily_p: "Daily Users:",
        online_p: "Online Players:"
    },
    tap_bot: {
        title: "Tap Bot",
        body: "While you were asleep, your Tap Bot earned some Shares for you ❤️"
    },
    leave: {
        text: "Leave the desktop. Mobile gaming rocks!"
    },
    wait: {
        text: "The application is currently overloaded.",
        txh: "Thank you for your patience!",
        reload_btn: "Reload",
        join_community: "Join our community"
    },
    ban: {
        text: "Your account has been temporarily suspended due to detected scripted bots or multi-account activity"
    },
    notifications: {
        title: "Bonus!",
        messages: {
            NL0: "Hello, a welcome bonus of 100,000 coins has been prepared especially for you."
        }
    },
    missions: {
        reward: "Reward",
        your_task: "Your tasks",
        erroe_message: "Activity not confirmed. Are you certain you completed this task?",
        done: "Done!",
        conget: "Congratulations",
        congret_desc: "You've successfully completed the mission",
        completed: "Mission is completed!",
        solana_wallet: "Solana Wallet",
        reminder: "👋 Your %value% Shares are waiting for you. Just complete the task to claim them!",
        provide_answer: "Provide an answer",
        cinema: {
            congret_cinema_desc: "You've successfully completed the TapSwap cinema mission!",
            info: {
                title: "TapSwap Cinema",
                desc: "Finish %value% YouTube missions and get an additional reward.",
                error_message: "Looks like you didn't watch the video. You need watch the whole video from start to the end in normal speed."
            }
        },
        stream: {
            title: "TapSwap Stream",
            description: "Join the stream and get an additional reward. Codes will appear approximately every 15 minutes. Enter the code here to claim your reward. Rewards can be huge, so don't miss out!",
            error: "This code is invalid code",
            congrats: "The code is correct! You've earned a reward!"
        },
        instructions: {
            tg: "Join the Telegram chat",
            x: "Follow X handle",
            website: "Visit website",
            fb: "Follow Facebook page",
            yt: "Subscribe to the YouTube channel",
            ig: "Follow Instagram page",
            em: "Subscribe to the newsletter",
            discord: "Join Discord server"
        },
        individual_instrunctions: {
            M5: ["Shhh, 🤫 subscribe and be the first to know!", "Join for exclusive insider info!", "Join the channel so you won't miss out on the next gem!"],
            M6: ["Access to exclusive crypto insights!"],
            M7: ["Don't miss out on crypto insights – join now!"],
            M8: ["Don't miss out on crypto insights – join now!"],
            M18: ["Join $BEER telegram channel", "Follow $BEER on twitter put your 🔔 on", "Follow $BEER on instagram", "Provide your Solana address (Phantom, or other) to participate in the giveaway"],
            M34: ["Register on Binance", "Complete the KYC", "Enter your Binance ID"],
            M44: ["Share your Solana adress (not from exchange)", "Join Telegram chanel", "Follow on Twitter", "Follow on instagram"]
        }
    },
    dashboard: {
        buttons: {
            sign_button: "Sign message",
            change_address: "Change address",
            back_to_app: "Back to mine"
        },
        header: "Welcome to TapSwap dashboard",
        description: "Connect your wallet and sign the message to submit your Solana address to the TapSwap application",
        solana_address: "Your confirmed solana address:"
    },
    pay: {
        ton: {
            header: "Pay with TON"
        },
        price: "Price",
        success_text: "Success",
        confirmation_await: "awaiting"
    },
    town: {
        message: "New interactive feature in the TapSwap app! Build and manage your virtual town, complete challenges, and earn rewards to increase your airdrop share!",
        the_building_price: "The building price:",
        level: "Level:",
        mining_rate: "Mining rate:",
        required_time: "Required time:",
        building_upgrate: "Building upgrate",
        level_number: "Level $level$",
        requirements: "Required Level",
        building_progress: "Building Progress",
        chilling: "Your worker is relaxing.",
        gem_market: "Gem Marketplace",
        market_desc: "Buy more gems to become the richest TappyTowner in the city and develop your infrastructure faster than others.",
        gem_amount: "$value$ GEMS",
        bonus: "Bonus",
        price: "Price: $$value$ ",
        first_purchase: "🔥 First Purchase!",
        you_will_receive: "You'll receive",
        wait_bit: "Please wait a moment for the system to check your subscription, and then try again.",
        you_should_subscribed: "You need to be subscribed to the $value$ channel",
        speed_up: "SpeedUp $value$ gems",
        max_builders_reached: "Max builders reached",
        buy_builder: "Buy builder with $nextBuilderPrice$ gems",
        not_enough_gems: "Insufficient gems",
        insufficient_balance: "Insufficient balance",
        need_required_building: "Required building needed",
        no_available_builders: "No builders available",
        building_in_progress: "Building in progress",
        checking_subscription: "Checking subscription $value$",
        time_to_start: "Time to start",
        town_bot: {
            title: "Town Revenue",
            body: "While you were asleep, your town earned some blocks for you! ❤️"
        },
        buildings: {
            b_01: {
                name: "TapFlix",
                description: "Watch series - get reward, and extra points."
            },
            b_02: {
                name: "Monument to Toncoin",
                description: "Place of power."
            },
            b_03: {
                name: "Factory",
                description: "A place where successful projects are born."
            },
            b_04: {
                name: "Taping Guru",
                description: "Monument of Taping Guru - oldest tapper in Tap Swap. Some say he really does have six fingers."
            },
            b_05: {
                name: "To the moon!",
                description: "Welcome to our airlines. Fasten your seatbelts, we are taking off."
            },
            b_06: {
                name: "Trampoline",
                description: "A springboard that “lifts” you up."
            },
            b_07: {
                name: "Bit Club",
                description: "A bit of techno vibes in our town."
            },
            b_08: {
                name: "Karaoke",
                description: "Rock the microphone!"
            },
            b_09: {
                name: "Point of view",
                description: "Wheel of Fortune, may luck be with you!"
            },
            b_10: {
                name: "Prosecco fountain",
                description: "Morning drinks for free to every citizen!"
            },
            b_11: {
                name: "Biker club",
                description: "Lets rock n roll on the Tappy Town roads!"
            },
            b_12: {
                name: "Istukan",
                description: "Simply a monument to the idol, without deep sences:)"
            },
            b_13: {
                name: "Salmon",
                description: "Salmon way, only the persistent achieve success."
            },
            b_14: {
                name: "Telegram duck",
                description: "Yes, it’s the same duck from Telegram."
            },
            b_15: {
                name: "Brewery",
                description: "Septemberfest. There will be something to celebrate in September ;)"
            },
            b_16: {
                name: "Webrave",
                description: "Web Rave. Our team’s personal flying saucer!"
            },
            b_17: {
                name: "Gold button",
                description: "Old but gold. We will achieve all the rewards together."
            },
            b_18: {
                name: "Casino",
                description: "A little game won’t hurt anyone! 13 friends of Tappy :)"
            },
            b_19: {
                name: "Cooking hub",
                description: "Tappy's cooking hub. Cooking in progress."
            },
            b_20: {
                name: "Tap stadium",
                description: "Our Colosseum! Bread and circuses!"
            }
        }
    },
    dex: {
        title: "The Dex",
        message: "The DEX feature in the TapSwap app allows users to seamlessly trade cryptocurrencies directly with others on a secure, decentralized exchange."
    },
    setting: {
        private_policy: "Privacy Policy"
    },
    currency: {
        usd: "$ $value$"
    },
    exchange: {
        title: "Swap tokens",
        you_send: "You send",
        you_receive: "You receive",
        search_assets: "Search assets",
        swap_details: "Swap Details",
        price_per_one: "1 %{value} price",
        max_slippage: "Max. slippage",
        minimum_received: "Minimum received",
        price_impact: "Price impact",
        blockchain_fee: "Blockchain fee",
        swap: "Swap",
        select_token: "Select token",
        settings: "Settings",
        enter_amount: "Enter an amount",
        insufficient_balance: "Insufficient %{value} balance",
        price_impact_is_too_high: "Price impact is too high",
        max_slipage_error: "The maximum slippage tolerance cannot be more than 50%. The recommended range is 1%",
        max_slipage_warning: "Range more than 5% may lead to loss of funds",
        min_slipage_error: "Recommended range is 1%",
        min_slipage_warining: "Range below 0.5% may result in a failed transaction",
        max_slippage_tooltip: "Your transaction will not be executed if the price changes unfavorably beyond 1%",
        minimum_received_tooltip: "Your transaction will revert if there is a large, unfavorable price movement before it is confirmed.",
        price_impact_tooltip: "The difference between the market price and estimated price due to trade size."
    }
}
  , loadingContent = "_loadingContent_t1zxm_1"
  , rotate = "_rotate_t1zxm_1"
  , Styles$4 = {
    loadingContent,
    rotate
}
  , LoadingView = ()=>u$2("div", {
    class: Styles$4.loadingContent,
    children: u$2("svg", {
        children: [u$2("defs", {
            children: u$2("linearGradient", {
                id: "gradient",
                x1: "0%",
                y1: "0%",
                x2: "0%",
                y2: "100%",
                children: [u$2("stop", {
                    offset: "0%",
                    "stop-color": "#FBBA40"
                }), u$2("stop", {
                    offset: "100%",
                    "stop-color": "#7028CD"
                })]
            })
        }), u$2("circle", {
            cx: "-150",
            cy: "150",
            r: "137",
            stroke: "url(#gradient)",
            "stroke-width": "16",
            fill: "none",
            "stroke-linecap": "round",
            transform: "rotate(-90)"
        })]
    })
})
  , primary$1 = "_primary_1xn79_1"
  , secondary$1 = "_secondary_1xn79_5"
  , accent = "_accent_1xn79_9"
  , warning = "_warning_1xn79_13"
  , error = "_error_1xn79_17"
  , Styles$3 = {
    primary: primary$1,
    secondary: secondary$1,
    accent,
    warning,
    error
};
function getColorClass(r) {
    return r === "primary" ? Styles$3.primary : r === "secondary" ? Styles$3.secondary : r === "accent" ? Styles$3.accent : r === "warning" ? Styles$3.warning : r === "error" ? Styles$3.error : ""
}
function getTextColorValue(r) {
    switch (r) {
    case "primary":
        return "var(--text-primary)";
    case "secondary":
        return "var(--text-secondary)";
    case "accent":
        return "var(--accent-gold)"
    }
}
const button = "_button_fffa0_1"
  , primary = "_primary_fffa0_13"
  , secondary = "_secondary_fffa0_21"
  , tertiary = "_tertiary_fffa0_29"
  , pressed = "_pressed_fffa0_33"
  , fullWidth = "_fullWidth_fffa0_37"
  , small = "_small_fffa0_41"
  , large = "_large_fffa0_49"
  , Styles$2 = {
    button,
    primary,
    secondary,
    tertiary,
    pressed,
    fullWidth,
    small,
    large
}
  , ButtonVariant = {
    primary: Styles$2.primary,
    secondary: Styles$2.secondary,
    tertiary: Styles$2.tertiary
}
  , ButtonSize = {
    small: Styles$2.small,
    large: Styles$2.large
}
  , ActionButton = ({variant: r="primary", size: d="large", ...f})=>{
    let m = `${Styles$2.button} ${ButtonVariant[r]} ${ButtonSize[d]}`;
    const [k,y] = h$1(!1);
    f.fullWidth && (m += ` ${Styles$2.fullWidth}`),
    f.pressed && (m += ` ${Styles$2.pressed}`);
    const ee = async()=>{
        y(!0),
        await f.onClick(),
        y(!1)
    }
    ;
    return f.href ? u$2("a", {
        class: m,
        href: f.href,
        children: f.children
    }) : u$2("button", {
        class: m,
        disabled: f.disabled || k,
        onClick: ()=>{
            ee().catch(console.error)
        }
        ,
        children: f.children
    })
}
  , walletImg = "/assets/wallet-2aTURJGs.png"
  , EXPLORER_URL = "https://tonviewer.com/";
function getTonExplorerContractLink(r) {
    return EXPLORER_URL + r
}
function formatTonRawAddress(r) {
    const d = dist$1.Address.parseRaw(r).toString({
        bounceable: !1
    });
    return d.slice(0, 4) + "..." + d.slice(-4)
}
const ChevronRight = r=>{
    const d = getTextColorValue(r.color ?? "primary")
      , f = getSize(r.size ?? "medium");
    return u$2("svg", {
        width: f,
        height: f,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: u$2("path", {
            d: "M9.70498 6L8.29498 7.41L12.875 12L8.29498 16.59L9.70498 18L15.705 12L9.70498 6Z",
            fill: d
        })
    })
}
;
function getSize(r) {
    switch (r) {
    case "medium":
        return 24;
    case "small":
        return 16
    }
}
const body2 = "_body2_nxvid_1"
  , Styles$1 = {
    body2
}
  , Body2 = r=>{
    const d = getColorClass(r.color);
    return u$2("p", {
        class: `${Styles$1.body2} ${d} ${r.className}`,
        children: r.children
    })
}
  , content = "_content_25i41_1"
  , chevron = "_chevron_25i41_20"
  , icon = "_icon_25i41_24"
  , Styles = {
    content,
    chevron,
    icon
}
  , PrimaryButton = r=>{
    const [d,f] = h$1(!1)
      , m = async()=>{
        f(!0),
        await r.onClick(),
        f(!1)
    }
    ;
    return u$2("button", {
        class: Styles.content,
        onClick: ()=>{
            m().catch(console.error)
        }
        ,
        disabled: d,
        children: [r.icon && u$2("div", {
            class: Styles.icon,
            children: r.icon
        }), u$2(Body2, {
            children: r.children
        }), u$2("div", {
            class: Styles.chevron,
            children: u$2(ChevronRight, {})
        })]
    })
}
  , TonWalletButton = r=>{
    const d = q$1(AppContext)
      , f = T$1(()=>{
        d.auth.init(),
        d.auth.connectToWallet().catch(console.error)
    }
    , [d.auth])
      , m = T$1(()=>{
        d.auth.disconnectWallet().catch(console.error)
    }
    , [d.auth])
      , k = d.auth.connected.value ? formatTonRawAddress(d.auth.getAddress() ?? "") : L.button.connect_wallet
      , y = d.auth.connected.value ? m : f;
    return r.useSecondary ? u$2(PrimaryButton, {
        onClick: y,
        icon: u$2("img", {
            src: walletImg,
            alt: k
        }),
        children: k
    }) : u$2(ActionButton, {
        size: "large",
        fullWidth: !0,
        variant: "secondary",
        onClick: y,
        children: k
    })
}
;
export {AppContext as A, Body2 as B, ChevronRight as C, L, PrimaryButton as P, TonWalletButton as T, ActionButton as a, LoadingView as b, getTonExplorerContractLink as c, getTextColorValue as d, appContextValue as e, AppLog as f, getColorClass as g, TonConnectUI as h};
//# sourceMappingURL=TonWalletButton-SptWbIh7.js.map
